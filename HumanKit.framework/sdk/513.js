(()=>{var V,Re={49513:(V,I,_)=>{(()=>{"use strict";function W(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}const r=_(38472),X=_(7928),O=_(65133),U=(0,O.create)(),E=(0,O.create)();function ee(e,n,t){if(t?(0,O.fromScaling)(E,t):(0,O.identity)(E),n){const o=n[0],s=n[1],i=n[2];o&&((0,O.fromXRotation)(U,o),(0,O.multiply)(E,U,E)),s&&((0,O.fromYRotation)(U,s),(0,O.multiply)(E,U,E)),i&&((0,O.fromZRotation)(U,i),(0,O.multiply)(E,U,E))}return(0,X.fromMat4)(e,E)}const te=(0,r.create)(),fe=Math.PI/180,ne=(0,r.create)(),de=Math.PI/180,Ae=2*Math.PI,oe=(0,r.create)(),we=Math.PI/180,xe=Math.PI/180,re=(0,r.create)(),ae=(0,r.create)(),he=Math.PI/180,Ce=Math.PI,Ue=2*Ce,me=Math.PI/180;class Fe{translate;rotate;scale;xform;inverseXform;normalXform;dirty}const De={shapeTranslate:"translate",shapeRotate:"rotate",shapeScale:"scale"};function $(e,n,t,o,s){const i=De[n],a=i&&e[i];return"shapeRotate"===n&&(t*=me,o*=me,s*=me),!!a&&(a[0]=t,a[1]=o,a[2]=s,e.dirty=!0,!0)}class ge extends Fe{constructor(n){super(),this.translate=n?.translate?(0,r.clone)(n.translate):null,this.xform=n?.scale||n?.rotate?(0,X.create)():null,this.xform?(this.rotate=(0,r.fromValues)(0,0,0),n?.rotate&&(0,r.scale)(this.rotate,n.rotate,me),this.scale=(0,r.fromValues)(1,1,1),n?.scale&&(0,r.copy)(this.scale,n.scale),this.inverseXform=(0,X.create)(),this.normalXform=(0,X.create)(),this.dirty=!0,this.updateXform()):(this.rotate=null,this.scale=null,this.inverseXform=null,this.normalXform=null,this.dirty=!1)}updateXform(){this.xform&&this.dirty&&(ee(this.xform,this.rotate,this.scale),(0,X.invert)(this.inverseXform,this.xform),(0,X.transpose)(this.normalXform,this.inverseXform)),this.dirty=!1}}const ve=(e,n=0,t=1)=>Math.max(n,Math.min(t,e)),w=new class{activeCount;size;get;release;constructor(e,n,t=100){const o=[];let s=0;Object.defineProperties(this,{activeCount:{get:()=>s},size:{get:()=>o.length}}),this.get=()=>(s++,o.length?o.pop():e()),this.release=i=>{if(s<=0)throw new Error("Pool: too many objects released.");s--,o.length<t&&(n&&n(i),o.push(i))}}}(()=>(0,r.create)(),e=>(0,r.set)(e,0,0,0)),Le=Math.PI/180,Xe=(0,X.create)();function _e(e,n){return n[0]*e.normal[0]+n[1]*e.normal[1]+n[2]*e.normal[2]}function Te(e){const n=e[0],t=e[1],o=e[2];return n*n+t*t+o*o}const K={Cube:class extends ge{in(e){const n=e[0],t=e[1],o=e[2];return n>=-.5&&n<=.5&&t>=-.5&&t<=.5&&o>=-.5&&o<=.5}out(e){const n=e[0],t=e[1],o=e[2];return n<=-.5||n>=.5||t<=-.5||t>=.5||o<=-.5||o>=.5}surfaceProjection(e,n,t){let o=e[0],s=e[1],i=e[2];const a=Math.abs(o+.5),c=Math.abs(o-.5),p=Math.abs(s+.5),l=Math.abs(s-.5),f=Math.abs(i+.5),h=Math.abs(i-.5);a<c&&a<p&&a<l&&a<f&&a<h?(o=-.5,(0,r.set)(t,-1,0,0)):c<p&&c<l&&c<f&&c<h?(o=.5,(0,r.set)(t,1,0,0)):p<l&&p<f&&p<h?(s=-.5,(0,r.set)(t,0,-1,0)):l<f&&l<h?(s=.5,(0,r.set)(t,0,1,0)):f<h?(i=-.5,(0,r.set)(t,0,0,-1)):(i=.5,(0,r.set)(t,0,0,1)),n[0]=ve(o,-.5,.5),n[1]=ve(s,-.5,.5),n[2]=ve(i,-.5,.5),this.xform&&(this.updateXform(),(0,r.transformMat3)(n,n,this.xform),(0,r.transformMat3)(t,t,this.normalXform),(0,r.normalize)(t,t)),this.translate&&(0,r.add)(n,n,this.translate)}},Cylinder:class extends ge{in(e){const n=e[0],t=e[1],o=e[2];return n*n+o*o<=1&&t>=-1&&t<=1}out(e){const n=e[0],t=e[1],o=e[2];return n*n+o*o>=1||t<=-1||t>=1}surfaceProjection(e,n,t){let o=e[0],s=e[1],i=e[2];if(s<=-1)(0,r.set)(t,0,-1,0),s=-1;else if(s>=1)(0,r.set)(t,0,1,0),s=1;else{const a=Math.sqrt(o*o+i*i);a>=1||1-Math.abs(s)>=1-a?(o/=a,i/=a,(0,r.set)(t,o,0,i)):(s=Math.sign(s),(0,r.set)(t,0,s,0))}n[0]=o,n[1]=s,n[2]=i,this.xform&&(this.updateXform(),(0,r.transformMat3)(n,n,this.xform),(0,r.transformMat3)(t,t,this.normalXform),(0,r.normalize)(t,t)),this.translate&&(0,r.add)(n,n,this.translate)}},Plane:class extends Fe{translate;rotate;normal;distance;xform;dirty=!0;constructor(e){super(),this.translate=(0,r.clone)(e.translate||[0,0,0]),this.rotate=(0,r.clone)(e.rotate||[0,0,0]),e.rotate&&(0,r.scale)(this.rotate,e.rotate,Le),this.normal=(0,r.create)(),this.distance=0,this.updateXform()}updateXform(){this.dirty&&(this.normal[0]=0,this.normal[1]=1,this.normal[2]=0,ee(Xe,this.rotate),(0,r.transformMat3)(this.normal,this.normal,Xe),this.distance=(0,r.dot)(this.translate,this.normal),this.dirty=!1)}in(e){return this.updateXform(),_e(this,e)<=this.distance}out(e){return this.updateXform(),_e(this,e)>=this.distance}surfaceProjection(e,n,t){this.updateXform(),t[0]=this.normal[0],t[1]=this.normal[1],t[2]=this.normal[2];const o=w.get();(0,r.scale)(o,t,this.distance-(0,r.dot)(e,t)),(0,r.add)(n,e,o),w.release(o)}},Sphere:class extends ge{in(e){return Te(e)<=1}out(e){return Te(e)>=1}surfaceProjection(e,n,t){(0,r.normalize)(n,e),W(t)?t.set(n):(0,r.copy)(t,n),this.xform&&(this.updateXform(),(0,r.transformMat3)(n,n,this.xform),(0,r.transformMat3)(t,t,this.normalXform),(0,r.normalize)(t,t)),this.translate&&(0,r.add)(n,n,this.translate)}}};function G(e,n,t,o){const s=3*o;return e[0]=t[s],e[1]=t[s+1],e[2]=t[s+2],n?.translate&&(e[0]-=n.translate[0],e[1]-=n.translate[1],e[2]-=n.translate[2]),n?.inverseXform&&(n instanceof ge&&n.updateXform(),(0,r.transformMat3)(e,e,n.inverseXform)),e}const ye=(0,r.create)(),Se=(0,r.create)(),se=(0,r.create)(),ke=(0,r.create)(),Ve=(0,r.create)(),N=(0,r.create)(),Q=(0,r.create)(),Ie={CubePosition:function(e){const n=e.translate?(0,r.clone)(e.translate):null,t=e.scale||e.rotate?(0,X.create)():null,o=t?(0,r.create)():null;e.rotate&&(0,r.scale)(o,e.rotate,fe);const s={scale:t?(0,r.clone)(e.scale)||(0,r.fromValues)(1,1,1):null,rotate:o,translate:n};let i=!0;return{set(a,c,p,l){"rotate"===a?(0,r.set)(o,c*fe,p*fe,l*fe):a in s&&(0,r.set)(s[a],c,p,l),i=!0},update(a,c,p){const l=a.get("position");t&&i&&(ee(t,o,s.scale),i=!1);for(let f=c,h=3*f;f<p;f++,h+=3)te[0]=Math.random()-.5,te[1]=Math.random()-.5,te[2]=Math.random()-.5,t&&(0,r.transformMat3)(te,te,t),n&&(0,r.add)(te,te,n),l.set(te,h)}}},CylinderPosition:function(e){const n=e.translate?(0,r.clone)(e.translate):null,t=e.scale||e.rotate?(0,X.create)():null,o=t?(0,r.create)():null;e.rotate&&(0,r.scale)(o,e.rotate,de);const s={scale:t?(0,r.clone)(e.scale)||(0,r.fromValues)(1,1,1):null,rotate:o,translate:n};let i=!0;return{set(a,c,p,l){"rotate"===a?(0,r.set)(o,c*de,p*de,l*de):a in s&&(0,r.set)(s[a],c,p,l),i=!0},update(a,c,p){const l=a.get("position");t&&i&&(ee(t,o,s.scale),i=!1);for(let f=c,h=3*f;f<p;f++,h+=3){const g=Math.random()*Ae,y=Math.random(),m=2*Math.random()-1;ne[0]=y*Math.cos(g),ne[1]=m,ne[2]=y*Math.sin(g),t&&(0,r.transformMat3)(ne,ne,t),n&&(0,r.add)(ne,ne,n),l.set(ne,h)}}}},DirectionalVelocity:function(e){const n=(0,r.clone)(e.directionAverage);(0,r.normalize)(n,n);const t={directionAverage:n},o={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0,directionVariance:e.directionVariance||0};return{components:["velocity"],set(s,i,a,c){s in t?(0,r.set)(t[s],i,a,c):s in o&&(o[s]=i)},update(s,i,a){const c=s.get("velocity"),{forceAverage:p,forceVariance:l,directionVariance:f}=o;for(let h=i,g=3*h;h<a;h++,g+=3){const y=p+2*Math.random()*l-l;oe[0]=n[0]+2*Math.random()*f-f,oe[1]=n[1]+2*Math.random()*f-f,oe[2]=n[2]+2*Math.random()*f-f,(0,r.normalize)(oe,oe),c[g]+=oe[0]*y,c[g+1]+=oe[1]*y,c[g+2]+=oe[2]*y}}}},Lifetime:function(e){const n={average:e.average,variance:e.variance||0};return{components:["lifetime","age"],set(t,o){t in n&&(n[t]=o)},update(t,o,s){const i=t.get("age"),a=t.get("lifetime");let{average:c,variance:p}=n;p>c&&(c=p=(c+p)/2);for(let l=o;l<s;l++)i[l]=0,a[l]=c,p>0&&(a[l]+=2*Math.random()*p-p)}}},PointPosition:function(e){const n=(0,r.clone)(e.position),t={position:n};return{set(o,s,i,a){o in t&&(0,r.set)(t[o],s,i,a)},update(o,s,i){const a=o.get("position");for(let c=s,p=3*c;c<i;c++,p+=3)a.set(n,p)}}},RandomRotation:function(e){const n={average:e.average*we,variance:(e.variance||0)*we};return{components:["uvRotate"],set(t,o){t in n&&(n[t]=o*we)},update(t,o,s){const i=t.get("uvRotate"),{average:a,variance:c}=n;for(let p=o;p<s;p++){let l=a;c>0&&(l+=2*Math.random()*c-c),i[p]=l}}}},RandomRotationSpeed:function(e){const n={average:e.average*xe,variance:(e.variance||0)*xe};return{components:["rotationSpeed","uvRotate"],set(t,o){t in n&&(n[t]=o*xe)},update(t,o,s){const i=t.get("rotationSpeed"),{average:a,variance:c}=n;for(let p=o;p<s;p++){let l=a;c>0&&(l+=2*Math.random()*c-c),i[p]=l}}}},RandomScale:function(e){const n={average:e.average,variance:e.variance||0};return{components:["scale"],set(t,o){t in n&&(n[t]=o)},update(t,o,s){const i=t.get("scale");let{average:a,variance:c}=n;c>a&&(a=c=(a+c)/2);for(let p=o;p<s;p++){let l=a;c>0&&(l+=2*Math.random()*c-c),i[p]=l}}}},RandomVelocity:function(e){const n={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0};return{components:["velocity"],set(t,o){t in n&&(n[t]=o)},update(t,o,s){const i=t.get("velocity"),{forceAverage:a,forceVariance:c}=n;for(let p=o,l=3*p;p<s;p++,l+=3){const f=a+2*Math.random()*c-c;re[0]=2*Math.random()-1,re[1]=2*Math.random()-1,re[2]=2*Math.random()-1,(0,r.normalize)(re,re),i[l]+=re[0]*f,i[l+1]+=re[1]*f,i[l+2]+=re[2]*f}}}},SpherePosition:function(e){const n=e.translate?(0,r.clone)(e.translate):null,t=e.scale||e.rotate?(0,X.create)():null,o=t?(0,r.create)():null;e.rotate&&(0,r.scale)(o,e.rotate,he);const s={scale:t?(0,r.clone)(e.scale)||(0,r.fromValues)(1,1,1):null,rotate:o,translate:n};let i=!0;return{set(a,c,p,l){"rotate"===a?(0,r.set)(o,c*he,p*he,l*he):a in s&&(0,r.set)(s[a],c,p,l),i=!0},update(a,c,p){const l=a.get("position");t&&i&&(ee(t,o,s.scale),i=!1);for(let f=c,h=3*f;f<p;f++,h+=3){const g=Math.random()*Ce,y=Math.random()*Ue,m=Math.random(),v=Math.sin(g);ae[0]=m*v*Math.sin(y),ae[1]=m*Math.cos(g),ae[2]=m*v*Math.cos(y),t&&(0,r.transformMat3)(ae,ae,t),n&&(0,r.add)(ae,ae,n),l.set(ae,h)}}}},SpriteAnimationDuration:function(e,n,t){const o={average:e.average,variance:e.variance||0,startFrame:t.spriteStartFrame||0,endFrame:t.spriteEndFrame||Math.max(0,t.spriteCols*t.spriteCols-1)};return{components:["uvTranslate","spriteFrameDuration","spriteCurrentTime"],set(s,i){s in o&&(o[s]=i)},update(s,i,a){const c=s.get("spriteFrameDuration"),p=s.get("spriteCurrentTime"),{startFrame:l,endFrame:f}=o,h=f-l;let{average:g,variance:y}=o;y>g&&(g=y=(g+y)/2);for(let m=i;m<a;m++){let v=g;y>0&&(v+=2*Math.random()*y-y),p[m]=0,c[m]=h?Math.max(v/h,0):0}}}}},Oe={AgeColorBlend:function(e){const n=[];for(let i=0,a=e.colors.length;i<a;i++)n[i]=new Uint8Array(e.colors[i]);const t=e.shape?new K[e.shape.type](e.shape):null,s=t?t[e.shape?.direction||"in"].bind(t):null;return{components:["position","age","lifetime","color"],set(i,a,c,p){$(t,i,a,c,p)},update(i,a,c){const p=i.get("position"),l=i.get("age"),f=i.get("lifetime"),h=i.get("color"),g=n.length-1,y=t?w.get():null;for(let m=a,v=4*m;m<c;m++,v+=4)if(!s||s(G(y,t,p,m))){const d=f[m]?l[m]/f[m]*g:0,A=Math.floor(d),S=n[A],u=n[A+1]||n[A],M=d-A,b=1-M;h[v]=b*S[0]+M*u[0],h[v+1]=b*S[1]+M*u[1],h[v+2]=b*S[2]+M*u[2],h[v+3]=b*S[3]+M*u[3]}y&&w.release(y)}}},AxisForce:function(e){const n=e.forceAverage,t=e.forceVariance||0,o=(0,r.clone)(e.position),s=(0,r.clone)(e.direction);(0,r.normalize)(s,s);const i=e.shape?new K[e.shape.type](e.shape):null,c=i?i[e.shape?.direction||"in"].bind(i):null,p={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0};return{components:["velocity","position"],set(l,f,h,g){"shapeTranslate"===l||"shapeRotate"===l||"shapeScale"===l?$(i,l,f,h,g):l in p&&(p[l]=f)},update(l,f,h,g){const y=l.get("position"),m=l.get("velocity"),v=n*g,d=t*g,A=i?w.get():null,x=w.get(),S=w.get(),u=w.get(),M=w.get();for(let b=f,z=3*b;b<h;b++,z+=3)if(!c||c(G(A,i,y,b))){const C=z+1,R=z+2;let F=v;d>0&&(F+=2*Math.random()*d-d),x[0]=y[z],x[1]=y[C],x[2]=y[R],(0,r.subtract)(M,x,o);const D=(0,r.dot)(M,s);(0,r.scale)(u,s,D),(0,r.add)(S,u,o),(0,r.subtract)(S,x,S),(0,r.normalize)(S,S),m[z]+=S[0]*F,m[C]+=S[1]*F,m[R]+=S[2]*F}A&&w.release(A),w.release(x),w.release(S),w.release(u),w.release(M)}}},BrownianMotion:function(e){const n=e.shape?new K[e.shape.type](e.shape):null,o=n?n[e.shape?.direction||"in"].bind(n):null,s={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0,frequency:e.frequency};return{components:["velocity","position"],set(i,a,c,p){"shapeTranslate"===i||"shapeRotate"===i||"shapeScale"===i?$(n,i,a,c,p):i in s&&(s[i]=a)},update(i,a,c,p){const l=i.get("position"),f=i.get("velocity"),h=s.frequency*p,g=s.forceAverage*p,y=s.forceVariance*p,m=n?w.get():null,v=w.get();for(let d=a,A=3*d;d<c;d++,A+=3)if((!o||o(G(m,n,l,d)))&&Math.random()<h){let x=g;y>0&&(x+=2*Math.random()*y-y),v[0]=2*Math.random()-1,v[1]=2*Math.random()-1,v[2]=2*Math.random()-1,(0,r.normalize)(v,v),f[A]+=v[0]*x,f[A+1]+=v[1]*x,f[A+2]+=v[2]*x}m&&w.release(m),w.release(v)}}},Gravity:function(e){const n=(0,r.clone)(e.position),t=e.shape?new K[e.shape.type](e.shape):null,s=t?t[e.shape?.direction||"in"].bind(t):null,i={position:n},a={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0,radius:e.radius};return{components:["velocity","position"],set(c,p,l,f){"shapeTranslate"===c||"shapeRotate"===c||"shapeScale"===c?$(t,c,p,l,f):c in i?(0,r.set)(i[c],p,l,f):c in a&&(a[c]=p)},update(c,p,l,f){const{forceAverage:h,forceVariance:g,radius:y}=a;if(0===y)return;const m=c.get("position"),v=c.get("velocity"),d=h*f,A=g*f,x=t?w.get():null,S=i.position,u=w.get();for(let M=p,b=3*M;M<l;M++,b+=3)if(!s||s(G(x,t,m,M))){let z=d;A>0&&(z+=2*Math.random()*A-A);const C=b+1,R=b+2;u[0]=S[0]-m[b],u[1]=S[1]-m[C],u[2]=S[2]-m[R];const F=1/Math.max((0,r.length)(u),y);(0,r.scale)(u,u,F),z*=F*F,v[b]+=u[0]*z,v[b+1]+=u[1]*z,v[b+2]+=u[2]*z}x&&w.release(x),w.release(u)}}},Friction:function(e){const n=e.shape?new K[e.shape.type](e.shape):null,o=n?n[e.shape?.direction||"in"].bind(n):null,s={friction:1-e.friction};return{components:["velocity","position"],set(i,a,c,p){"shapeTranslate"===i||"shapeRotate"===i||"shapeScale"===i?$(n,i,a,c,p):i in s&&(s[i]=1-a)},update(i,a,c,p){const l=i.get("position"),f=i.get("velocity"),h=Math.pow(s.friction,p),g=n?w.get():null;for(let y=a,m=3*y;y<c;y++,m+=3)o&&!o(G(g,n,l,y))||(f[m]*=h,f[m+1]*=h,f[m+2]*=h);g&&w.release(g)}}},Path:function(e,n){const t=function(a){const c=[];return a.forEach(({position:p,radius:l,forceAverage:f,forceVariance:h},g)=>{const y=(0,r.clone)(p),m=g?(0,r.subtract)((0,r.create)(),y,c[g-1].position):null,v=g?(0,r.length)(m):0,d={position:y,radiusSquared:l?l*l:0,forceVariance:h||0,forceAverage:f,vec:m,dir:g?(0,r.scale)((0,r.create)(),m,1/v):null,length:v};c.push(d)}),c}(e.nodes);n.path=t;const o=e.shape?new K[e.shape.type](e.shape):null,i=o?o[e.shape?.direction||"in"].bind(o):null;return{components:["velocity","position","pathIndex"],set(a,c,p,l){$(o,a,c,p,l)},update(a,c,p,l){const f=a.get("position"),h=a.get("velocity"),g=a.get("pathIndex"),y=o?w.get():null,m=w.get(),v=w.get(),d=w.get();for(let A=c,x=3*A;A<p;A++,x+=3)if(!i||i(G(y,o,f,A))){const S=g[A];let u=t[S];if(u){const M=x+1,b=x+2;m[0]=f[x],m[1]=f[M],m[2]=f[b];let z=null;if(S){if((0,r.subtract)(v,m,t[S-1].position),(0,r.dot)(v,u.dir)>u.length){const R=S+1;if(g[A]=R,u=t[R],u){d[0]=h[x],d[1]=h[M],d[2]=h[b];const F=(0,r.length)(d);(0,r.scale)(d,u.dir,F),h.set(d,x)}}u&&(z=u.dir)}else{if((0,r.squaredDistance)(m,u.position)<u.radiusSquared){const C=S+1;g[A]=C,u=t[C]}u&&((0,r.subtract)(v,u.position,m),z=(0,r.normalize)(v,v))}if(u){const R=u.forceVariance*l;let F=u.forceAverage*l;R>0&&(F+=2*Math.random()*R-R),h[x]+=z[0]*F,h[M]+=z[1]*F,h[b]+=z[2]*F}}}y&&w.release(y),w.release(m),w.release(v),w.release(d)}}},RadialForce:function(e){const n=(0,r.clone)(e.position),t=e.shape?new K[e.shape.type](e.shape):null,s=t?t[e.shape?.direction||"in"].bind(t):null,i={position:n},a={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0};return{components:["velocity","position"],set(c,p,l,f){"shapeTranslate"===c||"shapeRotate"===c||"shapeScale"===c?$(t,c,p,l,f):c in i?(0,r.set)(i[c],p,l,f):c in a&&(a[c]=p)},update(c,p,l,f){const h=c.get("position"),g=c.get("velocity"),y=a.forceAverage*f,m=a.forceVariance*f,v=t?w.get():null,d=w.get();for(let A=p,x=3*A;A<l;A++,x+=3)if(!s||s(G(v,t,h,A))){let S=y;m>0&&(S+=2*Math.random()*m-m);const u=x+1,M=x+2;d[0]=h[x]-n[0],d[1]=h[u]-n[1],d[2]=h[M]-n[2],(0,r.normalize)(d,d),g[x]+=d[0]*S,g[u]+=d[1]*S,g[M]+=d[2]*S}v&&w.release(v),w.release(d)}}},SpriteAnimation:function(e,n,t){const o=t.spriteRows||0,s=t.spriteCols||1,i=t.spriteStartFrame||0,a=(t.spriteEndFrame||Math.max(0,o*s-1))-i;return{components:["uvTranslate","spriteFrameDuration","spriteCurrentTime"],update(c,p,l,f){const h=c.get("uvTranslate"),g=c.get("spriteFrameDuration"),y=c.get("spriteCurrentTime");for(let m=p,v=2*m,d=m+1;m<l;m++,v+=2,d+=2){y[m]=(y[m]+f)%(a*g[m]);const x=Math.floor(y[m]/g[m]);h[v]=x%s/s;const u=Math.floor(x/s)+1;h[d]=-u/o}}}},UniformForce:function(e){const n=(0,r.clone)(e.directionAverage),t=e.shape?new K[e.shape.type](e.shape):null,s=t?t[e.shape?.direction||"in"].bind(t):null,i={directionAverage:n},a={forceAverage:e.forceAverage,forceVariance:e.forceVariance||0,directionVariance:e.directionVariance||0};return{components:["velocity","position"],set(c,p,l,f){"shapeTranslate"===c||"shapeRotate"===c||"shapeScale"===c?$(t,c,p,l,f):c in i?(0,r.set)(i[c],p,l,f):c in a&&(a[c]=p)},update(c,p,l,f){const h=c.get("position"),g=c.get("velocity"),{forceAverage:y,forceVariance:m,directionVariance:v}=a,d=y*f,A=m*f,x=t?w.get():null,S=w.get();for(let u=p,M=3*u;u<l;u++,M+=3)if(!s||s(G(x,t,h,u))){let b=d;A>0&&(b+=2*Math.random()*A-A),(0,r.copy)(S,n),v&&(S[0]+=2*Math.random()*v-v,S[1]+=2*Math.random()*v-v,S[2]+=2*Math.random()*v-v,(0,r.normalize)(S,S)),g[M]+=S[0]*b,g[M+1]+=S[1]*b,g[M+2]+=S[2]*b}x&&w.release(x),w.release(S)}}}},Ee={LifetimeKill:function(){return{components:["lifetime","age","dead"],update(e,n,t){const o=e.get("age"),s=e.get("lifetime"),i=e.get("dead");for(let a=n;a<t;a++)o[a]>=s[a]&&(i[a]=!0)}}},LifetimeStop:function(){return{components:["lifetime","age","stopped"],update(e,n,t){const o=e.get("age"),s=e.get("lifetime"),i=e.get("stopped");for(let a=n;a<t;a++)o[a]>=s[a]&&(i[a]=!0)}}},PathRadius:function(e,n){const{path:t=[]}=n;return{components:["position","pathIndex"],update(o,s,i){const a=o.get("position"),c=o.get("pathIndex");for(let p=s,l=3*p;p<i;p++,l+=3){const f=c[p],h=f>0?t[f]:null;if(h){const g=l+1,y=l+2;ye[0]=a[l],ye[1]=a[g],ye[2]=a[y],(0,r.subtract)(Se,ye,t[f-1].position);const v=(0,r.dot)(Se,h.dir);(0,r.scale)(se,h.dir,v),(0,r.subtract)(se,Se,se);const d=(0,r.squaredLength)(se);if(d>h.radiusSquared){(0,r.normalize)(se,se);const A=(0,r.scale)(se,se,Math.sqrt(h.radiusSquared)-Math.sqrt(d));a[l]=A[0],a[g]=A[1],a[y]=A[2]}}}}}},PathKill:function(e,n){const{path:t=[]}=n,o=t.length;return{components:["position","path","pathIndex","dead"],update(s,i,a){const c=s.get("pathIndex"),p=s.get("dead");for(let l=i;l<a;l++)c[l]>=o&&(p[l]=!0)}}},PathStop:function(e,n){const{path:t=[]}=n,o=t.length;return{components:["position","path","pathIndex","stopped"],update(s,i,a){const c=s.get("pathIndex"),p=s.get("stopped");for(let l=i;l<a;l++)c[l]>=o&&(p[l]=!0)}}},ShapeBounce:function(e,n){const t=new K[e.shape.type](e.shape),o=e.shape.direction||"in",s=!!e.trap,i=n.trapId||0;s&&(n.trapId=i+1);const a=1<<i,c=["position","velocity"];s&&c.push("trap");const p=t[o].bind(t);return{components:c,set(l,f,h,g){$(t,l,f,h,g)},update(l,f,h){const g=l.get("position"),y=l.get("velocity"),m=s?l.get("trap"):null,v=w.get();for(let d=f;d<h;d++)if(G(v,t,g,d),p(v)){if(!s||m[d]&a){const A=3*d;t.surfaceProjection(v,ke,Ve),g.set(ke,A),N[0]=y[A],N[1]=y[A+1],N[2]=y[A+2];const x=(0,r.length)(N);if(x){N[0]/=x,N[1]/=x,N[2]/=x;const S=(0,r.dot)(N,Ve);(0,r.scale)(Q,Ve,2*S),(0,r.subtract)(Q,N,Q),(0,r.scale)(Q,Q,x)}else Q[0]=0,Q[1]=0,Q[2]=0;y.set(Q,A)}}else s&&(m[d]|=a);w.release(v)}}},ShapeKill:function(e,n){const t=new K[e.shape.type](e.shape),o=e.shape.direction||"in",s=!!e.trap,i=n.trapId||0;s&&(n.trapId=i+1);const a=1<<i,c=["position","dead"];s&&c.push("trap");const p=t[o].bind(t);return{components:c,set(l,f,h,g){$(t,l,f,h,g)},update(l,f,h){const g=l.get("position"),y=l.get("dead"),m=s?l.get("trap"):null,v=w.get();for(let d=f;d<h;d++)G(v,t,g,d),p(v)?(!s||m[d]&a)&&(y[d]=!0):s&&(m[d]|=a);w.release(v)}}},ShapeStop:function(e,n){const t=new K[e.shape.type](e.shape),o=e.shape.direction||"in",s=!!e.trap,i=n.trapId||0;s&&(n.trapId=i+1);const a=1<<i,c=["position","stopped"];s&&c.push("trap");const p=t[o].bind(t);return{components:c,set(l,f,h,g){$(t,l,f,h,g)},update(l,f,h){const g=l.get("position"),y=l.get("stopped"),m=s?l.get("trap"):null,v=w.get();for(let d=f;d<h;d++)G(v,t,g,d),p(v)?(!s||m[d]&a)&&(y[d]=!0):s&&(m[d]|=a);w.release(v)}}}},Me={position:{construct:Float32Array,size:3},velocity:{construct:Float32Array,size:3},color:{construct:Uint8Array,size:4,geometry:!0},scale:{construct:Float32Array,size:1,geometry:!0,init:1},uvRotate:{construct:Float32Array,size:1,geometry:!0},uvTranslate:{construct:Float32Array,size:2,geometry:2,init(e,n,t,o){const{spriteRows:s=0,spriteCols:i=1,spriteStartFrame:a=0}=o,c=a%i/i,p=(s-1-Math.floor(a/i))/s;for(let l=2*n,f=2*t;l<f;l+=2)e[l]=c,e[l+1]=p}},dead:{init:!1},stopped:{init:!1}},j=(0,r.create)();class Ke{playBackRate;emissionAverage;emissionVariance;bounds=function(){return{min:(0,r.fromValues)(1/0,1/0,1/0),max:(0,r.fromValues)(-1/0,-1/0,-1/0)}}();arrays;particles;active;subSystemIds;update;reset;set;constructor(n){const{numParticles:t}=n,o=new Float32Array(3*t),s=new Float32Array(3*t),i={position:{data:o,numComponents:3,drawType:35048}},a=new Map([["position",o],["velocity",s]]),c={},p=new Map;function l(u){return"function"==typeof u?u:(u.components&&u.components.forEach(M=>{if(!a.has(M)){const b=Me[M],z=b?.construct||Array,C=b?.size||1,R=new z(t*C);a.set(M,R),b?.geometry&&(i[M]={data:R,drawType:35048,numComponents:C})}}),u.update)}const f=[];n.creators.filter(u=>!!Ie[u.type]||(console.error(`Undefined particle system creator: '${u.type}'`,u),!1)).forEach(u=>{const M=Ie[u.type](u,c,n),b=l(M);f.push(b),u.id&&("function"!=typeof M?p.set(u.id,M):console.error("Cannot update component",u.type))});const h=[];n.updaters?.filter(u=>!!Oe[u.type]||(console.error(`Undefined particle system updater: '${u.type}'`,u),!1)).map(u=>{const M=Oe[u.type](u,c,n),b=l(M);h.push(b),u.id&&("function"!=typeof M?p.set(u.id,M):console.error("Cannot update component",u.type))});const g=[];n.constraints?.filter(u=>!!Ee[u.type]||(console.error(`Undefined particle system constraint: '${u.type}'`,u),!1)).map(u=>{const M=Ee[u.type](u,c,n),b=l(M);g.push(b),u.id&&("function"!=typeof M?p.set(u.id,M):console.error("Cannot update component",u.type))});const y=n.maxSpeed||0,m=y*y;this.playBackRate=1,this.emissionAverage=n.emissionAverage??1,this.emissionVariance=n.emissionVariance||0,this.subSystemIds=new Set(p.keys());let v=1/0,d=0,A=0;function x(u){const M=d-1;d--,u!==M&&a.forEach((b,z)=>{const C=Me[z];if(C?.copy)return void C.copy(b,M,u);const R=C?.size||1;if(1===R)b[u]=b[M];else for(let F=0,D=M*R,H=u*R;F<R;F++,D++,H++)b[H]=b[D]})}function S(u){const M=A;A++,u!==M&&a.forEach((b,z)=>{const C=Me[z];if(C?.swap)return void C.swap(b,M,u);const R=C?.size||1;if(1===R){const F=b[u];b[u]=b[M],b[M]=F}else for(let F=0,D=M*R,H=u*R;F<R;F++,D++,H++){const pe=b[H];b[H]=b[D],b[D]=pe}})}this.update=u=>{const M=ve(u-v,0,.04)*this.playBackRate;v=u;let b=!1;if(d<t){const Y=this.emissionVariance*M;let L=Math.max(this.emissionAverage*M+2*Math.random()*Y-Y,0);if(L=L>=1?Math.floor(L):Math.random()<L?1:0,L>0){const T=Math.min(d+L,t);a.forEach((k,J)=>{const B=Me[J];if("function"==typeof B?.init)return void B.init(k,d,T,n);const ie=B?.size||1,ue=B?.init??0;if(W(k))k.fill(ue,d*ie,T*ie);else if(Array.isArray(k))if(1===ie)for(let ce=d;ce<T;ce++)k[ce]=ue;else for(let ce=d*ie,Ye=T*ie;ce<Ye;ce++)k[ce]=ue}),f.forEach(k=>{k(a,d,T,M)}),d=T,b=!0}}if(d>A){h.forEach(T=>{T(a,A,d,M)});for(let T=A,k=3*T,J=k+1,B=k+2;T<d;T++,k+=3,J+=3,B+=3){if(j[0]=s[k]*M,j[1]=s[J]*M,j[2]=s[B]*M,m>0){const ie=j[0]*j[0]+j[1]*j[1]+j[2]*j[2];if(ie>m){const ue=Math.sqrt(ie);(0,r.scale)(j,j,y/ue),s.set(j,k)}}o[k]+=j[0],o[J]+=j[1],o[B]+=j[2]}const q=a.get("rotationSpeed");if(q){const T=a.get("uvRotate");for(let k=A;k<d;k++)T[k]+=q[k]*M}const Y=a.get("age"),L=a.get("lifetime");if(Y&&L)for(let T=A;T<d;T++)Y[T]=Math.min(Y[T]+M,L[T]);g.forEach(T=>{T(a,A,d,M)}),b=!0}const z=a.get("dead"),C=a.get("stopped");if(z||C)for(let q=d-1;q>=A;q--)z&&z[q]?(x(q),b=!0):C&&C[q]&&(S(q),b=!0);let R=1/0,F=1/0,D=1/0,H=-1/0,pe=-1/0,Pe=-1/0;for(let q=0,Y=3*q,L=Y+1,T=Y+2;q<d;q++,Y+=3,L+=3,T+=3){const k=o[Y],J=o[L],B=o[T];k<R&&(R=k),J<F&&(F=J),B<D&&(D=B),k>H&&(H=k),J>pe&&(pe=J),B>Pe&&(Pe=B)}return(0,r.set)(this.bounds.min,R,F,D),(0,r.set)(this.bounds.max,H,pe,Pe),b},this.reset=()=>{d=0,A=0},this.set=(u,M,b,z,C)=>{const R=p.get(u);R&&R.set&&R.set(M,b,z,C)},Object.defineProperties(this,{arrays:{get:()=>i},particles:{get:()=>d},active:{get:()=>d-A}})}}const Z=new Map,be=new Set;let le=0;function qe(e,n,t="update"){const{particles:o,arrays:s,bounds:i}=n,a={},c=[];Object.keys(s).forEach(p=>{const{data:l,...f}=s[p],g=l.slice(0,"create"===t?l.length:o*(f.numComponents||3));a[p]={...f,data:g},c.push(g.buffer)}),self.postMessage({command:t,id:e,particles:o,arrays:a,bounds:{min:Array.from(i.min),max:Array.from(i.max)}},c)}function Be(){const e=performance.now()/1e3;be.forEach(n=>{const t=Z.get(n);t.update(e)&&qe(n,t)}),le=setTimeout(Be,8)}const Ge={create:function(e){const{id:n,def:t}=e;if(Z.has(n))return void console.warn(`Simulation worker: Simulation already exists: '${n}'`);const o=new Ke(t);Z.set(n,o),qe(n,o,"create")},destroy:function(e){const{id:n}=e;Z.get(n)?Z.delete(n):console.warn(`Simulation worker: Simulation not found: '${n}'`)},start:function(e){be.add(e.id),le||(le=setTimeout(Be,8))},pause:function(e){be.delete(e.id),be.size||(clearTimeout(le),le=0)},set(e){const{id:n,componentId:t,key:o,x:s,y:i,z:a}=e;Z.get(n).set(t,o,s,i,a)},playBackRate(e){const{id:n,value:t}=e;Z.get(n).playBackRate=t},emissionAverage(e){const{id:n,value:t}=e;Z.get(n).emissionAverage=t},emissionVariance(e){const{id:n,value:t}=e;Z.get(n).emissionVariance=t},reset(e){Z.get(e.id).reset()},returnArrays(){}};self.onmessage=e=>{const n=Ge[e.data.command];n?n(e.data):console.warn(`Simulation worker: Unrecognized command: '${e.data.command||""}'`)}})()}},ze={};function P(V){var I=ze[V];if(void 0!==I)return I.exports;var _=ze[V]={exports:{}};return Re[V](_,_.exports,P),_.exports}P.m=Re,P.x=()=>{var V=P.O(void 0,[449],()=>P(49513));return P.O(V)},V=[],P.O=(I,_,W,r)=>{if(!_){var O=1/0;for(X=0;X<V.length;X++){for(var[_,W,r]=V[X],U=!0,E=0;E<_.length;E++)(!1&r||O>=r)&&Object.keys(P.O).every(Ae=>P.O[Ae](_[E]))?_.splice(E--,1):(U=!1,r<O&&(O=r));if(U){V.splice(X--,1);var ee=W();void 0!==ee&&(I=ee)}}return I}r=r||0;for(var X=V.length;X>0&&V[X-1][2]>r;X--)V[X]=V[X-1];V[X]=[_,W,r]},P.d=(V,I)=>{for(var _ in I)P.o(I,_)&&!P.o(V,_)&&Object.defineProperty(V,_,{enumerable:!0,get:I[_]})},P.f={},P.e=V=>Promise.all(Object.keys(P.f).reduce((I,_)=>(P.f[_](V,I),I),[])),P.u=V=>V+".js",P.miniCssF=V=>{},P.o=(V,I)=>Object.prototype.hasOwnProperty.call(V,I),P.r=V=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(V,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(V,"__esModule",{value:!0})},(()=>{var V;P.tt=()=>(void 0===V&&(V={createScriptURL:I=>I},typeof trustedTypes<"u"&&trustedTypes.createPolicy&&(V=trustedTypes.createPolicy("angular#bundler",V))),V)})(),P.tu=V=>P.tt().createScriptURL(V),P.p="",(()=>{var V={513:1};P.f.i=(r,X)=>{V[r]||importScripts(P.tu(P.p+P.u(r)))};var _=self.webpackChunkviewer=self.webpackChunkviewer||[],W=_.push.bind(_);_.push=r=>{var[X,O,U]=r;for(var E in O)P.o(O,E)&&(P.m[E]=O[E]);for(U&&U(P);X.length;)V[X.pop()]=1;W(r)}})(),(()=>{var V=P.x;P.x=()=>P.e(449).then(V)})(),P.x()})();