/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} a Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be 
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getScaling = function (out, mat) {
  var m11 = mat[0],
      m12 = mat[1],
      m13 = mat[2],
      m21 = mat[4],
      m22 = mat[5],
      m23 = mat[6],
      m31 = mat[8],
      m32 = mat[9],
      m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }

    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0) {
        return 0;
    }
    else if(cosine < -1.0) {
        return Math.PI;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */

(function () {
    "use strict";

    var SceneJS_Map = window.SceneJS_Map = function(items, _baseId) {

        /**
         * @property Items in this map
         */
        this.items = items || [];


        var baseId = _baseId || 0;
        var lastUniqueId = baseId + 1;

        /**
         * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
         * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
         *
         * id = myMap.addItem("foo") // ID internally generated
         *
         * id = myMap.addItem("foo", "bar") // ID is "foo"
         *
         */
        this.addItem = function() {

            var item;

            if (arguments.length == 2) {

                var id = arguments[0];

                item = arguments[1];

                if (this.items[id]) { // Won't happen if given ID is string
                    SceneJS_error.fatalError(SceneJS.errors.ID_CLASH, "ID clash: '" + id + "'");
                }

                this.items[id] = item;

                return id;

            } else {

                while (true) {

                    item = arguments[0];
                    var findId = lastUniqueId++;

                    if (!this.items[findId]) {
                        this.items[findId] = item;
                        return findId;
                    }
                }
            }
        };

        /**
         * Removes the item of the given ID from the map
         */
        this.removeItem = function(id) {
            delete this.items[id];
        };
    };
})();

;/**
 * The SceneJS object.
 */

(function () {
    "use strict";

    var SceneJS = window.SceneJS = new (function () {

        /**
         * This SceneJS version
         */
        this.VERSION = '3.2';

        this.ENABLE_EXTENSIONS = [
            "WEBGL_depth_texture",
            "OES_texture_float",
            "OES_texture_float_linear",
            "OES_element_index_uint",
            "OES_standard_derivatives",
            "EXT_shader_texture_lod"
        ];

        this._baseStateId = 0;

        // Pub/sub support
        this._handleMap = new SceneJS_Map(); // Subscription handle pool
        this._topicSubs = {}; // A [handle -> callback] map for each topic name
        this._handleTopics = {}; // Maps handles to topic names
        this._topicPubs = {}; // Maps topics to publications

        /**
         * @property {SceneJS_Engine} Engines currently in existance
         */
        this._engines = {};

        this._engineIds = new SceneJS_Map();

        this.timer = window.performance || window.Date;

        this.WEBGL_INFO = (function() {
            var info = {
                WEBGL: false,
                SOFTWARE_RENDERER: false
            };

            var canvas = document.createElement("canvas");

            if (!canvas) {
                return info;
            }

            var gl = canvas.getContext("webgl", { antialias: true, failIfMajorPerformanceCaveat: true }) || canvas.getContext("experimental-webgl", { antialias: true, failIfMajorPerformanceCaveat: true });

            if (!gl) {
                gl = canvas.getContext("webgl", { antialias: true }) || canvas.getContext("experimental-webgl", { antialias: true });
                if (gl) {
                    info.SOFTWARE_RENDERER = true;
                }
            }

            info.WEBGL = !!gl;

            if (!info.WEBGL) {
                return info;
            }

            info.ANTIALIAS = gl.getContextAttributes().antialias;

            if (gl.getShaderPrecisionFormat) {
                if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                    info.FS_MAX_FLOAT_PRECISION = "highp";
                } else if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                    info.FS_MAX_FLOAT_PRECISION = "mediump";
                } else {
                    info.FS_MAX_FLOAT_PRECISION = "lowp";
                }
            } else {
                info.FS_MAX_FLOAT_PRECISION = "mediump";
            }

            info.DEPTH_BITS = gl.getParameter(gl.DEPTH_BITS);
            info.STENCIL_BITS = gl.getParameter(gl.STENCIL_BITS);
            info.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            info.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            info.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            info.MAX_TEXTURE_UNITS =  gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            info.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
            info.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            info.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            info.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);
            info.SAMPLE_BUFFERS = !!gl.getParameter(gl.SAMPLE_BUFFERS);
            info.SAMPLES = gl.getParameter(gl.SAMPLES);
            info.MAX_POINT_SIZE = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE)[1];
            info.MAX_VIEWPORT_DIMS = gl.getParameter(gl.MAX_VIEWPORT_DIMS);

            info.SUPPORTED_EXTENSIONS = {};

            gl.getSupportedExtensions().forEach(function(ext) {
                info.SUPPORTED_EXTENSIONS[ext] = true;
            });

            info.depthTexturesSupported = info.SUPPORTED_EXTENSIONS["WEBGL_depth_texture"] || false;
            info.floatTexturesSupported = info.SUPPORTED_EXTENSIONS["OES_texture_float"] || false;
            info.linearFloatTexturesSupported = info.SUPPORTED_EXTENSIONS["OES_texture_float_linear"] || false;
            info.drawBuffersSupported = info.SUPPORTED_EXTENSIONS["WEBGL_draw_buffers"] || false;
            info.standardDerivativesSupported = info.SUPPORTED_EXTENSIONS["OES_standard_derivatives"] || false;
            info.textureLODSupported = info.SUPPORTED_EXTENSIONS["EXT_shader_texture_lod"] || false;

            return info;
        })();

        this.DISPLAY_FLAGS = {
            FOG_LINEAR: 1,
            FOG_EXP:    2,
            FOG_EXP2:   3
        };

        this.TEXTURE_FLAGS = {
            baseColor:        1,
            specular:         1 << 1,
            emit:             1 << 2,
            alpha:            1 << 3,
            normals:          1 << 4,
            shine:            1 << 5,
            metallic:         1 << 6,
            roughness:        1 << 7,
            occlusion:        1 << 8,
            add:              1 << 9,
            multiply:         1 << 10,
            over:             1 << 11,
            transparency:     1 << 12,
            conditionalAlpha: 1 << 13,
            swizzledNormals:  1 << 14
        };

        this.CUBEMAP_FLAGS = {
            reflect:      1,
            light:        2
        };

        this.PROPERTY_FLAGS = {
            PICKING:            1,
            ENABLED:            1 << 1,
            REFLECTIVE:         1 << 2,
            SOLID:              1 << 3,
            SKYBOX:             1 << 4,
            XRAY:               1 << 5,
            CCW:                1 << 6,
            NO_DEPTH_MASK:      1 << 7,
            PARTIALLY_OPAQUE:   1 << 8,
            FORCE_TRANSPARENT:  1 << 9,
            ROUND_POINTS:       1 << 10,
            PERSPECTIVE_POINTS: 1 << 11,
            BILLBOARD:          1 << 12,
            CLIPPING:           1 << 13,
            STOCHASTIC_ALPHA:   1 << 14
        };

        this.COLOR_MOD_FLAGS = {
            SATURATION: 1,
            BRIGHTNESS: 1 << 1,
            CONTRAST:   1 << 2,
            TINT:       1 << 3
        };

        this.XFORM_FLAGS = {
            MATRIX_DIRTY: 1,      // Node matrix is dirty
            COMPILING:    1 << 1, // Hierarchy is dirty
            DIRTY:        1 << 2,
        };

        this.TRANSPARENCY_FLAGS = {
            ALPHA:              1,
            IMPROVED_ALPHA:     1 << 1,
            ADD_ALPHA:          1 << 2,
            ALPHA_TO_COVERAGE:  1 << 3,
            WEIGHTED_OIT:       1 << 4
        };

        this.DEPTH_TEST_FLAGS = {
            ENABLED:            1,
            DISABLED:           1 << 1,
            ALWAYS_PASS:        1 << 2
        };

        this.TRANSPARENCY_FLAGS.TWO_PASS = this.TRANSPARENCY_FLAGS.IMPROVED_ALPHA;
        this.TRANSPARENCY_FLAGS.ORDER_DEPENDENT = this.TRANSPARENCY_FLAGS.ALPHA | this.TRANSPARENCY_FLAGS.IMPROVED_ALPHA;
        this.TRANSPARENCY_FLAGS.ALPHA_NO_DEPTH_MASK = this.TRANSPARENCY_FLAGS.IMPROVED_ALPHA | this.TRANSPARENCY_FLAGS.ADD_ALPHA;
        this.TRANSPARENCY_FLAGS.ALPHA_BLEND = this.TRANSPARENCY_FLAGS.ALPHA | this.TRANSPARENCY_FLAGS.IMPROVED_ALPHA | this.TRANSPARENCY_FLAGS.ADD_ALPHA;

        this.KD_TREE_MAX_DEPTH = 10;
        this.KD_TREE_MIN_TRIANGLES = 20;

        // Should be called before creating a scene.
        this.setMaxPointSize = function (val) {
            SceneJS_ProgramSourceFactory.setMaxPointSize(val);
        };

        /**
         * Publishes to a topic.
         *
         * Immediately notifies existing subscriptions to that topic, retains the publication to give to
         * any subsequent notifications on that topic as they are made.
         *
         * @param {String} topic Publication topic
         * @param {Object} pub The publication
         * @param {Boolean} [forget] When true, the publication will be sent to subscribers then forgotten, so that any
         * subsequent subscribers will not receive it
         * @private
         */
        this.publish = function (topic, pub, forget) {
            if (!forget) {
                this._topicPubs[topic] = pub; // Save notification
            }
            var subsForTopic = this._topicSubs[topic];
            if (subsForTopic) { // Notify subscriptions
                for (var handle in subsForTopic) {
                    if (subsForTopic.hasOwnProperty(handle)) {
                        subsForTopic[handle].call(this, pub);
                    }
                }
            }
        };

        /**
         * Removes a topic publication
         *
         * Immediately notifies existing subscriptions to that topic, sending them each a null publication.
         *
         * @param topic Publication topic
         * @private
         */
        this.unpublish = function (topic) {
            var subsForTopic = this._topicSubs[topic];
            if (subsForTopic) { // Notify subscriptions
                for (var handle in subsForTopic) {
                    if (subsForTopic.hasOwnProperty(handle)) {
                        subsForTopic[handle].call(this, null);
                    }
                }
            }
            delete this._topicPubs[topic];
        };


        /**
         * Listen for data changes at a particular location
         *
         * <p>Your callback will be triggered for
         * the initial data and again whenever the data changes. Use {@link #off} to stop receiving updates.</p>
         *
         * <p>The callback is be called with SceneJS as scope.</p>
         *
         * @param {String} location Publication location
         * @param {Function(data)} callback Called when fresh data is available at the location
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        this.on = function (topic, callback) {
            var subsForTopic = this._topicSubs[topic];
            if (!subsForTopic) {
                subsForTopic = {};
                this._topicSubs[topic] = subsForTopic;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subsForTopic[handle] = callback;
            this._handleTopics[handle] = topic;
            var pub = this._topicPubs[topic];
            if (pub) { // A publication exists, notify callback immediately
                callback.call(this, pub);
            }
            return handle;
        };

        /**
         * Unsubscribes from a publication that was previously made with {@link #on}.
         * @param handle Publication handle
         */
        this.off = function (handle) {
            var topic = this._handleTopics[handle];
            if (topic) {
                delete this._handleTopics[handle];
                var topicSubs = this._topicSubs[topic];
                if (topicSubs) {
                    delete topicSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
                if (topic == "rendered") {
                    this._engine.branchDirty(this);
                }
            }
        };

        /**
         * Listens for exactly one data update at the specified location, and then stops listening.
         * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
         * @param {String} location Data location to listen to
         * @param {Function(data)} callback Called when fresh data is available at the location
         */
        this.once = function (topic, callback) {
            var self = this;
            var sub = this.on(topic,
                function (pub) {
                    self.off(sub);
                    callback(pub);
                });
        };

        /**
         * Creates a new scene from the given JSON description and begins rendering it
         *
         * @param {String} json JSON scene description
         * @param {*} options Optional options
         * @param {Boolean} options.simulateWebGLContextLost Set true to enable simulation of lost WebGL context (has performance impact)
         * @returns {SceneJS.Scene} New scene
         */
        this.createScene = function (json, options) {

           json = json || {};

            if (json.id) {
                if (this._engines[json.id]) {
                    SceneJS_error.fatalError(
                        SceneJS.errors.ILLEGAL_NODE_CONFIG,
                        "Scene already exists with this ID: '" + json.id + "'");
                }
                this._engineIds.addItem(json.id, {});
            } else {
                json.id = this._engineIds.addItem({});
            }

            var engine = new SceneJS_Engine(json, options);

            this._engines[json.id] = engine;

            return engine.scene;
        };

        /**
         * Gets an existing scene
         *
         * @param {String} sceneId ID of target scene
         * @deprecated
         * @returns {SceneJS.Scene} The selected scene
         */
        this.scene = function (sceneId) {

            var engine = this._engines[sceneId];

            return engine ? engine.scene : null;
        };

        /**
         * Gets an existing scene.
         *
         * When no scene ID is given, the first scene found is returned. This is a shorthand convenience for
         * easy scripting when only one scene is defined.
         *
         * @param {String} [sceneId] ID of target scene
         * @returns {SceneJS.Scene} The selected scene
         */
        this.getScene = function (sceneId) {

            if (!sceneId) {
                for (var sceneId in this._engines) {
                    if (this._engines.hasOwnProperty(sceneId)) {
                        return this._engines[sceneId].scene;
                    }
                }
            }

            var engine = this._engines[sceneId];

            return engine ? engine.scene : null;
        };

        /**
         * Gets existing scenes
         *
         * @returns  Existing scenes, mapped to their IDs
         */
        this.getScenes = function () {

            var scenes = {};

            for (var sceneId in this._engines) {
                if (this._engines.hasOwnProperty(sceneId)) {
                    scenes[sceneId] = this._engines[sceneId].scene;
                }
            }

            return scenes;
        };

        /**
         * Tests if the given object is an array
         * @private
         */
        this._isArray = function (testObject) {
            return testObject && !(testObject.propertyIsEnumerable('length'))
                && typeof testObject === 'object' && typeof testObject.length === 'number';
        };

        /**
         *
         */
        this._shallowClone = function (o) {
            var o2 = {};
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    o2[name] = o[name];
                }
            }
            return o2;
        };

        /**
         * Add properties of o to o2 where undefined or null on o2
         * @private
         */
        this._applyIf = function (o, o2) {
            for (var name in o) {
                if (o.hasOwnProperty(name)) {
                    if (o2[name] == undefined || o2[name] == null) {
                        o2[name] = o[name];
                    }
                }
            }
            return o2;
        };

        /**
         * Add properties of o to o2, overwriting them on o2 if already there.
         * The optional clear flag causes properties on o2 to be cleared first
         * @private
         */
        this._apply = function (o, o2, clear) {
            var name;
            if (clear) {
                for (name in o2) {
                    if (o2.hasOwnProperty(name)) {
                        delete o2[name];
                    }
                }
            }
            for (name in o) {
                if (o.hasOwnProperty(name) && o[name] != undefined) {
                    o2[name] = o[name];
                }
            }
            return o2;
        };

        var hasOwnProperty = Object.prototype.hasOwnProperty;

        /**
         * Tests is an object is empty
         * @param obj
         * @returns {boolean}
         * @private
         */
        this._isEmpty =function(obj) {
            // null and undefined are "empty"
            if (obj == null) return true;
            // Assume if it has a length property with a non-zero value
            // that that property is correct.
            if (obj.length > 0)    return false;
            if (obj.length === 0)  return true;
            // Otherwise, does it have any properties of its own?
            // Note that this doesn't handle
            // toString and valueOf enumeration bugs in IE < 9
            for (var key in obj) {
                if (hasOwnProperty.call(obj, key)) return false;
            }
            return true;
        };

        /**
         * Tests if the given value is a number
         * @param value
         * @returns {boolean}
         * @private
         */
        this._isNumeric = function (value) {
            return !isNaN(parseFloat(value)) && isFinite(value);
        };

        /**
        * Shim for slicing arrays regardless of the array type.
        * (Primarily because TypedArray.prototype.slice is
        * not supported on all platforms)
        */
        this._sliceArray = function(array, start, end) {
            if (array.slice) {
                return array.slice(start, end);
            }

            start = start || 0;
            end = end || array.length;

            var length = end - start;
            var newArray = new array.constructor(length);

            for (var i = 0; i < length; i++) {
                newArray[i] = array[start + i];
            }

            return newArray;
        };

        /**
            Load binary data.
        */
        this._loadBinary = function (src, callback) {
            var request = new XMLHttpRequest();
            request.responseType = "arraybuffer";
            request.open("GET", src);

            request.onload = function() {
                callback(request.response);
            };

            request.send(null);
        };

        /**
            Get a WebGL extension, including if prefixed.
        */
        var extensionPrefixes = ["", "MOZ_", "WEBKIT_"];

        this.checkExtension = function(extension) {
            for (var i = 0, len = extensionPrefixes.length; i < len; i++) {
                if (this.WEBGL_INFO.SUPPORTED_EXTENSIONS[extensionPrefixes[i] + extension]) {
                    return true;
                }
            }

            return false;
        };

        this._getExtension = function(gl, extension) {
            for (var i = 0, len = extensionPrefixes.length; i < len; i++) {
                var ext = gl.getExtension(extensionPrefixes[i] + extension);
                if (ext) {
                    return ext;
                }
            }

            return null;
        };

        this.printGraph = function(node) {
            printGraph(node, 0);
        }

        /**
         * Resets SceneJS, destroying all existing scenes
         */
        this.reset = function () {

            var temp = [];

            for (var id in this._engines) { // Collect engines to destroy
                if (this._engines.hasOwnProperty(id)) {

                    temp.push(this._engines[id]);

                    delete this._engines[id];

                    this._engineIds.removeItem(id);
                }
            }

            while (temp.length > 0) { // Destroy the engines
                temp.pop().destroy();
            }

            SceneJS_events.fireEvent(SceneJS_events.RESET);
        };

        function printGraph(node, level) {
            var padding = "";
            var i;

            for (i = 0; i < level; i++) {
                padding += " ";
            }
            padding += "-- "
            console.log(padding + node.type + " (id: " + node.id + ", coreId: " + node.coreId + ")");

            for (i = 0; i < node.nodes.length; i++) {
                printGraph(node.nodes[i], level + 1);
            }
        }


    })();

})();
;/**
 *  @private
 */

(function() {
    "use strict";

    var SceneJS_events = window.SceneJS_events = new (function () {

        this.ERROR = 0;
        this.RESET = 1;                         // SceneJS framework reset
        this.NODE_CREATED = 2;                 // Scene has just been created
        this.SCENE_CREATED = 3;                 // Scene has just been created
        this.SCENE_COMPILING = 4;               // Scene about to be compiled and drawn
        this.SCENE_DESTROYED = 5;               // Scene just been destroyed
        this.OBJECT_COMPILING = 6;
        this.WEBGL_CONTEXT_LOST = 7;
        this.WEBGL_CONTEXT_RESTORED = 8;
        this.RENDER = 9;

        /* Priority queue for each type of event
         */
        var events = [];

        /**
         * Registers a handler for the given event and returns a subscription handle
         *
         * The handler can be registered with an optional priority number which specifies the order it is
         * called among the other handler already registered for the event.
         *
         * So, with n being the number of commands registered for the given event:
         *
         * (priority <= 0)      - command will be the first called
         * (priority >= n)      - command will be the last called
         * (0 < priority < n)   - command will be called at the order given by the priority
         * @private
         * @param type Event type - one of the values in SceneJS_events
         * @param command - Handler function that will accept whatever parameter object accompanies the event
         * @param priority - Optional priority number (see above)
         * @return {String} - Subscription handle
         */
        this.addListener = function (type, command, priority) {

            var list = events[type];

            if (!list) {
                list = [];
                events[type] = list;
            }

            var handler = {
                command:command,
                priority:(priority == undefined) ? list.length : priority
            };

            var index = -1;

            for (var i = 0, len = list.length; i < len; i++) {
                if (!list[i]) {
                    index = i;
                    break;
                }
            }

            if (index < 0) {
                list.push(handler);
                index = list.length - 1;
            }

            var handle = type + "." + index;

            return handle;
        };

        /**
         * Removes a listener
         * @param handle Subscription handle
         */
        this.removeListener = function (handle) {

            var lastIdx = handle.lastIndexOf(".");

            var type = parseInt(handle.substr(0, lastIdx));
            var index = parseInt(handle.substr(lastIdx + 1));

            var list = events[type];

            if (!list) {
                return;
            }

            delete list[index];
        };

        /**
         * @private
         */
        this.fireEvent = function (type, params) {

            var list = events[type];

            if (list) {
                params = params || {};
                for (var i = 0; i < list.length; i++) {
                    if (list[i]) {
                        list[i].command(params);
                    }
                }
            }
        };

    })();


    /**
     * Subscribe to SceneJS events
     * @deprecated
     */
    SceneJS.bind = function (name, func) {
        switch (name) {

            case "error" :

                return SceneJS_events.addListener(SceneJS_events.ERROR, func);
                break;

            case "reset" :

                return SceneJS_events.addListener(
                    SceneJS_events.RESET,
                    function () {
                        func();
                    });
                break;

            case "webglcontextlost" :

                return SceneJS_events.addListener(
                    SceneJS_events.WEBGL_CONTEXT_LOST,
                    function (params) {
                        func(params);
                    });
                break;

            case "webglcontextrestored" :

                return SceneJS_events.addListener(
                    SceneJS_events.WEBGL_CONTEXT_RESTORED,
                    function (params) {
                        func(params);
                    });
                break;

            default:
                SceneJS_error.fatalError("SceneJS.bind - this event type not supported: '" + name + "'");
        }
    };

    /* Subscribe to SceneJS events
     * @deprecated
     */
    SceneJS.onEvent = SceneJS.bind;

    /* Unsubscribe from event
     */
    SceneJS.unEvent = function (handle) {
        return SceneJS_events.removeListener(handle);
    };

    SceneJS.subscribe = SceneJS.addListener = SceneJS.onEvent = SceneJS.bind;

    SceneJS.unsubscribe = SceneJS.unEvent;


    SceneJS.on = SceneJS.onEvent;
    SceneJS.off = SceneJS.unEvent;
})();

;/**
 *
 */

(function () {
    "use strict";

    var SceneJS_Canvas = window.SceneJS_Canvas = function (id, canvasId, contextAttr, options) {

        /**
         * ID of this canvas
         */
        this.canvasId;

        if (!canvasId) {
            // Automatic default canvas
            canvasId = "canvas-" + id;
            var body = document.getElementsByTagName("body")[0];
            var div = document.createElement('div');
            var style = div.style;
            style.height = "100%";
            style.width = "100%";
            style.padding = "0";
            style.margin = "0";
            style.left = "0";
            style.top = "0";
            style.position = "absolute";
            // style["z-index"] = "10000";
            div.innerHTML += '<canvas id="' + canvasId + '" style="width: 100%; height: 100%; margin: 0; padding: 0;"></canvas>';
            body.appendChild(div);
        }

        // Bind to canvas
        var canvas = document.getElementById(canvasId);
        if (!canvas) {
            SceneJS_error.fatalError(SceneJS.errors.CANVAS_NOT_FOUND,
                "SceneJS.Scene attribute 'canvasId' does not match any elements in the page");
        }

        canvas.addEventListener("webglcontextcreationerror", function(e) {
            console.error("Unable to initialize WebGL:", e.statusMessage || "Unknown error"); 
        }, false);

        this.canvasId = canvasId;

        /**
         * WebGL context options
         */
        this.options = options || {};

        this.canvas = canvas;

        if (this.options.simulateWebGLContextLost) {
            if (window.WebGLDebugUtils) {
                this.canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(this.canvas)
            } else {
                console.error("To simulate context loss, please include WebGLDebugUtils");
            }
        }

        // If the canvas uses css styles to specify the sizes make sure the basic
        // width and height attributes match or the WebGL context will use 300 x 150
        this.resolutionScaling = this.options.resolutionScaling || 1;

        this.canvas.width = this.canvas.clientWidth * this.resolutionScaling;
        this.canvas.height = this.canvas.clientHeight * this.resolutionScaling;

        /**
         * Attributes given when initialising the WebGL context
         */
        this.contextAttr = contextAttr || {};
        this.contextAttr.alpha = true;

        /**
         * The WebGL context
         */
        this.gl = null;

        /**
         * True when WebGL 2 support is enabled.
         *
         * @property webgl2
         * @type {Boolean}
         * @final
         */
        this.webgl2 = false; // Will set true in _initWebGL if WebGL is requested and we succeed in getting it.

        this.initWebGL();
    };

    /**
     * Names of recognised WebGL contexts
     */
    SceneJS_Canvas.prototype._WEBGL_CONTEXT_NAMES = [
        "webgl",
        "experimental-webgl",
        "webkit-3d",
        "moz-webgl",
        "moz-glweb20"
    ];

    /**
     * Initialise the WebGL context

     */
    SceneJS_Canvas.prototype.initWebGL = function () {

        if (this.options.webgl2 === true) {
            try {
                this.gl = this.canvas.getContext("webgl2", this.contextAttr);
            } catch (e) { // Try with next context name
            }
            if (!this.gl) {
                console.log('Failed to get a WebGL 2 context - defaulting to WebGL 1.');
            } else {
                this.webgl2 = true;
            }
        }

        if (!this.gl) {
            for (var i = 0; !this.gl && i < this._WEBGL_CONTEXT_NAMES.length; i++) {
                try {
                    this.gl = this.canvas.getContext(this._WEBGL_CONTEXT_NAMES[i], this.contextAttr);
                } catch (e) { // Try with next context name
                }
            }
        }

        if (!this.gl) {
            // DO NOT THROW
            // how will this effect control flow???
            SceneJS_error.fatalError(
                SceneJS.errors.WEBGL_NOT_SUPPORTED,
                "Failed to get a WebGL context"
            );
        }
    };


    /**
     * Simulate a lost WebGL context.
     * Only works if the simulateWebGLContextLost was given as an option to the canvas' constructor.
     */
    SceneJS_Canvas.prototype.loseWebGLContext = function () {
        if (this.options.simulateWebGLContextLost) {
            this.canvas.loseContext();
        }
    };

    /**
     * Set canvas size multiplier for supersample anti-aliasing
     */
    SceneJS_Canvas.prototype.setResolutionScaling = function (resolutionScaling) {
        this.resolutionScaling = resolutionScaling;
        this.canvas.width = this.canvas.clientWidth * resolutionScaling;
        this.canvas.height = this.canvas.clientHeight * resolutionScaling;
    };
})();

;/**
 * @class A container for a scene graph and its display
 *
 *
 * @private
 */

(function () {
    "use strict";

    var renderingEvent = {
        pass: 0
    };

    var renderOptions = {
        clear: true
    };

    var renderedEvent = {
        sceneId: -1,
        time: -1,
        pass: 0
    };

    var sleepEvent = {
        sceneId: -1,
        startTime: -1,
        prevTime: -1,
        time: -1
    };

    var width;
    var height;
    var lastWidth = null;
    var lastHeight = null;
    var prevTime = -1;
    var startTime = -1;

    var SceneJS_Engine = window.SceneJS_Engine = function (json, options) {
        options = options || {};

        json.type = "scene"; // The type property supplied by user on the root JSON node is ignored - would always be 'scene'

        /**
         * ID of this engine, also the ID of this engine's {@link SceneJS.Scene}
         * @type String
         */
        this.id = json.id;


        /**
         * Number of times the scene is drawn each time it's rendered.
         * <p>This is useful for when we need to do things like render for left and right eyes.
         * @type {*|number}
         */
        this._numPasses = json.numPasses || 1;

        /**
         * When doing multiple passes per frame, specifies whether to clear the
         * canvas before each pass (true) or just before the first pass (false, default).
         * @type Boolean
         */
        this._clearEachPass = !!json.clearEachPass;

        /**
         * Canvas and GL context for this engine
         */
        this.canvas = new SceneJS_Canvas(this.id, json.canvasId, json.contextAttr, options);

        /**
         * State core factory - creates, stores, shares and destroys cores
         */
        this._coreFactory = new SceneJS_CoreFactory();

        /**
         * Manages creation, recycle and destruction of {@link SceneJS.Node} instances for this engine's scene graph
         */
        this._nodeFactory = new SceneJS_NodeFactory();

        /**
         * Tracks statistics within this engine, such as numbers of
         * scenes, textures, geometries etc.
         *
         * @property stats
         * @type {*}
         * @final
         */
        this.stats = {
            build: {
                version: SceneJS.VERSION
            },
            client: {
                browser: (navigator && navigator.userAgent) ? navigator.userAgent : "n/a"
            },
            components: {},
            state: {
                programs: 0,
            },
            geometry: {
                meshes: 0,
                vertices: 0,
                triangles: 0,
            },
            textures: {},
            load: {
                sceneGraphCompilation: 0,
                shaderCompilation: 0,
                programCompilation: 0
            },
            memory: {
                positions: 0,
                colors: 0,
                normals: 0,
                uvs: 0,
                indices: 0,
                morphPositions: 0,
                morphNormals: 0,
                textures: 0,
                tangents: 0,
                pickPositions: 0,
                pickColors: 0
            },
            frame: {
                frameCount: 0,
                useProgram: 0,
                bindTexture: 0,
                bindArray: 0,
                drawElements: 0,
                drawArrays: 0,
                drawChunks: 0
            }
        };

        /**
         * The engine's scene renderer
         * @type SceneJS_Display
         */
        this.display = new SceneJS_Display(this.stats, {
            canvas: this.canvas,
            transparent: json.transparent,
            autoTangents : options.autoTangents,
            gammaInputPhong: options.gammaInputPhong
        });

        /**
         * Flags the entirety of the scene graph as needing to be (re)compiled into the display
         */
        this.sceneDirty = false;

        /**
         * Flag set when at least one branch of the scene graph needs recompilation
         */
        this._sceneBranchesDirty = false;

        /**
         * Flag to prevent engine from re-compiling the scene graph
         */
        this._compilationPaused = false;

        /**
         * List of nodes scheduled for destruction by #destroyNode
         * Destructions are done in a batch at the end of each render so as not to disrupt the render.
         */
        this._nodesToDestroy = [];

        /**
         * Number of nodes in destruction list
         */
        this._numNodesToDestroy = 0;

        /**
         * Flag set once this engine has been destroyed
         */
        this.destroyed = false;

        var gl = this.canvas.gl;

        var extensions = SceneJS.ENABLE_EXTENSIONS;
        for (var i = 0, len = extensions.length; i < len; ++i) {
            gl.getExtension(extensions[i]);
        }

        this.cpuTimer = SceneJS.timer;
        this.gpuTimer = gl.getExtension("EXT_disjoint_timer_query") || null;

        if (this.gpuTimer) {
            this.gpuTimerQuery = this.gpuTimer.createQueryEXT(this.gpuTimer.TIME_ELAPSED_EXT);
        }

        /**
         * The current scene graph status
         */
        this.sceneStatus = {
            nodes: {}, // Status for each node
            numTasks: 0  // Number of loads currently in progress
        };

        var self = this;

        // Create scene root first, then create its subnodes
        // This way nodes can access the scene in their constructors
        var nodes = json.nodes;
        json.nodes = [];
        this.scene = this.createNode(json); // Create scene root

        if (nodes) {
            json.nodes = nodes;
            this.scene.addNodes(nodes); // then create sub-nodes
        }

        this.canvas.canvas.addEventListener(// WebGL context lost
            "webglcontextlost",
            function (event) {
                event.preventDefault();
                SceneJS_events.fireEvent(SceneJS_events.WEBGL_CONTEXT_LOST, {scene: self.scene});
            },
            false);

        this.canvas.canvas.addEventListener(// WebGL context recovered
            "webglcontextrestored",
            function (event) {
                self.canvas.initWebGL();

                var gl = self.canvas.gl;

                var extensions = SceneJS.ENABLE_EXTENSIONS;
                for (var i = 0, len = extensions.length; i < len; ++i) {
                    gl.getExtension(extensions[i]);
                }

                self.gpuTimer = gl.getExtension("EXT_disjoint_timer_query");
                if (self.gpuTimer) {
                    self.gpuTimerQuery = self.gpuTimer.createQueryEXT(self.gpuTimer.TIME_ELAPSED_EXT);
                }
                self._coreFactory.webglRestored();  // Reallocate WebGL resources for node state cores
                self.display.webglRestored(); // Reallocate shaders and re-cache shader var locations for display state chunks
                SceneJS_events.fireEvent(SceneJS_events.WEBGL_CONTEXT_RESTORED, {scene: self.scene});
            },
            false);
    };

    /**
     * Sets the number of times the scene is drawn on each render.
     * <p>This is useful for when we need to do things like render for left and right eyes.
     * @param {Number} numPasses The number of times the scene is drawn on each frame.
     */
    SceneJS_Engine.prototype.setNumPasses = function (numPasses) {
        this._numPasses = numPasses;
    };

    /**
     *  When doing multiple passes per frame, specifies whether to clear the
     * canvas before each pass (true) or just before the first pass (false).
     *
     * <p>This is useful for when we need to do things like render a separate pass to a stereo framebuffer for left and right eyes,
     * where we want to clear the buffer before each pass.</p>
     *
     * @param {Boolean} clearEachPass True to clear before each pass (default is false).
     */
    SceneJS_Engine.prototype.setClearEachPass = function (clearEachPass) {
        this._clearEachPass = clearEachPass;
    };

    /**
     * Simulate a lost WebGL context.
     * Only works if the simulateWebGLContextLost was given as an option to the engine's constructor.
     */
    SceneJS_Engine.prototype.loseWebGLContext = function () {
        this.canvas.loseWebGLContext();
    };

    /**
     * Returns true if the given node type is currently loaded (ie. load not required)
     * @param type
     */
    SceneJS_Engine.prototype.hasNodeType = function (type) {
        return !!SceneJS_NodeFactory.nodeTypes[type];
    };

    /**
     * Creates a node subtree from JSON. The root node will an orphan.
     */
    SceneJS_Engine.prototype.createNode = function (json) {

        this._doDestroyNodes(); // Do buffered destroys now to avoid potential ID clashes

        json.type = json.type || "node";

        var core = this._coreFactory.getCore(json.type, json.coreId); // Create or share a core
        var node = this._nodeFactory.getNode(this, json, core);
        var nodes = json.nodes;

        if (nodes) {
            var nodeType = SceneJS_NodeFactory.nodeTypes[node.type];
            var fromPlugin = (!!nodeType && !!nodeType.prototype._fromPlugin);
            if (!fromPlugin) {
                for (var i = 0, len = nodes.length; i < len; i++) {
                    var childNode = this.createNode(nodes[i]);
                    node.addNode(childNode);
                }
            }
        }

        return node;
    };

    /**
     * Performs pending node destructions. When destroyed, each node and its core is released back to the
     * node and core pools for reuse, respectively.
     */
    SceneJS_Engine.prototype._doDestroyNodes = function () {
        var node;
        while (this._numNodesToDestroy > 0) {
            --this._numNodesToDestroy;
            node = this._nodesToDestroy[this._numNodesToDestroy];
            this._nodesToDestroy[this._numNodesToDestroy] = null; // Don't retain the node
            node._doDestroy();
            this._coreFactory.putCore(node._core);    // Release state core for reuse
            this._nodeFactory.putNode(node);         // Release node for reuse
        }
    };

    /**
     * Finds the node with the given ID in this engine's scene graph
     * @return {SceneJS.Node} The node if found, else null
     */
    SceneJS_Engine.prototype.findNode = function (nodeId) {
        return this._nodeFactory.nodes.items[nodeId];
    };

    /** Finds nodes in this engine's scene graph that have nodes IDs matching the given regular expression
     * @param {String} nodeIdRegex Regular expression to match on node IDs
     * @return {[SceneJS.Node]} Array of nodes whose IDs match the given regex
     */
    SceneJS_Engine.prototype.findNodes = function (nodeIdRegex) {

        var regex = new RegExp(nodeIdRegex);
        var nodes = [];
        var nodeMap = this._nodeFactory.nodes.items;

        for (var nodeId in nodeMap) {
            if (nodeMap.hasOwnProperty(nodeId)) {

                if (regex.test(nodeId)) {
                    nodes.push(nodeMap[nodeId]);
                }
            }
        }

        return nodes;
    };

    /**
     * Tests whether a core of the given ID exists for the given node type
     * @param {String} type Node type
     * @param {String} coreId
     * @returns Boolean
     */
    SceneJS_Engine.prototype.hasCore = function (type, coreId) {
        return this._coreFactory.hasCore(type, coreId);
    };

    /**
     * Schedules the given subtree of this engine's {@link SceneJS.Scene} for recompilation
     *
     * @param {SceneJS.Node} node Root node of the subtree to recompile
     */
    SceneJS_Engine.prototype.branchDirty = function (node) {

        if (this.sceneDirty) {
            return; // Whole scene will recompile anyway
        }

        /* Dealing with some weirdness with the embedded window and iframe / window fascism.
         */
        if (node == window) {
            return;
        }

        node.branchDirty = true;
        node.dirty = true;

        for (var n = node.parent; n && !(n.dirty || n.branchDirty); n = n.parent) { // Flag path down to this node
            n.dirty = true;
        }

        this._sceneBranchesDirty = true;
    };

    /**
     * Renders a single frame. Does any pending scene compilations or draw graph updates first.
     * Ordinarily the frame is rendered only if compilations or draw graph updates were performed,
     * but may be forced to render the frame regardless.
     *
     * @param {*} params Rendering parameters
     * @param {Boolean} params.clear True to clear the display first (default)
     */
    SceneJS_Engine.prototype.render = function (params) {

        var rendered = false;

        if (this._willRender() || (params && params.force)) {

            var time = Date.now();

            var force = params && params.force;
            var custom = params && params.custom;

            // Render the scene once for each pass
            for (var i = 0; i < this._numPasses; i++) {

                // Notify that render is upcoming
                this.scene.publish("rendering", {
                    pass: i
                });

                // Compile scene graph to display graph, if necessary
                this.compile();

                // Render display graph
                // Clear buffers only on first frame
                this.display.prepareScene();
                this.display.render({
                    pass: i,
                    clear: this._clearEachPass || i == 0,
                    force: force,
                    custom: custom,
                    opaqueOnly: params && params.opaqueOnly
                });

                // Notify that render completed
                this.scene.publish("rendered", {
                    sceneId: this.id,
                    time: time,
                    pass: i
                });

                rendered = true;
            }
        }

        return rendered;
    };

    /**
     * Performs a pick on this engine and returns a hit record containing at least the name of the picked
     * scene object (as configured by SceneJS.Name nodes) and the canvas pick coordinates. Ordinarily, picking
     * is the simple GPU color-name mapped method, but this method can instead perform a ray-intersect pick
     * when the 'rayPick' flag is set on the options parameter for this method. For that mode, this method will
     * also find the intersection point on the picked object's near surface with a ray cast from the eye that passes
     * through the mouse position on the projection plane.
     *
     * @param params Pick options
     * @param params.canvasPos Canvas coordinates
     * @param params.rayPick Performs additional ray-intersect pick when true
     * @param params.regionPick Performs additional region-intersect pick when true
     * @returns The pick record
     */
    SceneJS_Engine.prototype.pick = function (params) {

        // Do any pending scene compilations
        if (this._willRender()) {
            this.compile();
        }

        var hit = this.display.pick({
            pickTriangle: params ? params.rayPick : false,
            pickRegion: params ? params.regionPick : false,
            canvasPos: params.canvasPos,
            origin: params.origin,
            direction: params.direction
        });

        return hit;
    };

    /**
     * Reads colors of pixels from the last rendered frame.
     */
    SceneJS_Engine.prototype.readPixels = function (entries, size, opaqueOnly) {

        // Do any pending scene compilations
        if (this._willRender()) {
            this.compile();
        }

        return this.display.readPixels(entries, size, opaqueOnly);
    };

    /**
     * Returns true if view needs refreshing from scene
     * @returns {Boolean}
     * @private
     */
    SceneJS_Engine.prototype._willRender = function () {
        SceneJS_events.fireEvent(SceneJS_events.RENDER);

        return (this.display.imageDirty // Frame buffer needs redraw
        || this.display.objectListDirty // Draw list needs to be rebuilt
        || this._sceneBranchesDirty // One or more branches in scene graph need (re)compilation
        || this.sceneDirty); // Whole scene needs recompilation
    };

    /**
     * Prevent engine from compiling the scene graph
     */
    SceneJS_Engine.prototype.pauseCompilation = function () {
        this._compilationPaused = true;
    };

    /**
     * Resume compilation of scene graph
     */
    SceneJS_Engine.prototype.resumeCompilation = function () {
        this._compilationPaused = false;
    };

    /**
     * Performs any pending scene compilations or display rebuilds
     */
    SceneJS_Engine.prototype.compile = function () {
        if (this._compilationPaused) {
            return;
        }

        if (this._sceneBranchesDirty || this.sceneDirty) { // Need scene graph compilation
            this._sceneBranchesDirty = false;
            SceneJS_events.fireEvent(SceneJS_events.SCENE_COMPILING, {  // Notify compilation support start
                engine: this                                            // Compilation support modules get ready
            });
            var startTime = SceneJS.timer.now();
            this.scene._compileNodes(); // Begin depth-first compilation descent into scene sub-nodes
            this.stats.load.sceneGraphCompilation += SceneJS.timer.now() - startTime;
            this.sceneDirty = false;
        }
        this._doDestroyNodes(); // Garbage collect destroyed nodes - node destructions set imageDirty true
    };

    /**
     * Destroys a node within this engine's {@link SceneJS.Scene}
     *
     * @param {SceneJS.Node} node Node to destroy
     */
    SceneJS_Engine.prototype.destroyNode = function (node) {

        /* The node is actually scheduled for lazy destruction within the next invocation of #_tryCompile
         */
        this._nodesToDestroy[this._numNodesToDestroy++] = node;

        /* Stop tracking node's status
         */
        var nodeStatus = this.sceneStatus.nodes[node.id];

        if (nodeStatus) {
            this.sceneStatus.numTasks -= nodeStatus.numTasks;
            delete this.sceneStatus.nodes[node.id];
        }
    };

    /**
     * Destroys this engine
     */
    SceneJS_Engine.prototype.destroy = function () {
        this.destroyed = true;
    };

})();

;/**
 * Backend module that provides single point through which exceptions may be raised
 *
 * @class SceneJS_error
 * @private
 */

(function () {
    "use strict";

    var SceneJS_error = window.SceneJS_error = new (function() {

        var handler = undefined;
        var bufferedFatalError = undefined;

        this.setFatalErrorHandler = function(_handler) {
            handler = _handler;
            if (bufferedFatalError !== undefined) {
                handler(bufferedFatalError);
            }
        }

        this.fatalError = function(code, message) {
            if (typeof code == "string") {
                message = code;
                code = SceneJS.errors.ERROR;
            }
            var error = {
                errorName: SceneJS.errors._getErrorName(code) || "ERROR",
                code: code,
                messageFromCaller: message,
                stackTrace: Human.utils.getStackTrace(),
            };

            if (handler !== undefined) {
                handler(error);
            } else {
                bufferedFatalError = error;
            }
        };
    })();

    (function() {
        SceneJS.errors = {};

        var n = 0;
        SceneJS.errors.ERROR = n++;
        SceneJS.errors.INVALID_FRAMEBUFFER = n++;
        SceneJS.errors.WEBGL_NOT_SUPPORTED = n++;
        SceneJS.errors.WEBGL_CONTEXT_LOST = n++;
        SceneJS.errors.NODE_CONFIG_EXPECTED = n++;
        SceneJS.errors.ILLEGAL_NODE_CONFIG = n++;
        SceneJS.errors.SHADER_COMPILATION_FAILURE = n++;
        SceneJS.errors.SHADER_LINK_FAILURE = n++;
        SceneJS.errors.CANVAS_NOT_FOUND = n++;
        SceneJS.errors.OUT_OF_VRAM = n++;
        SceneJS.errors.WEBGL_UNSUPPORTED_NODE_CONFIG = n++;
        SceneJS.errors.NODE_NOT_FOUND = n++;
        SceneJS.errors.NODE_ILLEGAL_STATE = n++;
        SceneJS.errors.ID_CLASH = n++;
    })();

    SceneJS.errors._getErrorName = function(code) {
        for (var key in SceneJS.errors) {
            if (SceneJS.errors.hasOwnProperty(key) && SceneJS.errors[key] == code) {
                return key;
            }
        }
        return null;
    };


})();
;/**
 * @class Manages logging
 *  @private
 */

(function() {
    "use strict";

    SceneJS.log = new (function() {

        var activeSceneId;
        var funcs = null;
        var queues = {};
        var indent = 0;
        var indentStr = "";

        SceneJS_events.addListener(
                SceneJS_events.SCENE_COMPILING, // Set default logging for scene root
                function(params) {
                    activeSceneId = params.engine.id;
                });

        SceneJS_events.addListener(
                SceneJS_events.RESET,
                function() {
                    queues = {};
                    funcs = null;
                    activeSceneId = null;
                },
                100000);  // Really low priority - must be reset last

        this._setIndent = function(_indent) {
            indent = _indent;
            var indentArray = [];
            for (var i = 0; i < indent; i++) {
                indentArray.push("----");
            }
            indentStr = indentArray.join("");
        };

        this.error = function(msg) {
            this._log("error", msg);
        };

        this.warn = function(msg) {
            this._log("warn", msg);
        };

        this.info = function(msg) {
            this._log("info", msg);
        };

        this.debug = function(msg) {
            this._log("debug", msg);
        };

        this.setFuncs = function(l) {
            if (l) {
                funcs = l;
                for (var channel in queues) {
                    this._flush(channel);
                }
            }
        };

        this._flush = function(channel) {
            var queue = queues[channel];
            if (queue) {
                var func = funcs ? funcs[channel] : null;
                if (func) {
                    for (var i = 0; i < queue.length; i++) {
                        func(queue[i]);
                    }
                    queues[channel] = [];
                }
            }
        };

        this._log = function(channel, message) {
            if (SceneJS._isArray(message)) {
                for (var i = 0; i < message.length; i++) {
                    this.__log(channel, message[i]);
                }
            } else {
                this.__log(channel, message);
            }
        };

        this.__log = function(channel, message) {
            message = indentStr + message;

            if (funcs && funcs[channel]) {
                funcs[channel](message);

            } else if (console && console[channel]) {
                console[channel](message);
            }
        };

        this.getFuncs = function() {
            return funcs;
        };

    })();
})();


;(function () {
    "use strict";
    
    /*
     * Optimizations made based on glMatrix by Brandon Jones
     */

    /*
     * Copyright (c) 2010 Brandon Jones
     *
     * This software is provided 'as-is', without any express or implied
     * warranty. In no event will the authors be held liable for any damages
     * arising from the use of this software.
     *
     * Permission is granted to anyone to use this software for any purpose,
     * including commercial applications, and to alter it and redistribute it
     * freely, subject to the following restrictions:
     *
     *    1. The origin of this software must not be misrepresented; you must not
     *    claim that you wrote the original software. If you use this software
     *    in a product, an acknowledgment in the product documentation would be
     *    appreciated but is not required.
     *
     *    2. Altered source versions must be plainly marked as such, and must not
     *    be misrepresented as being the original software.
     *
     *    3. This notice may not be removed or altered from any source
     *    distribution.
     */


    // Some temporary vars to help avoid garbage collection

    var tempMat1 = mat4.create();
    var tempMat2 = mat4.create();
    var tempVec2 = vec2.create();
    var tempVec3 = vec3.create();
    var tempVec3b = vec3.create();
    var tempVec3c = vec3.create();
    var tempVec3d = vec3.create();
    var tempVec3e = vec3.create();
    var tempVec3f = vec3.create();
    var tempVec3g = vec3.create();
    var tempVec3h = vec3.create();
    var tempVec4 = vec4.create();

    if (Math.log2) {
        window.SceneJS_math_log2 = Math.log2;
    } else {
        window.SceneJS_math_log2 = function (x) {
            return Math.round(Math.log(x) * Math.LOG2E);
        };
    }

    window.SceneJS_math_isPOT = function (x) {
        return (x & (x - 1)) == 0;
    };

    /** @private */
    window.SceneJS_math_cross3Vec4 = function (u, v) {
        var u0 = u[0], u1 = u[1], u2 = u[2];
        var v0 = v[0], v1 = v[1], v2 = v[2];
        return [
            u1 * v2 - u2 * v1,
            u2 * v0 - u0 * v2,
            u0 * v1 - u1 * v0,
            0.0];
    };

    /** @private */
    window.SceneJS_math_setCellMat4 = function (m, row, col, s) {
        m[row + col * 4] = s;
    };

    /**
     * Default lookat properties - eye at 0,0,1, looking at 0,0,0, up vector pointing up Y-axis
     */
    window.SceneJS_math_LOOKAT_OBJ = {
        eye: {x: 0, y: 0, z: 10.0},
        look: {x: 0, y: 0, z: 0.0},
        up: {x: 0, y: 1, z: 0.0}
    };

    /**
     * Default lookat properties in array form - eye at 0,0,1, looking at 0,0,0, up vector pointing up Y-axis
     */
    window.SceneJS_math_LOOKAT_ARRAYS = {
        eye: [0, 0, 10.0],
        look: [0, 0, 0.0],
        up: [0, 1, 0.0]
    };

    /**
     * Default orthographic projection properties
     */
    window.SceneJS_math_ORTHO_OBJ = {
        left: -1.0,
        right: 1.0,
        bottom: -1.0,
        near: 0.1,
        top: 1.0,
        far: 5000.0
    };

    window.SceneJS_math_identityQuaternion = function () {
        return [0.0, 0.0, 0.0, 1.0];
    };

    window.SceneJS_math_angleAxisQuaternion = function (x, y, z, degrees) {
        var angleRad = (degrees / 180.0) * Math.PI;
        var halfAngle = angleRad / 2.0;
        var fsin = Math.sin(halfAngle);
        return [
            fsin * x,
            fsin * y,
            fsin * z,
            Math.cos(halfAngle)
        ];
    };

    window.SceneJS_math_mulQuaternions = function (p, q) {
        var p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];
        var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
        return [
            p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1,
            p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2,
            p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0,
            p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2
        ];
    };

    window.SceneJS_math_newMat4FromQuaternion = function (q) {
        var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
        var tx = 2.0 * q0;
        var ty = 2.0 * q1;
        var tz = 2.0 * q2;
        var twx = tx * q3;
        var twy = ty * q3;
        var twz = tz * q3;
        var txx = tx * q0;
        var txy = ty * q0;
        var txz = tz * q0;
        var tyy = ty * q1;
        var tyz = tz * q1;
        var tzz = tz * q2;
        var m = mat4.create();
        SceneJS_math_setCellMat4(m, 0, 0, 1.0 - (tyy + tzz));
        SceneJS_math_setCellMat4(m, 0, 1, txy - twz);
        SceneJS_math_setCellMat4(m, 0, 2, txz + twy);
        SceneJS_math_setCellMat4(m, 1, 0, txy + twz);
        SceneJS_math_setCellMat4(m, 1, 1, 1.0 - (txx + tzz));
        SceneJS_math_setCellMat4(m, 1, 2, tyz - twx);
        SceneJS_math_setCellMat4(m, 2, 0, txz - twy);
        SceneJS_math_setCellMat4(m, 2, 1, tyz + twx);
        SceneJS_math_setCellMat4(m, 2, 2, 1.0 - (txx + tyy));
        return m;
    };

    window.SceneJS_math_normalizeQuaternion = function (q) {
        var len = vec4.length([q[0], q[1], q[2], q[3]]);
        return [q[0] / len, q[1] / len, q[2] / len, q[3] / len];
    };

    window.SceneJS_math_angleAxisFromQuaternion = function (q) {
        q = SceneJS_math_normalizeQuaternion(q);
        var q3 = q[3];
        var angle = 2 * Math.acos(q3);
        var s = Math.sqrt(1 - q3 * q3);
        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
            return {
                x: q[0],
                y: q[1],
                z: q[2],
                angle: angle * 57.295779579
            };
        } else {
            return {
                x: q[0] / s,
                y: q[1] / s,
                z: q[2] / s,
                angle: angle * 57.295779579
            };
        }
    };

    window.SceneJS_math_decompressPosition  = function(out, position, decodeMatrix) {
        out[0] = position[0] * decodeMatrix[0]  + decodeMatrix[12];
        out[1] = position[1] * decodeMatrix[5]  + decodeMatrix[13];
        out[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];
    };

    window.SceneJS_math_decompressUV  = function(out, uv, decodeMatrix) {
        out[0] = uv[0] * decodeMatrix[0]  + decodeMatrix[6];
        out[1] = uv[1] * decodeMatrix[4]  + decodeMatrix[7];
    };

    /**
     * Builds vertex and index arrays needed by color-indexed triangle picking.
     *
     * @method getPickPrimitives
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {*} Object containing the arrays, created by this method or reused from 'pickTris' parameter.
     */
    window.SceneJS_math_getPickPrimitives = function (positions, indices, compressed) {

        var pickPositions;
        var numIndices;
        var hasIndices = !!indices;

        if (hasIndices) {
            numIndices = indices.length;
            pickPositions = compressed ? new Uint16Array(numIndices * 3) : new Float32Array(numIndices * 3);
        } else {
            numIndices = positions.length / 3;
            pickPositions = positions;
        }
        var pickColors = new Uint8Array(numIndices * 4);

        var primIndex = 0;

        // Positions array index
        var vi;

        // Picking positions array index
        var pvi;

        // Picking color array index
        var pci;

        // Triangle indices

        var i;
        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            pvi = location * 3;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF);
            b = (primIndex >> 16 & 0xFF);
            g = (primIndex >> 8 & 0xFF);
            r = (primIndex & 0xFF);

            // A

            if (hasIndices) {
                i = indices[location];
                vi = i * 3;

                pickPositions[pvi]     = positions[vi];
                pickPositions[pvi + 1] = positions[vi + 1];
                pickPositions[pvi + 2] = positions[vi + 2];
            }

            pickColors[pci]     = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;


            // B

            if (hasIndices) {
                i = indices[location + 1];
                vi = i * 3;

                pickPositions[pvi + 3] = positions[vi];
                pickPositions[pvi + 4] = positions[vi + 1];
                pickPositions[pvi + 5] = positions[vi + 2];
            }

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;


            // C

            if (hasIndices) {
                i = indices[location + 2];
                vi = i * 3;

                pickPositions[pvi + 6] = positions[vi];
                pickPositions[pvi + 7] = positions[vi + 1];
                pickPositions[pvi + 8] = positions[vi + 2];
            }

            pickColors[pci + 8]  = r;
            pickColors[pci + 9]  = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return {
            positions: pickPositions,
            colors: pickColors
        };
    };

    /**
     * Builds vertex array needed by color-indexed triangle picking (for morph target positions).
     *
     * @method getPickPositions
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {Array of Number} The pick positions.
     */
    window.SceneJS_math_getPickPositions = function (positions, indices) {

        var numIndices = indices.length;

        var pickPositions = new Float32Array(numIndices * 3);
        var pvi, vi;
        var i;

        for (var location = 0; location < numIndices; location++) {

            // Picking position array index
            pvi = location * 3;

            i = indices[location];

            // Drawing position index
            vi = i * 3;

            pickPositions[pvi]     = positions[vi];
            pickPositions[pvi + 1] = positions[vi + 1];
            pickPositions[pvi + 2] = positions[vi + 2];

        }

        return pickPositions;
    };

    /**
     * Builds color arrays needed by color-indexed triangle picking.
     *
     * @method getPickPrimitives
     * @static
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {Array of Number} The pick colors
     */
    window.SceneJS_math_getPickColors = function (indices) {

        var numIndices = indices.length;

        var pickColors = new Uint8Array(numIndices * 4);

        var primIndex = 0;
        var pci;

        // Triangle indices

        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            // Picking color array index;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF);
            b = (primIndex >> 16 & 0xFF);
            g = (primIndex >> 8 & 0xFF);
            r = (primIndex & 0xFF);

            // A

            pickColors[pci]     = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;

            // B

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;

            // C

            pickColors[pci + 8]  = r;
            pickColors[pci + 9]  = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return pickColors;
    };

    /**
     * Finds the intersection of a 3D ray with a plane defined by 3 points.
     *
     * @method rayPlaneIntersect
     * @static
     * @param {Array of Number} origin Ray origin.
     * @param {Array of Number} dir Ray direction.
     * @param {Array of Number} a First point on plane.
     * @param {Array of Number} b Second point on plane.
     * @param {Array of Number} c Third point on plane.
     * @param {Array of Number} [isect] Intersection point.
     * @returns {Array of Number} The intersection point.
     */
    window.SceneJS_math_rayPlaneIntersect = function (origin, dir, a, b, c, isect) {

        isect = isect || vec3.create();
        dir = vec3.normalize(tempVec3, dir);

        var edge1 = vec3.subtract(tempVec3b, b, a);
        var edge2 = vec3.subtract(tempVec3c, c, a);

        var n = vec3.cross(tempVec3d, edge1, edge2);
        vec3.normalize(n, n);

        var d = -vec3.dot(a, n);

        var t = -(vec3.dot(origin, n) + d) / vec3.dot(dir, n);
        isect[0] = origin[0] + t * dir[0];
        isect[1] = origin[1] + t * dir[1];
        isect[2] = origin[2] + t * dir[2];

        return isect;
    };


    /**
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     *
     * @method cartesianToBaryCentric
     * @static
     * @param {Array of Number} cartesian Cartesian coordinates.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [bary] The barycentric coordinates.
     * @returns {Array of Number} The barycentric coordinates, or null if the triangle was invalid.
     * @returns {*}
     */

    window.SceneJS_math_cartesianToBarycentric = function (cartesian, a, b, c, dest) {

        var v0 = vec3.subtract(tempVec3, c, a);
        var v1 = vec3.subtract(tempVec3b, b, a);
        var v2 = vec3.subtract(tempVec3c, cartesian, a);

        var dot00 = vec3.dot(v0, v0);
        var dot01 = vec3.dot(v0, v1);
        var dot02 = vec3.dot(v0, v2);
        var dot11 = vec3.dot(v1, v1);
        var dot12 = vec3.dot(v1, v2);

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        // Colinear or singular triangle

        if (denom === 0) {

            // Arbitrary location outside of triangle

            return null;
        }

        var invDenom = 1 / denom;

        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        dest[0] = 1 - u - v;
        dest[1] = v;
        dest[2] = u;

        return dest;
    };

    /**
     * Gets local-space coordinates in Euclidean coordnates from barycentric coordinate on arbitrary triangle
     *
     * @method barycentricToCartesian
     * @static
     * @param {Array of Number} barycentric Barycentric coordiantes
     * @param {Array of Number} a First triangle vertex
     * @param {Array of Number} b Second triangle vertex
     * @param {Array of Number} c Third triangle vertex
     * @param {Array of Number} cartesian output coordiantes
     */
    window.SceneJS_math_barycentricToCartesian = function(barycentric, a, b, c, cartesian) {
        var u = barycentric[0];
        var v = barycentric[1];
        var w = barycentric[2];
        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;
        return cartesian;
    }

    /**
     * Gets cartesian coordinates from barycentric coordinates within a triangle.
     *
     * @method barycentricToCartesian
     * @static
     * @param {Array of Number} bary The barycentric coordinate.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [cartesian] Cartesian coordinates.
     * @returns {Array of Number} The cartesian coordinates, or null if the triangle was invalid.
     * @returns {*}
     */
    window.SceneJS_math_barycentricToCartesian = function (barycentric, a, b, c, cartesian) {

        cartesian = cartesian || vec3.create();

        var u = barycentric[0];
        var v = barycentric[1];
        var w = barycentric[2];

        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;

        return cartesian;
    };


    /**
     * Builds vertex tangent vectors from positions, UVs and indices
     *
     * @method buildTangents
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @param {Array of Number} uv One-dimensional flattened array of UV coordinates.
     * @returns {Array of Number} One-dimensional flattened array of tangents.
     */

    window.SceneJS_math_buildTangents = function (positions, indices, uv, decodePositions, decodeUV) {

        var tangents = new Float32Array(positions.length);

        // The vertex arrays needs to be calculated
        // before the calculation of the tangents

        var MIN_DEN = 1e-3;

        var v0 = vec3.create();
        var v1 = vec3.create();
        var v2 = vec3.create();

        var uv0 = vec2.create();
        var uv1 = vec2.create();
        var uv2 = vec2.create();

        var numVertices = indices ? indices.length : positions.length / 3;

        for (var location = 0; location < numVertices; location += 3) {

            // Recontructing each vertex and UV coordinate into the respective vectors

            var index = indices ? indices[location] : location;

            v0.set(positions.subarray(index * 3, index * 3 + 3));
            uv0.set(uv.subarray(index * 2, index * 2 + 2));

            index = indices ? indices[location + 1] : location + 1;

            v1.set(positions.subarray(index * 3, index * 3 + 3));
            uv1.set(uv.subarray(index * 2, index * 2 + 2));

            index = indices ? indices[location + 2] : location + 2;

            v2.set(positions.subarray(index * 3, index * 3 + 3));
            uv2.set(uv.subarray(index * 2, index * 2 + 2));

            if (decodePositions) {
                SceneJS_math_decompressPosition(v0, v0, decodePositions);
                SceneJS_math_decompressPosition(v1, v1, decodePositions);
                SceneJS_math_decompressPosition(v2, v2, decodePositions);
            }

            if (decodeUV) {
                SceneJS_math_decompressUV(uv0, uv0, decodeUV);
                SceneJS_math_decompressUV(uv1, uv1, decodeUV);
                SceneJS_math_decompressUV(uv2, uv2, decodeUV);
            }

            var deltaPos1 = vec3.subtract(tempVec3, v1, v0);
            var deltaPos2 = vec3.subtract(tempVec3b, v2, v0);

            var deltaUV1 = vec2.subtract(tempVec3c, uv1, uv0);
            var deltaUV2 = vec2.subtract(tempVec3d, uv2, uv0);

            var den = deltaUV1[0] * deltaUV2[1] - deltaUV1[1] * deltaUV2[0];

            if (den === 0) {
                den = MIN_DEN;
            }

            var r = 1 / den;

            var tangent = vec3.scale(tempVec3f,
                vec3.subtract(tempVec3g,
                    vec3.scale(tempVec3e, deltaPos1, deltaUV2[1]),
                    vec3.scale(tempVec3f, deltaPos2, deltaUV1[1])
                ),
                r
            );

            // Average the value of the vectors outs
            for (var v = 0; v < 3; v++) {
                var addTo = indices ? indices[location + v] * 3 : (location + v) * 3;

                tangents[addTo]     += tangent[0];
                tangents[addTo + 1] += tangent[1];
                tangents[addTo + 2] += tangent[2];
            }
        }

        return tangents;
    };

    window.SceneJS_math_octDecodeVec2 = function(oct, result) {
        var x = oct[0];
        var y = oct[1];
        x = (2 * x + 1) / 255;
        y = (2 * y + 1) / 255;

        var z = 1 - Math.abs(x) - Math.abs(y);

        if (z < 0) {
            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        }

        var length = Math.sqrt(x * x + y * y + z * z);

        result[0] = x / length;
        result[1] = y / length;
        result[2] = z / length;

        return result;
    };

})();
;(function () {
    "use strict";

    SceneJS._webgl = {
        enumMap: {
            funcAdd: "FUNC_ADD",
            funcSubtract: "FUNC_SUBTRACT",
            funcReverseSubtract: "FUNC_REVERSE_SUBTRACT",
            zero: "ZERO",
            one: "ONE",
            srcColor: "SRC_COLOR",
            oneMinusSrcColor: "ONE_MINUS_SRC_COLOR",
            dstColor: "DST_COLOR",
            oneMinusDstColor: "ONE_MINUS_DST_COLOR",
            srcAlpha: "SRC_ALPHA",
            oneMinusSrcAlpha: "ONE_MINUS_SRC_ALPHA",
            dstAlpha: "DST_ALPHA",
            oneMinusDstAlpha: "ONE_MINUS_DST_ALPHA",
            contantColor: "CONSTANT_COLOR",
            oneMinusConstantColor: "ONE_MINUS_CONSTANT_COLOR",
            constantAlpha: "CONSTANT_ALPHA",
            oneMinusConstantAlpha: "ONE_MINUS_CONSTANT_ALPHA",
            srcAlphaSaturate: "SRC_ALPHA_SATURATE",
            front: "FRONT",
            back: "BACK",
            frontAndBack: "FRONT_AND_BACK",
            never: "NEVER",
            less: "LESS",
            equal: "EQUAL",
            lequal: "LEQUAL",
            greater: "GREATER",
            notequal: "NOTEQUAL",
            gequal: "GEQUAL",
            always: "ALWAYS",
            cw: "CW",
            ccw: "CCW",
            linear: "LINEAR",
            nearest: "NEAREST",
            linearMipMapNearest: "LINEAR_MIPMAP_NEAREST",
            nearestMipMapNearest: "NEAREST_MIPMAP_NEAREST",
            nearestMipMapLinear: "NEAREST_MIPMAP_LINEAR",
            linearMipMapLinear: "LINEAR_MIPMAP_LINEAR",
            repeat: "REPEAT",
            clampToEdge: "CLAMP_TO_EDGE",
            mirroredRepeat: "MIRRORED_REPEAT",
            alpha: "ALPHA",
            rgb: "RGB",
            rgba: "RGBA",
            luminance: "LUMINANCE",
            luminanceAlpha: "LUMINANCE_ALPHA",
            textureBinding2D: "TEXTURE_BINDING_2D",
            textureBindingCubeMap: "TEXTURE_BINDING_CUBE_MAP",
            compareRToTexture: "COMPARE_R_TO_TEXTURE", // Hardware Shadowing Z-depth,
            unsignedByte: "UNSIGNED_BYTE"
        }
    };
})();


;/** Buffer for vertices and indices
 *
 * @private
 * @param gl  WebGL gl
 * @param type     Eg. ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER
 * @param values   WebGL array wrapper
 * @param numItems Count of items in array wrapper
 * @param itemSize Size of each item
 * @param usage    Eg. STATIC_DRAW
 */


(function () {
    "use strict";

    SceneJS._webgl.ArrayBuffer = function (gl, type, values, numItems, itemSize, usage, normalize) {

        /**
         * True when this buffer is allocated and ready to go
         * @type {boolean}
         */
        this.allocated = false;

        switch (values.constructor) {

            case Uint8Array:
                this.itemType = gl.UNSIGNED_BYTE;
                this.itemByteSize = 1;
                break;

            case Int8Array:
                this.itemType = gl.BYTE;
                this.itemByteSize = 1;
                break;

            case  Uint16Array:
                this.itemType = gl.UNSIGNED_SHORT;
                this.itemByteSize = 2;
                break;

            case  Int16Array:
                this.itemType = gl.SHORT;
                this.itemByteSize = 2;
                break;

            case Uint32Array:
                this.itemType = gl.UNSIGNED_INT;
                this.itemByteSize = 4;
                break;

            case Int32Array:
                this.itemType = gl.INT;
                this.itemByteSize = 4;
                break;

            default:
                this.itemType = gl.FLOAT;
                this.itemByteSize = 4;
        }

        this.gl = gl;
        this.type = type;
        this.numItems = numItems;
        this.itemSize = itemSize;
        this.usage = usage;
        this.normalize = !!normalize;
        this._allocate(values, numItems);
    };

    /**
     * Allocates this buffer
     *
     * @param values
     * @param numItems
     * @private
     */
    SceneJS._webgl.ArrayBuffer.prototype._allocate = function (values, numItems) {
        this.allocated = false;
        this.handle = this.gl.createBuffer();
        if (!this.handle) {
            SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to allocate WebGL ArrayBuffer");
        }
        if (this.handle) {
            this.gl.bindBuffer(this.type, this.handle);
            this.gl.bufferData(this.type, values, this.usage);
            this.gl.bindBuffer(this.type, null);
            this.numItems = numItems;
            this.length = values.length;
            this.allocated = true;
        }
    };

    /**
     * Updates values within this buffer, reallocating if needed
     *
     * @param data
     */
    SceneJS._webgl.ArrayBuffer.prototype.setData = function (data) {
        if (!this.allocated) {
            return;
        }

        this.gl.bindBuffer(this.type, this.handle);

        if (data.length > this.length) {
            // Needs reallocation
            this.gl.bufferData(this.type, data, this.usage);
            this.length = data.length;
        } else {
            // No reallocation needed
            this.gl.bufferSubData(this.type, 0, data);
        }
        this.gl.bindBuffer(this.type, null);
        this.numItems = data.length;
    };

    /**
     * Unbinds this buffer on WebGL
     */
    SceneJS._webgl.ArrayBuffer.prototype.unbind = function () {
        if (!this.allocated) {
            return;
        }
        this.gl.bindBuffer(this.type, null);
    };

    /**
     * Destroys this buffer
     */
    SceneJS._webgl.ArrayBuffer.prototype.destroy = function () {
        if (!this.allocated) {
            return;
        }
        this.gl.deleteBuffer(this.handle);
        this.handle = null;
        this.allocated = false;
    };


    SceneJS._webgl.ArrayBuffer.prototype.bind = function () {
        if (!this.allocated) {
            return;
        }
        this.gl.bindBuffer(this.type, this.handle);
    };

})();
;
/** An attribute within a shader
 */

(function() {
    "use strict";

    SceneJS._webgl.Attribute = function (gl, location) {
        this.gl = gl;
        this.location = location;
    };

    SceneJS._webgl.Attribute.prototype.bindArrayBuffer = function (buffer) {
        if (buffer) {
            buffer.bind();
            this.gl.enableVertexAttribArray(this.location);
            this.gl.vertexAttribPointer(this.location, buffer.itemSize, buffer.itemType, buffer.normalize, 0, 0);   // Vertices are not homogeneous - no w-element
        }
    };
    
})();
;(function() {
    "use strict";

    SceneJS._webgl.Framebuffer = function (cfg) {

        /**
         * True as soon as this buffer is allocated and ready to go
         */
        this.allocated = false;

        /**
         * The canvas, to synch buffer size with when its dimensions change
         */
        this.canvas = cfg.canvas;

        /**
         * WebGL context
         */
        this.gl = cfg.canvas.gl;

        // Initialized on touch
        this.canvasWidth = 0;
        this.canvasHeight = 0;
        this.sizeRatio = cfg.sizeRatio || 1;

        if (typeof cfg.colorAttachments === "number") {
            cfg.colorAttachments = new Array(cfg.colorAttachments);
        }

        var colorAttachments = cfg.colorAttachments || new Array(1);
        this.numColorAttachments = colorAttachments.length;
        this.colorAttachments = new Array(this.numColorAttachments);
        for (var i = 0; i < this.numColorAttachments; ++i) {
            var attachment = colorAttachments[i] || {};
            this.colorAttachments[i] = {
                format: attachment.format !== undefined ? this.gl[attachment.format] : this.gl.RGBA,
                type: attachment.type !== undefined ? this.gl[attachment.type] : this.gl.UNSIGNED_BYTE,
                minFilter: attachment.minFilter !== undefined ? this.gl[attachment.minFilter] : this.gl.LINEAR,
                magFilter: attachment.magFilter !== undefined ? this.gl[attachment.magFilter] : this.gl.LINEAR,
                wrapS: attachment.wrapS !== undefined ? this.gl[attachment.wrapS] : this.gl.CLAMP_TO_EDGE,
                wrapT: attachment.wrapT !== undefined ? this.gl[attachment.wrapT] : this.gl.CLAMP_TO_EDGE
            };       
        }

        this.sharedDepthBuffer = cfg.sharedDepthBuffer || null;
        this.hasDepthAttachment = cfg.depthAttachment !== false;

        this.useDepthTextures = SceneJS.WEBGL_INFO.depthTexturesSupported;
        this.drawBuffers = this.gl.getExtension("WEBGL_draw_buffers");

        // [GH] - BrightSign boards don't support this
        if (window.localContentOnly) {
            this.useDepthTextures = false;
        }

        /**
         * Buffer resources, set up in #_touch
         */
        this.buf = null;

        /**
         * True while this buffer is bound
         * @type {boolean}
         */
        this.bound = false;
    };

    /**
     * Called after WebGL context is restored.
     */
    SceneJS._webgl.Framebuffer.prototype.webglRestored = function (_gl) {
        this.gl = _gl;
        this.buf = null;
        this.allocated = false;
        this.bound = false;
    };

    /**
     * Binds this buffer
     */
    SceneJS._webgl.Framebuffer.prototype.bind = function () {
        this._touch();
        if (this.bound) {
            return;
        }
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);
        this.gl.viewport(0, 0, this.buf.width, this.buf.height);
        this.bound = true;
    };

    SceneJS._webgl.Framebuffer.prototype._touch = function () {
        var canvasWidth = this.gl.drawingBufferWidth;
        var canvasHeight = this.gl.drawingBufferHeight;
        if (this.buf) { // Currently have a buffer
            if (this.canvasWidth == canvasWidth && this.canvasHeight == canvasHeight) { // Canvas size unchanged, buffer still good
                return;
            } else { // Buffer needs reallocation for new canvas size
                for (var i = 0; i < this.numColorAttachments; ++i) {
                    this.gl.deleteTexture(this.buf.colorTargets[i]);
                }
                if (!this.sharedDepthBuffer) {
                    if (this.useDepthTextures) {
                        this.gl.deleteTexture(this.buf.depthTarget);
                    } else {
                        this.gl.deleteRenderbuffer(this.buf.depthTarget);
                    }
                }
                this.gl.deleteFramebuffer(this.buf.framebuf);
            }
        }

        this.canvasWidth = canvasWidth;
        this.canvasHeight = canvasHeight;

        var width = Math.floor(canvasWidth * this.sizeRatio);
        var height = Math.floor(canvasHeight * this.sizeRatio);

        this.buf = {
            framebuf: this.gl.createFramebuffer(),
            colorTargets: new Array(this.numColorAttachments),
            width: width,
            height: height
        };

        if (this.sharedDepthBuffer) {
            this.buf.depthTarget = this.sharedDepthBuffer.getDepthTarget().texture();
        } else {
            this.buf.depthTarget = this.useDepthTextures ? this.gl.createTexture() : this.gl.createRenderbuffer();
        }

        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);

        for (var i = 0; i < this.numColorAttachments; ++i) {
            this.buf.colorTargets[i] = this.gl.createTexture();
            this._setTexture(this.buf.colorTargets[i], width, height, this.colorAttachments[i]);
            this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.buf.colorTargets[i], 0);
        }

        if (this.drawBuffers) {
            var attachments = new Array(this.numColorAttachments);
            for (var i = 0; i < this.numColorAttachments; ++i) {
                attachments[i] = this.gl.COLOR_ATTACHMENT0 + i;
            }
            this.drawBuffers.drawBuffersWEBGL(attachments)
        }

        if (this.hasDepthAttachment) {
            if (this.useDepthTextures) {
                if (!this.sharedDepthBuffer) {
                    this._setTexture(this.buf.depthTarget, width, height, {
                        format: this.gl.DEPTH_COMPONENT, 
                        type: this.gl.UNSIGNED_INT
                    });
                }
                this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.buf.depthTarget, 0);
            } else {
                if (!this.sharedDepthBuffer) {
                    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.buf.depthTarget);
                    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);
                }
                this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.buf.depthTarget);
                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
            }
        }
        
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

        // Verify framebuffer is OK
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);

        if (!this.gl.isFramebuffer(this.buf.framebuf)) {
            SceneJS_error.fatalError(SceneJS.errors.INVALID_FRAMEBUFFER, "Invalid framebuffer");
        }

        var status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);

        switch (status) {

            case this.gl.FRAMEBUFFER_COMPLETE:
                break;

            case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");

            case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");

            case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");

            case this.gl.FRAMEBUFFER_UNSUPPORTED:
                SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");

            default:
                SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: " + status);
        }

        this.bound = false;
    };

    SceneJS._webgl.Framebuffer.prototype._setTexture = function (texture, width, height, options) {
        var format = options.format !== undefined ? options.format : this.gl.RGBA; 
        var type = options.type !== undefined ? options.type : this.gl.UNSIGNED_BYTE; 
        var minFilter = options.minFilter !== undefined ? options.minFilter : this.gl.LINEAR; 
        var magFilter = options.magFilter !== undefined ? options.magFilter : this.gl.LINEAR; 
        var wrapS = options.wrapS !== undefined ? options.wrapS : this.gl.CLAMP_TO_EDGE; 
        var wrapT = options.wrapT !== undefined ? options.wrapT : this.gl.CLAMP_TO_EDGE;

        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);

        try {
            // Do it the way the spec requires
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
        } catch (exception) {
            // Workaround for what appears to be a Minefield bug.
            var textureStorage = new WebGLUnsignedByteArray(width * height * 3);
            this.gl.texImage2D(this.gl.TEXTURE_2D, 0, format, width, height, 0, format, type, textureStorage);
        }

        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapS);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapT);
    };

    /**
     * Clears this renderbuffer
     */
    SceneJS._webgl.Framebuffer.prototype.clear = function () {
        if (!this.bound) {
            throw "Render buffer not bound";
        }
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        this.gl.disable(this.gl.BLEND);
    };

    /**
     * Reads buffer pixel at given coordinates
     */
    SceneJS._webgl.Framebuffer.prototype.read = function (pickX, pickY) {
        var x = pickX;
        var y = this.canvas.canvas.height - pickY;
        var pix = new Uint8Array(4);
        this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pix);
        return pix;
    };

    /**
     * Unbinds this renderbuffer
     */
    SceneJS._webgl.Framebuffer.prototype.unbind = function () {
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        this.bound = false;
    };

    /** Returns the texture
     */
    SceneJS._webgl.Framebuffer.prototype.getColorTarget = function (i) {
        var self = this;
        i = i || 0;
        return {
            bind: function (unit) {
                if (self.buf && self.buf.colorTargets[i]) {
                    self.gl.activeTexture(self.gl.TEXTURE0 + unit);
                    self.gl.bindTexture(self.gl.TEXTURE_2D, self.buf.colorTargets[i]);
                    return true;
                }
                return false;
            },
            unbind: function (unit) {
                if (self.buf && self.buf.colorTargets[i]) {
                    self.gl.activeTexture(self.gl.TEXTURE0 + unit);
                    self.gl.bindTexture(self.gl.TEXTURE_2D, null);
                }
            },
            texture: function () {
                return self.buf.colorTargets[i];
            }
        };
    };

    SceneJS._webgl.Framebuffer.prototype.getDepthTarget = function () {
        var self = this;
        if (this.sharedDepthBuffer) {
            return this.sharedDepthBuffer.getDepthTarget();
        }
        return {
            bind: function (unit) {
                if (self.buf && self.buf.depthTarget) {
                    self.gl.activeTexture(self.gl.TEXTURE0 + unit);
                    self.gl.bindTexture(self.gl.TEXTURE_2D, self.buf.depthTarget);
                    return true;
                }
                return false;
            },
            unbind: function (unit) {
                if (self.buf && self.buf.depthTarget) {
                    self.gl.activeTexture(self.gl.TEXTURE0 + unit);
                    self.gl.bindTexture(self.gl.TEXTURE_2D, null);
                }
            },
            texture: function () {
                return self.buf.depthTarget;
            }
        };
    };

    /** Destroys this buffer
     */
    SceneJS._webgl.Framebuffer.prototype.destroy = function () {
        if (this.buf) {
            for (var i = 0; i < this.numColorAttachments; ++i) {
                this.gl.deleteTexture(this.buf.colorTargets[i]);
            }
            this.gl.deleteFramebuffer(this.buf.framebuf);
            if (!this.sharedDepthBuffer) {
                if (this.useDepthTextures) {
                    this.gl.deleteTexture(this.buf.depthTarget);
                } else {
                    this.gl.deleteRenderbuffer(this.buf.depthTarget);
                }
            }
            this.buf = null;
            this.bound = false;
        }
    };

})();

;/**
 * @class Wrapper for a WebGL program
 *
 * @param hash SceneJS-managed ID for program
 * @param {*} stats Collects scene statistics
 * @param gl WebGL gl
 * @param vertexSources Source codes for vertex shaders
 * @param fragmentSources Source codes for fragment shaders
 * @param logging Program and shaders will write to logging's debug channel as they compile and link
 */

(function() {
    "use strict";

    SceneJS._webgl.Program = function (stats, gl, hash, vertexSource, fragmentSource) {

        this.stats = stats;
        this.hash = hash;
        this.useCount = 0;

        /**
         * True as soon as this program is allocated and ready to go
         * @type {boolean}
         */
        this.allocated = false;

        this.gl = null;

        this._uniforms = {};
        this._samplers = {};
        this._attributes = {};

        // Create shaders from sources
        this.vertexSource = vertexSource;
        this.fragmentSource = fragmentSource;
        this._vertexShader = null;
        this._fragmentShader = null;

        this.build(gl);
    };

    SceneJS._webgl.Program.prototype.build = function (gl) {
        
        var a, i, u, u_name, location, shader;

        var startTime = SceneJS.timer.now();
        var stats = this.stats;

        this.gl = gl;

        this._vertexShader = new SceneJS._webgl.Shader(stats, gl, gl.VERTEX_SHADER, this.vertexSource);
        this._fragmentShader = new SceneJS._webgl.Shader(stats, gl, gl.FRAGMENT_SHADER, this.fragmentSource);

        // Create program, attach shaders, link and validate program

        this.handle = gl.createProgram();

        if (this.handle) {

            gl.attachShader(this.handle, this._vertexShader.handle);
            gl.attachShader(this.handle, this._fragmentShader.handle);

            gl.linkProgram(this.handle);

            if (!gl.getProgramParameter(this.handle, gl.LINK_STATUS)) {
                SceneJS.log.error("Shader program failed to link: " + gl.getProgramInfoLog(this.handle));
            }

            // Discover uniforms and samplers

            var numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
            var valueIndex = 0;
            for (i = 0; i < numUniforms; ++i) {
                u = gl.getActiveUniform(this.handle, i);
                if (u) {
                    u_name = u.name;
                    if (u_name[u_name.length - 1] == "\u0000") {
                        u_name = u_name.substr(0, u_name.length - 1);
                    }
                    location = gl.getUniformLocation(this.handle, u_name);
                    if ((u.type == gl.SAMPLER_2D) || (u.type == gl.SAMPLER_CUBE) || (u.type == 35682)) {
                        this._samplers[u_name] = location;
                    } else {
                        this._uniforms[u_name] = new SceneJS._webgl.Uniform(gl, u.type, u.size, location);
                        ++valueIndex;
                    }
                }
            }

            // Discover attributes

            var numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);
            for (i = 0; i < numAttribs; i++) {
                a = gl.getActiveAttrib(this.handle, i);
                if (a) {
                    location = gl.getAttribLocation(this.handle, a.name);
                    this._attributes[a.name] = new SceneJS._webgl.Attribute(gl, location);
                }
            }

            stats.load.programCompilation += SceneJS.timer.now() - startTime;

            // Program allocated
            this.allocated = true;

        } // if (this.handle)

    };

    SceneJS._webgl.Program.prototype.bind = function () {
        if (!this.allocated) {
            return;
        }
        this.gl.useProgram(this.handle);
    };

    SceneJS._webgl.Program.prototype.getUniformLocation = function (name) {
        if (!this.allocated) {
            return;
        }
        var u = this._uniforms[name];
        if (u) {
            return u.getLocation();
        }
    };

    SceneJS._webgl.Program.prototype.getUniform = function (name) {
        if (!this.allocated) {
            return;
        }
        var u = this._uniforms[name];
        if (u) {
            return u;
        }
    };

    SceneJS._webgl.Program.prototype.getAttribute = function (name) {
        if (!this.allocated) {
            return;
        }
        var attr = this._attributes[name];
        if (attr) {
            return attr;
        }
    };

    SceneJS._webgl.Program.prototype.bindArrayBuffer = function (name, buffer) {
        if (!this.allocated) {
            return;
        }
        var attr = this._attributes[name];
        if (attr) {
            attr.bindArrayBuffer(buffer);
        }
    };

    SceneJS._webgl.Program.prototype.bindTexture = function (name, texture, unit) {
        if (!this.allocated) {
            return false;
        }
        var sampler = this._samplers[name];

        if (!sampler) {
            return false;
        }

        if (!texture.bind(unit)) {
            return false;
        }

        this.gl.uniform1i(sampler, unit);

        return true;
    };

    SceneJS._webgl.Program.prototype.destroy = function () {
        if (!this.allocated) {
            return;
        }
        this.gl.deleteProgram(this.handle);
        this.gl.deleteShader(this._vertexShader.handle);
        this.gl.deleteShader(this._fragmentShader.handle);
        this.handle = null;
        this._attributes = null;
        this._uniforms = null;
        this._samplers = null;
        this.allocated = false;
    };


    SceneJS._webgl.Program.prototype.setUniform = function (name, value) {
        if (!this.allocated) {
            return;
        }
        var u = this._uniforms[name];
        if (u) {
            u.setValue(value);
        }
    };

})(); 
;/**
 * A vertex/fragment shader in a program
 *
 * @private
 * @param gl WebGL gl
 * @param gl.VERTEX_SHADER | gl.FRAGMENT_SHADER
 * @param source Source code for shader
 * @param logging Shader will write logging's debug channel as it compiles
 */

(function() {
    "use strict";

    SceneJS._webgl.Shader = function (stats, gl, type, source) {

        /**
         * True as soon as this shader is allocated and ready to go
         * @type {boolean}
         */
        this.allocated = false;

        var startTime = SceneJS.timer.now();

        this.handle = gl.createShader(type);

        if (!this.handle) {
            SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to create WebGL shader");
        }

        gl.shaderSource(this.handle, source);
        gl.compileShader(this.handle);

        this.valid = (gl.getShaderParameter(this.handle, gl.COMPILE_STATUS) != 0);

        if (!this.valid) {

            if (!gl.isContextLost()) { // Handled explicitely elsewhere, so wont rehandle here

                SceneJS.log.error("Shader program failed to compile: " + gl.getShaderInfoLog(this.handle));
                SceneJS.log.error("Shader source:");
                var lines = source.split('\n');
                for (var j = 0; j < lines.length; j++) {
                    SceneJS.log.error((j + 1) + ": " + lines[j]);
                }

                SceneJS_error.fatalError(
                    SceneJS.errors.SHADER_COMPILATION_FAILURE, "Shader program failed to compile");
            }
        }

        stats.load.shaderCompilation += SceneJS.timer.now() - startTime;

        this.allocated = true;
    };

})();
;
(function() {
    "use strict";

    SceneJS._webgl.Texture2D = function (gl, cfg) {

        try {
            this._init(gl, cfg);
        } catch (e) {
            SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to create texture: " + e.message || e);
        }

    };

    SceneJS._webgl.Texture2D.prototype._init = function (gl, cfg) {
        /**
         * True as soon as this texture is allocated and ready to go
         * @type {boolean}
         */
        this.allocated = false;
        this.gl = gl;

        this.target = cfg.target || gl.TEXTURE_2D;
        this.minFilter = cfg.minFilter;
        this.magFilter = cfg.magFilter;
        this.wrapS = cfg.wrapS;
        this.wrapT = cfg.wrapT;
        this.update = cfg.update;  // For dynamically-sourcing textures (ie movies etc)
        this.texture = cfg.texture;
        this.compressed = !!cfg.compressed;
        this.format = gl.RGBA;
        this.isDepth = false;
        this.depthMode = 0;
        this.depthCompareMode = 0;
        this.depthCompareFunc = 0;

        gl.bindTexture(this.target, this.texture);

        if (cfg.minFilter) {
            gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, cfg.minFilter);
        }

        if (cfg.magFilter) {
            gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, cfg.magFilter);
        }

        if (cfg.wrapS) {
            gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, cfg.wrapS);
        }

        if (cfg.wrapT) {
            gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, cfg.wrapT);
        }

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, cfg.flipY !== false);

        if (!this.compressed &&
             (this.minFilter == gl.NEAREST_MIPMAP_NEAREST ||
              this.minFilter == gl.LINEAR_MIPMAP_NEAREST ||
              this.minFilter == gl.NEAREST_MIPMAP_LINEAR ||
              this.minFilter == gl.LINEAR_MIPMAP_LINEAR)) {
            gl.generateMipmap(this.target);
        }

        gl.bindTexture(this.target, null);

        this.allocated = true;
    }

    SceneJS._webgl.Texture2D.prototype.bind = function (unit) {
        if (!this.allocated) {
            return;
        }

        var gl = this.gl;

        if (this.texture) {
            gl.activeTexture(gl["TEXTURE" + unit]);
            gl.bindTexture(this.target, this.texture);
            if (this.update) {
                this.update(gl);
            }
            return true;
        }
        return false;
    };

    SceneJS._webgl.Texture2D.prototype.unbind = function (unit) {
        if (!this.allocated) {
            return;
        }

        var gl = this.gl;

        if (this.texture) {
            gl.activeTexture(gl["TEXTURE" + unit]);
            gl.bindTexture(this.target, null);
        }
    };

    SceneJS._webgl.Texture2D.prototype.destroy = function () {
        if (!this.allocated) {
            return;
        }

        var gl = this.gl;

        if (this.texture) {
            gl.deleteTexture(this.texture);
            this.texture = null;
        }
    };

})();

;(function() {
    "use strict";

    var SET_VALUE_FUNCS = (function() {
        var FUNCS = {};
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if(!gl) {
            return FUNCS;
        }

        FUNCS[gl.BOOL] = function (v) {
            var cached = true;
            var i, len;

            if (this.length === 1) {
                if (this.value[0] !== v) {
                    cached = false;
                } 
            } else {
                for (i = 0, len = this.length; i < len; ++i) {
                    if (this.value[i] !== v[i]) {
                        cached = false;
                        break;
                    }
                }
            }
            

            if (cached) {
                return;
            }
            
            if (this.length === 1) {
                this.value[0] = v;
            } else {
                while (i < len) {
                    this.value[i] = v[i];
                    ++i;
                }
            }
            
            this.gl.uniform1fv(this.location, this.value);
        };

        FUNCS[gl.BOOL_VEC2] = function (v) {
            var cached = true;
            var i, len;
            for (i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            while (i < len) {
                this.value[i] = v[i];
                ++i;
            }

            this.gl.uniform2iv(this.location, v);
        };

        FUNCS[gl.BOOL_VEC3] = function (v) {
            var cached = true;
            var i, len;
            for (i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            while (i < len) {
                this.value[i] = v[i];
                ++i;
            }

            this.gl.uniform3iv(this.location, v);
        };

        FUNCS[gl.BOOL_VEC4] = function (v) {
            var cached = true;
            var i, len;
            for (i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            while (i < len) {
                this.value[i] = v[i];
                ++i;
            }

            this.gl.uniform4iv(this.location, v);
        };

        FUNCS[gl.INT_VEC2] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            this.value.set(v);
            this.gl.uniform2iv(this.location, v);
        };

        FUNCS[gl.INT_VEC3] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            this.value.set(v);
            this.gl.uniform3iv(this.location, v);
        };

        FUNCS[gl.INT_VEC4] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            this.value.set(v);
            this.gl.uniform4iv(this.location, v);
        };

        FUNCS[gl.FLOAT] = function (v) {
            var cached = true;

            if (this.length === 1) {
                if (this.value[0] !== v) {
                    cached = false;
                } 
            } else {
                for (var i = 0, len = this.length; i < len; ++i) {
                    if (this.value[i] !== v[i]) {
                        cached = false;
                        break;
                    }
                }
            }
            

            if (cached) {
                return;
            }
            
            if (this.length === 1) {
                this.value[0] = v;
            } else {
                this.value.set(v);
            }
            
            this.gl.uniform1fv(this.location, this.value);
        };

        FUNCS[gl.FLOAT_VEC2] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            this.value.set(v);
            this.gl.uniform2fv(this.location, v);
        };

        FUNCS[gl.FLOAT_VEC3] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            this.value.set(v);
            this.gl.uniform3fv(this.location, v);
        };

        FUNCS[gl.FLOAT_VEC4] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }
            
            this.value.set(v);
            this.gl.uniform4fv(this.location, v);
        };

        FUNCS[gl.FLOAT_MAT2] = function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }

            this.value.set(v);
            this.gl.uniformMatrix2fv(this.location, false, v);
        };


        FUNCS[gl.FLOAT_MAT3] =function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }

            this.value.set(v);
            this.gl.uniformMatrix3fv(this.location, false, v);
        };

        FUNCS[gl.FLOAT_MAT4] =function (v) {
            var cached = true;
            for (var i = 0, len = this.length; i < len; ++i) {
                if (this.value[i] !== v[i]) {
                    cached = false;
                    break;
                }
            }

            if (cached) {
                return;
            }

            this.value.set(v);
            this.gl.uniformMatrix4fv(this.location, false, v);
        };

        return FUNCS;
    })();

    SceneJS._webgl.Uniform = function (gl, type, size, location) {
        // This is just an integer key for caching the uniform's value, more efficient than caching by name.
        this.gl = gl;
        this.location = location;
        this.value = getCache(gl, type, size);
        this.length = this.value.length;
        this.setValue = SET_VALUE_FUNCS[type];
    };


    SceneJS._webgl.Uniform.prototype.getLocation = function() {
        return this.location;
    };

    function getCache(gl, type, size) {
        if (type === gl.BOOL) {
            return new Array(size);
        } else if (type === gl.BOOL_VEC2) {
            return new Array(size * 2);
        } else if (type === gl.BOOL_VEC3) {
            return new Array(size * 3);
        } else if (type === gl.BOOL_VEC4) {
            return new Array(size * 4);
        } else if (type === gl.INT) {
            return new Uint32Array(size);
        } else if (type === gl.INT_VEC2) {
            return new Uint32Array(size * 2);
        } else if (type === gl.INT_VEC3) {
            return new Uint32Array(size * 3);
        } else if (type === gl.INT_VEC4) {
            return new Uint32Array(size * 4);
        } else if (type === gl.FLOAT) {
            return new Float32Array(size);
        } else if (type === gl.FLOAT_VEC2) {
            return new Float32Array(size * 2);
        } else if (type === gl.FLOAT_VEC3) {
            return new Float32Array(size * 3);
        } else if (type === gl.FLOAT_VEC4) {
            return new Float32Array(size * 4);
        } else if (type === gl.FLOAT_MAT2) {
            return new Float32Array(size * 4);
        } else if (type === gl.FLOAT_MAT3) {
            return new Float32Array(size * 9);
        } else if (type === gl.FLOAT_MAT4) {
            return new Float32Array(size * 16);
        } else {
            throw "Unsupported shader uniform type: " + type;
        }
    }
})();








;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}  
 *
 * @private
 */

(function () {
    "use strict";

    var SceneJS_Core = window.SceneJS_Core = function(type) {

        /**
         * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
         * @type String
         * @see SceneJS.Node#type
         */
        this.type = type;

        /**
         * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
         * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
         * this core instance.
         * @type String|Number
         */
        this.coreId = null;

        /**
         * Uniquely identifies this state core within a {@link SceneJS_Display}.
         *
         * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores, 
         * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
         * same value for this ID.
         *
         * @type Number
         */
        this.stateId = null;

        /**
         * Count of {@link SceneJS.Node} instances this core holds state for
         */
        this.useCount = 0;
    };

})();
;// accept a single array or separate arguments
function ColorFresnel(args) {
    // center, edge, centerBias, edgeBias, power
    var params = [[1,1,1],[1,1,1],1,0,1]; // default
    if (arguments.length === 5) {
        params = Array.prototype.slice.call(arguments);
    } else if (Array.isArray(args)){
        params = args;
    }
    this.isColorFresnel = true;
    this.center = params[0]; // [number, number, number]
    this.edge = params[1]; // [number, number, number]
    this.centerBias = params[2];
    this.edgeBias = params[3];
    this.power = params[4];
}

// use as static function on the prototype
ColorFresnel.prototype.isEqual = function(colorFresnel1, colorFresnel2) {
    var centerEqual = colorFresnel1.center.reduce(function(equal, channel, idx){
        return equal && channel === colorFresnel2.center[idx];
    }, true);

    var edgeEqual = colorFresnel1.edge.reduce(function(equal, channel, idx){
        return equal && channel === colorFresnel2.edge[idx];
    }, true);

    var edgeBiasEqual = colorFresnel1.edgeBias === colorFresnel2.edgeBias;
    var centerBiasEqual = colorFresnel1.centerBias === colorFresnel2.centerBias;
    var powerEqual = colorFresnel1.power === colorFresnel2.power;

    return centerEqual && edgeEqual && edgeBiasEqual && centerBiasEqual && powerEqual;
}
;function ScalarFresnel(args) {
    // center, edge, centerBias, edgeBias, power
    var params = [1,1,1,0,1]; // default
    if (arguments.length === 5) {
        params = Array.prototype.slice.call(arguments);
    } else if (Array.isArray(args)){
        params = args;
    }
    this.isScalarFresnel = true;
    this.center = params[0]; // [number, number, number]
    this.edge = params[1]; // [number, number, number]
    this.centerBias = params[2];
    this.edgeBias = params[3];
    this.power = params[4];
}

// use as static function on the prototype
ScalarFresnel.prototype.isEqual = function(fresnel1, fresnel2) {
    var centerEqual = fresnel1.center === fresnel2.center;

    var edgeEqual = fresnel1.edge == fresnel2.edge;

    var edgeBiasEqual = fresnel1.edgeBias === fresnel2.edgeBias;
    var centerBiasEqual = fresnel1.centerBias === fresnel2.centerBias;
    var powerEqual = fresnel1.power === fresnel2.power;

    return centerEqual && edgeEqual && edgeBiasEqual && centerBiasEqual && powerEqual;
}
;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}
 *
 * @private
 */
(function() {
    "use strict";
    
    var KD_TREE_MAX_DEPTH = SceneJS.KD_TREE_MAX_DEPTH;
    var KD_TREE_MIN_TRIANGLES = SceneJS.KD_TREE_MIN_TRIANGLES;

    var SceneJS_GeometryCore = window.SceneJS_GeometryCore = function() {

        /**
         * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
         * @type String
         * @see SceneJS.Node#type
         */
        this.type = "xform";

        /**
         * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
         * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
         * this core instance.
         * @type String|Number
         */
        this.coreId = null;

        /**
         * Uniquely identifies this state core within a {@link SceneJS_Display}.
         *
         * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores,
         * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
         * same value for this ID.
         *
         * @type Number
         */
        this.stateId = null;

        this.kdTree = null;
        this.kdTreeDirty = true;
    };

    // Lazy-build tangents, only when needed as rendering
    SceneJS_GeometryCore.prototype.getTangents = function (uvLayerIdx) {

        // We're only allowed one normal map per drawable, but we'll
        // cache tangents for each UV layer. In practice the cache would
        // only contain one array of tangents, for the UV layer that
        // happens to be used for normal mapping.

        if (!this.tangentBufs) {
            this.tangentBufs = [];
        }
        if (this.tangentBufs[uvLayerIdx]) {
            return this.tangentBufs[uvLayerIdx];
        }
        var arrays = this.arrays;
        var tangents = this.arrays.tangents[uvLayerIdx];
        var gl = this._engine.canvas.gl;
        if (!tangents) {
            // Retaining tangents data after WebGL context recovery
            if (arrays.positions && arrays.uvs && arrays.uvs[uvLayerIdx]) {
                tangents = SceneJS_math_buildTangents(arrays.positions, arrays.indices, arrays.uvs[uvLayerIdx],
                            this.positionDecodeMat, this.compressedUVs && this.uvDecodeMats[uvLayerIdx]); // Build tangents array;
                this._engine.stats.memory.tangents += tangents.length * tangents.constructor.BYTES_PER_ELEMENT;
            }
        }
        if (tangents) {
            this.tangentBufs[uvLayerIdx] = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, tangents, tangents.length, 3, gl.STATIC_DRAW);
            this.arrays.tangents[uvLayerIdx] = true; // Don't need array anymore.
            return this.tangentBufs[uvLayerIdx];
        } else {
            return null;
        }
    };

    // Buffers for primitive-pick rendering

    SceneJS_GeometryCore.prototype.getPickPositions = function () {
        if (this.pickPositionsBuf) {
            return this.pickPositionsBuf;
        }

        createPickArrays(this);

        return this.pickPositionsBuf;
    };

    SceneJS_GeometryCore.prototype.getPickColors = function () {
        if (this.pickColorsBuf) {
            return this.pickColorsBuf;
        }

        createPickArrays(this);

        return this.pickColorsBuf;
    };

    SceneJS_GeometryCore.prototype.getKdTree = function () {
        if (!this.kdTree) {
            this.buildKdTree();
        }
        
        return this.kdTree;
    };

    // k-d tree nodes have the following structure: 
    //   {
    //       triangles: [NUMBER, NUMBER, ...],    // Indices of triangles in this leaf node (null if not leaf node)
    //       left: kdTreeNode,                    // Left subtree (null if leaf node)
    //       right: kdTreeNode,                   // Right subtree (null if leaf node)
    //       leaf: BOOLEAN,                       // Is this a leaf node?
    //       splitDim: 0,                         // Dimension split on at this node (0 = x, 1 = y, 2 = z)
    //       bb: {                                // Bounding box of triangles in this node and its subtrees.
    //           min: VEC3,
    //           max: VEC3
    //       }
    //   }
    // 
    SceneJS_GeometryCore.prototype.buildKdTree = function () {
        if (!this.kdTreeDirty) {
            return;
        }

        var positions = this.arrays.positions;
        var indices = this.arrays.indices;

        if (!positions) {
            return;
        }

        var numTris;

        if (indices) {
            numTris = indices.length / 3;
        } else {
            numTris = positions.length / 9;
        }
        var triangles = new Array(numTris);
        for (var i = 0; i < numTris; ++i) {
            triangles[i] = i;
        }
        this.kdTree = buildKdTreeNode(triangles, indices, positions, this.positionDecodeMat, 0, 0);
        this.kdTreeDirty = false;
    };

    function createPickArrays(core) {
        var gl = core._engine.canvas.gl;

        var pickArrays, pickPositions, pickColors;

        if (core.arrays.positions) {
            pickArrays = SceneJS_math_getPickPrimitives(core.arrays.positions, core.arrays.indices, core.compressedPositions);
            pickPositions = pickArrays.positions;
            pickColors = pickArrays.colors;
            core.pickPositionsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickPositions, pickPositions.length, 3, gl.STATIC_DRAW);
            core._engine.stats.memory.pickPositions += pickPositions.length * pickPositions.constructor.BYTES_PER_ELEMENT;
            core._engine.stats.memory.pickColors += pickColors.length * pickColors.constructor.BYTES_PER_ELEMENT;
        } else {
            pickColors = SceneJS_math_getPickColors(core.arrays.indices);
            core._engine.stats.memory.pickColors += pickColors.length * pickColors.constructor.BYTES_PER_ELEMENT;
        }

        core.pickColorsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW, true);
    }

    var position = vec3.create();

    function buildKdTreeNode(triangles, indices, positions, decompress, dim, depth) {
        var min = vec3.create();
        var max = vec3.create();

        var node = {
            triangles: null,
            left: null,
            right: null,
            bb: {
                min: min,
                max: max
            }
        };

        min[0] = min[1] = min[2] = Number.POSITIVE_INFINITY;
        max[0] = max[1] = max[2] = Number.NEGATIVE_INFINITY;

        var t, len;
        
        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;

            for (var j = 0; j < 3; ++j) {
                var pi;
                if (indices) {
                    pi = indices[ii + j] * 3;
                } else {
                    pi = (ii + j) * 3;
                }
                
                position[0] = positions[pi];
                position[1] = positions[pi + 1];
                position[2] = positions[pi + 2];

                if (decompress) {
                    SceneJS_math_decompressPosition(position, position, decompress);
                }

                if (position[0] < min[0]) {
                    min[0] = position[0]
                } 

                if (position[0] > max[0]) {
                    max[0] = position[0]
                }

                if (position[1] < min[1]) {
                    min[1] = position[1]
                } 

                if (position[1] > max[1]) {
                    max[1] = position[1]
                }

                if (position[2] < min[2]) {
                    min[2] = position[2]
                } 

                if (position[2] > max[2]) {
                    max[2] = position[2]
                }
            }
        }

        if (depth > KD_TREE_MAX_DEPTH) {
            node.triangles = triangles;
            return node;
        }


        var mid = (min[dim] + max[dim]) / 2;
        var left = new Array(triangles.length);
        var numLeft = 0;
        var right = new Array(triangles.length);
        var numRight = 0;

        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;

            var i0, i1, i2;
            if (indices) {
                i0 = indices[ii];
                i1 = indices[ii + 1];
                i2 = indices[ii + 2];
            } else {
                i0 = ii;
                i1 = ii + 1;
                i2 = ii + 2;
            }
            

            var pi0 = i0 * 3;
            var pi1 = i1 * 3;
            var pi2 = i2 * 3;

            var v1 = positions[pi0 + dim];
            var v2 = positions[pi1 + dim];
            var v3 = positions[pi2 + dim];

            if (decompress) {
                var scale = decompress[dim * 5];
                var translate = decompress[dim + 12]
                v1 = v1 * scale + translate;
                v2 = v2 * scale + translate;
                v3 = v3 * scale + translate;
            }

            if (v1 <= mid || v2 <= mid || v3 <= mid) {
                left[numLeft++] = triangles[t];
            } else {
                right[numRight++] = triangles[t];
            }
        }

        if (numLeft < KD_TREE_MIN_TRIANGLES || numRight < KD_TREE_MIN_TRIANGLES) {
            node.triangles = triangles;
            return node;
        }

        left.length = numLeft;
        right.length = numRight;

        node.left = buildKdTreeNode(left, indices, positions, decompress, (dim + 1) % 3, depth + 1);
        node.right = buildKdTreeNode(right, indices, positions, decompress, (dim + 1) % 3, depth + 1);

        return node;
    }

})();
;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}
 *
 * @private
 */
(function () {
    "use strict";

    var FLAGS = SceneJS.PROPERTY_FLAGS;
    var DEPTH_TEST_FLAGS = SceneJS.DEPTH_TEST_FLAGS;

    var SceneJS_PropertiesCore = window.SceneJS_PropertiesCore = function() {


        /**
         * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
         * @type String
         * @see SceneJS.Node#type
         */
        this.type = "properties";

        /**
         * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
         * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
         * this core instance.
         * @type String|Number
         */
        this.coreId = null;

        /**
         * Uniquely identifies this state core within a {@link SceneJS_Display}.
         *
         * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores,
         * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
         * same value for this ID.
         *
         * @type Number
         */
        this.stateId = null;

        /**
         * Count of {@link SceneJS.Node} instances this core holds state for
         */
        this.useCount = 0;

        this.xrayParams = new Float32Array([0.4, 0.8]); // x = glassfactor, y = murkiness, z = opacity
        // this.colorParams = new Float32Array([0, 1, 0, 1]); // x = saturation, y = contrast, z = brightness, w = opacity
        this.solidColor = new Float32Array([1.0, 1.0, 1.0]); // RGB = solidColor, A = Clipping
        this.colorModifiers = []; // {applyTo:"brightness|contrast|saturation|tintColor",value:<FLOAT>,(colorRange):{}}
        this.colorModRange = false;
        this.opacityModifiers = [];
        this.opacityModRange = false;
        this.name = null;              // Picking name
        this.flags = FLAGS.PICKING | FLAGS.ENABLED | FLAGS.REFLECTIVE | FLAGS.CCW | FLAGS.CLIPPING;
        this.transparent = false;
        this.partiallyOpaque = false;
        this.stochasticAlpha = false;
        this.blend = false;
        this.fragmentShaderHeader = null;
        this.fragmentShaderFooter = null;
        this.depthTest = DEPTH_TEST_FLAGS.ENABLED;

        this.hash = "refl;;;;;;;";
    };

    SceneJS_PropertiesCore.prototype.getFlag = function(flag) {
        return !!(this.flags & flag);
    };

    SceneJS_PropertiesCore.prototype.setFlag = function(flag, value) {
        this.flags = value ? (this.flags | flag) : (this.flags & ~flag);
    };

    SceneJS_PropertiesCore.prototype.resetTransparency = function() {
        var opacityModifiers = this.opacityModifiers;
        var opacityModified = false;
        var opacityRangeModified = false;
        var omi = 0;
        for(omi = 0; omi < opacityModifiers.length; omi++) {
            if (opacityModifiers[omi].value < 1) {
                opacityModified = true;
                break;
            }
        }
        for(omi = 0; omi < opacityModifiers.length; omi++) {
            if (opacityModifiers[omi].range) {
                opacityRangeModified = true;
                break;
            }
        }
        this.stochasticAlpha = this.getFlag(FLAGS.STOCHASTIC_ALPHA);
        this.transparent = this.getFlag(FLAGS.FORCE_TRANSPARENT) ||
            (!this.stochasticAlpha &&
            (opacityModified || this.getFlag(FLAGS.XRAY)));
        this.partiallyOpaque = this.getFlag(FLAGS.PARTIALLY_OPAQUE) ||
            (opacityModified && opacityRangeModified && !this.getFlag(FLAGS.XRAY));
    };

})();
;/**
 * @class Manages creation, recycle and destruction of {@link SceneJS_Core} instances
 * @private
 */

(function () {
    "use strict";

    var SceneJS_CoreFactory = window.SceneJS_CoreFactory = function () {

        this._stateMap = new SceneJS_Map(null, SceneJS._baseStateId);  // For creating unique state IDs for cores

        this._cores = {}; // Map of cores for each type
    };

    SceneJS_CoreFactory.coreConstructors = {
        geometry: SceneJS_GeometryCore,
        properties: SceneJS_PropertiesCore,
        default: SceneJS_Core
    };

    /**
     * Gets a core of the given type from this factory. Reuses any existing existing core of the same type and ID.
     *
     * The caller (a scene node) will then augment the core with type-specific attributes and methods.
     *
     * @param {String} type Type name of core, e.g. "material", "texture"
     * @param {String} coreId ID for the core, unique among all cores of the given type within this factory
     * @returns {Core} The core
     */
    SceneJS_CoreFactory.prototype.getCore = function (type, coreId) {

        var cores = this._cores[type];

        if (!cores) {
            cores = this._cores[type] = {};
        }

        var core;

        if (coreId) { // Attempt to reuse a core

            core = cores[coreId];

            if (core) {
                core.useCount++;
                return core;
            }
        }

        var Core = SceneJS_CoreFactory.coreConstructors[type] || SceneJS_CoreFactory.coreConstructors.default;

        core = new Core(type);
        core.useCount = 1;  // One user so far

        core.stateId = this._stateMap.addItem(core);
        core.coreId = (coreId != undefined && coreId != null) ? coreId : core.stateId; // Use state ID as core ID by default

        cores[core.coreId] = core;

        return core;
    };


    /**
     * Tests if a core of the given type and ID currently exists within this factory.
     *
     * @param {String} type Type name of core, e.g. "material", "texture"
     * @param {String} coreId ID for the core, unique among all cores of the given type within this factory
     * @returns {Boolean} True if the core exists
     */
    SceneJS_CoreFactory.prototype.hasCore = function (type, coreId) {
        var cores = this._cores[type];
        return cores && cores[coreId];
    };

    /**
     * Releases a state core back to this factory, destroying it if the core's use count is then zero.
     * @param {Core} core Core to release
     */
    SceneJS_CoreFactory.prototype.putCore = function (core) {

        if (core.useCount == 0) {
            return; // In case of excess puts
        }

        if (--core.useCount <= 0) {                    // Release shared core if use count now zero

            var cores = this._cores[core.type];

            delete cores[core.coreId];

            this._stateMap.removeItem(core.stateId);  // Release state ID for reuse
        }
    };

    /**
     * Reallocates WebGL resources for cores within this factory
     */
    SceneJS_CoreFactory.prototype.webglRestored = function () {

        var cores;
        var core;

        for (var type in this._cores) {
            if (this._cores.hasOwnProperty(type)) {

                cores = this._cores[type];

                if (cores) {

                    for (var coreId in cores) {
                        if (cores.hasOwnProperty(coreId)) {

                            core = cores[coreId];

                            if (core && core.webglRestored) { // Method augmented on core by user
                                core.webglRestored();
                            }
                        }
                    }
                }
            }
        }
    };

})();
;/**
 * @class The basic scene graph node type
 */

(function() {
    "use strict";

    SceneJS.Node = function () {
    };

    /**
     * @class Basic scene graph node
     */
    SceneJS.Node.prototype.constructor = SceneJS.Node;

    /**
     * Called by SceneJS_Engine after it has instantiated the node
     *
     * @param {SceneJS_Engine} engine The engine which will manage this node
     * @param {SceneJS_Core} core The core which will hold state for this node, may be shared with other nodes of the same type
     * @param cfg Configuration for this node
     * @param {String} cfg.id ID for the node, unique among all nodes in the scene
     * @param {String} cfg.type type Type of this node (eg. "material", "texture" etc)
     * @param {Object} cfg.data Optional arbitrary JSON object to attach to node
     * @param {String} nodeId Optional ID for node
     */
    SceneJS.Node.prototype._construct = function (engine, core, cfg, nodeId) {

        /**
         * Engine that manages this node
         * @type SceneJS_Engine
         */
        this._engine = engine;

        /**
         * The core which holds state for this node, may be shared with other nodes of the same type
         * @type SceneJS_Core
         */
        this._core = core;

        /**
         * The core ID
         * @type {String|Number}
         */
        this.coreId = core.coreId;

        /**
         * ID of this node, unique within its scene. The ID is a string if it was defined by the application
         * via the node's JSON configuration, otherwise it is a number if it was left to SceneJS to automatically create.
         * @type String|Number
         */
        this.id = cfg.id || cfg.nodeId || nodeId;

        /**
         * Type of this node (eg. "material", "texture" etc)
         * @type String
         */
        this.type = cfg.type || "node";

        /**
         * Optional arbitrary JSON object attached to this node
         * @type JSON
         */
        this.data = cfg.data;

        /**
         * Parent node
         * @type SceneJS.Node
         */
        this.parent = null;

        /**
         * Child nodes
         * @type SceneJS.Node[]
         */
        this.nodes = [];

        /**
         *
         */
        this.dirty = false;

        this.disabled = false;

        /**
         *
         */
        this.branchDirty = false;

        if (this._init) {
            this._init(cfg);
        }
    };

    SceneJS.Node.prototype.disable = function () {
        if (!this.disabled) {
            this.disabled = true;
            this._engine.branchDirty(this);
        }
    };

    SceneJS.Node.prototype.enable = function () {
        if (this.disabled) {
            this.disabled = false;
            this._engine.branchDirty(this);
        }
    };

    /**
     * Logs a message in the context of this node
     * @param {String} [channel] Logging channel - "error", "warn" or "info" (default)
     * @param {String} msg Message to log
     */
    SceneJS.Node.prototype.log = function () {
        var channel;
        var msg;
        if (arguments.length == 1) {
            channel = "info";
            msg = arguments[0];
        } else if (arguments.length == 2) {
            channel = arguments[0];
            msg = arguments[1];
        }
        switch (channel) {
            case "warn":
                msg = "WARN;  [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
                break;
            case "error":
                msg = "ERROR; [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
                break;
            default:
                msg = "INFO;  [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
                break;
        }

        if (console[channel]) {
            console[channel](msg);
        } else {
            console.log(msg);
        }
    };

    /**
     * Returns this node's {@link SceneJS.Scene}
     */
    SceneJS.Node.prototype.getScene = function () {
        return this._engine.scene;
    };

    /**
     * Returns the ID of this node's core
     */
    SceneJS.Node.prototype.getCoreId = function () {
        return this._core.coreId;
    };

    /**
     * Get the node's ID
     *
     */
    SceneJS.Node.prototype.getID = function () {
        return this.id;
    };

    /**
     * Alias for getID
     *  @function
     */
    SceneJS.Node.prototype.getId = function () {
        return this.id;
    };

    /**
     * Alias for getID
     *  @function
     */
    SceneJS.Node.prototype.getNodeId = function () {
        return this.id;
    };


    /**
     * Returns the node's type. For the Node base class, it is "node", overridden in sub-classes.
     */
    SceneJS.Node.prototype.getType = function () {
        return this.type;
    };

    /**
     * Returns the data object attached to this node.
     */
    SceneJS.Node.prototype.getData = function () {
        return this.data;
    };

    /**
     * Sets a data object on this node.
     */
    SceneJS.Node.prototype.setData = function (data) {
        this.data = data;
        return this;
    };

    /**
     * Returns the number of child nodes
     */
    SceneJS.Node.prototype.getNumNodes = function () {
        return this.nodes.length;
    };

    /** Returns child nodes
     * @returns {Array} Child nodes
     */
    SceneJS.Node.prototype.getNodes = function () {
        return this.nodes.slice(0);
    };

    /** Returns child node at given index. Returns null if no node at that index.
     * @param {Number} index The child index
     * @returns {Node} Child node, or null if not found
     */
    SceneJS.Node.prototype.getNodeAt = function (index) {
        if (index < 0 || index >= this.nodes.length) {
            return null;
        }
        return this.nodes[index];
    };

    /** Returns first child node. Returns null if no child nodes.
     * @returns {Node} First child node, or null if not found
     */
    SceneJS.Node.prototype.getFirstNode = function () {
        if (this.nodes.length == 0) {
            return null;
        }
        return this.nodes[0];
    };

    /** Returns last child node. Returns null if no child nodes.
     * @returns {Node} Last child node, or null if not found
     */
    SceneJS.Node.prototype.getLastNode = function () {
        if (this.nodes.length == 0) {
            return null;
        }
        return this.nodes[this.nodes.length - 1];
    };

    /** Returns child node with the given ID.
     * Returns null if no such child node found.
     */
    SceneJS.Node.prototype.getNode = function (id) {
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].id == id) {
                return this.nodes[i];
            }
        }
        return null;
    };

    /** Disconnects the child node at the given index from its parent node
     * @param {int} index Child node index
     * @returns {Node} The disconnected child node if located, else null
     */
    SceneJS.Node.prototype.disconnectNodeAt = function (index) {
        var r = this.nodes.splice(index, 1);
        if (r.length > 0) {
            r[0]._disconnectFromScene();
            r[0].parent = null;
            this._engine.branchDirty(this);
            return r[0];
        } else {
            return null;
        }
    };

    /** Disconnects the child node from its parent, given as a node object
     * @param {String | Node} id The target child node, or its ID
     * @returns {Node} The removed child node if located
     */
    SceneJS.Node.prototype.disconnect = function () {
        if (this.parent) {
            for (var i = 0; i < this.parent.nodes.length; i++) {
                if (this.parent.nodes[i] === this) {
                    var node = this.parent.disconnectNodeAt(i);
                    this._disconnectFromScene();
                    this.parent = null;
                    return node;
                }
            }
            this._disconnectFromScene();
            this.parent = null;
        }
        return null;
    };

    /**
     * Connection callback that can be overridden in
     * specific node types
     */
    SceneJS.Node.prototype._connectToScene = function () {
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            this.nodes[i]._connectToScene();
        }
    };

    /**
     * Disconnection callback that can be overridden in
     * specific node types
     */
    SceneJS.Node.prototype._disconnectFromScene = function () {
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            this.nodes[i]._disconnectFromScene();
        }
    };

    /** Removes the child node at the given index
     * @param {int} index Child node index
     */
    SceneJS.Node.prototype.removeNodeAt = function (index) {
        var child = this.disconnectNodeAt(index);
        if (child) {
            child.destroy();
        }
    };

    /** Removes the child node, given as either a node object or an ID string.
     * @param {String | Node} id The target child node, or its ID
     * @returns {Node} The removed child node if located
     */
    SceneJS.Node.prototype.removeNode = function (node) {

        if (!node) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#removeNode - node argument undefined");
        }

        if (!node._compile) {
            if (typeof node == "string") {
                var gotNode = this._engine.findNode(node);
                if (!gotNode) {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_NOT_FOUND,
                        "Node#removeNode - node not found anywhere: '" + node + "'");
                }
                node = gotNode;
            }
        }

        if (node._compile) { //  instance of node
            for (var i = 0; i < this.nodes.length; i++) {
                if (this.nodes[i] === node) {
                    var removedNode = this.removeNodeAt(i);
                    return removedNode;
                }
            }
        }

        SceneJS_error.fatalError(
            SceneJS.errors.NODE_NOT_FOUND,
            "Node#removeNode - child node not found: " + (node._compile ? ": " + node.id : node));
    };

    /** Disconnects all child nodes from their parent node and returns them in an array.
     */
    SceneJS.Node.prototype.disconnectNodes = function () {
        var len = this.nodes.length;
        for (var i = 0; i < len; i++) {  // Unlink nodes from this
            this.nodes[i]._disconnectFromScene();
            this.nodes[i].parent = null;
        }
        var nodes = this.nodes;
        this.nodes = [];
        this._engine.branchDirty(this);
        return nodes;
    };

    /** Removes all child nodes and returns them in an array.
     */
    SceneJS.Node.prototype.removeNodes = function () {
        var nodes = this.disconnectNodes();
        for (var i = 0; i < nodes.length; i++) {
            nodes[i].destroy();
        }
    };

    /** Destroys this node and moves children up to parent, inserting them where this node resided.
     */
    SceneJS.Node.prototype.splice = function () {

        var i, len;

        if (this.parent == null) {
            return null;
        }
        var parent = this.parent;
        var nodes = this.disconnectNodes();
        for (i = 0, len = nodes.length; i < len; i++) {  // Link this node's nodes to new parent
            nodes[i].parent = this.parent;
            nodes[i]._connectToScene();
        }
        for (i = 0, len = parent.nodes.length; i < len; i++) { // Replace node on parent's nodes with this node's nodes
            if (parent.nodes[i] === this) {

                parent.nodes.splice.apply(parent.nodes, [i, 1].concat(nodes));

                this.nodes = [];
                this._disconnectFromScene();
                this.parent = null;

                this.destroy();

                this._engine.branchDirty(parent);

                return parent;
            }
        }
    };

    /** Appends multiple child nodes
     */
    SceneJS.Node.prototype.addNodes = function (nodes) {
        if (!nodes) {
            return null;
        }
        for (var i = nodes.length - 1; i >= 0; i--) {
            this.addNode(nodes[i]);
        }
    };

    /** Appends a child node
     */
    SceneJS.Node.prototype.addNode = function (node, ok) {

        node = node || {};

        // Graft node object
        if (node._compile) {
            if (node.parent != null) {
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Node#addNode - node argument is still attached to another parent");
            }
            this.nodes.push(node);
            node.parent = this;
            node._connectToScene();
            this._engine.branchDirty(node);
            if (ok) {
                ok(node);
            }
            return node;
        }

        // Graft node object by ID reference
        if (typeof node == "string") {
            var gotNode = this._engine.findNode(node);
            if (!gotNode) {
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Node#addNode - node not found: '" + node + "'");
            }
            node = gotNode;
            if (node.parent != null) {
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Node#addNode - node argument is still attached to another parent");
            }
            this.nodes.push(node);
            node.parent = this;
            node._connectToScene();
            this._engine.branchDirty(node);
            if (ok) {
                ok(node);
            }
            return node;
        }

        // Create node

        node.type = node.type || "node";

        if (node.type == "node" || this._engine.hasNodeType(node.type)) {

            // Root node's type is already loaded, so we are able
            // to create the root synchronously. When the caller
            // is creating a core node type, then by this contract
            // it can rely on the return value

            node = this._engine.createNode(node);
            this.nodes.push(node);
            node.parent = this;
            node._connectToScene();
            this._engine.branchDirty(node);
            if (ok) {
                ok(node);
            }
            return node;

        } else {

            // Otherwise the root node's type needs to be loaded,
            // so we need to create it asynchronously. By this contract,
            // the Caller would not rely on synchronous creation of
            // non-core types.
            var self = this;
            this._engine.createNode(node,
                function (node) {
                    self.nodes.push(node);
                    node.parent = self;
                    node._connectToScene();
                    self._engine.branchDirty(node);
                    if (ok) {
                        ok(node);
                    }
                });
            return null;
        }
    };

    /** Inserts a subgraph into child nodes
     * @param {Node} node Child node
     * @param {int} i Index for new child node
     * @return {Node} The child node
     */
    SceneJS.Node.prototype.insertNode = function (node, i) {

        if (!node) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.Node#insertNode - node argument is undefined");
        }

        if (!node._compile) { // JSON node definition
            node = this._engine.createNode(node); // Create node
        }

        if (!node._compile) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.Node#insertNode - node argument is not a SceneJS.Node");
        }

        if (node.parent != null) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.Node#insertNode - node argument is still attached to another parent");
        }

        if (i === undefined || i === null) {
            node.addNodes(this.disconnectNodes());
            this.addNode(node);

        } else if (i < 0) {

            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.Node#insertNode - node index out of range: -1");

        } else if (i >= this.nodes.length) {
            this.nodes.push(node);
        } else {
            this.nodes.splice(i, 0, node);
        }

        node.parent = this;
        node._connectToScene();
        return node;
    };

    /** Calls the given function on each node in the subgraph rooted by this node, including this node.
     * The callback takes each node as it's sole argument and traversal stops as soon as the function returns
     * true and returns the node.
     * @param {function(Node)} func The function
     */
    SceneJS.Node.prototype.mapNodes = function (func) {
        if (func(this)) {
            return this;
        }
        var result;
        for (var i = 0; i < this.nodes.length; i++) {
            result = this.nodes[i].mapNodes(func);
            if (result) {
                return result;
            }
        }
        return null;
    };

    /**
     * Returns the parent node
     * @return {SceneJS.Node}
     */
    SceneJS.Node.prototype.getParent = function (type) {
        return this.parent;
    };

    /**
     * Finds the first node of given type on path to root.
     * @param {String} type Parent type to find on path to root
     * @return {SceneJS.Node}
     */
    SceneJS.Node.prototype.getParentOfType = function (type) {
        var parent = this.parent;
        while (parent && parent.type != type) {
            parent = parent.parent;
        }
        return parent;
    };

    /**
     * Iterates over parent nodes on the path from the selected node to the root, executing a function
     * for each.
     * If the function returns true at any node, then traversal stops and a selector is
     * returned for that node.
     * @param {Function(node, index)} fn Function to execute on each instance node
     * @return {Object} Selector for selected node, if any
     */
    SceneJS.Node.prototype.eachParent = function (fn) {

        if (!fn) {
            throw "SceneJS.Node.eachParent param 'fn' is null or undefined";
        }

        var count = 0;
        var node = this;

        while (node.parent) {
            if (fn.call(node.parent, count++) === true) {
                return node.parent;
            }
            node = node.parent;
        }

        return null;
    };

    /** Returns true if a child node matching given ID or index exists on this node
     * @param {Number|String} node Child node index or ID
     */
    SceneJS.Node.prototype.hasNode = function (node) {

        if (node === null || node === undefined) {
            throw "SceneJS.Node.hasNode param 'node' is null or undefined";
        }

        var type = typeof node;
        var nodeGot;

        if (type == "number") {
            nodeGot = this.getNodeAt(node);

        } else if (type == "string") {
            nodeGot = this.getNode(node);

        } else {
            throw "SceneJS.Node.hasNode param 'node' should be either an index number or an ID string";
        }

        return (nodeGot != undefined && nodeGot != null);
    };

    /** Selects a child node matching given ID or index
     * @param {Number|String} node Child node index or ID
     */
    SceneJS.Node.prototype.node = function (node) {

        if (node === null || node === undefined) {
            throw "SceneJS.Node.node param 'node' is null or undefined";
        }

        var type = typeof node;
        var nodeGot;

        if (type == "number") {
            nodeGot = this.getNodeAt(node);

        } else if (type == "string") {
            nodeGot = this.getNode(node);

        } else {
            throw "SceneJS.Node.node param 'node' should be either an index number or an ID string";
        }

        if (!nodeGot) {
            throw "SceneJS.Node.node - node not found: '" + node + "'";
        }

        return nodeGot;
    };

    /**
     * Iterates over sub-nodes of the selected node, executing a function
     * for each. With the optional options object we can configure is depth-first or breadth-first order.
     * If neither, then only the child nodes are iterated.
     * If the function returns true at any node, then traversal stops and a selector is
     * returned for that node.
     * @param {Function(index, node)} fn Function to execute on each child node
     * @return {Object} Selector for selected node, if any
     */
    SceneJS.Node.prototype.eachNode = function (fn, options) {

        if (!fn) {
            throw "SceneJS.Node.eachNode param 'fn' is null or undefined";
        }

        if (typeof fn != "function") {
            throw "SceneJS.Node.eachNode param 'fn' should be a function";
        }

        var stoppedNode;
        options = options || {};
        var count = 0;

        if (options.andSelf) {
            if (fn.call(this, count++) === true) {
                return this;
            }
        }

        if (!options.depthFirst && !options.breadthFirst) {
            stoppedNode = this._iterateEachNode(fn, this, count);

        } else if (options.depthFirst) {
            stoppedNode = this._iterateEachNodeDepthFirst(fn, this, count, false); // Not below root yet

        } else {
            // TODO: breadth-first
        }

        if (stoppedNode) {
            return stoppedNode;
        }

        return undefined; // IDE happy now
    };

    SceneJS.Node.prototype.numNodes = function () {
        return this.nodes.length;
    };

    SceneJS.Node.prototype._iterateEachNode = function (fn, node, count) {

        var len = node.nodes.length;
        var child;

        for (var i = 0; i < len; i++) {
            child = node.nodes[i];

            if (fn.call(child, count++) === true) {
                return child;
            }
        }

        return null;
    };

    SceneJS.Node.prototype._iterateEachNodeDepthFirst = function (fn, node, count, belowRoot) {

        if (belowRoot) {

            /* Visit this node - if we are below root, because entry point visits the root
             */
            if (fn.call(node, count++) === true) {
                return node;
            }
        }

        belowRoot = true;

        /* Iterate nodes
         */
        var len = node.nodes.length;
        var child;
        for (var i = 0; i < len; i++) {
            child = this._iterateEachNodeDepthFirst(fn, node.nodes[i], count, belowRoot);
            if (child) {
                return child;
            }
        }

        return null;
    };

    /** Returns either all child or all sub-nodes of the given type, depending on whether search is recursive or not.
     */
    SceneJS.Node.prototype.findNodesByType = function (type, recursive) {
        return this._findNodesByType(type, [], recursive);
    };

    SceneJS.Node.prototype._findNodesByType = function (type, list, recursive) {
        var i;
        for (i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];
            if (node.type == type) {
                list.push(node);
            }
        }
        if (recursive) {
            for (i = 0; i < this.nodes.length; i++) {
                this.nodes[i]._findNodesByType(type, list, recursive);
            }
        }
        return list;
    };

    /** Finds the first node on path up to root whose type equals that given
     */
    SceneJS.Node.prototype.findParentByType = function (type) {
        var parent = this.parent;
        while (parent && parent.type != type) {
            parent = parent.parent;
        }
        return parent;
    };

    /**
     * Returns an object containing the attributes that were given when creating the node. Obviously, the map will have
     * the current values, plus any attributes that were later added through set/add methods on the node
     *
     */
    SceneJS.Node.prototype.getJSON = function () {
        return this;
    };


    SceneJS.Node.prototype._compile = function (ctx) {
        if (this.preCompile) {
            this.preCompile();
        }
        this._compileNodes(ctx);
        if (this.postCompile) {
            this.postCompile();
        }
    };

    SceneJS.Node.prototype._compileNodes = function (ctx) {

        var renderSubs = !!this.onRendered;

        var child;

        for (var i = 0, len = this.nodes.length; i < len; i++) {

            child = this.nodes[i];

            child.branchDirty = child.branchDirty || this.branchDirty; // Compile subnodes if scene branch dirty

            if (child.dirty || child.branchDirty || this._engine.sceneDirty) {  // Compile nodes that are flagged dirty
                if (child.disabled) {
                    child._compileNodes(ctx);
                } else {
                    child._compile(ctx);
                }
                child.dirty = false;
                child.branchDirty = false;
            }
        }
    };



    /**
     * Destroys this node. It is marked for destruction; when the next scene traversal begins (or the current one ends)
     * it will be destroyed and removed from it's parent.
     */
    SceneJS.Node.prototype.destroy = function () {

        if (!this.destroyed) {

            if (this.parent) {

                // Remove from parent's child node list

                var parentNodes = this.parent.nodes;
                var len = parentNodes.length;
                for (var i = 0; i < len; i++) {
                    if (parentNodes[i].id === this.id) {
                        parentNodes.splice(i, 1);
                        break;
                    }
                }
            }

            // Remove publication
            this._engine.scene.unpublish("nodes/" + this.id);

            /* Recusrsively destroy child nodes without
             * bothering to remove them from their parents
             */
            this._destroyTree();

            /* Need object list recompilation on display
             */
            this._engine.display.objectListDirty = true;
        }

        return this;
    };

    SceneJS.Node.prototype._destroyTree = function () {

        this.destroyed = true;

        this._engine.destroyNode(this); // Release node object

        var childNode;
        for (var i = 0, len = this.nodes.length; i < len; i++) {
            childNode = this.nodes[i];
            this._engine.scene.unpublish("nodes/" + childNode.id);
            childNode._destroyTree();
        }
    };

    /**
     * Performs the actual destruction of this node, calling the node's optional template destroy method
     */
    SceneJS.Node.prototype._doDestroy = function () {

        if (this._destroy) {  // Call destruction handler for each node subclass
            this._destroy();
        }

        return this;
    };

})();
;/**
 * @class Manages creation, recycle and destruction of {@link SceneJS.Node} instances
 * @private
 */

(function () {
    "use strict";

    var SceneJS_NodeFactory = window.SceneJS_NodeFactory = function () {
        this.nodes = new SceneJS_Map({});
    };

    SceneJS_NodeFactory.nodeTypes = {};

    SceneJS_NodeFactory.createNodeType = function (typeName) {
        if (SceneJS_NodeFactory.nodeTypes[typeName]) {
            throw "Node type already defined: " + typeName;
        }
        var nodeType = function () { // Create the class
            SceneJS.Node.apply(this, arguments);
            this.type = typeName;
        };
        nodeType.prototype = new SceneJS.Node();            // Inherit from base class
        nodeType.prototype.constructor = nodeType;
        SceneJS_NodeFactory.nodeTypes[typeName] = nodeType;
        return nodeType;
    };

    SceneJS_NodeFactory.prototype.getNode = function (engine, json, core) {
        json.type = json.type || "node";
        var nodeType;
        if (json.type === "node") {
            nodeType = SceneJS.Node;
        } else {
            nodeType = SceneJS_NodeFactory.nodeTypes[json.type];
            if (!nodeType) {
                console.error("Unknown node type: " + json.type + " - can't create - making a SceneJS.Node by default");
                nodeType = SceneJS.Node;
            }
        }
        var node = new nodeType();
        var id = json.id || json.nodeId;
        if (id) {
            this.nodes.addItem(id, node);
        } else {
            id = this.nodes.addItem(node);
        }
        node._construct(engine, core, json, id); // Instantiate node
        return node;
    };

    SceneJS_NodeFactory.prototype.putNode = function (node) {
        this.nodes.removeItem(node.id);
    };

})();
;(function () {
    "use strict";

    var FLAGS = SceneJS.PROPERTY_FLAGS;
    var COLOR_MOD_FLAGS = SceneJS.COLOR_MOD_FLAGS;
    var DEPTH_TEST_FLAGS = SceneJS.DEPTH_TEST_FLAGS;

    var STRING_TO_MOD_FLAG = {
        saturation: COLOR_MOD_FLAGS.SATURATION,
        brightness: COLOR_MOD_FLAGS.BRIGHTNESS,
        contrast: COLOR_MOD_FLAGS.CONTRAST,
        tintColor: COLOR_MOD_FLAGS.TINT
    };

    var STRING_TO_DEPTH_TEST_FLAG = {
        enabled: DEPTH_TEST_FLAGS.ENABLED,
        disabled: DEPTH_TEST_FLAGS.DISABLED,
        alwaysPass: DEPTH_TEST_FLAGS.ALWAYS_PASS
    };

    var DEPTH_TEST_FLAG_TO_STRING = {};
    for (var key in STRING_TO_DEPTH_TEST_FLAG) {
        var flag = STRING_TO_DEPTH_TEST_FLAG[key];
        DEPTH_TEST_FLAG_TO_STRING[flag] = key;
    }

    /**
     * The default state core singleton for {@link SceneJS.Properties} nodes
     */
    var defaultCore = new SceneJS_PropertiesCore();
    defaultCore.stateId = SceneJS._baseStateId++;

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.properties = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which sets rendering mode properties for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Properties = SceneJS_NodeFactory.createNodeType("properties");

    SceneJS.Properties.prototype._init = function (params) {

        if (this._core.useCount == 1) {         // This node is first to reference the state core, so sets it up
            if (params.properties) {                  // 'properties' property is actually optional in the node definition
                this.setProperties(params.properties);
            }
        }
    };

    SceneJS.Properties.prototype.setProperties = function (properties) {

        var core = this._core;

        if (properties.picking != undefined) {
            core.setFlag(FLAGS.PICKING, properties.picking);
            this._engine.display.imageDirty = true;
        }

        if (properties.solidColor != undefined) {
            var defaultClippingParams = defaultCore.solidColor;
            var color = properties.solidColor;
            core.solidColor[0] = color.r != undefined ? color.r : defaultClippingParams[0];
            core.solidColor[1] = color.g != undefined ? color.g : defaultClippingParams[1];
            core.solidColor[2] = color.b != undefined ? color.b : defaultClippingParams[2];
            this._engine.display.imageDirty = true;
        }

        if (properties.clipping != undefined) {
            core.setFlag(FLAGS.CLIPPING, properties.clipping);
            this._engine.branchDirty(this);
        }

        if (properties.enabled != undefined) {
            core.setFlag(FLAGS.ENABLED, properties.enabled);
            this._engine.display.objectListDirty = true;
        }

        if (properties.frontface != undefined) {
            core.setFlag(FLAGS.CCW, properties.frontface === "ccw");
            this._engine.display.imageDirty = true;
        }

        if (properties.reflective != undefined) {
            core.setFlag(FLAGS.REFLECTIVE, properties.reflective);
            this._engine.branchDirty(this);
        }

        if (properties.solid != undefined) {
            core.setFlag(FLAGS.SOLID, properties.solid);
            this._engine.branchDirty(this);
        }

        if (properties.skybox != undefined) {
            core.setFlag(FLAGS.SKYBOX, properties.skybox);
            this._engine.branchDirty(this);
        }

        if (properties.billboard != undefined) {
            core.setFlag(FLAGS.BILLBOARD, properties.billboard);
            this._engine.branchDirty(this);
        }

        if (properties.colorModifiers) {
            var applyTo, applyVal;
            core.colorModifiers.length = properties.colorModifiers.length;
            core.colorModRange = false;
            for (var cmi = 0, cmLen = properties.colorModifiers.length; cmi < cmLen; cmi++) {
                var cm = properties.colorModifiers[cmi];
                applyTo = STRING_TO_MOD_FLAG[cm.applyTo] || cm.applyTo;
                applyVal = cm.value;

                if (!applyVal.isScalarFresnel && !applyVal.isColorFresnel) {
                    if (applyTo === COLOR_MOD_FLAGS.CONTRAST && !cm.normalized) {
                        applyVal = cm.value + 1; // normalize
                    }
                }

                // assign
                core.colorModifiers[cmi] = {
                    applyTo: applyTo,
                    value: applyVal,
                    range: null
                };

                if (applyTo === COLOR_MOD_FLAGS.CONTRAST) {
                    core.colorModifiers[cmi].normalized = true;
                }

                // optional range value
                if (cm.range) {
                    core.colorModRange = true;
                    core.colorModifiers[cmi].range = {
                        center: new Float32Array(cm.range.center),
                        radius: new Float32Array([cm.range.minRadius, cm.range.maxRadius - cm.range.minRadius])
                    };
                }

            }
        }

        if (properties.name != undefined) {
            core.name = properties.name;
        }

        if (properties.xray != undefined) {
            var wasTransparent = core.transparent;
            core.setFlag(FLAGS.XRAY, properties.xray);
            core.resetTransparency();
            if (core.transparent !== wasTransparent) {
                this._engine.display.objectListDirty = true;
            }
            this._engine.display.imageDirty = true;
        }

        if (properties.glassFactor != undefined) {
            core.xrayParams[0] = properties.glassFactor;
            this._engine.display.imageDirty = true;
        }

        if (properties.murkiness != undefined) {
            core.xrayParams[1] = properties.murkiness;
            this._engine.display.imageDirty = true;
        }

        if (properties.opacityModifiers) {
            var wasTransparent = core.transparent;
            var applyVal;
            var om, len = properties.opacityModifiers.length;
            core.opacityModifiers.length = len;
            core.opacityModRange = false;
            for (var omi = 0; omi < len; ++omi) {
                om = properties.opacityModifiers[omi];
                applyVal = om.value;

                // assign
                core.opacityModifiers[omi] = {
                    value: applyVal,
                    range: null
                }

                // optional range value
                if (om.range) {
                    core.opacityModRange = true;
                    core.opacityModifiers[omi].range = {
                        center: new Float32Array(om.range.center),
                        radius: new Float32Array([om.range.minRadius, om.range.maxRadius - om.range.minRadius])
                    };
                }
            }
            core.resetTransparency();
            if (core.transparent !== wasTransparent) {
                this._engine.display.objectListDirty = true;
            }
            this._engine.display.imageDirty = true;
        }

        if (properties.noDepthMask != undefined) {
            core.setFlag(FLAGS.NO_DEPTH_MASK, properties.noDepthMask);
            this._engine.display.imageDirty = true;
        }

        if (properties.partiallyOpaque != undefined) {
            var wasPartiallyOpaque = core.partiallyOpaque;
            core.setFlag(FLAGS.PARTIALLY_OPAQUE, properties.partiallyOpaque);
            core.resetTransparency();
            if (core.partiallyOpaque !== wasPartiallyOpaque) {
                this._engine.branchDirty(this);
            }
            this._engine.display.imageDirty = true;
        }

        if (properties.forceTransparent != undefined) {
            var wasTransparent = core.transparent;
            core.setFlag(FLAGS.FORCE_TRANSPARENT, properties.forceTransparent);
            core.resetTransparency();
            if (core.transparent !== wasTransparent) {
                this._engine.display.objectListDirty = true;
            }
            this._engine.display.imageDirty = true;
        }

        if (properties.stochasticAlpha != undefined) {
            var wasTransparent = core.transparent;
            core.setFlag(FLAGS.STOCHASTIC_ALPHA, properties.stochasticAlpha);
            core.resetTransparency();
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.roundPoints != undefined) {
            core.setFlag(FLAGS.ROUND_POINTS, properties.roundPoints);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.perspectivePoints != undefined) {
            core.setFlag(FLAGS.PERSPECTIVE_POINTS, properties.perspectivePoints);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.fragmentShaderHeader != undefined) {
            core.fragmentShaderHeader = properties.fragmentShaderHeader;
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.fragmentShaderFooter != undefined) {
            core.fragmentShaderFooter = properties.fragmentShaderFooter;
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.depthTest != undefined) {
            core.depthTest = STRING_TO_DEPTH_TEST_FLAG[properties.depthTest] || properties.depthTest;
            this._engine.display.imageDirty = true;
        }

        var oldHash = core.hash;
        core.hash = getHash(core);
        if (core.hash !== oldHash) {
            this._engine.branchDirty(this);
        }
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.Properties.prototype.getProperties = function () {
        var core = this._core;
        return {
            picking: core.getFlag(FLAGS.PICKING),
            clipping: core.getFlag(FLAGS.CLIPPING),
            enabled: core.getFlag(FLAGS.ENABLED),
            frontface: core.getFlag(FLAGS.CCW) ? "ccw" : "cw",
            reflective: core.getFlag(FLAGS.REFLECTIVE),
            solid: core.getFlag(FLAGS.SOLID),
            solidColor: core.solidColor,
            skybox: core.getFlag(FLAGS.SKYBOX),
            billboard: core.getFlag(FLAGS.BILLBOARD),
            fullyTransparent: core.getFlag(FLAGS.FULLY_TRANSPARENT),
            roundPoints: core.getFlag(FLAGS.ROUND_POINTS),
            perspectivePoints: core.getFlag(FLAGS.PERSPECTIVE_POINTS),
            xray: core.getFlag(FLAGS.XRAY),
            glassFactor: core.xrayParams[0],
            murkiness: core.xrayParams[1],
            colorModifiers: core.colorModifiers,
            opacityModifier: core.opacityModifiers,
            pointPerspectiveDistance: core.pointPerspectiveDistance,
            fragmentShaderHeader: core.fragmentShaderHeader,
            fragmentShaderFooter: core.fragmentShaderFooter,
            depthTest: DEPTH_TEST_FLAG_TO_STRING[core.depthTest] || "enabled"
        };
    };

    SceneJS.Properties.prototype.setPicking = function (picking) {
        picking = !!picking;
        if (this._core.getFlag(FLAGS.PICKING) !== picking) {
            this._core.setFlag(FLAGS.PICKING, picking);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getPicking = function () {
        return this._core.getFlag(FLAGS.PICKING);
    };

    SceneJS.Properties.prototype.setClipping = function (clipping) {
        this.setProperties({clipping: clipping})
        return this;
    };

    SceneJS.Properties.prototype.getClipping = function () {
        return !!this.solidColor[3];
    };

    SceneJS.Properties.prototype.setEnabled = function (enabled) {
        return this.setProperties({enabled: enabled});
    };

    SceneJS.Properties.prototype.getEnabled = function () {
        return this._core.getFlag(FLAGS.ENABLED);
    };

    SceneJS.Properties.prototype.setFrontface = function (frontface) {
        var ccw = frontface === "ccw";
        if (this._core.getFlag(FLAGS.CCW) !== ccw) {
            this._core.setFlag(FLAGS.CCW, ccw);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getFrontface = function () {
        return this._core.getFlag(FLAGS.CCW) ? "ccw" : "cw";
    };

    SceneJS.Properties.prototype.setReflective = function (reflective) {
        reflective = !!reflective;
        if (this._core.getFlag(FLAGS.REFLECTIVE) != reflective) {
            this._core.setFlag(FLAGS.REFLECTIVE, reflective);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getReflective = function () {
        return this._core.getFlag(FLAGS.REFLECTIVE);
    };

    SceneJS.Properties.prototype.setSolid = function (solid) {
        solid = !!solid;
        if (this._core.getFlag(FLAGS.SOLID) != solid) {
            this._core.setFlag(FLAGS.SOLID, solid);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getSolid = function () {
        return this._core.getFlag(FLAGS.SOLID);
    };

    SceneJS.Properties.prototype.setSolidColor = function (color) {
        this.setProperties({solidColor: color})
        return this;
    };

    SceneJS.Properties.prototype.getSolidColor = function () {
        return {
            r: this._core.solidColor[0],
            g: this._core.solidColor[1],
            b: this._core.solidColor[2]
        };
    };

    SceneJS.Properties.prototype.setSkybox = function (skybox) {
        skybox = !!skybox;
        if (this._core.getFlag(FLAGS.SKYBOX) != skybox) {
            this._core.setFlag(FLAGS.SKYBOX, skybox);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getSkybox = function () {
        return this._core.getFlag(FLAGS.SKYBOX);
    };

    SceneJS.Properties.prototype.setName = function (name) {
        this._core.name = name;
    };

    SceneJS.Properties.prototype.getName = function () {
        return this._core.name;
    };

    SceneJS.Properties.prototype.setFullyTransparent = function (ft) {
        ft = !!ft;
        if (this._core.getFlag(FLAGS.FULLY_TRANSPARENT) !== ft) {
            this._core.setFlag(FLAGS.FULLY_TRANSPARENT, ft);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getFullyTransparent = function () {
        return this._core.getFlag(FLAGS.FULLY_TRANSPARENT);
    };

    SceneJS.Properties.prototype.setRoundPoints = function (roundPoints) {
        roundPoints = !!roundPoints;
        if (this._core.getFlag(FLAGS.ROUND_POINTS) != roundPoints) {
            this._core.setFlag(FLAGS.ROUND_POINTS, roundPoints);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getRoundPoints = function () {
        return this._core.getFlag(FLAGS.ROUND_POINTS);
    };

    SceneJS.Properties.prototype._compile = function (ctx) {
        this._engine.display.properties = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.properties = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    function getColorModificationHash(core) {
        var hash = "";
        var cmi = 0, cmlen = core.colorModifiers.length;
        for (cmi = 0; cmi < cmlen; cmi++) {

            var colorModifier = core.colorModifiers[cmi];
            var applyTo = colorModifier.applyTo;
            var range = colorModifier.range;
            var value = colorModifier.value;

            // hash on apply to
            if (applyTo === COLOR_MOD_FLAGS.BRIGHTNESS) {
                hash += "b";
            } else if (applyTo === COLOR_MOD_FLAGS.CONTRAST) {
                hash += "c";
            } else if (applyTo === COLOR_MOD_FLAGS.SATURATION) {
                hash += "s";
            } else if (applyTo === COLOR_MOD_FLAGS.TINT) {
                hash += "t";
            }

            // hash on modifier-range
            if (range) {
                hash += "r";
            }

            // hash on value
            if (value.isScalarFresnel) {
                hash += "sf";
            } else if (value.isColorFresnel) {
                hash += "cf";
            } else {
                hash += "nv"; // "number value"
            }
        }
        return hash;
    }

    function getOpacityModificationHash(core) {
        var hash = "";
        var omi = 0, len = core.opacityModifiers.length;
        for (omi = 0; omi < len; omi++) {
            var opacityModifier = core.opacityModifiers[omi];
            var range = opacityModifier.range;
            var value = opacityModifier.value;
            // hash on modifier-range
            if (range) {
                hash += "r";
            } else {
                hash += "o";
            }
            // hash on value
            if (value.isScalarFresnel) {
                hash += "sf";
            } else {
                hash += "nv"; // "number value"
            }
        }
        return hash;
    }

    function getHash(core) {
        return (core.getFlag(FLAGS.REFLECTIVE) ? "refl" : "") + ";" +
            (core.getFlag(FLAGS.SKYBOX) ? "sky" : "") + ";" +
            (core.getFlag(FLAGS.SOLID) ? "s" : "") + ";" +
            (core.getFlag(FLAGS.ROUND_POINTS) ? "rpt" : "") + ";" +
            (core.getFlag(FLAGS.PERSPECTIVE_POINTS) ? "ppt" : "") + ";" +
            (core.getFlag(FLAGS.BILLBOARD) ? "b" : "") + ";" +
            (core.getFlag(FLAGS.STOCHASTIC_ALPHA) ? "sa" : "") + ";" +
            getColorModificationHash(core) + ";" +
            getOpacityModificationHash(core) + ";" +
            (core.fragmentShaderHeader || "") + ";" +
            (core.fragmentShaderFooter || "") + ";";
    }

})();
;(function () {
    "use strict";

    /**
     * @class Scene graph node that defines geometry.
     * @extends SceneJS.Node
     * When this node is at a leaf, it defines a scene object which inherits the state set up by all the nodes above it
     * on the path up to the root. These nodes can be nested, so that child geometries inherit arrays
     * defined by parent geometries.
     */
    SceneJS.Geometry = SceneJS_NodeFactory.createNodeType("geometry");

    SceneJS.Geometry.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the core

            this._initNodeCore(params, {
                origin: params.origin,
                scale: params.scale,
                autoNormals: params.normals == "auto"
            });

            this._buildNodeCore(this._engine.canvas.gl, this._core);

            this._boundary = {
                xmin: Number.POSITIVE_INFINITY,
                ymin: Number.POSITIVE_INFINITY,
                zmin: Number.POSITIVE_INFINITY,
                xmax: Number.NEGATIVE_INFINITY,
                ymax: Number.NEGATIVE_INFINITY,
                zmax: Number.NEGATIVE_INFINITY
            };

            this._boundaryDirty = true;

            this.backfaces = params.backfaces !== false;
            
            // Weird to put these here, but want it to be per
            // renderable object.
            this.addBlend = params.addBlend === true;
            this.layer = params.layer || 0;
            this.onObjectCreate = params.onObjectCreate || null;

            this._core.webglRestored = getContextRestoredCallback(this);

            this._engine.stats.geometry.meshes++;
        }
    };

    /**
     * Convert JSON arrays into typed arrays,
     * apply optional baked Model-space transforms to positions
     */
    SceneJS.Geometry.prototype._initNodeCore = function (data, options) {

        var self = this;

        options = options || {};

        var primitive = data.primitive || "triangles";
        var core = this._core;
        var IndexArrayType = SceneJS.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"] ? Uint32Array : Uint16Array;

        core._engine = this._engine;
        core.primitive = this._getPrimitiveType(primitive);
        core.primitiveName = primitive;
        core.pointSize = data.pointSize || 1;
        core.pointUVScale = data.pointUVScale || new Float32Array([1.0, 1.0]);
        core.compressedPositions = false;
        core.compressedNormals = false;
        core.compressedUVs = false;

        // Generate normals
        if (data.normals) {
            if (primitive == "triangles") {
                if (data.normals === "auto" || data.normals === true) {
                    if (data.positions && data.indices) {
                        this._buildNormals(data); // Auto normal generation - build normals array
                    }
                }
            }
        }

        // Create typed arrays, apply any baked transforms
        core.arrays = {};

        if (data.positions) {
            if (data.positionDecodeMat) {
                core.arrays.positions = data.positions;


                core.positionDecodeMat = data.positionDecodeMat;
                core.compressedPositions = true;
            } else {
                if (data.positions.constructor != Float32Array) {
                    data.positions = new Float32Array(data.positions);
                }

                if (options.scale || options.origin) {
                    this._applyOptions(data.positions, options)
                }

                core.arrays.positions = data.positions;
            }
            this._engine.stats.geometry.vertices += data.positions.length / 3;
            this._engine.stats.memory.positions += data.positions.length * data.positions.constructor.BYTES_PER_ELEMENT;
        }

        if (data.normals) {
            if (data.normals.constructor == Int8Array) {
                core.arrays.normals = data.normals;

                core.compressedNormals = true;
            } else {
                if (data.normals.constructor != Float32Array) {
                    data.normals = new Float32Array(data.normals);
                }

                core.arrays.normals = data.normals;
            }

            this._engine.stats.memory.normals += data.normals.length * data.normals.constructor.BYTES_PER_ELEMENT;
        }

        var uvs, uv;
        if (data.uvDecodeMats) {
            uvs = data.uvs;
            uv;
            for (var i = 0, len = uvs.length; i < len; i++) {
                uv = uvs[i];
                if (uv.constructor != Uint16Array) {
                    uvs[i] = new Uint16Array(uvs[i]);
                }
                this._engine.stats.memory.uvs += uv.length * uv.constructor.BYTES_PER_ELEMENT;
            }
            core.arrays.uvs = uvs;
            core.uvDecodeMats = data.uvDecodeMats;
            core.compressedUVs = true;
        } else if (data.uvs) {
            uvs = data.uvs;
            uv;
            for (var i = 0, len = uvs.length; i < len; i++) {
                uv = uvs[i];
                if (uv.constructor != Float32Array) {
                    uvs[i] = new Float32Array(uvs[i]);
                }
                this._engine.stats.memory.uvs += uv.length * uv.constructor.BYTES_PER_ELEMENT;
            }
            core.arrays.uvs = uvs;
        }

        // ---------------- Backward-compatibility -------------------

        if (data.uv) {
            if (data.uv.constructor != Float32Array) {
                data.uv = new Float32Array(data.uv);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[0] = data.uv;
            this._engine.stats.memory.uvs += data.uv.length * data.uv.constructor.BYTES_PER_ELEMENT;
        }

        if (data.uv1) {
            if (data.uv1.constructor != Float32Array) {
                data.uv1 = new Float32Array(data.uv1);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[1] = data.uv1;
            this._engine.stats.memory.uvs += data.uv1.length * data.uv1.constructor.BYTES_PER_ELEMENT;
        }

        if (data.uv2) {
            if (data.uv2.constructor != Float32Array) {
                data.uv2 = new Float32Array(data.uv2);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[2] = data.uv2;
            this._engine.stats.memory.uvs += data.uv2.length * data.uv2.constructor.BYTES_PER_ELEMENT;
        }

        if (data.uv3) {
            if (data.uv3.constructor != Float32Array) {
                data.uv3 = new Float32Array(data.uv3);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[3] = data.uv3;
            this._engine.stats.memory.uvs += data.uv3.length * data.uv3.constructor.BYTES_PER_ELEMENT;
        }

        // ----------------------------------------------------------

        if (core.arrays.normals && core.arrays.uvs) {
            core.arrays.tangents = [];
        }

        if (data.colors) {
            if (data.colors.constructor != Uint8Array) {
                data.colors = new Uint8Array(data.colors);
            }

            core.arrays.colors = data.colors;
            this._engine.stats.memory.colors += data.colors.length * data.colors.constructor.BYTES_PER_ELEMENT;
        }

        if (data.indices) {
            if (data.indices.constructor != Uint8Array &&
                data.indices.constructor != Uint16Array &&
                data.indices.constructor != Uint32Array)
            {
                data.indices = new IndexArrayType(data.indices);
            }

            core.arrays.indices = data.indices;
            this._engine.stats.geometry.triangles += data.indices.length / 3;
            this._engine.stats.memory.indices += data.indices.length * data.indices.constructor.BYTES_PER_ELEMENT;
        }

        if (data.pointScaleRotations) {
            if (data.pointScaleRotations.constructor != Float32Array) {
                data.pointScaleRotations = new Float32Array(data.pointScaleRotations);
            }

            core.arrays.pointScaleRotations = data.pointScaleRotations;
            this._engine.stats.memory.pointScaleRotations += data.pointScaleRotations.length * data.pointScaleRotations.constructor.BYTES_PER_ELEMENT;
        }

        if (data.pointUVTranslates) {
            if (data.pointUVTranslates.constructor != Float32Array) {
                data.pointUVTranslates = new Float32Array(data.pointUVTranslates);
            }

            core.arrays.pointUVTranslates = data.pointUVTranslates;
            this._engine.stats.memory.pointUVTranslates += data.pointUVTranslates.length * data.pointUVTranslates.constructor.BYTES_PER_ELEMENT;
        }
    };


    /**
     * Returns WebGL constant for primitive name
     */
    SceneJS.Geometry.prototype._getPrimitiveType = function (primitive) {

        var gl = this._engine.canvas.gl;

        switch (primitive) {

            case "points":
                return gl.POINTS;

            case "lines":
                return gl.LINES;

            case "line-loop":
                return gl.LINE_LOOP;

            case "line-strip":
                return gl.LINE_STRIP;

            case "triangles":
                return gl.TRIANGLES;

            case "triangle-strip":
                return gl.TRIANGLE_STRIP;

            case "triangle-fan":
                return gl.TRIANGLE_FAN;

            default:
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "geometry primitive unsupported: '" +
                    primitive +
                    "' - supported types are: 'points', 'lines', 'line-loop', " +
                    "'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'");
        }
    };

    /**
     * Apply baked Model-space transformations to give position array
     */
    SceneJS.Geometry.prototype._applyOptions = function (positions, options) {

        if (options.scale) {

            var scaleX = options.scale.x != undefined ? options.scale.x : 1.0;
            var scaleY = options.scale.y != undefined ? options.scale.y : 1.0;
            var scaleZ = options.scale.z != undefined ? options.scale.z : 1.0;

            for (var i = 0, len = positions.length; i < len; i += 3) {
                positions[i] *= scaleX;
                positions[i + 1] *= scaleY;
                positions[i + 2] *= scaleZ;
            }
        }

        if (options.origin) {

            var originX = options.origin.x != undefined ? options.origin.x : 0.0;
            var originY = options.origin.y != undefined ? options.origin.y : 0.0;
            var originZ = options.origin.z != undefined ? options.origin.z : 0.0;

            for (var i = 0, len = positions.length; i < len; i += 3) {
                positions[i] -= originX;
                positions[i + 1] -= originY;
                positions[i + 2] -= originZ;
            }
        }

        return positions;
    };

    function getContextRestoredCallback(node) {
        return function () {

            // Ensure that we recreate these in subsequent calls to
            // core.getTangents and core.getPickPositions
            node._core.tangentBufs = null;
            node._core.pickPositionsBuf = null;

            if (node._core.arrays.tangents) {
                node._core.arrays.tangents = [];
            }

            node._buildNodeCore(node._engine.canvas.gl, node._core);
        }
    }

    /**
     * Destroy vertex buffers associated with given core
     */
    var destroyBuffers = function (core) {
        if (core.vertexBuf) {
            core.vertexBuf.destroy();
            core.vertexBuf = null;
        }

        if (core.normalBuf) {
            core.normalBuf.destroy();
            core.normalBuf = null;
        }

        if (core.uvBufs) {
            var uvBufs = core.uvBufs;
            var uvBuf;
            for (var i = 0, len = uvBufs.length; i < len; i++) {
                uvBuf = uvBufs[i];
                if (uvBuf) {
                    uvBuf.destroy();
                }
            }
            core.uvBufs = null;
        }

        if (core.colorBuf) {
            core.colorBuf.destroy();
            core.colorBuf = null;
        }

        if (core.pointScaleRotationBuf) {
            core.pointScaleRotationBuf.destroy();
            core.pointScaleRotationBuf = null;
        }

        if (core.pointUVTranslateBuf) {
            core.pointUVTranslateBuf.destroy();
            core.pointUVTranslateBuf = null;
        }

        if (core.tangentBufs) {
            var tangentBufs = core.tangentBufs;
            var tangentBuf;
            for (var j = 0, lenj = tangentBufs.length; j < lenj; j++) {
                tangentBuf = tangentBufs[j];
                if (tangentBuf) {
                    tangentBuf.destroy();
                }
            }
            core.tangentBufs = null;
        }

        if (core.indexBuf) {
            core.indexBuf.destroy();
            core.indexBuf = null;
        }
    };

    /**
     * Allocates WebGL buffers for geometry arrays
     *
     * In addition to initially allocating those, this is called to reallocate them after
     * WebGL context is regained after being lost.
     */
    SceneJS.Geometry.prototype._buildNodeCore = function (gl, core) {

        try { // TODO: Modify usage flags in accordance with how often geometry is evicted
            buildCore(gl, core);
        } catch (e) { // Allocation failure - delete whatever buffers got allocated
            destroyBuffers(core);
            SceneJS_error.fatalError(
                SceneJS.errors.ERROR,
                "Failed to allocate geometry: " + e);
        }
    };

    SceneJS.Geometry.prototype._updateArray = function (array, items, offset) {

        var arrayLen = array.length;
        var itemsLen = items.length;

        if (itemsLen + offset > arrayLen) {
            itemsLen -= (itemsLen + offset) - arrayLen;
        }

        for (var i = offset, j = 0; j < itemsLen; i++, j++) {
            array[i] = items[j];
        }

    };

    /** Builds normal vectors from positions and indices
     * @private
     */
    SceneJS.Geometry.prototype._buildNormals = function (data) {

        var positions = data.positions;
        var indices = data.indices;
        var nvecs = new Array(positions.length / 3);
        var j0;
        var j1;
        var j2;
        var v1;
        var v2;
        var v3;

        for (var i = 0, len = indices.length - 3; i < len; i += 3) {
            j0 = indices[i + 0];
            j1 = indices[i + 1];
            j2 = indices[i + 2];

            v1 = [positions[j0 * 3 + 0], positions[j0 * 3 + 1], positions[j0 * 3 + 2]];
            v2 = [positions[j1 * 3 + 0], positions[j1 * 3 + 1], positions[j1 * 3 + 2]];
            v3 = [positions[j2 * 3 + 0], positions[j2 * 3 + 1], positions[j2 * 3 + 2]];

            v2 = vec4.subtract(vec4.create(), v2, v1);
            v3 = vec4.subtract(vec4.create(), v3, v1);

            var n = vec4.normalize(vec4.create(), SceneJS_math_cross3Vec4(v2, v3, [0, 0, 0, 0]));

            if (!nvecs[j0]) nvecs[j0] = [];
            if (!nvecs[j1]) nvecs[j1] = [];
            if (!nvecs[j2]) nvecs[j2] = [];

            nvecs[j0].push(n);
            nvecs[j1].push(n);
            nvecs[j2].push(n);
        }

        var normals = new Float32Array(positions.length);

        // now go through and average out everything
        for (var i = 0, len = nvecs.length; i < len; i++) {
            var nvec = nvecs[i];
            if (!nvec) {
                continue;
            }
            var count = nvec.length;
            var x = 0;
            var y = 0;
            var z = 0;
            for (var j = 0; j < count; j++) {
                x += nvec[j][0];
                y += nvec[j][1];
                z += nvec[j][2];
            }
            normals[i * 3 + 0] = (x / count);
            normals[i * 3 + 1] = (y / count);
            normals[i * 3 + 2] = (z / count);
        }

        data.normals = normals;
        this._engine.stats.memory.normals += normals.length / 3;
    };

    SceneJS.Geometry.prototype.setSource = function (sourceConfigs) {
        this._sourceConfigs = sourceConfigs;
        var source = this._source;
        if (source && source.configure) {
            source.configure(sourceConfigs);
        }
    };

    SceneJS.Geometry.prototype.getSource = function () {
        return this._sourceConfigs || {};
    };

    SceneJS.Geometry.prototype.getBackfaces = function () {
        return this.backfaces;
    };

    SceneJS.Geometry.prototype.setBackfaces = function (bf) {
        this.backfaces = bf;
        var object = this.getObject();
        if (object) {
            object.backfaces = bf;
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Geometry.prototype.getAddBlend = function () {
        return this.addBlend;
    };

    SceneJS.Geometry.prototype.setAddBlend = function (ab) {
        this.addBlend = ab;
        var object = this.getObject();
        if (object) {
            object.addBlend = ab;
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Geometry.prototype.getLayer = function () {
        return this.layer;
    };

    SceneJS.Geometry.prototype.setLayer = function (l) {
        this.layer = l;
        var object = this.getObject();
        if (object) {
            object.layer = l;
        }
        this._engine.display.objectListDirty = true;
    };

    SceneJS.Geometry.prototype.setPositions = function (positions) {
        if (positions && this._core.vertexBuf) {
            this._boundaryDirty = true;
            var core = this._core;
            core.vertexBuf.bind();
            core.vertexBuf.setData(positions);
            core.arrays.positions.set(positions);
            core.kdTreeDirty = true;
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getPositions = function () {
        return this._core.arrays ? this._core.arrays.positions : null;
    };

    SceneJS.Geometry.prototype.getPositionDecodeMat = function () {
        return this._core.positionDecodeMat || null;
    };

    SceneJS.Geometry.prototype.setNormals = function (normals) {
        if (normals && this._core.normalBuf) {
            var core = this._core;
            core.normalBuf.bind();
            core.normalBuf.setData(normals);
            core.arrays.normals.set(normals);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getNormals = function () {
        return this._core.arrays ? this._core.arrays.normals : null;
    };

    SceneJS.Geometry.prototype.setColors = function (colors) {
        if (colors && this._core.colorBuf) {
            var core = this._core;
            core.colorBuf.bind();
            core.colorBuf.setData(colors);
            core.arrays.colors.set(colors);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getColors = function () {
        return this._core.arrays ? this._core.arrays.colors : null;
    };

    SceneJS.Geometry.prototype.setIndices = function (indices) {
        if (indices && this._core.indexBuf) {
            this._boundaryDirty = true;
            var core = this._core;
            core.indexBuf.bind();

            // Make sure indices remain of the same type.
            if (indices.constructor != core.arrays.indices.constructor) {
                indices = new core.arrays.indices.constructor(indices);
            }
            core.indexBuf.setData(indices);
            core.arrays.indices.set(indices);
            core.kdTreeDirty = true;
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getIndices = function () {
        return this._core.arrays ? this._core.arrays.indices : null;
    };

    SceneJS.Geometry.prototype.getUVs = function () {
        return this._core.arrays ? this._core.arrays.uvs : null;
    };

    SceneJS.Geometry.prototype.getUV = function () {
        return this._core.arrays ? this._core.arrays.uvs[0] : null;
    };

    SceneJS.Geometry.prototype.getUVDecodeMat = function (i) {
        return this._core.uvDecodeMats[i || 0] || null;
    };

    SceneJS.Geometry.prototype.getUV2 = function () {
        return this._core.arrays ? this._core.arrays.uvs[1] : null;
    };

    SceneJS.Geometry.prototype.getUV2 = function () {
        return this._core.arrays ? this._core.arrays.uvs[2] : null;
    };

    SceneJS.Geometry.prototype.getUv3 = function () {
        return this._core.arrays ? this._core.arrays.uvs[3] : null;
    };

    SceneJS.Geometry.prototype.setUV = function (i, data) {
        if (data && this._core.uvBufs && this._core.uvBufs[i]) {
            var core = this._core;
            core.uvBufs[i].bind();
            core.uvBufs[i].setData(data);
            core.arrays.uvs[i].set(data);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.hasCompressedPositions = function () {
        return !!this._core.compressedPositions;
    };

    SceneJS.Geometry.prototype.hasCompressedNormals = function () {
        return !!this._core.compressedNormals;
    };

    SceneJS.Geometry.prototype.hasCompressedUVs = function () {
        return !!this._core.compressedUVs;
    };

    SceneJS.Geometry.prototype.getPrimitive = function () {
        return this.primitive;
    };

    SceneJS.Geometry.prototype.getPointSize = function () {
        return this._core.pointSize;
    };

    SceneJS.Geometry.prototype.setPointSize = function (size) {
        if (size && this._core.pointSize !== size) {
            this._core.pointSize = size;
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getPointUVScale = function () {
        return this._core.pointUVScale;
    };

    SceneJS.Geometry.prototype.setPointUVScale = function (uvScale) {
        if (uvScale && this._core.pointUVScale !== uvScale) {
            this._core.pointUVScale = uvScale;
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.setPointScaleRotations = function (pointScaleRotations) {
        if (pointScaleRotations && this._core.pointScaleRotationBuf) {
            var core = this._core;
            core.pointScaleRotationBuf.bind();
            core.pointScaleRotationBuf.setData(pointScaleRotations);
            core.arrays.pointScaleRotations.set(pointScaleRotations);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getPointScaleRotations = function () {
        return this._core.arrays ? this._core.arrays.pointScaleRotations : null;
    };

    SceneJS.Geometry.prototype.setPointUVTranslates = function (pointUVTranslates) {
        if (pointUVTranslates && this._core.pointUVTranslateBuf) {
            var core = this._core;
            core.pointUVTranslateBuf.bind();
            core.pointUVTranslateBuf.setData(pointUVTranslates);
            core.arrays.pointUVTranslates.set(pointUVTranslates);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getPointUVTranslates = function () {
        return this._core.arrays ? this._core.arrays.pointUVTranslates : null;
    };

    SceneJS.Geometry.prototype.getKdTree = function () {
        var object = this.getObject();
        if (object) {
            return object.getKdTree();
        } else {
            return this._core.getKdTree();
        }
    };

    SceneJS.Geometry.prototype.getObject = function() {
        return this._engine.display._objects[this.id] || null;
    };

    /** Returns the Model-space boundary of this geometry
     *
     * @returns {*}
     */
    SceneJS.Geometry.prototype.getBoundary = function () {
        if (!this._boundaryDirty) {
            return this._boundary;
        }

        var arrays = this._core.arrays;

        if (!arrays) {
            return null;
        }

        var positions = arrays.positions;

        if (!positions) {
            return null;
        }

        this._boundary.xmin = Number.POSITIVE_INFINITY;
        this._boundary.ymin = Number.POSITIVE_INFINITY;
        this._boundary.zmin = Number.POSITIVE_INFINITY;
        this._boundary.xmax = Number.NEGATIVE_INFINITY;
        this._boundary.ymax = Number.NEGATIVE_INFINITY;
        this._boundary.zmax = Number.NEGATIVE_INFINITY;

        var x, y, z;

        for (var i = 0, len = positions.length - 2; i < len; i += 3) {

            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];

            if (x < this._boundary.xmin) {
                this._boundary.xmin = x;
            }
            if (y < this._boundary.ymin) {
                this._boundary.ymin = y;
            }
            if (z < this._boundary.zmin) {
                this._boundary.zmin = z;
            }
            if (x > this._boundary.xmax) {
                this._boundary.xmax = x;
            }
            if (y > this._boundary.ymax) {
                this._boundary.ymax = y;
            }
            if (z > this._boundary.zmax) {
                this._boundary.zmax = z;
            }
        }

        this._boundaryDirty = false;

        return this._boundary;
    };

    SceneJS.Geometry.prototype._compile = function (ctx) {

        if (this._core._loading) { // TODO: Breaks with asynch loaded cores - this node needs to recompile when target core is loaded
            this._compileNodes(ctx);
            return;
        }

        var core = this._core;

        var parts = [                           // Safe to build geometry hash here - geometry is immutable
            core.normalBuf ? "t" : "f",
            core.arrays && core.arrays.tangents ? "t" : "f",
            core.colorBuf ? "t" : "f",
            core.primitive,
            core.compressedPositions ? "t" : "f",
            core.compressedNormals ? "t" : "f",
            core.compressedUVs ? "t" : "f",
            core.pointScaleRotationBuf ? "t" : "f",
            core.pointUVTranslateBuf ? "t" : "f"
        ];

        // Hash parts for UVs

        parts.push(";uvs");
        var uvBufs = core.uvBufs;
        if (uvBufs) {
            for (var i = 0, len = uvBufs.length; i < len; i++) {
                parts.push(uvBufs[i] ? "t" : "f");
            }
        }

        core.hash = parts.join("");

        core.stateId = this._core.stateId;
        core.type = "geometry";

        this._engine.display.geometry = core;

        SceneJS_events.fireEvent(SceneJS_events.OBJECT_COMPILING, { // Pull in state updates from scenes nodes
            display: this._engine.display
        });

        this._engine.display.buildObject(this.id, { backfaces: this.backfaces, addBlend: this.addBlend, layer: this.layer } );

        if (this.onObjectCreate) {
            this.onObjectCreate(this.getObject());
        }

        this._compileNodes(ctx);
    };

    SceneJS.Geometry.prototype._destroy = function () {

        this._engine.display.removeObject(this.id);

        /* Destroy core if no other references
         */
        if (this._core.useCount == 1) {

            this._destroyNodeCore();

            if (this._source && this._source.destroy) {
                this._source.destroy();
            }

            this._engine.stats.geometry.meshes--;
        }
    };

    SceneJS.Geometry.prototype._disconnectFromScene = function () {
        this._engine.display.removeObject(this.id);
    };


    SceneJS.Geometry.prototype._destroyNodeCore = function () {

        if (document.getElementById(this._engine.canvas.canvasId)) { // Context won't exist if canvas has disappeared
            destroyBuffers(this._core);
        }

        var arrays = this._core.arrays;

        if (arrays.positions) {
            this._engine.stats.memory.positions -= arrays.positions.length / 3;
        }
        if (arrays.normals) {
            this._engine.stats.memory.normals -= arrays.normals.length / 3;
        }
        if (arrays.colors) {
            this._engine.stats.memory.colors -= arrays.colors.length / 3;
        }
        if (arrays.uvs && arrays.uvs.length > 0) {
            this._engine.stats.memory.uvs -= arrays.uvs.length * (arrays.uvs[0].length / 2);
        }
        if (arrays.indices) {
            this._engine.stats.memory.indices -= arrays.indices.length;
        }
        if (arrays.pointScaleRotations) {
            this._engine.stats.memory.pointScaleRotations -= arrays.pointScaleRotations.length / 2;
        }
        if (arrays.pointUVTranslates) {
            this._engine.stats.memory.pointUVTranslates -= arrays.pointUVTranslates.length / 2;
        }
    };

    function buildCore(gl, core) {
        var usage = gl.STATIC_DRAW;
        var arrays = core.arrays;
        var compressed = core.compressedPositions || core.compressedNormals || core.compressedUVs;
        var dataLength = 0;

        core.transparent = !!arrays.colors;

        if (arrays.positions) {
            core.vertexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.positions, arrays.positions.length, 3, usage);
        }

        if (core.compressedNormals) {
            // Note: Oct-encoded normal buffer has to be normalized.
            core.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.normals, arrays.normals.length, 2, usage, true);
        } else if (arrays.normals) {
            core.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.normals, arrays.normals.length, 3, usage);
        }

        if (arrays.uvs) {

            var uvs = arrays.uvs;
            var offsets;
            var i;
            var len;
            var uv;

            core.uvBufs = [];

            for (i = 0, len = uvs.length; i < len; i++) {
                uv = arrays.uvs[i];
                if (uv.length > 0) {
                    core.uvBufs.push(new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, usage));
                }
            }
        }

        if (arrays.colors) {
            core.colorBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.colors, arrays.colors.length, 4, usage, true);
        }

        if (arrays.indices) {
            core.indexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, arrays.indices, arrays.indices.length, 1, usage);
        }

        if (arrays.pointScaleRotations) {
            core.pointScaleRotationBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.pointScaleRotations, arrays.pointScaleRotations.length, 2, usage, true);
        }

        if (arrays.pointUVTranslates) {
            core.pointUVTranslateBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.pointUVTranslates, arrays.pointUVTranslates.length, 2, usage, true);
        }
    }

})();
;/**
 * @class Scene graph node which assigns nodes in its subgraph to a library
 * @extends SceneJS.Node
 */
(function () {
    "use strict";
    
    SceneJS.Library = SceneJS_NodeFactory.createNodeType("library");
    SceneJS.Library.prototype._compile = function(ctx) { // Bypass child nodes
    };
})();



;/*

 TODO: material system from virtualworldframework:

 "color":
 "ambient":
 "specColor":
 "shininess":
 "reflect":
 "specular":
 "emit":
 "alpha":
 "binaryAlpha":
 */
(function () {
    "use strict";
        
    /**
     * @class Scene graph node which defines surface material properties for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Material = SceneJS_NodeFactory.createNodeType("material");

    /**
     * Blinn-Phong workflow ID.
     */
    SceneJS.Material.PHONG = 0;

    /**
     * Metallic-roughness workflow ID.
     */
    SceneJS.Material.METALLIC = 1;

    /**
     * The default state core singleton for {@link SceneJS.Material} nodes
     */
    var defaultCore = {
        type:"material",

        stateId:SceneJS._baseStateId++,

        workflow: SceneJS.Material.PHONG,

        baseColor:new Float32Array([ 1.0, 1.0, 1.0, 1.0 ]), // phong & metalRough
        specularColor:new Float32Array([ 1.0, 1.0, 1.0, 1.0 ]), // phong
        emitColor:new Float32Array([ 1.0, 1.0, 1.0, 0.0 ]), // phong & metalRough
        shine:70.0, // phong
        metalRoughspecularf0: new Float32Array([ 1.0, 1.0, 0.1, 0.0 ]) // Packed metalRough params: metallic, roughness and specularf0
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.material = defaultCore;
            stackLen = 0;
        });

    SceneJS.Material.prototype._init = function (params) {
        if (this._core.useCount == 1) {
            this._core.baseColor = new Float32Array(defaultCore.baseColor);
            this._core.specularColor = new Float32Array(defaultCore.specularColor);
            this._core.emitColor = new Float32Array(defaultCore.emitColor);
            this._core.shine = defaultCore.shine;
            this._core.metalRoughspecularf0 = new Float32Array(defaultCore.metalRoughspecularf0);
            if (params.color || params.baseColor) {
                this.setBaseColor(params.color || params.baseColor);
            }
            if (params.specularColor) {
                this.setSpecularColor(params.specularColor);
            }
            if (params.emitColor) {
                this.setEmitColor(params.emitColor);
            }
            if (params.specular != undefined) {
                this.setSpecular(params.specular);
            }
            if (params.shine != undefined) {
                this.setShine(params.shine);
            }
            if (params.emit != undefined) {
                this.setEmit(params.emit);
            }
            if (params.alpha != undefined) {
                this.setAlpha(params.alpha);
            }
            if (params.metallic != undefined) {
                this.setMetallic(params.metallic);
            }
            if (params.roughness != undefined) {
                this.setRoughness(params.roughness);
            }
            if (params.specularf0 != undefined) {
                this.setspecularf0(params.specularf0);
            }
            this.setWorkflow(params.workflow);
        }
    };

    SceneJS.Material.prototype.setWorkflow = function (workflow) {
        workflow = workflow || "phong";
        if (workflow === "phong") {
            this._core.workflow = SceneJS.Material.PHONG;
        } else if (workflow === "metallic") {
            this._core.workflow = SceneJS.Material.METALLIC;
        } else {
            console.error("Unsupported SceneJS material workflow: " + workflow);
            this._core.workflow = SceneJS.Material.PHONG;
        }
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getWorkflow = function () {
        switch (this._core.workflow) {
            case  SceneJS.Material.PHONG:
                return "phong";
            case  SceneJS.Material.METALLIC:
                return "metallic";
        }
    };

    /**
     * @deprecated
     * @param color
     * @return {*}
     */
    SceneJS.Material.prototype.setBaseColor = function (color) {
        var defaultBaseColor = defaultCore.baseColor;
        this._core.baseColor[0] = color.r != undefined ? color.r : defaultBaseColor[0];
        this._core.baseColor[1] = color.g != undefined ? color.g : defaultBaseColor[1];
        this._core.baseColor[2] = color.b != undefined ? color.b : defaultBaseColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.setColor = SceneJS.Material.prototype.setBaseColor;

    /**
     * @deprecated
     * @return {Object}
     */
    SceneJS.Material.prototype.getBaseColor = function () {
        return {
            r:this._core.baseColor[0],
            g:this._core.baseColor[1],
            b:this._core.baseColor[2]
        };
    };

    SceneJS.Material.prototype.getColor = SceneJS.Material.prototype.getBaseColor;

    SceneJS.Material.prototype.setSpecularColor = function (color) {
        var defaultSpecularColor = defaultCore.specularColor;
        this._core.specularColor[0] = color.r != undefined ? color.r : defaultSpecularColor[0];
        this._core.specularColor[1] = color.g != undefined ? color.g : defaultSpecularColor[1];
        this._core.specularColor[2] = color.b != undefined ? color.b : defaultSpecularColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getSpecularColor = function () {
        return {
            r:this._core.specularColor[0],
            g:this._core.specularColor[1],
            b:this._core.specularColor[2]
        };
    };

    SceneJS.Material.prototype.setEmitColor = function (color) {
        var defaultEmitColor = defaultCore.emitColor;
        this._core.emitColor[0] = color.r != undefined ? color.r : defaultEmitColor[0];
        this._core.emitColor[1] = color.g != undefined ? color.g : defaultEmitColor[1];
        this._core.emitColor[2] = color.b != undefined ? color.b : defaultEmitColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getEmitColor = function () {
        return {
            r:this._core.emitColor[0],
            g:this._core.emitColor[1],
            b:this._core.emitColor[2]
        };
    };

    SceneJS.Material.prototype.setSpecular = function (specular) {
        this._core.specularColor[3] = (specular != undefined && specular != null) ? specular : defaultCore.specularColor[3];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getSpecular = function () {
        return this._core.specularColor[3];
    };

    SceneJS.Material.prototype.setShine = function (shine) {
        this._core.shine = (shine != undefined) ? shine : defaultCore.shine;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getShine = function () {
        return this._core.shine;
    };

    SceneJS.Material.prototype.setEmit = function (emit) {
        this._core.emitColor[3] = (emit != undefined) ? emit : defaultCore.emitColor[3];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getEmit = function () {
        return this._core.emitColor[3];
    };

    SceneJS.Material.prototype.setAlpha = function (alpha) {
        var wasTrasparent = this._core.baseColor[3] < 1;
        this._core.baseColor[3] = (alpha != undefined) ? alpha : defaultCore.baseColor[3];
        this._core.transparent = this._core.baseColor[3] < 1;
        this._engine.display.imageDirty = true;

        if (wasTrasparent !== this._core.transparent) {
            this._engine.display.objectListDirty = true;
        }

        return this;
    };

    SceneJS.Material.prototype.getAlpha = function () {
        return this._core.baseColor[3];
    };

    SceneJS.Material.prototype.setMetallic = function (metallic) {
        this._core.metalRoughspecularf0[0] = (metallic != undefined) ? metallic : defaultCore.metalRoughspecularf0[0];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getMetallic = function () {
        return this._core.metalRoughspecularf0[0];
    };

    SceneJS.Material.prototype.setRoughness = function (roughness) {
        this._core.metalRoughspecularf0[1] = (roughness != undefined) ? roughness : defaultCore.metalRoughspecularf0[1];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getRoughness = function () {
        return this._core.metalRoughspecularf0[1];
    };

    SceneJS.Material.prototype.setspecularf0 = function (specularf0) {
        this._core.metalRoughspecularf0[2] = (specularf0 != undefined) ? specularf0 : defaultCore.metalRoughspecularf0[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getspecularf0 = function () {
        return this._core.metalRoughspecularf0[2];
    };

    SceneJS.Material.prototype._compile = function (ctx) {
        this._engine.display.material = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.material = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();
;(function () {
    "use strict";
    
    var KD_TREE_MAX_DEPTH = SceneJS.KD_TREE_MAX_DEPTH;
    var KD_TREE_MIN_TRIANGLES = SceneJS.KD_TREE_MIN_TRIANGLES;

    /**
     * The default state core singleton for {@link SceneJS.MorphGeometry} nodes
     */
    var defaultCore = {
        type: "morphGeometry",
        stateId: SceneJS._baseStateId++,
        hash: "",
        //         empty: true,
        morph: null
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.morphGeometry = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines morphing behaviour for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.MorphGeometry = SceneJS_NodeFactory.createNodeType("morphGeometry");

    SceneJS.MorphGeometry.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the resource

            this._pickPositionsDirty = true;

            this._buildNodeCore(params);

            this._core.webglRestored = function () {
                //self._buildNodeCore(self._engine.canvas.gl, self._core);
            };

            var self = this;

            // For the morph target at the given index,
            // returns a positions VBO for triangle-picking,
            // lazy-generated from the given indices if not yet existing.

            this._core.getPickPositions = function (index, indices) {
                if (self._pickPositionsDirty) {
                    self._buildPickPositions(indices);
                }
                return self._core.targets[index].pickPositionsBuf;
            };

            // For the morph target at the given index,
            // returns tangents for normal mapping
            // lazy-generated from the given indices if not yet existing.

            this._core.getTangents = function (index, indices, uv, positionDecodeMat, uvDecodeMat) {
                var core = self._core;
                var target = core.targets[index];
                if (target.tangentBuf) {
                    return target.tangentBuf;
                }
                var positions = target.positions;
                var positionDecodeMat = target.positionDecodeMat || positionDecodeMat;
                uv = target.uv || uv;
                if (positions && indices && uv) {
                    var gl = self._engine.canvas.gl;
                    var tangents = SceneJS_math_buildTangents(positions, indices, uv, positionDecodeMat, uvDecodeMat);
                    target.tangents = tangents;
                    var usage = gl.STATIC_DRAW;
                    target.tangentBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, tangents, tangents.length, 3, usage);
                    return target.tangentBuf;
                }
            };

            this.setFactor(params.factor);
        }

        this._core.factor = params.factor || 0;
        this._core.clamp = !!params.clamp;
    };

    SceneJS.MorphGeometry.prototype._buildNodeCore = function (data) {

        try {
            buildCore(this, data);
        } catch (e) {

            /* Allocation failure - deallocate target VBOs
             */
            for (var i = 0, len = this._core.targets.length; i < len; i++) {

                target = core.targets[i];

                if (target.vertexBuf) {
                    target.vertexBuf.destroy();
                }
                if (target.normalBuf) {
                    target.normalBuf.destroy();
                }
                if (target.uvBuf) {
                    target.uvBuf.destroy();
                }
                if (target.uvBuf2) {
                    target.uvBuf2.destroy();
                }
            }

            SceneJS_error.fatalError(
                SceneJS.errors.ERROR,
                "Failed to allocate VBO(s) for morphGeometry: " + e);
        }

    };

    SceneJS.MorphGeometry.prototype._buildPickPositions = function (indices) {

        var core = this._core;
        var target = null;
        var pickPositions;
        var gl = this._engine.canvas.gl;
        var usage = gl.STATIC_DRAW;

        // On each morph target, build a positions array for
        // color-indexed triangle-picking.

        for (var i = 0, len = core.targets.length; i < len; i++) {

            target = core.targets[i];

            if (target.positions) {

                if (target.pickPositionsBuf) {
                    target.pickPositionsBuf.destroy();
                    target.pickPositionsBuf = null;
                }

                pickPositions = SceneJS_math_getPickPositions(target.positions, indices);

                target.pickPositionsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickPositions, pickPositions.length, 3, usage);
            }
        }

        this._pickPositionsDirty = false;
    };

    SceneJS.MorphGeometry.prototype.setFactor = function (factor) {
        factor = factor || 0.0;

        var core = this._core;

        var keys = core.keys;
        var key1 = core.key1;
        var key2 = core.key2;

        var oldFactor = core.factor;

        if (factor < keys[0]) {
            key1 = 0;
            key2 = 1;

        } else if (factor > keys[keys.length - 1]) {
            key1 = keys.length - 2;
            key2 = key1 + 1;

        } else {
            while (keys[key1] > factor) {
                key1--;
                key2--;
            }
            while (keys[key2] < factor) {
                key1++;
                key2++;
            }
        }

        var frameUpdate = key1 != core.key1;

        /* Normalise factor to range [0.0..1.0] for the target frame
         */
        core.factor = (factor - keys[key1]) / (keys[key2] - keys[key1]);

        this._factor = factor;

        var morphUpdate = frameUpdate || oldFactor != core.factor;

        core.key1 = key1;
        core.key2 = key2;

        if (morphUpdate) {
            var currentFrame = this.getCurrentFrame();
            if (this.onUpdate) {
                this.onUpdate(currentFrame);
            }
            if (frameUpdate && this.onFrameUpdate) {
                this.onFrameUpdate(currentFrame);
            }
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.MorphGeometry.prototype.getFactor = function () {
        return this._factor;
    };

    SceneJS.MorphGeometry.prototype.getKeys = function () {
        return this._core.keys;
    };

    SceneJS.MorphGeometry.prototype.getTargets = function () {
        return this._core.targets;
    };

    SceneJS.MorphGeometry.prototype.getCurrentFrame = function () {
        var core = this._core;
        var key1 = core.key1;
        var key2 = core.key2;
        return {
            key1: key1,
            key2: key2,
            factor: core.factor,
            target1: core.targets[key1],
            target2: core.targets[key2]
        }
    };

    SceneJS.MorphGeometry.prototype._compile = function (ctx) {

        if (!this._core.hash) {
            this._makeHash();
        }

        this._engine.display.morphGeometry = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.morphGeometry = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.MorphGeometry.prototype._makeHash = function () {
        var core = this._core;
        if (core.targets.length > 0) {
            var target0 = core.targets[0];  // All targets have same arrays
            var t = "t";
            var f = "f";
            core.hash = ([
                target0.vertexBuf ? t : f,
                target0.normalBuf ? t : f,
                target0.uvBuf ? t : f,
                target0.uvBuf2 ? t : f
            ]).join("");
        } else {
            core.hash = "";
        }
    };

    SceneJS.MorphGeometry.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Destroy core if no other references
            if (document.getElementById(this._engine.canvas.canvasId)) { // Context won't exist if canvas has disappeared
                var core = this._core;
                var target;
                for (var i = 0, len = core.targets.length; i < len; i++) {
                    target = core.targets[i];
                    if (target.vertexBuf) {
                        target.vertexBuf.destroy();
                    }
                    if (target.pickPositionsBuf) {
                        target.pickPositionsBuf.destroy();
                    }
                    if (target.normalBuf) {
                        target.normalBuf.destroy();
                    }
                    if (target.uvBuf) {
                        target.uvBuf.destroy();
                    }
                    if (target.uvBuf2) {
                        target.uvBuf2.destroy();
                    }
                }
            }
        }
    };

    function buildCore(node, data) {
        var targetsData = data.targets || [];
        if (targetsData.length < 2) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "morphGeometry node should have at least two targets");
        }

        var keysData = data.keys || [];
        if (keysData.length != targetsData.length) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "morphGeometry node mismatch in number of keys and targets");
        }

        var core = node._core;
        var gl = node._engine.canvas.gl;
        var usage = gl.STATIC_DRAW; //var usage = (!arrays.fixed) ? gl.STREAM_DRAW : gl.STATIC_DRAW;

        core.keys = keysData;
        core.targets = [];
        core.key1 = 0;
        core.key2 = 1;

        /* First target's arrays are defaults for where not given on previous and subsequent targets.
         * When target does have array, subsequent targets without array inherit it.
         */

        var positions;
        var normals;
        var uv;
        var uv2;

        var targetData;

        for (var i = 0, len = targetsData.length; i < len; i++) {
            targetData = targetsData[i];

            if (!positions && targetData.positions) {
                positions = targetData.positions;
            }
            if (!normals && targetData.normals) {
                normals = targetData.normals;
            }
            if (!uv && targetData.uv) {
                uv = targetData.uv;
            }
            if (!uv2 && targetData.uv2) {
                uv2 = targetData.uv2;
            }
        }

        var target;
        var arry;

        for (var i = 0, len = targetsData.length; i < len; i++) {
            targetData = targetsData[i];
            target = {};

            arry = targetData.positions || positions;
            if (arry) {
                if (targetData.positionDecodeMat) {
                    target.positions = arry;
                    target.positionDecodeMat = targetData.positionDecodeMat;
                    core.compressedPositions = true;
                } else {
                    target.positions = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                }

                target.vertexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.positions, arry.length, 3, usage);

                positions = arry;
                node._engine.stats.memory.morphPositions += target.positions.length * target.positions.constructor.BYTES_PER_ELEMENT;
            }

            arry = targetData.normals || normals;
            if (arry) {
                if (arry.constructor == Int8Array) {
                    target.normals = arry;
                    core.compressedNormals = true;
                    target.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.normals, arry.length, 2, usage, true);
                } else {
                    target.normals = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                    target.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.normals, arry.length, 3, usage);
                }
                normals = arry;
                node._engine.stats.memory.morphNormals += target.normals.length * target.normals.constructor.BYTES_PER_ELEMENT;
            }

            arry = targetData.uv || uv;
            if (arry) {
                target.uv = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.uvBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.uv, arry.length, 2, usage);
                uv = arry;
            }

            arry = targetData.uv2 || uv2;
            if (arry) {
                target.uv2 = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.uvBuf2 = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.uv2, arry.length, 2, usage);
                uv2 = arry;
            }

            core.targets.push(target);  // We'll iterate this to destroy targets when we recover from error
        }

        core.kdTree = null;
        core.kdTreeDirty = true;

        core.getKdTree = function (indices) {
            if (!this.kdTreeDirty) {
                return this.kdTree;
            }

            var numTris = indices.length / 3;
            var triangles = new Array(numTris);
            for (var i = 0; i < numTris; ++i) {
                triangles[i] = i;
            }
            this.kdTree = buildKdTreeNode(triangles, indices, this.targets, 0, 0);
            this.kdTreeDirty = false;

            return this.kdTree;
        };

        node._pickPositionsDirty = true;
    }

    var position1 = vec3.create();
    var position2 = vec3.create();
    var position = vec3.create();

    function buildKdTreeNode(triangles, indices, targets, dim, depth) {
        var min = vec3.create();
        var max = vec3.create();

        var node = {
            triangles: null,
            left: null,
            right: null,
            bb: {
                min: min,
                max: max
            }
        };

        min[0] = min[1] = min[2] = Number.POSITIVE_INFINITY;
        max[0] = max[1] = max[2] = Number.NEGATIVE_INFINITY;

        var t, len;
        var numTargets = targets.length;
        
        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;

            for (var j = 0; j < 3; ++j) {
                var pi = indices[ii + j] * 3;

                for (var k = 0; k < numTargets; ++k) {
                    var positions = targets[k].positions;
                    var decompress = targets[k].positionDecodeMat;

                    position[0] = positions[pi];
                    position[1] = positions[pi + 1];
                    position[2] = positions[pi + 2];

                    if (decompress) {
                        SceneJS_math_decompressPosition(position, position, decompress);
                    }

                    if (position[0] < min[0]) {
                        min[0] = position[0]
                    } 

                    if (position[0] > max[0]) {
                        max[0] = position[0]
                    }

                    if (position[1] < min[1]) {
                        min[1] = position[1]
                    } 

                    if (position[1] > max[1]) {
                        max[1] = position[1]
                    }

                    if (position[2] < min[2]) {
                        min[2] = position[2]
                    } 

                    if (position[2] > max[2]) {
                        max[2] = position[2]
                    }
                }
            }
        }

        if (depth > KD_TREE_MAX_DEPTH) {
            node.triangles = triangles;
            return node;
        }

        var mid = (min[dim] + max[dim]) / 2;
        var left = new Array(triangles.length);
        var numLeft = 0;
        var right = new Array(triangles.length);
        var numRight = 0;

        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;
            var i0 = indices[ii];
            var i1 = indices[ii + 1];
            var i2 = indices[ii + 2];

            var pi0 = i0 * 3;
            var pi1 = i1 * 3;
            var pi2 = i2 * 3;

            var splitRight = true;

            for (var k = 0; k < numTargets; ++k) {
                var positions = targets[k].positions;
                var decompress = targets[k].positionDecodeMat;

                var v1 = positions[pi0 + dim];
                var v2 = positions[pi1 + dim];
                var v3 = positions[pi2 + dim];

                if (decompress) {
                    var scale = decompress[dim * 5];
                    var translate = decompress[dim + 12]
                    v1 = v1 * scale + translate;
                    v2 = v2 * scale + translate;
                    v3 = v3 * scale + translate;
                }

                if (v1 < mid || v2 < mid || v3 < mid) {
                    splitRight = false;
                    break; 
                }
            }

            if (splitRight) {
                right[numRight++] = triangles[t];
            } else {
                left[numLeft++] = triangles[t];
            }
        }

        if (numLeft < KD_TREE_MIN_TRIANGLES || numRight < KD_TREE_MIN_TRIANGLES ) {
            node.triangles = triangles;
            return node;
        }

        left.length = numLeft;
        right.length = numRight;

        node.left = buildKdTreeNode(left, indices, targets, (dim + 1) % 3, depth + 1);
        node.right = buildKdTreeNode(right, indices, targets, (dim + 1) % 3, depth + 1);

        return node;
    }
})();
;/**
 * @class The root node of a scenegraph
 * @extends SceneJS.Node
 *
 */

(function () {
    "use strict";

    SceneJS.Scene = SceneJS_NodeFactory.createNodeType("scene");

    SceneJS.Scene.prototype._init = function (params) {

        /**
         * Set false when canvas is to be transparent.
         * @type {boolean}
         */
        this.transparent = (params.transparent === true);

        /**
         * Tracks statistics within this engine, such as numbers of
         * scenes, textures, geometries etc.
         *
         * @property stats
         * @type {*}
         * @final
         */
        this.stats = this._engine.stats;

        // Pub/sub support
        this._handleMap = new SceneJS_Map(); // Subscription handle pool
        this._topicSubs = {}; // A [handle -> callback] map for each topic name
        this._handleTopics = {}; // Maps handles to topic names
        this._topicPubs = {}; // Maps topics to publications
    };


    /**
     * Simulate a lost WebGL context for testing purposes.
     * Only works if the simulateWebGLLost was given as an option to {@link SceneJS.createScene}.
     */
    SceneJS.Scene.prototype.loseWebGLContext = function () {
        this._engine.loseWebGLContext();
    };


    /**
     * Returns the HTML canvas for this scene
     * @return {HTMLCanvas} The canvas
     */
    SceneJS.Scene.prototype.getCanvas = function () {
        return this._engine.canvas.canvas;
    };

    SceneJS.Scene.prototype.setTransparencyMode = function (mode) {
        this._engine.display.setTransparencyMode(mode);
        this._engine.branchDirty(this);
    };

    SceneJS.Scene.prototype.setDepthSort = function (sort) {
        this._engine.display.depthSort = sort;
        this._engine.display.objectListDirty = true;
    };

    /**
     * Returns the WebGL context for this scene
     */
    SceneJS.Scene.prototype.getGL = function () {
        return this._engine.canvas.gl;
    };

    SceneJS.Scene.prototype.getGPUTimer = function () {
        return this._engine.gpuTimer;
    };

    SceneJS.Scene.prototype.getGPUTimerQuery = function () {
        return this._engine.gpuTimerQuery;
    };

    /**
     * True if WebGL 2 is supported
     */
    SceneJS.Scene.prototype.getWebGL2Supported = function () {
        return this._engine.canvas.webgl2;
    };

    /** Returns the Z-buffer depth in bits of the webgl context that this scene is to bound to.
     */
    SceneJS.Scene.prototype.getZBufferDepth = function () {
        var gl = this._engine.canvas.gl;
        return gl.getParameter(gl.DEPTH_BITS);
    };

    /**
     * Set canvas size multiplier for supersample anti-aliasing
     */
    SceneJS.Scene.prototype.setResolutionScaling = function (resolutionScaling) {
        return this._engine.canvas.setResolutionScaling(resolutionScaling);
    };

    SceneJS.Scene.prototype.setProjection = function (p) {
        var display = this._engine.display;
        var type = p.type;
        if (!type) {
            if (display.projection) {
                type = display.projection.type;
            }
        }

        type = type || "perspective";
        if (type == "ortho") {
            display.projection = SceneJS._applyIf(SceneJS_math_ORTHO_OBJ, {
                type: type,
                left: p.left,
                bottom: p.bottom,
                near: p.near,
                right: p.right,
                top: p.top,
                far: p.far
            });
        } else if (type == "frustum") {
            display.projection = {
                type: type,
                left: p.left || -1.0,
                bottom: p.bottom || -1.0,
                near: p.near || 0.1,
                right: p.right || 1.00,
                top: p.top || 1.0,
                far: p.far || 10000.0
            };
        } else if (type == "perspective") {
            if (p.fovy != undefined) {
                p.fov = p.fovy;
            }

            display.projection = {
                type: type,
                fov: p.fov || 60.0,
                aspect: p.aspect == undefined ? 1.0 : p.aspect,
                near: p.near || 0.1,
                far: p.far || 10000.0
            };
        }

        display.projection.pan = p.pan;
        display.buildProjectionMatrix();
        display.imageDirty = true;
    };

    SceneJS.Scene.prototype.getProjection = function () {
        return this._engine.display.projection;
    };

    SceneJS.Scene.prototype.setCamera = function (p) {
        var display = this._engine.display;
        if (p.eye) {
            display.camera.eye.set(p.eye);
        }
        if (p.look) {
            display.camera.look.set(p.look);
        }
        if (p.up) {
            display.camera.up.set(p.up);
        }
        if (p.deviceMatrix) {
            display.hasDeviceMatrix = true;
            display.deviceMatrix.set(p.deviceMatrix);
        }
        display.buildViewMatrix();
        display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setLights = function(lights) {
        lights = lights || [];

        var display = this._engine.display;
        display.lights.length = lights.length;
        var hash = "";

        display._ambientColor[0] = 0;
        display._ambientColor[1] = 0;
        display._ambientColor[2] = 0;

        var numLights = 0;
        for (var i = 0, len = lights.length; i < len; ++i) {
            display.lights[numLights] = display.lights[numLights] || {};

            var light = display.lights[numLights];
            var cfg = lights[i];

            var mode = cfg.mode || "dir";
            if (mode != "dir" && mode != "point" && mode != "ambient" && mode != "spot") {
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Light mode not supported - should be 'dir' or 'point' or 'spot' or 'ambient'");
            }

            var pos = cfg.pos;
            var dir = cfg.dir;

            var color = cfg.color;
            light.color = new Float32Array([
                    color.r != undefined ? color.r : 1.0,
                    color.g != undefined ? color.g : 1.0,
                    color.b != undefined ? color.b : 1.0
            ]);

            if (mode === "ambient") {
                display._ambientColor[0] = light.color[0];
                display._ambientColor[1] = light.color[1];
                display._ambientColor[2] = light.color[2];
                continue;
            }

            // Ambient lights hardwired to contribute to diffuse lighting
            light.mode = mode;
            light.diffuse = (mode == "ambient") ? true : ((cfg.diffuse != undefined) ? cfg.diffuse : true);
            light.specular = (mode == "ambient") ? false : ((cfg.specular != undefined) ? cfg.specular : true);
            light.pos = new Float32Array(cfg.pos ? [pos.x || 0, pos.y || 0, pos.z || 0 ] : [0, 0, 0]);
            light.dir = new Float32Array(cfg.dir ? [dir.x || 0, dir.y || 0, dir.z || 0] : [0, 0, 1]);
            light.innerCone = cfg.innerCone != undefined ? cfg.innerCone : 0.25;
            light.outerCone = cfg.outerCone != undefined ? cfg.outerCone : 0;
            light.attenuation = new Float32Array([
                    cfg.constantAttenuation != undefined ? cfg.constantAttenuation : 0.0,
                    cfg.linearAttenuation || 0.0,
                    cfg.quadraticAttenuation || 0.0
            ]);

            light.space = cfg.space || "world";

            ++numLights;

            hash += light.mode;
            if (light.specular) {
                hash += "s";
            }
            if (light.diffuse) {
                hash += "d";
            }
            hash += (light.space === "world" ? "w" : "v");

            if (i < len - 1) {
                hash += "/";
            }
        }

        display.lights.length = numLights;

        if (display.lightHash !== hash) {
            display.lightHash = hash;
            this._engine.branchDirty(this);
        } else {
            display.imageDirty = true;
        }

    };

    SceneJS.Scene.prototype.setClips = function(clipCfg) {
        var display = this._engine.display;
        var clips = display.clips;
        var hash = "";

        clips.clips.length = clipCfg.length;
        clips.enabled = false;
        for (var i = 0, len = clipCfg.length; i < len; ++i) {
            var cfg = clipCfg[i];
            var clip = clips.clips[i] || (clips.clips[i] = {
                normalAndDist: vec4.create(),
                fade: false,
                fadeDistance: 0
            });

            // Define the plane: Normal and Distance or Normal and Point on plane
            var n = cfg.n;
            vec3.normalize(n, n);
            var d = 0;
            if (cfg.d){
                d = cfg.d;
            } else if (cfg.p) {
                d = -vec3.dot(n, cfg.p);
            }
            clip.normalAndDist.set(n);
            clip.normalAndDist[3] = d;

            clip.fade = !!cfg.fade;
            clip.fadeDistance = 0;
            if (clip.fade) {
                // only add offset if needed for clip effect
                clips.clipFade = true;
                clip.fadeDistance = cfg.fadeDistance; // distance along plane normal at which to end effect. DO NOT SET TO ZERO
            } else {
                clips.clipDiscard = true;
            }

            hash += clip.fade ? "f" : "c";
        }   

        if (hash === display.clipsHash) {
            display.imageDirty = true;
        } else {
            this._engine.branchDirty(this);
            display.clipsHash = hash;
        }
    };

    SceneJS.Scene.prototype.createReflection = function(id, cfg) {
        var display = this._engine.display;
        var reflections = display.reflections;
        var reflection = reflections.reflections[id];
        if (reflection) {
            console.error("Reflection already exists: " + id);
            return;
        }
        reflection = new SceneJS.GlobalCubemap(this, id, cfg);
        reflections.reflections[id] = reflection;
    };

    SceneJS.Scene.prototype.activateReflection = function(id) {
        var reflections = this._engine.display.reflections;
        var reflection = reflections.reflections[id];
        if (!reflection) {
            console.error("Reflection not found: " + id);
            return;
        }
        reflections.activeReflection = reflection;
        this._updateReflectionsHash();
    };

    SceneJS.Scene.prototype._updateReflectionsHash = function() {
        var display = this._engine.display;
        var activeReflection = display.reflections.activeReflection;
        var hash = display.reflections.activeReflection ? activeReflection.hash : ";";
        if (hash === display.reflectionsHash) {
            display.imageDirty = true;
        } else {
            this._engine.branchDirty(this);
            display.reflectionsHash = hash;
        }
    };

    SceneJS.Scene.prototype.deactivateReflection = function() {
        var reflections = this._engine.display.reflections;
        if (reflections.activeReflection) {
            reflections.activeReflection = null;
            this._updateReflectionsHash();
        }
    };

    SceneJS.Scene.prototype.destroyReflection = function(id) {
        var display = this._engine.display;
        var reflections = display.reflections;
        var reflection = reflections.reflections[id];
        if (!reflection) {
            console.error("Reflection not found: " + id);
            return;
        }
        if (reflections.activeReflection && reflections.activeReflection.id === reflection.id) {
            this.deactivateReflection();
        }
        reflection.destroy();
        delete reflections.reflections[id];
    };

    SceneJS.Scene.prototype.destroyAllReflections = function() {
        var ids = Object.keys(this._engine.display.reflections.reflections);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroyReflection(ids[i]);
        }
    };

    SceneJS.Scene.prototype.createLightmap = function(id, cfg) {
        var display = this._engine.display;
        var lightmaps = display.lightmaps;
        var lightmap = lightmaps.lightmaps[id];
        if (lightmap) {
            console.error("Lightmap already exists: " + id);
            return;
        }
        lightmap = new SceneJS.GlobalCubemap(this, id, cfg);
        lightmaps.lightmaps[id] = lightmap;
    };

    SceneJS.Scene.prototype.activateLightmap = function(id) {
        var lightmaps = this._engine.display.lightmaps;
        var lightmap = lightmaps.lightmaps[id];
        if (!lightmap) {
            console.error("Lightmap not found: " + id);
            return;
        }
        lightmaps.activeLightmap = lightmap;
        this._updateLightmapsHash();
    };

    SceneJS.Scene.prototype._updateLightmapsHash = function() {
        var display = this._engine.display;
        var activeLightmap = display.lightmaps.activeLightmap;
        var hash = display.lightmaps.activeLightmap ? activeLightmap.hash : ";";
        if (hash === display.lightmapsHash) {
            display.imageDirty = true;
        } else {
            this._engine.branchDirty(this);
            display.lightmapsHash = hash;
        }
    };

    SceneJS.Scene.prototype.deactivateLightmap = function() {
        var lightmaps = this._engine.display.lightmaps;
        if (lightmaps.activeLightmap) {
            lightmaps.activeLightmap = null;
            this._updateLightmapsHash();
        }
    };

    SceneJS.Scene.prototype.destroyLightmap = function(id) {
        var display = this._engine.display;
        var lightmaps = display.lightmaps;
        var lightmap = lightmaps.lightmaps[id];
        if (!lightmap) {
            console.error("Lightmap not found: " + id);
            return;
        }
        if (lightmaps.activeLightmap && lightmaps.activeLightmap.id === lightmap.id) {
            this.deactivateLightmap();
        }
        lightmap.destroy();
        delete lightmaps.lightmaps[id];
    };

    SceneJS.Scene.prototype.destroyAllLightmaps = function() {
        var ids = Object.keys(this._engine.display.lightmaps.lightmaps);
        for (var i = 0, len = ids.length; i < len; i++) {
            this.destroyLightmap(ids[i]);
        }
    };

    SceneJS.Scene.prototype.setDeviceMatrix = function (mat) {
        var display = this._engine.display;
        display.hasDeviceMatrix = !!mat;
        if (mat) {
            display.deviceMatrix.set(mat);
        }
        display.imageDirty = true;
    };

    SceneJS.Scene.prototype.getCamera = function () {
        return this._engine.display.camera;
    };

    SceneJS.Scene.prototype.getViewMatrix = function() {
        return this._engine.display.viewMatrix;
    };

    SceneJS.Scene.prototype.getProjectionMatrix = function() {
        return this._engine.display.projectionMatrix;
    };

    SceneJS.Scene.prototype.setFogDensity = function(d) {
        this._engine.display.fogDensity = d;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogStart = function(s) {
        this._engine.display.fogParams[0] = s;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogEnd = function(e) {
        this._engine.display.fogParams[1] = e;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogMin = function(min) {
        this._engine.display.fogParams[2] = min;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogMax = function(max) {
        this._engine.display.fogParams[3] = max;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogColor = function(r, g, b) {
        this._engine.display.fogColor[0] = r;
        this._engine.display.fogColor[1] = g;
        this._engine.display.fogColor[2] = b;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogDensity = function(d) {
        this._engine.display.fogColor[3] = d;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogMode = function(mode) {
        this._engine.display.fogMode = mode;
        this._engine.branchDirty(this);
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setFogEnabled = function(enabled) {
        this._engine.display.fogEnabled = enabled;
        this._engine.branchDirty(this);
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.setXrayColor = function(r, g, b) {
        this._engine.display.xrayColor[0] = r;
        this._engine.display.xrayColor[1] = g;
        this._engine.display.xrayColor[2] = b;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Scene.prototype.mainFramebufferParams = function(params) {
        this._engine.display.mainFramebufferParams = params || null;
    }; 

    SceneJS.Scene.prototype.createFramebuffer = function (id, cfg) {
        this._engine.display.createFramebuffer(id, cfg);
    };

    SceneJS.Scene.prototype.destroyFramebuffer = function (id) {
        this._engine.display.destroyFramebuffer(id);
    };

    SceneJS.Scene.prototype.getPostProcessStage = function (id) {
        return this._engine.display.getPostProcessStage(id);
    };

    SceneJS.Scene.prototype.createPostProcessType = function (type, src, options) {
        this._engine.display.createPostProcessType(type, src, options);
    };

    SceneJS.Scene.prototype.postProcessOpaque = function (cfg) {
        this._engine.display.postProcessOpaque(cfg);
    };

    SceneJS.Scene.prototype.postProcessFinal = function (cfg) {
        this._engine.display.postProcessFinal(cfg);
    };

    /**
     * Sets the number of times this scene is drawn on each render.
     * <p>This is useful for when we need to do things like render for left and right eyes.
     * @param {Number} numPasses The number of times the scene is drawn on each frame.
     */
    SceneJS.Scene.prototype.setNumPasses = function (numPasses) {
        this._engine.setNumPasses(numPasses);
    };

    /**
     *  When doing multiple passes per frame, specifies whether to clear the
     * canvas before each pass (true) or just before the first pass (false).
     *
     * <p>This is useful for when we need to do things like render a separate pass to a stereo framebuffer for left and right eyes,
     * where we want to clear the buffer before each pass.</p>
     *
     * @param {Boolean} clearEachPass Tryu to clear before each pass (default is false).
     */
    SceneJS.Scene.prototype.setClearEachPass = function (clearEachPass) {
        this._engine.setClearEachPass(clearEachPass);
    };

    SceneJS.Scene.prototype.setViewport = function (xmin, ymin, width, height) {
        this._engine.display.setViewport(xmin, ymin, width, height);
    };

    /**
     * Render a single frame if new frame pending, or force a new frame
     * Returns true if frame rendered
     */
    SceneJS.Scene.prototype.render = function (params) {
        return this._engine.render(params);
    };

    /**
     * Prevent re-compilation of scene graph.
     */
    SceneJS.Scene.prototype.pauseCompilation = function () {
        return this._engine.pauseCompilation();
    };

    /**
     * Resume re-compilation of scene graph.
     */
    SceneJS.Scene.prototype.resumeCompilation = function () {
        return this._engine.resumeCompilation();
    };

    /**
     * Force compilation of the scene graph.
     */
    SceneJS.Scene.prototype.compile = function () {
        return this._engine.compile();
    };

    /**
     * Signals that a new frame will be needed
     * @param params
     */
    SceneJS.Scene.prototype.needFrame = function () {
        this._engine.display.imageDirty = true;
    };

    /**
     * Starts the render loop for this scene
     */
    SceneJS.Scene.prototype.start = function (params) {
        this._engine.start(params);
    };

    /**
     *
     */
    SceneJS.Scene.prototype.pick = function () {

        // Backwards compatibility with pick(canvasX, canvasY, params)
        var params;
        if (SceneJS._isNumeric(arguments[0])) {
            var canvasX = arguments[0];
            var canvasY = arguments[1];
            params = arguments[2] || {};
            params.canvasPos = new Float32Array([canvasX, canvasY])
        } else {
            params = arguments[0] || {};
        }

        var result = this._engine.pick(params);
        this.render({force: true}); // HACK: canvas blanks after picking
        if (result) {
            this.publish("pick", result);
            return result;
        } else {
            this.publish("nopick");
        }
    };


    /**
     * Reads colors of pixels from the last rendered frame.
     *
     * <p>Call this method like this:</p>
     *
     * <pre>
     *
     * // Ignore transparent pixels (default is false)
     * var opaqueOnly = true;
     *
     * #readPixels([
     *      { x: 100, y: 22,  r: 0, g: 0, b: 0 },
     *      { x: 120, y: 82,  r: 0, g: 0, b: 0 },
     *      { x: 12,  y: 345, r: 0, g: 0, b: 0 }
     * ], 3, opaqueOnly);
     * </pre>
     *
     * Then the r,g,b components of the entries will be set to the colors at those pixels.
     */
    SceneJS.Scene.prototype.readPixels = function (entries, size, opaqueOnly) {
        return this._engine.readPixels(entries, size, opaqueOnly);
    };

    /**
     * Scene node's destroy handler, called by {@link SceneJS_node#destroy}
     * @private
     */
    SceneJS.Scene.prototype._destroy = function () {
        if (!this.destroyed) {
            delete SceneJS._engines[this.id];  // HACK: circular dependency
            SceneJS._engineIds.removeItem(this.id); // HACK: circular dependency
            this.destroyed = true;
        }
    };

    /**
     * Returns true if scene active, ie. not destroyed. A destroyed scene becomes active again
     * when you render it.
     */
    SceneJS.Scene.prototype.isActive = function () {
        return !this._engine.destroyed;
    };

    /**
     * Stops current render loop that was started with {@link #start}. After this, {@link #isRunning} will return false.
     */
    SceneJS.Scene.prototype.stop = function () {
        this._engine.stop();
    };

    /** Determines if node exists in this scene
     * @deprecated
     */
    SceneJS.Scene.prototype.containsNode = function (nodeId) {
        return !!this._engine.findNode(nodeId);
    };

    /**
     * Finds nodes in this scene that have nodes IDs matching the given regular expression
     *
     * @param {String} nodeIdRegex Regular expression to match on node IDs
     * @return {[SceneJS.Node]} Array of nodes whose IDs match the given regex
     */
    SceneJS.Scene.prototype.findNodes = function (nodeIdRegex) {
        return this._engine.findNodes(nodeIdRegex);
    };

    /**
     * Finds the node with the given ID in this scene
     * @deprecated
     * @param {String} nodeId Node ID
     * @return {SceneJS.Node} The node if found, else null
     */
    SceneJS.Scene.prototype.findNode = function (nodeId) {
        return this.getNode(nodeId);
    };

    /**
     * @function Finds the node with the given ID in this scene
     * @param {String} nodeId Node ID
     * @return {SceneJS.Node} The node if found, else null
     */
    SceneJS.Scene.prototype.getNode = function (nodeId) {
        return this._engine.findNode(nodeId);
    };

    /**
     * Tests whether a node core of the given ID exists for the given node type
     * @param {String} type Node type
     * @param {String} coreId
     * @returns Boolean
     */
    SceneJS.Scene.prototype.hasCore = function (type, coreId) {
        return this._engine.hasCore(type, coreId);
    };

    /**
     * Publishes to a topic on this node.
     *
     * Immediately notifies existing subscriptions to that topic, and unless the "forget' parameter is
     * true, retains the publication to give to any subsequent notifications on that topic as they are made.
     *
     * @param {String} topic Publication topic
     * @param {Object} pub The publication
     * @param {Boolean} [forget] When true, the publication will be sent to subscribers then forgotten, so that any
     * subsequent subscribers will not receive it
     */
    SceneJS.Scene.prototype.publish = function (topic, pub, forget) {
        if (!forget) {
            this._topicPubs[topic] = pub; // Save notification
        }
        if (this._topicSubs[topic]) { // Notify subscriptions
            var subsForTopic = this._topicSubs[topic];
            for (var handle in subsForTopic) {
                if (subsForTopic.hasOwnProperty(handle)) {
                    subsForTopic[handle].call(this, pub);
                }
            }
        }
    };

    /**
     * Removes a topic publication
     *
     * Immediately notifies existing subscriptions to that topic, sending them each a null publication.
     *
     * @param topic Publication topic
     * @private
     */
    SceneJS.Scene.prototype.unpublish = function (topic) {
        var subsForTopic = this._topicSubs[topic];
        if (subsForTopic) { // Notify subscriptions
            for (var handle in subsForTopic) {
                if (subsForTopic.hasOwnProperty(handle)) {
                    subsForTopic[handle].call(this, null);
                }
            }
        }
        delete this._topicPubs[topic];
    };


    /**
     * Listen for data changes at a particular location on this node
     *
     * <p>Your callback will be triggered for
     * the initial data and again whenever the data changes. Use {@link #off} to stop receiving updates.</p>
     *
     * <p>The callback is be called with this node as scope.</p>
     *
     * @param {String} location Publication location
     * @param {Function(data)} callback Called when fresh data is available at the location
     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
     */
    SceneJS.Scene.prototype.on = function (topic, callback) {
        var subsForTopic = this._topicSubs[topic];
        if (!subsForTopic) {
            subsForTopic = {};
            this._topicSubs[topic] = subsForTopic;
        }
        var handle = this._handleMap.addItem(); // Create unique handle
        subsForTopic[handle] = callback;
        this._handleTopics[handle] = topic;
        var pub = this._topicPubs[topic];
        if (pub) { // A publication exists, notify callback immediately
            callback.call(this, pub);
        }
        if (topic == "rendered") {
            this._engine.branchDirty(this);
        }
        return handle;
    };

    /**
     * Unsubscribes from a publication on this node that was previously made with {@link #on}.
     * @param handle Publication handle
     */
    SceneJS.Scene.prototype.off = function (handle) {
        var topic = this._handleTopics[handle];
        if (topic) {
            delete this._handleTopics[handle];
            var topicSubs = this._topicSubs[topic];
            if (topicSubs) {
                delete topicSubs[handle];
            }
            this._handleMap.removeItem(handle); // Release handle
            if (topic == "rendered") {
                this._engine.branchDirty(this);
            }
        }
    //    else {
    //        this._engine.scene.off(handle);
    //    }
    };

    /**
     * Listens for exactly one data update at the specified location on this node, and then stops listening.
     * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
     * @param {String} location Data location to listen to
     * @param {Function(data)} callback Called when fresh data is available at the location
     */
    SceneJS.Scene.prototype.once = function (topic, callback) {
        var self = this;
        var sub = this.on(topic,
            function (pub) {
                self.off(sub);
                callback(pub);
            });
    };

})();

;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
 /*
    Compressed texture code based on Brandon Jones' Texture Format Tester
    http://toji.github.io/texture-tester/
 */
(function () {
    "use strict";

    // The default state core singleton for {@link SceneJS.Texture} nodes
    var defaultCore = {
        type: "texture",
        stateId: SceneJS._baseStateId++,
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.texture = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    // Set up compressed texture constants
    var GL_CONSTANTS = null;
    var DDS_CONSTANTS = null;
    var PVR_CONSTANTS = null;
    var KTX_CONSTANTS = null;

    var FLAGS = SceneJS.TEXTURE_FLAGS;

    /**
     * @class Scene graph node which defines one or more textures to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.TextureMap = SceneJS_NodeFactory.createNodeType("texture");

    SceneJS.TextureMap.prototype._init = function (params) {

        var self = this;

        if (this._core.useCount == 1) { // This node is the resource definer

            var applyFrom = params.applyFrom || "uv";
            if (applyFrom.substring(0,2) !== "uv") {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value is unsupported - should be 'uv<index>'");
            }
            var uvLayerIdx = 0;
            if (applyFrom !== "uv") {
                uvLayerIdx = parseInt(applyFrom.substring(2));
                if (isNaN(uvLayerIdx)) {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value invalid - should be 'uv<index>'");
                }
            }

            if (params.applyTo) {

                var applyTo = params.applyTo;

                if (applyTo != "baseColor" && // Colour map (deprecated)
                    applyTo != "color" && // Colour map
                    applyTo != "occlusion" && // Ambient occlusion map
                    applyTo != "specular" && // Specular map
                    applyTo != "emit" && // Emission map
                    applyTo != "alpha" && // Alpha map
                    applyTo != "normals" && // Normal map
                    applyTo != "shine" && //
                    applyTo != "transparency" && // Transparency map
                    applyTo != "metallic" && // Metallic map
                    applyTo != "roughness" && // Roughness map
                    applyTo != "metallicRoughness" // Combined metallic & roughness map
                  ) { // Shininess map

                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyTo value is unsupported: " + applyTo);
                }
            }

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply" && params.blendMode != "over" && params.blendMode != "conditionalAlpha") {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture layer blendMode value is unsupported - " +
                        "should be either 'add' or 'multiply'");
                }
            }

            if (params.applyTo == "color") {
                params.applyTo = "baseColor";
            }

            var flags = FLAGS[params.applyTo || "baseColor"] | FLAGS[params.blendMode || "multiply"];

            if (params.swizzledNormals) {
                flags |= FLAGS["swizzledNormals"];
            }

            SceneJS._apply({
                    waitForLoad: params.waitForLoad == undefined ? true : params.waitForLoad,
                    texture: null,
                    minFilter: params.minFilter,
                    magFilter: params.magFilter,
                    wrapS: params.wrapS,
                    wrapT: params.wrapT,
                    flipY: params.flipY,
                    uvLayerIdx: uvLayerIdx,
                    isNormalMap: params.applyTo === "normals",
                    isAlphaMap: params.applyTo === "alpha",
                    isTransparencyMap: params.applyTo === "transparency",
                    flags: flags,
                    blendFactor: (params.blendFactor != undefined && params.blendFactor != null) ? params.blendFactor : 1.0,
                },
                this._core);
            this._initTexture(params.preloadColor);
            if (params.compressedImage) {
                this.setCompressedImage(params.compressedImage, params.containerFormat, params.compressedSrc);
            } else if (params.compressedSrc) {
                this._core.compressedSrc = params.compressedSrc;  // Can be used for context recovery if provided.
                var parseFunction;
                if (params.containerFormat === "dds") {
                    parseFunction = this._parseDDS;
                } else if (params.containerFormat === "pvr") {
                    parseFunction = this._parsePVR;
                } else if (params.containerFormat === "ktx") {
                    parseFunction = this._parseKTX;
                } else {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "Compressed textures require containerFormat parameter to be 'dds' or 'pvr'");
                }
                SceneJS._loadBinary(params.compressedSrc, parseFunction.bind(this));
            } else if (params.image) { // Create from image
                this._setTextureImage(params.image);
            } else if (params.src) { // Load from URL
                this._core.src = params.src;
                this._loadTexture(params.src, params.preloadSrc);
            }

            this._core.mipMapLevels = 0;
            this._core.drawTexture = params.drawTexture || false;
            this._core.webglRestored = getContextRestoredCallback(this, this._core, params.preloadColor, params.containerFormat);

        }
    };

    function getContextRestoredCallback(node, core, preloadColor, containerFormat) {
        return function () {
            if (core.compressedSrc) {
                node._initTexture(preloadColor);
                var parseFunction;
                if (containerFormat === "dds") {
                    parseFunction = node._parseDDS;
                } else if (containerFormat === "pvr") {
                    parseFunction = node._parsePVR;
                }
                SceneJS._loadBinary(core.compressedSrc, parseFunction.bind(this));
            } else if (core.image) {
                node._initTexture(preloadColor);
                node._setTextureImage(core.image);
            } else if (core.src) {
                node._initTexture(preloadColor);
                node._loadTexture(core.src);
            }
        };
    }

    SceneJS.TextureMap.prototype._initTexture = function (preloadColor) {
        var gl = this._engine.canvas.gl;

        preloadColor = preloadColor || { r: 0.57735, g: 0.57735, b: 0.57735 };
        preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;

        preloadColor = new Uint8Array([
            Math.floor(preloadColor.r * 255),
            Math.floor(preloadColor.g * 255),
            Math.floor(preloadColor.b * 255),
            Math.floor(preloadColor.a * 255)
        ]);

        this._core.width = 1;
        this._core.height = 1;

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
        this._setCoreTexture(texture);
    };

    SceneJS.TextureMap.prototype._loadTexture = function (src, preloadSrc) {
        var self = this;
        var image = new Image();
        var loaded = false;
        var taskFinished = false;

        if (preloadSrc) {
            var preloadImage = new Image();

            preloadImage.onload = function () {
                if (!loaded) {
                    self._setTextureImage(preloadImage);
                    taskFinished = true;
                    self._engine.display.imageDirty = true;
                }
            };

            preloadImage.src = preloadSrc;
        }

        image.onload = function () {
            self._setTextureImage(image);
            loaded = true;
            self._engine.display.imageDirty = true;
        };
        image.src = src;
    };

    SceneJS.TextureMap.prototype._setTextureImage = function (image) {

        var gl = this._engine.canvas.gl;
        var core = this._core;
        var texture = core.texture && core.texture.texture ? core.texture.texture : gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        core.width = image.width;
        core.height = image.height;
        this._setCoreTexture(texture);

        // Note(Tarek): Assumes mip maps are generated.
        this._gatherStats(image.width, image.height, image.width * image.height * 4);
    };

    SceneJS.TextureMap.prototype._setCompressedTextureImage = function (data, extension, internalFormat, width, height, mipMapLevels, imageSizePrefix) {

        var gl = this._engine.canvas.gl;
        var core = this._core;
        var texture = core.texture && core.texture.texture ? core.texture.texture : gl.createTexture();

        var ext = SceneJS._getExtension(gl, extension);

        if (!ext) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Compressed texture format " + extension + "not available.");
        }

        gl.bindTexture(gl.TEXTURE_2D, texture);

        var offset = 0;

        this._core.width = width;
        this._core.height = height;
        this._core.mipMapLevels = mipMapLevels;
        this._core.compressed = true;

        var sizeFunction = GL_CONSTANTS.SIZE_FUNCTIONS[internalFormat];

        var levelWidth = width;
        var levelHeight = height;

        for (var i = 0; i < mipMapLevels; ++i) {
            var levelSize = 0;

            if (imageSizePrefix) {
                // For KTX
                levelSize = data[offset] + (data[offset + 1] << 8) + (data[offset + 2] << 16) + (data[offset + 3] << 24);
                offset += 4;
            } else {
                levelSize = sizeFunction(levelWidth, levelHeight);
            }

            var image = new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);

            gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, levelWidth, levelHeight, 0, image);

            levelWidth = levelWidth / 2;
            levelHeight = levelHeight / 2;

            offset += levelSize;
        }

        this._setCoreTexture(texture);

        this._gatherStats(width, height, data.byteLength);
    };

    SceneJS.TextureMap.prototype._gatherStats = function (width, height, mem) {
        this._engine.stats.memory.textures += mem;

        var textureStats = this._engine.stats.textures;
        var dimensions = width + "x" + height;

        var applyTo = this._getTextureTarget();
        var textureTargetStats = textureStats[applyTo] = textureStats[applyTo] || {};
        textureTargetStats[dimensions] = (textureTargetStats[dimensions] || 0) + 1;
        textureTargetStats.memory = (textureTargetStats.memory || 0) + mem;
    };

    SceneJS.TextureMap.prototype._setCoreTexture = function (texture) {
        var gl = this._engine.canvas.gl;
        var pot = SceneJS_math_isPOT(this._core.width) & SceneJS_math_isPOT(this._core.height);

        var defaultWrap = pot ? gl.REPEAT : gl.CLAMP_TO_EDGE;
        var defaultMinFilter = this._core.mipMapLevels === 1 || !pot ? gl.LINEAR : gl.LINEAR_MIPMAP_NEAREST;

        this._core.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", defaultMinFilter),
            magFilter: this._getGLOption("magFilter", gl.LINEAR),
            wrapS: this._getGLOption("wrapS", defaultWrap),
            wrapT: this._getGLOption("wrapT", defaultWrap),
            compressed: this._core.compressed,
            flipY: this._core.flipY,
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            this._core.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype._getTextureTarget = function () {
        var flags = this._core.flags;

        if (flags & FLAGS.baseColor) {
            return "baseColor";
        }

        if (flags & FLAGS.occlusion) {
            return "occlusion";
        }

        if (flags & FLAGS.normals) {
            return "normals";
        }

        if (flags & FLAGS.alpha) {
            return "alpha";
        }

        if (flags & FLAGS.specular) {
            return "specular";
        }

        if (flags & FLAGS.emit) {
            return "emit";
        }

        if (flags & FLAGS.shine) {
            return "shine";
        }

        if (flags & FLAGS.transparency) {
            return "transparency";
        }

        if (flags & FLAGS.metallic) {
            return "metallic";
        }

        if (flags & FLAGS.roughness) {
            return "roughness";
        }

        if (flags & FLAGS.metallicRoughness) {
            return "metallicRoughness";
        }
    };

    SceneJS.TextureMap.prototype._getGLOption = function (name, defaultVal) {
        var gl = this._engine.canvas.gl;
        var value = this._core[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        return gl[glName];
    };

    SceneJS.TextureMap.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    SceneJS.TextureMap.prototype.setSrc = function (src) {
        this._core.image = null;
        this._core.src = src;
        this._core.target = null;
        this._loadTexture(src);
    };

    SceneJS.TextureMap.prototype.setImage = function (image) {
        this._core.src = null;
        this._core.target = null;
        this._setTextureImage(image);
    };

    SceneJS.TextureMap.prototype.setCompressedImage = function (image, container, src) {
        this._core.src = null;
        this._core.image = null;
        this._core.target = null;
        this._core.compressedSrc = src;  // Can be used for context recovery if provided.
        if (container === "dds") {
            this._parseDDS(image);
        } else if (container === "pvr") {
            this._parsePVR(image);
        } else {
            this._parseKTX(image);
        }
    };

    SceneJS.TextureMap.prototype.setTarget = function (target) {
        if (target.type != "colorTarget" && target.type != "depthTarget") {
            console.log("Target node type not compatible: " + target.type);
            return;
        }
        delete this._core.src;
        this._core.target = target;
        this._core.src = null;
        this._core.image = null;
        this._core.texture = target._core.renderBuf.getTexture(); // TODO: what happens when the target is destroyed?
        this._core.texture.bufType = target._core.bufType;
        this._engine.display.imageDirty = true;
    };

    /**
     * Sets the texture's blend factor with respect to other active textures.
     * @param {number} blendFactor The blend factor, in range [0..1]
     */
    SceneJS.TextureMap.prototype.setBlendFactor = function (blendFactor) {
        this._core.blendFactor = blendFactor;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getBlendFactor = function () {
        return this._core.blendFactor;
    };

    SceneJS.TextureMap.prototype.setTranslate = function (t) {
        if (!this._core.translate) {
            this._core.translate = {x: 0, y: 0};
        }
        this._core.translate.x = t.x;
        this._core.translate.y = t.y;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getTranslate = function () {
        return this._core.translate;
    };

    SceneJS.TextureMap.prototype.setScale = function (s) {
        if (!this._core.scale) {
            this._core.scale = {x: 0, y: 0};
        }
        this._core.scale.x = s.x;
        this._core.scale.y = s.y;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getScale = function () {
        return this._core.scale;
    };

    SceneJS.TextureMap.prototype.setRotate = function (angle) {
        this._core.rotate = angle;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getRotate = function () {
        return this._core.rotate;
    };

    SceneJS.TextureMap.prototype.getMatrix = function () {
        if (this._core._matrixDirty) {
            this._core.buildMatrix.call(this.core)()
        }
        return this.core.matrix;
    };

    SceneJS.TextureMap.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("texture");
            this.__core.transparent = false;
            this.__core.drawLayer = -1; //Layer index of texture used for draw operations
        }
        var parentCore = this._engine.display.texture;
        if (!this._core.empty) {
            this.__core.layers = (parentCore && parentCore.layers) ? parentCore.layers.concat([this._core]) : [this._core];
            this.__core.transparent = this._core.isAlphaMap || this._core.isTransparencyMap || parentCore.transparent;
            if (this._core.drawTexture) {
                this.__core.drawLayerIndex = this.__core.layers.length - 1;
            }
        }
        this._makeHash(this.__core);
        coreStack[stackLen++] = this.__core;
        this._engine.display.texture = this.__core;
        this._compileNodes(ctx);
        this._engine.display.texture = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.TextureMap.prototype._makeHash = function (core) {
        var hashParts = [];
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.uvLayerIdx);
                hashParts.push("/");
                hashParts.push(texLayer.flags);
                if (texLayer.matrix) {
                    hashParts.push("/anim");
                }
                if (texLayer.compressed) {
                    hashParts.push("/comp");
                }
                if (texLayer.applyTo === "normals") {
                    if (SceneJS.WEBGL_INFO.standardDerivativesSupported) {
                        hashParts.push("/gt"); // Generate tangents in fragment shader
                    }
                }
            }
        }
        var hash = hashParts.join("");
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.TextureMap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last core user
            if (this._core.texture && !this._core.target) { // Don't wipe out target texture
                this._core.texture.destroy();
                this._core.texture = null;
            }
            this._engine.stats.memory.textures--;
        }

    };

    SceneJS.TextureMap.prototype._parseDDS = function(buffer) {

        if (!DDS_CONSTANTS) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "DXT compressed textures not supported on this platform.");
        }

        var header = new Uint32Array(buffer, 0, DDS_CONSTANTS.HEADER_LENGTH);

        if (header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX] != DDS_CONSTANTS.MAGIC_NUMBER) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid DDS File: Magic number invalid.");
        }

        if (header[DDS_CONSTANTS.PIXEL_FORMAT_FLAGS_INDEX] & DDS_CONSTANTS.PIXEL_FORMAT_FOURCC_FLAG === 0) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid DDS File: FourCC required.");
        }

        var internalFormat = DDS_CONSTANTS.FOURCC_MAP[header[DDS_CONSTANTS.PIXEL_FORMAT_FOURCC_INDEX]];
        var extension = DDS_CONSTANTS.EXTENSION_MAP[header[DDS_CONSTANTS.PIXEL_FORMAT_FOURCC_INDEX]];

        var mipMapLevels = 1;
        if (header[DDS_CONSTANTS.FLAGS_INDEX] & DDS_CONSTANTS.MIPMAPCOUNT_FLAG) {
            mipMapLevels = header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX];
        }

        var width = header[DDS_CONSTANTS.WIDTH_INDEX];
        var height = header[DDS_CONSTANTS.HEIGHT_INDEX];

        var data = new Uint8Array(buffer, DDS_CONSTANTS.DATA_OFFSET);

        this._setCompressedTextureImage(data, extension, internalFormat, width, height, mipMapLevels);
    }

    SceneJS.TextureMap.prototype._parsePVR = function(buffer) {

        var header = new Uint32Array(buffer, 0, PVR_CONSTANTS.HEADER_LENGTH);

        if (header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX] != PVR_CONSTANTS.MAGIC_NUMBER) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid PVR File: Magic number invalid.");
        }

        var pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX]

        var extension = PVR_CONSTANTS.EXTENSION_MAP[pvrFormat];
        var internalFormat = PVR_CONSTANTS.FORMAT_MAP[pvrFormat];

        var mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];

        var width = header[PVR_CONSTANTS.WIDTH_INDEX];
        var height = header[PVR_CONSTANTS.HEIGHT_INDEX];

        var dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];

        var data = new Uint8Array(buffer, dataOffset);

        this._setCompressedTextureImage(data, extension, internalFormat, width, height, mipMapLevels);
    }

    SceneJS.TextureMap.prototype._parseKTX = function(buffer) {

        var header = new Uint32Array(buffer, 0, KTX_CONSTANTS.HEADER_LENGTH);

        for (var i = 0; i < KTX_CONSTANTS.IDENTIFIER_LENGTH; ++i) {
            if (header[i] != KTX_CONSTANTS.IDENTIFIER[i]) {
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Invalid KTX File: Identifier invalid.");
            }
        }

        var internalFormat = header[KTX_CONSTANTS.INTERNAL_FORMAT_INDEX];
        var extension = KTX_CONSTANTS.EXTENSION_MAP[internalFormat];

        var mipMapLevels = header[KTX_CONSTANTS.MIPMAPCOUNT_INDEX];

        var width = header[KTX_CONSTANTS.WIDTH_INDEX];
        var height = header[KTX_CONSTANTS.HEIGHT_INDEX];

        var dataOffset = KTX_CONSTANTS.HEADER_SIZE + header[KTX_CONSTANTS.KEY_VALUE_SIZE_INDEX];

        var data = new Uint8Array(buffer, dataOffset);

        this._setCompressedTextureImage(data, extension, internalFormat, width, height, mipMapLevels, true);
    }

    // Builds a numeric code for a given fourCC DDS file string
    function parseFourCC(value) {
      return value.charCodeAt(0) +
            (value.charCodeAt(1) << 8) +
            (value.charCodeAt(2) << 16) +
            (value.charCodeAt(3) << 24);
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    function pvrtc2bppSize(width, height) {
        var width = Math.max(width, 16);
        var height = Math.max(height, 8);

        return width * height / 4;
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    function pvrtc4bppSize(width, height) {
        var width = Math.max(width, 8);
        var height = Math.max(height, 8);

        return width * height / 2;
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/
    // Also size for RGB ATC
    function dxt1etc1Size(width, height) {
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    // Also size for both alpha ATC formats
    function dxt35Size(width, height) {
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    }

    (function() {
        var canvas = document.createElement("canvas");

        if (!canvas) {
            return;
        }

        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if (!gl) {
            return;
        }

        GL_CONSTANTS = getGLConstants(gl);
        DDS_CONSTANTS = getDDSConstants();
        PVR_CONSTANTS = getPVRConstants();
        KTX_CONSTANTS = getKTXConstants();

        function getGLConstants(gl) {
            var pvrtc = SceneJS._getExtension(gl, "WEBGL_compressed_texture_pvrtc");
            var etc1 = SceneJS._getExtension(gl, "WEBGL_compressed_texture_etc1");
            var dxt = SceneJS._getExtension(gl, "WEBGL_compressed_texture_s3tc");

            var CONSTANTS = {
                PVRTC_SUPPORTED: !!pvrtc,
                ETC1_SUPPORTED: !!etc1,
                DXT_SUPPORTED: !!dxt,
                FORMAT_ENUMS: {},
                SIZE_FUNCTIONS: {}
            }

            if (CONSTANTS.PVRTC_SUPPORTED) {
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = pvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = pvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = pvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = pvrtc2bppSize;
                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = pvrtc2bppSize;
                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = pvrtc4bppSize;
                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = pvrtc4bppSize;
            }

            if (CONSTANTS.ETC1_SUPPORTED) {
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL = etc1.COMPRESSED_RGB_ETC1_WEBGL;

                CONSTANTS.SIZE_FUNCTIONS[etc1.COMPRESSED_RGB_ETC1_WEBGL] = dxt1etc1Size;
            }

            if (CONSTANTS.DXT_SUPPORTED) {
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT = dxt.COMPRESSED_RGB_S3TC_DXT1_EXT;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT = dxt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT = dxt.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                CONSTANTS.SIZE_FUNCTIONS[dxt.COMPRESSED_RGB_S3TC_DXT1_EXT] = dxt1etc1Size;
                CONSTANTS.SIZE_FUNCTIONS[dxt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = dxt35Size;
                CONSTANTS.SIZE_FUNCTIONS[dxt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = dxt35Size;
            }

            return CONSTANTS;
        }

        function getDDSConstants() {

            // http://msdn.microsoft.com/en-us/library/bb943991.aspx/
            var CONSTANTS = {
                MAGIC_NUMBER: 0x20534444,
                MIPMAPCOUNT_FLAG: 0x20000,
                PIXEL_FORMAT_FOURCC_FLAG: 0x4,

                HEADER_LENGTH: 31,

                MAGIC_NUMBER_INDEX: 0,

                SIZE_INDEX: 1,
                FLAGS_INDEX: 2,
                HEIGHT_INDEX: 3,
                WIDTH_INDEX: 4,

                MIPMAPCOUNT_INDEX: 7,

                PIXEL_FORMAT_FLAGS_INDEX: 20,
                PIXEL_FORMAT_FOURCC_INDEX: 21,

                DATA_OFFSET: 128,

                FOURCC_MAP: {},
                EXTENSION_MAP: {}
            };

            if (GL_CONSTANTS.DXT_SUPPORTED) {
                var dxt1 = parseFourCC("DXT1");
                var dxt3 = parseFourCC("DXT3");
                var dxt5 = parseFourCC("DXT5");

                CONSTANTS.FOURCC_MAP[dxt1] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT;
                CONSTANTS.FOURCC_MAP[dxt3] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                CONSTANTS.FOURCC_MAP[dxt5] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                CONSTANTS.EXTENSION_MAP[dxt1] = "WEBGL_compressed_texture_s3tc";
                CONSTANTS.EXTENSION_MAP[dxt3] = "WEBGL_compressed_texture_s3tc";
                CONSTANTS.EXTENSION_MAP[dxt5] = "WEBGL_compressed_texture_s3tc";
            }

            if (GL_CONSTANTS.ETC1_SUPPORTED) {
                var etc1 = parseFourCC("ETC1");

                CONSTANTS.FOURCC_MAP[etc1] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL;

                CONSTANTS.EXTENSION_MAP[etc1] = "WEBGL_compressed_texture_etc1";
            }

            return CONSTANTS;
        }

        function getPVRConstants() {

            // http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf
            var CONSTANTS = {
                MAGIC_NUMBER: 0x03525650,
                HEADER_LENGTH: 13,
                HEADER_SIZE: 52,
                MAGIC_NUMBER_INDEX: 0,
                PIXEL_FORMAT_INDEX: 2,
                HEIGHT_INDEX: 6,
                WIDTH_INDEX: 7,
                MIPMAPCOUNT_INDEX: 11,
                METADATA_SIZE_INDEX: 12,
                EXTENSION_MAP: {
                    0: "WEBGL_compressed_texture_pvrtc",
                    1: "WEBGL_compressed_texture_pvrtc",
                    2: "WEBGL_compressed_texture_pvrtc",
                    3: "WEBGL_compressed_texture_pvrtc",
                    6: "WEBGL_compressed_texture_etc1",
                    7: "WEBGL_compressed_texture_s3tc",
                    9: "WEBGL_compressed_texture_s3tc",
                    11: "WEBGL_compressed_texture_s3tc"
                },
                FORMAT_MAP: {}
            };

            if (GL_CONSTANTS.PVRTC_SUPPORTED) {
                CONSTANTS.FORMAT_MAP[0] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_MAP[1] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_MAP[2] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                CONSTANTS.FORMAT_MAP[3] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            }

            if (GL_CONSTANTS.ETC1_SUPPORTED) {
                CONSTANTS.FORMAT_MAP[6] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL;
            }

            if (GL_CONSTANTS.DXT_SUPPORTED) {
                CONSTANTS.FORMAT_MAP[7] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT;
                CONSTANTS.FORMAT_MAP[9] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                CONSTANTS.FORMAT_MAP[11] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }

            return CONSTANTS;
        }

        function getKTXConstants() {
            var BYTE_IDENTIFIER = new Uint8Array([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A]);

            // https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
            var CONSTANTS = {
                IDENTIFIER: new Uint32Array(BYTE_IDENTIFIER.buffer),
                IDENTIFIER_LENGTH: 3,
                HEADER_LENGTH: 16,
                HEADER_SIZE: 64,
                INTERNAL_FORMAT_INDEX: 7,
                WIDTH_INDEX: 9,
                HEIGHT_INDEX: 10,
                MIPMAPCOUNT_INDEX: 14,
                KEY_VALUE_SIZE_INDEX: 15,
                EXTENSION_MAP: {}
            };

            if (GL_CONSTANTS.DXT_SUPPORTED) {
                CONSTANTS.EXTENSION_MAP[GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT ] = "WEBGL_compressed_texture_s3tc";
                CONSTANTS.EXTENSION_MAP[GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT] = "WEBGL_compressed_texture_s3tc";
                CONSTANTS.EXTENSION_MAP[GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT] = "WEBGL_compressed_texture_s3tc";
            }

            if (GL_CONSTANTS.ETC1_SUPPORTED) {
                CONSTANTS.EXTENSION_MAP[GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL] = "WEBGL_compressed_texture_etc1";
            }

            return CONSTANTS;
        }
    })();


})();
;/**
 * @class Scene graph node which defines fresnels to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
(function () {
    "use strict";

    var FLAGS = SceneJS.TEXTURE_FLAGS;

    // The default state core singleton for {@link SceneJS.Fresnel} nodes
    var defaultCore = {
        type: "fresnel",
        stateId: SceneJS._baseStateId++,
        power: 1.0,
        centerColor: new Float32Array([ 1.0, 1.0, 1.0, 1.0 ]),
        edgeColor: new Float32Array([ 0.0, 0.0, 0.0, 0.0 ]),
        blendFactor: 1.0,
        blendMode: FLAGS.multiply,
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.fresnel = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    /**
     * @class Scene graph node which defines a fresnel to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Fresnel = SceneJS_NodeFactory.createNodeType("fresnel");

    SceneJS.Fresnel.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node is the resource definer

            if (params.applyTo) {
                if (params.applyTo != "color" &&
                    params.applyTo != "specular" &&
                    params.applyTo != "alpha" &&
                    params.applyTo != "reflect" &&
                    params.applyTo != "emit" &&
                    params.applyTo != "fragment" &&
                    params.applyTo != "transparency") {

                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "fresnel applyTo value is unsupported - should be either 'color', 'specular', 'alpha', 'reflect', 'emit' or 'fragment'");
                }
            }

            this._core.applyTo = params.applyTo;

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply") {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture layer blendMode value is unsupported - " +
                        "should be either 'add' or 'multiply'");
                }
            }

            this._core.blendMode = FLAGS[params.blendMode || "multiply"];

            this._core.centerColor = new Float32Array(defaultCore.centerColor);
            this._core.edgeColor = new Float32Array(defaultCore.edgeColor);
            this._core.power = defaultCore.power;

            if (params.centerBias != undefined) {
                this.setCenterBias(params.centerBias);
            }
            if (params.edgeBias != undefined) {
                this.setEdgeBias(params.edgeBias);
            }
            if (params.power != undefined) {
                this.setPower(params.power);
            }
            if (params.centerColor != undefined) {
                this.setCenterColor(params.centerColor);
            }
            if (params.edgeColor != undefined) {
                this.setEdgeColor(params.edgeColor);
            }
        }
    };

    SceneJS.Fresnel.prototype.getApplyTo = function () {
        return this._core.applyTo;
    };

    SceneJS.Fresnel.prototype.setCenterBias = function (centerBias) {
        this._core.centerColor[3] = (centerBias !== undefined) ? centerBias : defaultCore.centerColor[3];
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getCenterBias = function () {
        return this._core.centerColor[3];
    };

    SceneJS.Fresnel.prototype.setEdgeBias = function (edgeBias) {
        this._core.edgeColor[3] = (edgeBias !== undefined) ? edgeBias : defaultCore.edgeColor[3];
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getEdgeBias = function () {
        return this._core.edgeColor[3];
    };

    SceneJS.Fresnel.prototype.setPower = function (power) {
        this._core.power = (power !== undefined) ? power : defaultCore.power;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getPower = function () {
        return this._core.power;
    };

    SceneJS.Fresnel.prototype.setCenterColor = function (color) {
        var defaultCenterColor = defaultCore.centerColor;
        this._core.centerColor[0] = color.r != undefined ? color.r : defaultCenterColor[0];
        this._core.centerColor[1] = color.g != undefined ? color.g : defaultCenterColor[1];
        this._core.centerColor[2] = color.b != undefined ? color.b : defaultCenterColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Fresnel.prototype.getCenterColor = function () {
        return {
            r:this._core.centerColor[0],
            g:this._core.centerColor[1],
            b:this._core.centerColor[2]
        };
    };

    SceneJS.Fresnel.prototype.setEdgeColor = function (color) {
        var defaultEdgeColor = defaultCore.edgeColor;
        this._core.edgeColor[0] = color.r != undefined ? color.r : defaultEdgeColor[0];
        this._core.edgeColor[1] = color.g != undefined ? color.g : defaultEdgeColor[1];
        this._core.edgeColor[2] = color.b != undefined ? color.b : defaultEdgeColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Fresnel.prototype.getEdgeColor = function () {
        return {
            r:this._core.edgeColor[0],
            g:this._core.edgeColor[1],
            b:this._core.edgeColor[2]
        };
    };

    SceneJS.Fresnel.prototype._compile = function (ctx) {

        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("fresnel");
            this.__core.transparent = false;
            this.__core.partiallyOpaque = false;
        }

        var parentCore = this._engine.display.fresnel;

        if (!this._core.empty) {
            this.__core.diffuse = this._core.applyTo == "color" ? this._core : parentCore.diffuse;
            this.__core.specular = this._core.applyTo == "specular" ? this._core : parentCore.specular;
            this.__core.alpha = this._core.applyTo == "alpha" ? this._core : parentCore.alpha;
            this.__core.reflect = this._core.applyTo == "reflect" ? this._core : parentCore.reflect;
            this.__core.emit = this._core.applyTo == "emit" ? this._core : parentCore.emit;
            this.__core.fragment = this._core.applyTo == "fragment" ? this._core : parentCore.fragment;
            this.__core.transparency = this._core.applyTo == "transparency" ? this._core : parentCore.transparency;
            this.__core.transparent  = parentCore.transparent;
            this.__core.partiallyOpaque  = parentCore.partiallyOpaque;

            if (this._core.applyTo == "alpha" || this._core.applyTo == "transparency") {
                this.__core.transparent = true;
                if (this._core.centerColor[0] >= 1 || this._core.edgeColor[0] >= 1) {
                    this.__core.partiallyOpaque = true;
                }
            }
        }

        this._makeHash(this.__core);

        coreStack[stackLen++] = this.__core;

        this._engine.display.fresnel = this.__core;
        this._compileNodes(ctx);
        this._engine.display.fresnel = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Fresnel.prototype._makeHash = function (core) {
        var hash = [];
        if (core.diffuse) {
            hash.push("d" + core.diffuse.blendMode + ";")
        }
        if (core.specular) {
            hash.push("s" + core.specular.blendMode + ";")
        }
        if (core.alpha) {
            hash.push("a" + core.alpha.blendMode + ";")
        }
        if (core.reflect) {
            hash.push("r" + core.reflect.blendMode + ";")
        }
        if (core.emit) {
            hash.push("e" + core.emit.blendMode + ";")
        }
        if (core.fragment) {
            hash.push("f" + core.fragment.blendMode + ";")
        }
        if (core.transparency) {
            hash.push("t" + core.transparency.blendMode + ";");
        }
        hash.push(core.blendMode + ";");
        hash = hash.join("");

        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Fresnel.prototype._destroy = function () {
    };

})();
;(function () {
    "use strict";

    // The default state core singleton for {@link SceneJS.ColorBuf} nodes
    var defaultCore = {
        type: "cubemap",
        stateId: SceneJS._baseStateId++,
        empty: true,
        texture: null,
        space: "world",
        hash: ""
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.cubemap = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures the color buffer for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Cubemap = SceneJS_NodeFactory.createNodeType("cubemap");

    SceneJS.Cubemap.prototype._init = function (params) {
        if (this._core.useCount === 1) { // This node is first to reference the state core, so sets it up
            this._core.hash = "y";

            if (params.blendMode) {
                if (params.blendMode !== "add" && params.blendMode !== "multiply") {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                            "cubemap blendMode value is unsupported - " +
                            "should be either 'add' or 'multiply'");
                }
            }
            var applyTo = params.applyTo || "reflect";
            if (applyTo !== "reflect" && applyTo !== "light") {
                SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "cubemap applyTo value is unsupported - should be either 'reflect' or 'light'");
            }

            this._core.blendMode = params.blendMode || "multiply";
            this._core.intensity = (params.intensity != undefined && params.intensity != null) ? params.intensity : 1.0;
            this._core.applyTo = SceneJS.CUBEMAP_FLAGS[applyTo];

            var space = params.space || "world";
            if (space !== "view" && space !== "world") {
                SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "cubemap 'space' value is unsupported: '" + space + "' - should be 'view' or 'world'");
            }

            if (space === "view" && applyTo === "reflect") {
                // View-space reflection mapping not supported - defaulting to World-space
                space = "world;"
            }

            this._core.space = space;

            var self = this;

            var gl = this._engine.canvas.gl;
            var texture = gl.createTexture();

            var faces = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
            ];

            var images = new Array(6);
            var loadFailed = false;

            var imagesToLoad = 6;
            for (var i = 0; i < faces.length; i++) {

                var image = new Image();

                image.onload = (function(index) {

                    var _image = image;

                    return function () {

                        if (loadFailed) {
                            return;
                        }

                        images[index] = _image;

                        if (--imagesToLoad === 0) {

                            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

                            for (var j = 0, lenj = images.length; j < lenj; j++) {
                                gl.texImage2D(faces[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[j]);
                            }

                            self._core.texture = new SceneJS._webgl.Texture2D(gl, {
                                texture: texture,
                                target: gl.TEXTURE_CUBE_MAP,
                                minFilter: gl.LINEAR_MIPMAP_LINEAR,
                                magFilter: gl.LINEAR,
                                wrapS: gl.CLAMP_TO_EDGE,
                                wrapT: gl.CLAMP_TO_EDGE
                            });

                            var minDim = Math.min(_image.width, _image.height);
                            self._core.mipLevels = SceneJS_math_log2(minDim);

                            self._engine.display.imageDirty = true;
                        }
                    };
                })(i);

                image.onerror = function () {
                    loadFailed = true;
                };

                image.src = params.src[i];
            }
        }
    };

    SceneJS.Cubemap.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("cubemap");
        }
        var parentCore = this._engine.display.cubemap;
        if (!this._core.empty) {
            this.__core.layers = (parentCore && parentCore.layers) ? parentCore.layers.concat([this._core]) : [this._core];
        }
        this._makeHash(this.__core);
        coreStack[stackLen++] = this.__core;
        this._engine.display.cubemap = this.__core;
        this._compileNodes(ctx);
        this._engine.display.cubemap = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Cubemap.prototype._makeHash = function (core) {
        var hash;
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var hashParts = [];
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.applyTo);
                hashParts.push("/");
                hashParts.push(texLayer.space);
                hashParts.push("/");
                hashParts.push(texLayer.blendMode);
            }
            hash = hashParts.join("");
        } else {
            hash = "";
        }
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Cubemap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last resource user
            if (this._core.texture) {
                this._core.texture.destroy();
                this._core.texture = null;
            }
        }
    }

})();
;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
(function () {
    "use strict";

    // The default state core singleton for {@link SceneJS.RegionMap} nodes
    var defaultCore = {
        type: "regionMap",
        stateId: SceneJS._baseStateId++,
        empty: true,
        texture: null,
        regionColor:[ -1.0, -1.0, -1.0 ],    // Highlight off by default
        highlightFactor:[ 1.5, 1.5, 0.0 ],
        hideAlpha: 0.0,
        regionData: [],
        mode: "info",
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.regionMap = defaultCore;
            stackLen = 0;
        });

    var stackLen = 0;
    var validModes = {
        info: true,
        highlight: true,
        hide: true,
        isolate: true
    };

    /**
     * @class Scene graph node which defines a color-coded region map
     * @extends SceneJS.Node
     */
    SceneJS.RegionMap = SceneJS_NodeFactory.createNodeType("regionMap");

    SceneJS.RegionMap.prototype._init = function (params) {

        var self = this;

        if (this._core.useCount == 1) { // This node is the resource definer

            SceneJS._apply({
                    regionMap: null
                },
                this._core);

            // Index of UV layer for this region map

            var applyFrom = params.applyFrom || "uv";
            if (applyFrom.substring(0,2) !== "uv") {
                SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "texture applyFrom value is unsupported - should be 'uv<index>'");
            }
            var uvLayerIdx = 0;
            if (applyFrom !== "uv") {
                uvLayerIdx = applyFrom.substring(2);
                if (isNaN(uvLayerIdx)) {
                    SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value invalid - should be 'uv<index>'");
                }
            }
            this._core.uvLayerIdx = uvLayerIdx;

            if (params.src) {

                // Load from URL

                this._initTexture();
                this._core.src = params.src;
                this._loadTexture(params.src);

            } else if (params.image) {

                // Create from image

                this._initTexture(params.preloadColor);
                this._core.image = params.image;
                this._setTextureImage(params.image);
            }

            this._core.webglRestored = function () {

                if (self._core.image) {
                    self._initTexture();
                    self._setTextureImage(self._core.image);

                } else if (self._core.src) {
                    self._initTexture();
                    self._loadTexture(self._core.src);

                } else if (self._core.target) {
                    // Don't need to rebind anything for targets
                }
            };

            this.setRegionColor(params.regionColor);
            this.setHighlightFactor(params.highlightFactor);
            this.setHideAlpha(params.hideAlpha);
            this.setRegionData(params.regionData);
            this.setMode(params.mode);
        }
    };

    SceneJS.RegionMap.prototype._initTexture = function () {

        var gl = this._engine.canvas.gl;

        // Keep this for a little bit for debugging
        var preloadColor = {r: 0.57735, g: 0.57735, b: 0.57735};
        preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;
        preloadColor = new Uint8Array([
            Math.floor(preloadColor.r * 255),
            Math.floor(preloadColor.g * 255),
            Math.floor(preloadColor.b * 255),
            Math.floor(preloadColor.a * 255)
        ]);

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
        this._setCoreTexture(texture);
    };

    SceneJS.RegionMap.prototype._loadTexture = function (src) {
        var self = this;
        var image = new Image();
        var loaded = false;
        var taskFinished = false;

        image.onload = function () {
            self._setTextureImage(image);
            loaded = true;
            self._engine.display.imageDirty = true;
        };

        this._fetchImage(image, src);
    };

    SceneJS.RegionMap.prototype._fetchImage = function (image, src) {
        if (src.indexOf("data") == 0) {  // Image data
            image.src = src;
        } else { // Image file
            image.crossOrigin = "Anonymous";
            image.src = src;
        }
    };

    SceneJS.RegionMap.prototype._setTextureImage = function (image) {
        var gl = this._engine.canvas.gl;
        var texture = this._core.texture ? this._core.texture.texture : gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        this._core.image = image;
        this._setCoreTexture(texture);
    };

    SceneJS.RegionMap.prototype._setCoreTexture = function (texture) {
        var gl = this._engine.canvas.gl;

        this._core.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", gl.NEAREST_MIPMAP_NEAREST),  // Don't want any interpolation
            magFilter: this._getGLOption("magFilter", gl.NEAREST),
            wrapS: this._getGLOption("wrapS", gl.REPEAT),
            wrapT: this._getGLOption("wrapT", gl.REPEAT),
            isDepth: this._getOption(this._core.isDepth, false),
            depthMode: this._getGLOption("depthMode", gl.LUMINANCE),
            depthCompareMode: this._getGLOption("depthCompareMode", gl.COMPARE_R_TO_TEXTURE),
            depthCompareFunc: this._getGLOption("depthCompareFunc", gl.LEQUAL),
            flipY: this._getOption(this._core.flipY, true),
            width: this._getOption(this._core.width, 1),
            height: this._getOption(this._core.height, 1),
            internalFormat: this._getGLOption("internalFormat", gl.ALPHA),
            sourceFormat: this._getGLOption("sourceFormat", gl.ALPHA),
            sourceType: this._getGLOption("sourceType", gl.UNSIGNED_BYTE),
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            this._core.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.RegionMap.prototype._getGLOption = function (name, defaultVal) {
        var gl = this._engine.canvas.gl;
        var value = this._core[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        return gl[glName];
    };

    SceneJS.RegionMap.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    SceneJS.RegionMap.prototype.setSrc = function (src) {
        this._core.image = null;
        this._core.src = src;
        this._core.target = null;
        this._loadTexture(src);
    };

    SceneJS.RegionMap.prototype.setImage = function (image) {
        this._core.image = image;
        this._core.src = null;
        this._core.target = null;
        this._setTextureImage(image);
    };

    SceneJS.RegionMap.prototype.setTarget = function (target) {
        if (target.type != "colorTarget" && target.type != "depthTarget") {
            console.log("Target node type not compatible: " + target.type);
            return;
        }
        delete this._core.src;
        this._core.target = target;
        this._core.src = null;
        this._core.image = null;
        this._core.texture = target._core.renderBuf.getTexture(); // TODO: what happens when the target is destroyed?
        this._core.texture.bufType = target._core.bufType;
        this._engine.display.imageDirty = true;
    };

    SceneJS.RegionMap.prototype.setRegionColor = function (color) {
        var defaultHighlightColor = defaultCore.regionColor;
        this._core.regionColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultHighlightColor[0],
            color.g != undefined && color.g != null ? color.g : defaultHighlightColor[1],
            color.b != undefined && color.b != null ? color.b : defaultHighlightColor[2]
        ] : defaultCore.regionColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setHighlightFactor = function (color) {
        var defaultHighlightFactor = defaultCore.highlightFactor;
        this._core.highlightFactor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultHighlightFactor[0],
            color.g != undefined && color.g != null ? color.g : defaultHighlightFactor[1],
            color.b != undefined && color.b != null ? color.b : defaultHighlightFactor[2]
        ] : defaultCore.highlightFactor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setHideAlpha = function (hideAlpha) {
        this._core.hideAlpha = hideAlpha != undefined ? hideAlpha : defaultCore.hideAlpha;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setMode = function (mode) {
        var wasTransparent = !!this._core.transparent;
        this._core.mode = mode && validModes[mode] ? mode : defaultCore.mode;
        this._core.transparent = this._core.mode === "hide" || this._core.mode === "isolate";
        if (wasTransparent !== this._core.transparent) {
            this._engine.display.objectListDirty = true;
        }
        this._engine.branchDirty(this);
        this._engine.display.imageDirty = true;
        this._core.hash = "reg-" + mode;
        return this;
    };

    SceneJS.RegionMap.prototype.setRegionData = function (data) {
        this._core.regionData = data ? data : defaultCore.regionData;
        return this;
    };


    SceneJS.RegionMap.prototype._compile = function (ctx) {
        var parentCore = this._engine.display.regionMap;
        this._engine.display.regionMap = this._core;
        this._compileNodes(ctx);
        this._engine.display.regionMap = parentCore;
    };

    SceneJS.RegionMap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last core user
            if (this._core.texture && !this._core.target) { // Don't wipe out target texture
                this._core.texture.destroy();
                this._core.texture = null;
            }
        }
    };

})();
;(function () {
    "use strict";

    SceneJS.GlobalCubemap = function (scene, id, cfg) {
        this.scene = scene;
        this.id = id;
        this.intensity = (cfg.intensity !== undefined && cfg.intensity !== null) ? cfg.intensity : 1.0;

        var space = cfg.space || "world";
        if (space !== "view" && space !== "world") {
            console.error("cubemap 'space' value is unsupported: '" + space + "' - should be 'view' or 'world' - defaulting to 'world'");
            space = "world";
        }

        this.space = space;
        this.hash = [this.space].join("");

        var self = this;

        var gl = scene._engine.canvas.gl;
        var texture = gl.createTexture();
        var faces = [
            gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];
        var images = new Array(6);
        var loadFailed = false;
        var imagesToLoad = 6;
        for (var i = 0; i < faces.length; i++) {
            var image = new Image();
            image.onload = (function (index) {
                var _image = image;
                return function () {
                    if (loadFailed) {
                        return;
                    }
                    images[index] = _image;
                    if (--imagesToLoad === 0) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                        for (var j = 0, lenj = images.length; j < lenj; j++) {
                            gl.texImage2D(faces[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, images[j]);
                        }
                        self.texture = new SceneJS._webgl.Texture2D(gl, {
                            texture: texture,
                            target: gl.TEXTURE_CUBE_MAP,
                            minFilter: gl.LINEAR_MIPMAP_LINEAR,
                            magFilter: gl.LINEAR,
                            wrapS: gl.CLAMP_TO_EDGE,
                            wrapT: gl.CLAMP_TO_EDGE
                        });
                        var minDim = Math.min(_image.width, _image.height);
                        self.mipLevels = SceneJS_math_log2(minDim);
                        scene._engine.display.imageDirty = true;
                    }
                };
            })(i);
            image.onerror = function () {
                loadFailed = true;
            };
            image.src = cfg.src[i];
        }
    };

    SceneJS.GlobalCubemap.prototype.destroy = function () {
        if (this.texture) {
            this.texture.destroy();
            this.texture = null;
        }
    };
})();
;/**
 * @class Scene graph node which defines the modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */

(function () {
    "use strict";

    var coreStack = [];
    var stackLen = 0;

    var defaultCore = {
        type:"xform",

        stateId: SceneJS._baseStateId++,
        matrix: mat4.create(),
        normalMatrix: mat4.create()
    };

    SceneJS.XForm = SceneJS_NodeFactory.createNodeType("xform");

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.modelTransform = defaultCore;
            stackLen = 0;
        });

    SceneJS.XForm.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node is the resource definer

            this._core.matrix = mat4.create();
            this._core.normalMatrix = mat4.create();

            if (params.elements) {
                this.setElements(params.elements);
            }
        }
    };

    /**
     * Get Model matrix
     * @return {*}
     */
    SceneJS.XForm.prototype.getMatrix = function() {
        return this._core.matrix;
    };

    SceneJS.XForm.prototype.setElements = function (elements) {

        if (elements.length != 16) {
            SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.XForm elements should number 16");
        }

        var core = this._core;

        core.matrix.set(elements);

        mat4.invert(core.normalMatrix, core.matrix);
        mat4.transpose(core.normalMatrix, core.normalMatrix);
        
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.XForm.prototype.getElements = function () {
        return this._core.matrix;
    };

    SceneJS.XForm.prototype._compile = function (ctx) {
        this._engine.display.modelTransform = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.modelTransform = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();

;/**
 * Container for custom node types
 */

(function () {
    "use strict";

    SceneJS.Types = new (function () {

        /**
         * Installs a node type
         * @param typeName
         * @param methods
         */
        this.addType = function (typeName, methods) {
            var type = SceneJS_NodeFactory.createNodeType(typeName);
            var method;
            for (var methodName in methods) {
                if (methods.hasOwnProperty(methodName)) {
                    method = methods[methodName];
                    switch (methodName) {
                        case "init": // Deprecated
                        case "construct":
                            (function () {
                                var _method = methods[methodName];
                                type.prototype._init = function (params) {
                                    _method.call(this, params);
                                };

                                // Mark node type as a plugin
                                type.prototype._fromPlugin = true;
                            })();
                            break;
                        case "destroy": // Deprecated
                        case "destruct":
                            type.prototype._destroy = method;
                            break;
                        default:
                            type.prototype[methodName] = method;
                    }
                }
            }
        };

        /**
         * Tests if given node type is installed
         * @param typeName
         */
        this.hasType = function (typeName) {
            return !!SceneJS_NodeFactory.nodeTypes[typeName];
        };
    })();
})();



;/**
 * @class Display compiled from a {@link SceneJS.Scene}, providing methods to render and pick.
 * @private
 *
 * <p>A Display is a container of {@link SceneJS_Object}s which are created (or updated) by a depth-first
 * <b>compilation traversal</b> of a {@link SceneJS.Scene}.</b>
 *
 * <h2>Rendering Pipeline</h2>
 *
 * <p>Conceptually, a Display implements a pipeline with the following stages:</p>
 *
 * <ol>
 * <li>Create or update {@link SceneJS_Object}s during scene compilation</li>
 * <li>Organise the {@link SceneJS_Object} into an <b>object list</b></li>
 * <li>Determine the GL state sort order for the object list</li>
 * <li>State sort the object list</li>
 * <li>Create a <b>draw list</b> containing {@link SceneJS_Chunk}s belonging to the {@link SceneJS_Object}s in the object list</li>
 * <li>Render the draw list to draw the image</li>
 * </ol>
 *
 * <p>An update to the scene causes the pipeline to be re-executed from one of these stages, and SceneJS is designed
 * so that the pipeline is always re-executed from the latest stage possible to avoid redoing work.</p>
 *
 * <p>For example:</p>
 *
 * <ul>
 * <li>when an object is created or updated, we need to (re)do stages 2, 3, 4, 5 and 6</li>
 * <li>when an object is made invisible, we need to redo stages 5 and 6</li>
 * <li>when an object is assigned to a different scene render layer (works like a render bin), we need to redo
 *   stages 3, 4, 5, and 6</li>
 *<li>when the colour of an object changes, or maybe when the viewpoint changes, we simplt redo stage 6</li>
 * </ul>
 *
 * <h2>Object Creation</h2>
 * <p>The object soup (stage 1) is constructed by a depth-first traversal of the scene graph, which we think of as
 * "compiling" the scene graph into the Display. As traversal visits each scene node, the node's state core is
 * set on the Display (such as {@link #flags}, {@link #layer}, {@link #renderer} etc), which we think of as the
 * cores that are active at that instant during compilation. Each of the scene's leaf nodes is always
 * a {@link SceneJS.Geometry}, and when traversal visits one of those it calls {@link #buildObject} to create an
 * object in the soup. For each of the currently active cores, the object is given a {@link SceneJS_Chunk}
 * containing the WebGL calls for rendering it.</p>
 *
 * <p>The object also gets a shader (implemented by {@link SceneJS_Program}), taylored to render those state cores.</p>
 *
 * <p>Limited re-compilation may also be done on portions of a scene that have been added or sufficiently modified. When
 * traversal visits a {@link SceneJS.Geometry} for which an object already exists in the display, {@link #buildObject}
 * may update the {@link SceneJS_Chunk}s on the object as required for any changes in the core soup since the
 * last time the object was built. If differences among the cores require it, then {@link #buildObject} may also replace
 * the object's {@link SceneJS_Program} in order to render the new core soup configuration.</p>
 *
 * <p>So in summary, to each {@link SceneJS_Object} it builds, {@link #buildObject} creates a list of
 * {@link SceneJS_Chunk}s to render the set of node state cores that are currently set on the {@link SceneJS_Display}.
 * When {@link #buildObject} is re-building an existing object, it may replace one or more {@link SceneJS_Chunk}s
 * for state cores that have changed from the last time the object was built or re-built.</p>

 * <h2>Object Destruction</h2>
 * <p>Destruction of a scene graph branch simply involves a call to {@link #removeObject} for each {@link SceneJS.Geometry}
 * in the branch.</p>
 *
 * <h2>Draw List</h2>
 * <p>The draw list is actually comprised of two lists of state chunks: a "pick" list to render a pick buffer
 * for colour-indexed GPU picking, along with a "draw" list for normal image rendering. The chunks in these lists
 * are held in the state-sorted order of their objects in #_objectList, with runs of duplicate states removed.</p>
 *
 * <p>After a scene update, we set a flag on the display to indicate the stage we will need to redo from. The pipeline is
 * then lazy-redone on the next call to #render or #pick.</p>
 */

(function() {
    "use strict";

    var SceneJS_Display = window.SceneJS_Display = function (stats, cfg) {

        // Collects runtime statistics
        this.stats = stats || {};

        // Display is bound to the lifetime of an HTML5 canvas
        this._canvas = cfg.canvas;

        // Factory which creates and recycles {@link SceneJS_Program} instances
        this._programFactory = new SceneJS_ProgramFactory(this.stats, {
            canvas: cfg.canvas
        });

        // Factory which creates and recycles {@link SceneJS.Chunk} instances
        this._chunkFactory = new SceneJS_ChunkFactory();

        /**
         * True when the background is to be transparent
         * @type {boolean}
         */
        this.transparent = cfg.transparent === true;

        /**
         * Depth sort mode. Default to only sorting transparent objects.
         */
        this.depthSort = cfg.depthSort === true;

        /**
         * Set true when shader should attempt to auto-generate tangents if OES_standard_derivatives is supported.
         * @type {boolean}
         */
        this.autoTangents = cfg.autoTangents === true;

        /**
         * Set true when shader should convert Phong textures from sRGB to linear space.
         * @type {boolean}
         */
        this.gammaInputPhong = cfg.gammaInputPhong === true;

        /**
         * Node state core for the last {@link SceneJS.Flags} visited during scene graph compilation traversal
         * @type Object
         */
        this.properties = null;

        /**
         * Node state core for the last {@link SceneJS.Material} visited during scene graph compilation traversal
         * @type Object
         */
        this.material = null;

        /**
         * Node state core for the last {@link SceneJS.Texture} visited during scene graph compilation traversal
         * @type Object
         */
        this.texture = null;

        /**
         * Node state core for the last {@link SceneJS.Fresnel} visited during scene graph compilation traversal
         * @type Object
         */
        this.fresnel = null;

        /**
         * Node state core for the last {@link SceneJS.Cubemap} visited during scene graph compilation traversal
         * @type Object
         */
        this.cubemap = null;

        /**
         * Node state core for the last {@link SceneJS.XForm} visited during scene graph compilation traversal
         * @type Object
         */
        this.modelTransform = null;

        /**
         * Node state core for the last {@link SceneJS.RegionMap} visited during scene graph compilation traversal
         * @type Object
         */
        this.regionMap = null;

        /**
         * Node state core for the last {@link SceneJS.MorphGeometry} visited during scene graph compilation traversal
         * @type Object
         */
        this.morphGeometry = null;

        /**
         * Node state core for the last {@link SceneJS.Geometry} visited during scene graph compilation traversal
         * @type Object
         */
        this.geometry = null;

        /**
         * The objects in the display
         */
        this._objects = {};

        /**
         * Ambient color, which must be given to gl.clearColor before draw list iteration
         */
        this._ambientColor = [0.7, 0.7, 0.8];

        this.projection = {
            type: "perspective",
            fov: 60.0,
            aspect: 1.0,
            near: 0.1,
            far: 500.0,
            pan: 0
        };

        this.projectionMatrix = mat4.create();

        this.buildProjectionMatrix();

        this.camera = {
            eye: new Float32Array([0, 0, 10]),
            look: new Float32Array([0, 0, 0]),
            up: new Float32Array([0, 1, 0])
        };

        this.viewMatrix = mat4.create();
        this.hasDeviceMatrix = false;
        this.deviceMatrix = mat4.create();

        this.buildViewMatrix();

        this.lights = [
            {
                mode: "dir",
                color: new Float32Array([1.0, 1.0, 1.0 ]),
                diffuse: true,
                specular: true,
                dir: new Float32Array([-0.5, -0.5, -1.0 ]),
                space: "view"
            },
            {
                mode: "dir",
                color: new Float32Array([1.0, 1.0, 1.0 ]),
                diffuse: false,
                specular: true,
                dir: new Float32Array([1.0, -0.9, -0.7 ]),
                space: "view"
            }
        ];
        this.lightHash = "dirsdv/dirsv/";

        this.clips = {
            clips : [],
            clipFade: false,
            clipDiscard: false,
            enabled: false
        };
        this.clipsHash = "";

        this.reflections = {
            reflections: {},
            activeReflection: null
        };
        this.reflectionsHash = "";

        this.lightmaps = {
            lightmaps: {},
            activeLightmap: null
        };
        this.lightmapsHash = "";

        this.highlightColor = new Float32Array([1.5, 1.5, 0.5]);
        this.desatParams = new Float32Array([0.9, 0.3]);
        this.fogParams = new Float32Array([0, 1000, 0, 1]);
        this.fogColor = new Float32Array([1, 1, 1, 0.01]);
        this.fogEnabled = false;
        this.xrayColor = new Float32Array([0.0, 0.0, 0.1]);
        this.fogMode = SceneJS.DISPLAY_FLAGS.FOG_LINEAR;
        this.viewport = new Float32Array([0, 0, this._canvas.canvas.width, this._canvas.canvas.height]);

        /**
         * The object list, containing all elements of #_objects, kept in GL state-sorted order
         */

        this._opaqueObjects = [];
        this._numOpaqueObjects = 0;

        this._transparentObjects = [];
        this._numTransparentObjects = 0;

        this._pickLookup = [];

        /* The frame context holds state shared across a single render of the draw list, along with any results of
         * the render, such as pick hits
         */
        this._frameCtx = {
            regionData: [],
            canvas: this._canvas,           // The canvas
            VAO: null                       // Vertex array object extension
        };

        /*-------------------------------------------------------------------------------------
         * Flags which schedule what the display is to do when #render is next called.
         *------------------------------------------------------------------------------------*/
        
        /**
         * Flags the object list as needing to be rebuilt from existing objects on the next call to {@link #render} or {@link #pick}.
         * Setting this will cause the rendering pipeline to be executed from stage #2 (see class comment),
         * causing object list rebuild, state order determination, state sort, draw list construction and image render.
         * @type Boolean
         */
        this.objectListDirty = true;

        /**
         * Flags the image as needing to be redrawn from the draw list on the next call to {@link #render} or {@link #pick}.
         * Setting this will cause the rendering pipeline to be executed from stage #6 (see class comment),
         * causing the image render.
         * @type Boolean
         */
        this.imageDirty = true;

        this._nextProgramId = 0;

        this.postProcessPipelineOpaque = [];
        this.postProcessPipelineTransparent = [];
        this.postProcessPipelineFinal = [];

        this._postProcessTypes = {};
        this._postProcesses = {};
        this.framebuffers = {};

        this.mainFramebuffer = null;
        this.mainFramebufferParams = null;
        this.oitAccumulateFramebuffer = null;
        this.oitPostprocessType = null;
        this.oitPostprocess = null;
        this.blitPostprocessType = null;
        this.blitPostprocess = null;

        this.transparencyMode = SceneJS.TRANSPARENCY_FLAGS.ALPHA;
        this.depthSort = false;

        this.postProcessInitialized = false;
        this.oitInitialized = false;
    };

    SceneJS_Display.prototype.initPostProcess = function() {
        if (this.postProcessInitialized) {
            return;
        }

        this.mainFramebuffer = this.createFramebuffer("__MAIN", this.mainFramebufferParams);

        this.blitPostprocessType = this.createPostProcessType("__BLIT", [
           "precision highp float;",
           "varying vec2 vUV;",
           "uniform sampler2D uTexture;",
           "void main() {",
           "    gl_FragColor = texture2D(uTexture, vUV);",
           "}"
        ].join("\n"));

        this.blitPostprocess = new SceneJS_PostProcessStage(this, {
            type: "__BLIT",
            textures: {
                uTexture: {
                    framebuffer: "__MAIN",
                    target: "color"
                }
            }
        });

        this.postProcessInitialized = true;
    };

    SceneJS_Display.prototype.initOIT = function() {
        if (this.oitInitialized) {
            return;
        }

        this.initPostProcess();

        this.oitAccumulateFramebuffer = this.createFramebuffer("__OIT_ACCUMULATE", {
            colorAttachments: [
                {
                    type: "FLOAT"
                }
            ],
            sharedDepthBuffer: this.mainFramebuffer
        });

        this.oitDepthBuffer = this.createFramebuffer("__OIT_DEPTH", {
            colorAttachments: 0
        });

        this.oitPostprocessType = this.createPostProcessType("__OIT", [
           "precision highp float;",
           "varying vec2 vUV;",
           "uniform vec2 uTexelOffset;",
           "uniform sampler2D uAccumulate;",
           "#define THRESH 0.1176",
           "float edgeFilter(vec2 center, vec2 a0, vec2 a1, vec2 a2, vec2 a3){", 
           "    vec4 luminance = vec4(a0.x, a1.x , a2.x, a3.x);",
           "    vec4 w = 1.0 - step(THRESH, abs(luminance - center.x));", 
           "    float W = w.x + w.y + w.z + w.w;",
           "    w.x = W == 0.0 ? 1.0 : w.x;",  
           "    W = W == 0.0 ? 1.0 : W;",  
           "    return (w.x * a0.y + w.y * a1.y + w.z * a2.y + w.w * a3.y) / W;",
           "}",
           "void main() {",
           "    vec4 accum = texture2D(uAccumulate, vUV);",
           "    vec4 a0 = texture2D(uAccumulate, vUV + vec2(uTexelOffset.x, 0.0));",
           "    vec4 a1 = texture2D(uAccumulate, vUV - vec2(uTexelOffset.x, 0.0));",
           "    vec4 a2 = texture2D(uAccumulate, vUV + vec2(0.0, uTexelOffset.y));",
           "    vec4 a3 = texture2D(uAccumulate, vUV - vec2(0.0, uTexelOffset.y));",
           "    accum.rg /= max(accum.b, 0.001);",     
           "    a0.rg /= max(a0.b, 0.001);",     
           "    a1.rg /= max(a1.b, 0.001);",     
           "    a2.rg /= max(a2.b, 0.001);",     
           "    a3.rg /= max(a3.b, 0.001);",     
           "    vec3 ycocg = vec3(accum.rg, edgeFilter(accum.rg, a0.rg, a1.rg, a2.rg, a3.rg));",
           "    bool checkerboard = mod(gl_FragCoord.x, 2.0) == mod(gl_FragCoord.y, 2.0);",
           "    ycocg.gb = checkerboard ? ycocg.gb : ycocg.bg;",
           "    vec3 rgb = vec3(ycocg.r + ycocg.g - ycocg.b, ycocg.r + ycocg.b, ycocg.r - ycocg.g - ycocg.b);",
           "    float a = 1.0 - accum.a;",
           "    gl_FragColor = vec4(a * rgb, a);",
           "}"
        ].join("\n"));

        this.oitPostprocess = new SceneJS_PostProcessStage(this, {
            type: "__OIT",
            uniforms: {
                uTexelOffset: new Float32Array([1 / window.innerWidth, 1 / window.innerHeight])
            },
            textures: {
                uAccumulate: {
                    framebuffer: "__OIT_ACCUMULATE",
                    target: "color"
                }
            }
        });

        this.oitInitialized = true;
    };

    SceneJS_Display.prototype.setTransparencyMode = function (mode) {
        this.transparencyMode = mode;

        if (mode === SceneJS.TRANSPARENCY_FLAGS.WEIGHTED_OIT) {
            this.initOIT();
        }

        this.objectListDirty = true;
    };

    SceneJS_Display.prototype.createFramebuffer = function (id, cfg) {
        if (this.framebuffers[id]) {
            this.framebuffers[id].destroy();
        }

        cfg = cfg || {};
        cfg.canvas = this._canvas;
        this.framebuffers[id] = new SceneJS._webgl.Framebuffer(cfg);

        return this.framebuffers[id];
    };

    SceneJS_Display.prototype.destroyFramebuffer = function (id) {
        if (this.framebuffers[id]) {
            this.framebuffers[id].destroy();
        }

        delete this.framebuffers[id];
    };

    SceneJS_Display.prototype.getPostProcessStage = function (id) {
        return this._postProcesses[id];
    };

    SceneJS_Display.prototype.createPostProcessType = function (type, src, option) {
        this._postProcessTypes[type] = new SceneJS_PostProcess(this.stats, this._canvas.gl, src, option);
        return this._postProcessTypes[type];
    };

    SceneJS_Display.prototype.postProcessOpaque = function (cfg) {
        var i, len;
        cfg = cfg || [];

        if (cfg.length > 0) {
            this.initPostProcess();
        }


        for (i = 0, len = this.postProcessPipelineOpaque.length; i < len; ++i) {
            var pp = this.postProcessPipelineOpaque[i];
            delete this._postProcesses[pp.id];
            pp.destroy();
        }

        this.postProcessPipelineOpaque.length = 0;

        for (i = 0, len = cfg.length; i < len; ++i) {
            var stage = cfg[i];
            var id = stage.id;

            this._postProcesses[id] = new SceneJS_PostProcessStage(this, stage);
            this.postProcessPipelineOpaque.push(this._postProcesses[id]);
        }

        this.imageDirty = true;
    };

    SceneJS_Display.prototype.postProcessFinal = function (cfg) {
        var i, len;
        cfg = cfg || [];

        if (cfg.length > 0) {
            this.initPostProcess();
        }

        for (i = 0, len = this.postProcessPipelineFinal.length; i < len; ++i) {
            var pp = this.postProcessPipelineFinal[i];
            delete this._postProcesses[pp.id];
            pp.destroy();
        }

        this.postProcessPipelineFinal.length = 0;

        for (i = 0, len = cfg.length; i < len; ++i) {
            var stage = cfg[i];
            var id = stage.id;

            this._postProcesses[id] = new SceneJS_PostProcessStage(this, stage);
            this.postProcessPipelineFinal.push(this._postProcesses[id]);
        }

        this.imageDirty = true;
    };

    /**
     * Reallocates WebGL resources for objects within this display
     */
    SceneJS_Display.prototype.webglRestored = function () {
        this._programFactory.webglRestored();// Reallocate programs
        this._chunkFactory.webglRestored(); // Recache shader var locations
        var gl = this._canvas.gl;
        if (this.pickBuf) {
            this.pickBuf.webglRestored(gl);          // Rebuild pick buffers
        }

        for (var fb in this.framebuffers) {
            this.framebuffers[fb].webglRestored(gl);
        }

        for (var pp in this._postProcessTypes) {
            this._postProcessTypes[pp].webglRestored(gl);
        }

        this.imageDirty = true;             // Need redraw
    };

    SceneJS_Display.prototype.setViewport = function (xmin, ymin, width, height) {
        this.viewport[0] = xmin;
        this.viewport[1] = ymin;
        this.viewport[2] = width;
        this.viewport[3] = height;
        this.imageDirty = true;
    };


    SceneJS_Display.prototype.buildProjectionMatrix = function () {
        var projection = this.projection;
        var projectionMatrix = this.projectionMatrix;

        if (projection.type == "ortho") {
            mat4.ortho(
                projectionMatrix,
                projection.left,
                projection.right,
                projection.bottom,
                projection.top,
                projection.near,
                projection.far);

        } else if (projection.type == "frustum") {
            mat4.frustum(
                projectionMatrix,
                projection.left,
                projection.right,
                projection.bottom,
                projection.top,
                projection.near,
                projection.far);

        } else if (projection.type == "perspective") {
            var fov = projection.fov;

            fov = Math.min(fov, 120);

            mat4.perspective(
                projectionMatrix,
                fov * Math.PI / 180.0,
                projection.aspect,
                projection.near,
                projection.far);
        }

        if (projection.pan) {
            // Post-multiply a screen-space pan
            var pan = projection.pan;
            var panMatrix = mat4.fromTranslation(mat4.create(), [pan.x || 0, pan.y || 0, pan.z || 0]);
            mat4.multiply(projectionMatrix, panMatrix, projectionMatrix);
        }
    };

    SceneJS_Display.prototype.buildViewMatrix = function () {
        var camera = this.camera;
        var viewMatrix = this.viewMatrix;
        mat4.lookAt(viewMatrix, camera.eye, camera.look, camera.up);
        if (this.hasDeviceMatrix) {
            var tempmatrix = mat4.create();
            mat4.multiply(tempmatrix, this.deviceMatrix, viewMatrix); // Post-multiply the device matrix by the lookat matrix
            viewMatrix.set(tempmatrix);
        }
    };

    /**
     * Internally creates (or updates) a {@link SceneJS_Object} of the given ID from whatever node state cores are currently set
     * on this {@link SceneJS_Display}. The object is created if it does not already exist in the display, otherwise it is
     * updated with the current state cores, possibly replacing cores already referenced by the object.
     *
     * @param {String} objectId ID of object to create or update
     */
    SceneJS_Display.prototype.buildObject = function (objectId, params) {

        var object = this._objects[objectId];

        if (!object) { // Create object
            object = this._objects[objectId] = new SceneJS_Object(objectId);
        }

        object.modelTransform = this.modelTransform;
        object.viewMatrix = this.viewMatrix;
        object.projectionMatrix = this.projectionMatrix;
        object.texture = this.texture;
        object.cubemap = this.cubemap;
        object.geometry = this.geometry;
        object.morphGeometry = this.morphGeometry;
        object.properties = this.properties;
        object.material = this.material;
        object.fresnel = this.fresnel;
        object.regionMap = this.regionMap;
        object.backfaces = params.backfaces;
        object.addBlend = params.addBlend;
        object.layer = params.layer;

        var hash = ([                   // Build current state hash
            this.geometry.hash,
            this.morphGeometry.hash,
            this.texture.hash,
            this.fresnel.hash,
            this.cubemap.hash,
            this.lightHash,
            this.clipsHash,
            this.reflectionsHash,
            this.lightmapsHash,
            this.properties.hash,
            ((this.transparencyMode & SceneJS.TRANSPARENCY_FLAGS.TWO_PASS) && object.isPartiallyOpaque()) ? "pt" : "",
            this.regionMap.hash,
            this.fogEnabled ? ("f" + this.fogMode) : "",
        ]).join(";");

        if (!object.program || hash != object.hash) {
            // Get new program for object if no program or hash mismatch
            if (object.program) {
                this._programFactory.putProgram(object.program.draw);
                this._programFactory.putProgram(object.program.xray);
                this._programFactory.putProgram(object.program.pick);
                this._programFactory.putProgram(object.program.pickTriangle);
                this._programFactory.putProgram(object.program.depth);
                this._programFactory.putProgram(object.program.drawTexture);
                SceneJS_ProgramSourceFactory.putSource(object.hash);
            }

            var source = SceneJS_ProgramSourceFactory.getSource(hash, this, object);

            object.program = {
                draw: this._programFactory.getProgram(hash + "-draw", source.drawVertexSrc, source.drawFragmentSrc),
                xray: this._programFactory.getProgram(hash + "-xray", source.xrayVertexSrc, source.xrayFragmentSrc),
                pick: this._programFactory.getProgram(hash + "-pick", source.pickVertexSrc, source.pickFragmentSrc),
                pickTriangle: this._programFactory.getProgram(hash + "-pickTriangle", source.pickTriangleVertexSrc, source.pickTriangleFragmentSrc),
                depth: this._programFactory.getProgram(hash + "-depth", source.depthVertexSrc, source.depthFragmentSrc),
                drawTexture: this._programFactory.getProgram(hash + "-drawTexture", source.drawTextureVertexSrc, source.drawTextureFragmentSrc),
                id: this._nextProgramId++,
                gl: this._canvas.gl
            };
            object.hash = hash;
            object.sortKey = (object.program.id + 1) * 100000 + object.texture.stateId;
        }

        // Build draw chunks for object
        this._setChunk(object, "draw", 0, "program"); // Must be first
        this._setChunk(object, "draw", 1, "object", [this.properties, this.modelTransform]);
        this._setChunk(object, "draw", 2, "material", [this.material, this.texture, this.fresnel, this.cubemap]);
        this._setChunk(object, "draw", 3, "regionMap", [this.regionMap]);
        this._setChunk(object, "draw", 4, "geometry", [this.morphGeometry, this.geometry]);
        this._setChunk(object, "draw", 5, "draw", [this.geometry]); // Must be last

        this._setChunk(object, "xray", 0, "program"); // Must be first
        this._setChunk(object, "xray", 1, "object", [this.properties, this.modelTransform]);
        this._setChunk(object, "xray", 2, "geometry", [this.morphGeometry, this.geometry]);
        this._setChunk(object, "xray", 3, "draw", [this.geometry]); // Must be last

        this._setChunk(object, "pick", 0, "program"); // Must be first
        this._setChunk(object, "pick", 1, "object", [this.properties, this.modelTransform]);
        this._setChunk(object, "pick", 2, "regionMap", [this.regionMap]);
        this._setChunk(object, "pick", 3, "geometry", [this.morphGeometry, this.geometry]);
        this._setChunk(object, "pick", 4, "draw", [this.geometry]); // Must be last

        this._setChunk(object, "pickTriangle", 0, "program"); // Must be first
        this._setChunk(object, "pickTriangle", 1, "object", [this.properties, this.modelTransform]);
        this._setChunk(object, "pickTriangle", 2, "geometry", [this.morphGeometry, this.geometry]);
        this._setChunk(object, "pickTriangle", 3, "draw", [this.geometry]); // Must be last

        this._setChunk(object, "depth", 0, "program"); // Must be first
        this._setChunk(object, "depth", 1, "object", [this.properties, this.modelTransform]);
        this._setChunk(object, "depth", 2, "geometry", [this.morphGeometry, this.geometry]);
        this._setChunk(object, "depth", 3, "draw", [this.geometry]); // Must be last

        this._setChunk(object, "drawTexture", 0, "program"); // Must be first
        this._setChunk(object, "drawTexture", 1, "object", [this.properties, this.modelTransform]);
        this._setChunk(object, "drawTexture", 2, "material", [this.material, this.texture, this.fresnel, this.cubemap]);
        this._setChunk(object, "drawTexture", 3, "geometry", [this.morphGeometry, this.geometry]);
        this._setChunk(object, "drawTexture", 4, "draw", [this.geometry]); // Must be last

        // At the very least, the object sort order
        // will need be recomputed

        this.objectListDirty = true;
    };


    SceneJS_Display.prototype._setChunk = function (object, renderMode, order, chunkType, cores, core2) {

        var chunkId;
        var chunkClass = this._chunkFactory.chunkTypes[chunkType];

        if (object.chunkSets[renderMode] === undefined) {
            object.chunkSets[renderMode] = [];
        }

        var chunkSet = object.chunkSets[renderMode];

        if (cores) {

            var allEmpty = true;
            for (var i = 0, len = cores.length; i < len; ++i) {
                if (!cores[i].empty) {
                    allEmpty = false;
                    break;
                }
            }
            if (allEmpty) { // Only set default cores for state types that have them
                var oldChunk = chunkSet[order];
                if (oldChunk) {
                    this._chunkFactory.putChunk(oldChunk); // Release previous chunk to pool
                }
                chunkSet[order] = null;
                return;
            }

            // Note that core.stateId can be either a number or a string, that's why we make
            // chunkId a string here.
            // TODO: Would it be better if all were numbers?
            chunkId = 'p' + object.program.id;

            for (var i = 0, len = cores.length; i < len; ++i) {
                chunkId += '_' + cores[i].stateId
            }
        } else {

            // No core supplied, probably a program.
            // Only one chunk of this type per program.
            chunkId = 'p' + object.program.id;
        }

        // This is needed so that chunkFactory can distinguish between draw and geometry
        // chunks with the same core.
        chunkId = order + '__' + chunkId;

        var oldChunk = chunkSet[order];

        if (oldChunk) {
            if (oldChunk.id == chunkId) { // Avoid needless chunk reattachment
                return;
            }
            this._chunkFactory.putChunk(oldChunk); // Release previous chunk to pool
        }

        chunkSet[order] = this._chunkFactory.getChunk(chunkId, chunkType, object.program, cores); // Attach new chunk
    };

    /**
     * Removes an object from this display
     *
     * @param {String} objectId ID of object to remove
     */
    SceneJS_Display.prototype.removeObject = function (objectId) {
        var object = this._objects[objectId];
        if (!object) {
            return;
        }
        this._programFactory.putProgram(object.program);
        object.program = null;
        object.hash = null;
        for (var chunkSet in object.chunkSets) {
            var chunks = object.chunkSets[chunkSet];
            var chunk;
            for (var i = 0, len = chunks.length; i < len; i++) {
                chunk = chunks[i];
                if (chunk) {
                    this._chunkFactory.putChunk(chunk);
                }
            }
        }

        delete this._objects[objectId];
        this.objectListDirty = true;
    };

    /**
     * Render this display. What actually happens in the method depends on what flags are set.
     *
     */
    SceneJS_Display.prototype.prepareScene = function () {
        if (this.objectListDirty) {
            this._buildObjectList();          // Build object render bin
            this.objectListDirty = false;
            this.imageDirty = true;
        }
    };

    /**
     * Render this display. What actually happens in the method depends on what flags are set.
     *
     */
    SceneJS_Display.prototype.render = function (params) {

        params = params || {};

        if (this._canvas.canvas.width == 0 || this._canvas.canvas.height == 0) {
            // Canvas hidden
            return;
        }

        if (this.imageDirty || params.force) {
            this._doDrawList({ // Render, no pick
                clear: (params.clear !== false), // Clear buffers by default
                opaqueOnly: params.opaqueOnly,
                pass: params.pass,
                custom: params.custom
            });
            this.imageDirty = false;
            this.pickBufDirty = true;       // Pick buff will now need rendering on next pick
        }
    };

    SceneJS_Display.prototype._buildObjectList = function () {
        var lastOpaqueIndex = this._numOpaqueObjects;
        var lastTransparentIndex = this._numTransparentObjects;
        var objectId, i;
        var ENABLED_FLAG = SceneJS.PROPERTY_FLAGS.ENABLED;
        var twoPass = !!(this.transparencyMode & SceneJS.TRANSPARENCY_FLAGS.TWO_PASS);


        this._numOpaqueObjects = 0;
        this._numTransparentObjects = 0;
        for (objectId in this._objects) {
            var object = this._objects[objectId];
            if (object.properties.flags & ENABLED_FLAG) {
                if (object.isTransparent()) {
                    this._transparentObjects[this._numTransparentObjects++] = object;
                    if (twoPass  && object.isPartiallyOpaque()) {
                        this._opaqueObjects[this._numOpaqueObjects++] = object;
                    }
                } else {
                    this._opaqueObjects[this._numOpaqueObjects++] = object;
                }
            }
        }

        // Release memory
        this._opaqueObjects.length = this._numOpaqueObjects;
        this._opaqueObjects.sort(sortObjects);
        
        this._transparentObjects.length = this._numTransparentObjects;  
        if (this.transparencyMode & SceneJS.TRANSPARENCY_FLAGS.ORDER_DEPENDENT) {
            this._transparentObjects.sort(sortLayers);
        } else {
            this._transparentObjects.sort(sortObjects);
        }
    };

    function sortObjects(o1, o2) {
        return o1.sortKey - o2.sortKey;
    }

    function sortLayers(o1, o2) {
        return (o1.layer - o2.layer) 
            || (o1.properties.stateId - o2.properties.stateId)  
            || (o1.sortTieBreaker - o2.sortTieBreaker);
    }

    function sortDepth(o1, o2) {
        return (o1.layer - o2.layer) || (o2.getDepth() - o1.getDepth());
    }

    (function () {

        var localRayOrigin = vec3.create();
        var localRayDir = vec3.create();

        var pickViewMatrix = mat4.create();
        var pickProjMatrix = mat4.frustum(mat4.create(), -1, 1, -1, 1, 0.1, 10000);

        var a = vec3.create();
        var b = vec3.create();
        var c = vec3.create();

        var na = vec3.create();
        var nb = vec3.create();
        var nc = vec3.create();

        var uva = vec3.create();
        var uvb = vec3.create();
        var uvc = vec3.create();

        // for lerp
        var a1 = vec3.create();
        var b1 = vec3.create();
        var c1 = vec3.create();
        var a2 = vec3.create();
        var b2 = vec3.create();
        var c2 = vec3.create();

        var tempMat4 = mat4.create();
        var tempMat4b = mat4.create();

        var tempVec4 = vec4.create();
        var tempVec4b = vec4.create();

        var tempVec3 = vec3.create();
        var tempVec3b = vec3.create();
        var tempVec3c = vec3.create();
        var tempVec3d = vec3.create();

        var tempVec2 = vec2.create();
        var tempVec2b = vec2.create();
        var tempVec2c = vec2.create();
        var tempVec2d = vec2.create();


        // Transforms canvas coordinates into a Local-space ray

        var canvasPosToLocalRay = (function () {

            var vmMat = mat4.create();
            var pvMat = mat4.create();
            var pvMatInv = mat4.create();
            var a  = vec4.create(); // Local-space ray endpoints
            var b = vec4.create();

            return function (canvas, object, canvasPos, localRayOrigin, localRayDir) {

                var modelMat = object.modelTransform.matrix;
                var viewMat = object.viewMatrix;
                var projMat = object.projectionMatrix;

                mat4.multiply(vmMat, viewMat, modelMat);
                mat4.multiply(pvMat, projMat, vmMat);
                mat4.invert(pvMatInv, pvMat);

                var canvasWidth = canvas.width;
                var canvasHeight = canvas.height;

                var clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates
                var clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);

                vec4.transformMat4(a, [clipX, clipY, -1, 1], pvMatInv);
                vec3.scale(a, a, 1 / a[3]);

                vec4.transformMat4(b, [clipX, clipY, 1, 1], pvMatInv);
                vec3.scale(b, b, 1 / b[3]);

                localRayOrigin[0] = a[0];
                localRayOrigin[1] = a[1];
                localRayOrigin[2] = a[2];

                vec3.subtract(localRayDir, b, a);
                vec3.normalize(localRayDir, localRayDir)
            };
        })();

        // Transforms a World-space ray into Local-space ray

        var worldRayToLocalRay = (function () {

            var modelMatInv = mat4.create();
            var a = vec4.create();
            var b = vec4.create();

            return function (object, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) {

                var modelMat = object.modelTransform.matrix;

                mat4.invert(modelMatInv, modelMat);

                a[0] = worldRayOrigin[0];
                a[1] = worldRayOrigin[1];
                a[2] = worldRayOrigin[2];
                a[3] = 1;

                vec4.transformMat4(b, a, modelMatInv);

                localRayOrigin[0] = b[0];
                localRayOrigin[1] = b[1];
                localRayOrigin[2] = b[2];

                vec3.transformMat4(localRayDir, worldRayDir, modelMatInv);
            };
        })();

        /**
         * Performs a pick on the display graph and returns info on the result.
         * @param {*} params
         * @returns {*}
         */
        SceneJS_Display.prototype.pick = function (params) {

            if (!params.canvasPos && (params.rayPick && (!params.origin || !params.direction))) {
                console.warn("Incomplete pick parameters");
                return;
            }

            if (this._canvas.canvas.width == 0 || this._canvas.canvas.height == 0) {
                // Canvas hidden
                return;
            }

            var canvas = this._canvas.canvas;
            var resolutionScaling = this._canvas.resolutionScaling;
            var canvasPos = params.canvasPos;
            if (canvasPos) {
                canvasPos = new Float32Array([canvasPos[0] * resolutionScaling, canvasPos[1] * resolutionScaling]);
            }

            var pickBuf = this.pickBuf;
            var hit = null;
            var object;
            var i;
            var len;

            // Lazy-create pick buffer
            if (!pickBuf) {
                pickBuf = this.pickBuf = new SceneJS._webgl.Framebuffer({
                    canvas: this._canvas
                });
            }

            var worldRayPicking = !params.canvasPos; // Picking with ray given as origin->direction

            var worldRayOrigin;
            var worldRayDir;

            var pickBufX;
            var pickBufY;

            if (worldRayPicking) {

                worldRayOrigin = params.origin || new Float32Array([0, 0, 0]);
                worldRayDir = params.direction || new Float32Array([0, 0, 1]);

                var look = vec3.add(tempVec3, worldRayOrigin, worldRayDir);
                var up = new Float32Array([0, 1, 0]); // TODO: derive from ray?

                mat4.lookAt(pickViewMatrix, worldRayOrigin, look, up);

                pickBufX = canvas.clientWidth * 0.5; // Sample center of pick buffer
                pickBufY = canvas.clientHeight * 0.5;

            } else {

                pickBufX = canvasPos[0];
                pickBufY = canvasPos[1];
            }

            this.prepareScene();
            this.render(); // Do any pending visible render

            //------------------------------------------------------------------
            // Pick an object using color-indexed render
            //------------------------------------------------------------------

            pickBuf.bind();

            pickBuf.clear();

            this._doDrawList({
                pickObject: true,
                clear: true,
                pickViewMatrix: worldRayPicking ? pickViewMatrix : null,
                pickProjMatrix: worldRayPicking ? pickProjMatrix : null
            });

            this._canvas.gl.finish();

            // Read pixel color in pick buffer at given coordinates,
            // convert to an index into the pick name list

            var pix = pickBuf.read(pickBufX, pickBufY);

            var pickedColorIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

            var objectIndex = this._pickLookup[pickedColorIndex - 1];

            if (objectIndex >= 0) {

                if (objectIndex < this._numOpaqueObjects) {
                    object = this._opaqueObjects[objectIndex];
                } else {
                    object = this._transparentObjects[objectIndex - this._numOpaqueObjects];
                }
                

                hit = {
                    canvasPos: canvasPos,
                    objectId: object.id
                };

                var properties = object.properties;

                if (properties) {
                    hit.name = properties.name;
                    hit.nodeId = properties.nodeId;
                }
            }

            if (params.pickRegion) {

                //------------------------------------------------------------------
                // Pick a region
                // Region picking is independent of having picked an object
                //------------------------------------------------------------------

                pickBuf.clear();

                this._doDrawList({
                    pickRegion: true,
                    object: object,
                    pickViewMatrix: worldRayPicking ? pickViewMatrix: null,
                    pickProjMatrix: worldRayPicking ? pickProjMatrix: null,
                    clear: true
                });

                pix = pickBuf.read(pickBufX, pickBufY);

                if (pix[0] !== 0 || pix[1] !== 0 || pix[2] !== 0 || pix[3] !== 0) {

                    hit = hit || {
                            canvasPos: canvasPos
                        };

                    var regionColor = {r: pix[0] / 255, g: pix[1] / 255, b: pix[2] / 255, a: pix[3] / 255};
                    var regionData = this._frameCtx.regionData;
                    var tolerance = 0.01;
                    var data = {};
                    var color, delta;

                    for (i = 0, len = regionData.length; i < len; i++) {
                        color = regionData[i].color;
                        if (regionColor && regionData[i].data) {
                            delta = Math.max(
                                Math.abs(regionColor.r - color.r),
                                Math.abs(regionColor.g - color.g),
                                Math.abs(regionColor.b - color.b),
                                Math.abs(regionColor.a - (color.a === undefined ? regionColor.a : color.a))
                            );

                            if (delta < tolerance) {
                                data = regionData[i].data;
                                break;
                            }
                        }
                    }

                    hit.color = regionColor;
                    hit.regionData = data;
                }
            }

            if (params.pickTriangle && object) {

                //------------------------------------------------------------------
                // Pick a triangle on the picked object
                //------------------------------------------------------------------

                pickBuf.clear();

                this._doDrawList({
                    pickTriangle: true,
                    object: object,
                    pickViewMatrix: worldRayPicking ? pickViewMatrix: null,
                    pickProjMatrix: worldRayPicking ? pickProjMatrix: null,
                    clear: true
                });

                pix = pickBuf.read(pickBufX, pickBufY);
                var primitiveIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);
                primitiveIndex *= 3; // Convert from triangle number to first vertex in indices

                hit.primitiveIndex = primitiveIndex;
                if (object.geometry.primitiveName === "triangles") {

                    // Triangle picked; this only happens when the
                    // GameObject has a Geometry that has primitives of type "triangle"

                    hit.primitive = "triangle";

                    // Find the local-space ray to test for intersection with the triangle
                    if (worldRayPicking) { // Convert world-space picking ray to local-space ray
                        worldRayToLocalRay(object, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);
                    } else  { // Convert canvas pos to local-space ray
                        canvasPosToLocalRay(canvas, object, canvasPos, localRayOrigin, localRayDir);
                    }

                    // Get hit face vertex indices
                    hit.indices = vec3.create();
                    object.getTriangleIndices(primitiveIndex, hit.indices);

                    // Get hit face vertex positions in local-space: a, b, c
                    object.getTrianglePositionOnSurface(primitiveIndex, a, b, c);

                    // Get hit position in local-space
                    hit.position = vec3.create();
                    SceneJS_math_rayPlaneIntersect(localRayOrigin, localRayDir, a, b, c, hit.position);

                    // get barycentric coordinate of hit position
                    hit.barycentric = vec3.create();
                    object.cartesianToBarycentric(primitiveIndex, hit.position, hit.barycentric);

                    // get hit normal
                    hit.normal = vec3.create();
                    object.normalFromBarycentric(primitiveIndex, hit.barycentric, hit.normal);

                    // get hit position in world-space
                    hit.worldPos = vec3.create();
                    object.getPointInWorldSpace(hit.position, hit.worldPos);

                    // get hit uv coordinates (for each uv layer)
                    hit.uvs = []; // TODO: Optimize for GC
                    object.uvFromBarycentric(primitiveIndex, hit.barycentric, hit.uvs);
                    if (hit.uvs.length > 0) {
                        hit.uv = hit.uvs[0]; // Backward compatibility
                    }
                }
            }

            pickBuf.unbind();

            return hit;
        };
    })();

    /** Renders either the draw or pick list.
     *
     * @param {*} params
     * @param {Boolean} params.clear Set true to clear the color, depth and stencil buffers first
     * @param {*} params.object Object to render chunks of, for pickTriangle or pickRegion modes
     * @param {Number} [params.pass=0] Which rendering pass we're drawing for (eg. left vs right eye)
     * @param {Boolean} params.pickObject Set true to render for object-picking, using per-object indexed color
     * @param {Boolean} params.pickTriangle Set true to render for triangle-picking, using per-triangle indexed color
     * @param {Boolean} params.pickRegion Set true to render for region-picking
     * @param {Boolean} params.transparent Set false to only render opaque objects
     * @private
     */
    SceneJS_Display.prototype._doDrawList = (function() {

        var chunkCaches = {};
        var screenTexelOffset = new Float32Array(2);

        function resetChunkCache(renderMode) {
            if (!chunkCaches[renderMode]) {
                chunkCaches[renderMode] = new Int32Array(8);
            }

            var lastChunkId = chunkCaches[renderMode];
            for (var i = 0, len = lastChunkId.length; i < len; ++i) {
                lastChunkId[i] = -1;
            }
        }

        function drawObject(frameCtx, object, renderMode) {
            var gl = frameCtx.gl;
            var chunks = object.chunkSets[renderMode];
            var lastChunkId = chunkCaches[renderMode];
            var chunk;

            if (frameCtx.backfaces != object.backfaces) {
                if (object.backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frameCtx.backfaces = object.backfaces;
            }

            if (frameCtx.addBlend != object.addBlend) {
                if(object.addBlend) {
                    gl.blendFunc(gl.ONE, gl.ONE);
                } else {
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                }
                frameCtx.addBlend = object.addBlend;
            }

            for (var j = 0, lenj = chunks.length; j < lenj; j++) {
                chunk = chunks[j];
                if (chunk) {
                    if (chunk.unique || lastChunkId[j] !== chunk.numericId) {
                        chunk.draw(renderMode, frameCtx);
                        lastChunkId[j] = chunk.numericId;
                    }
                }
            }
        }

        return function (params) {

            var gl = this._canvas.gl;

            var frameCtx = this._frameCtx;

            frameCtx.gl = gl;
            frameCtx.pass = params.pass || 0;
            frameCtx.targetIndex = 0;
            frameCtx.viewMatrix = this.viewMatrix;
            frameCtx.cameraEye = this.camera.eye;
            frameCtx.modelMat = null;
            frameCtx.cameraMat = null;
            frameCtx.projectionMatrix = this.projectionMatrix;
            frameCtx.lights = this.lights;
            frameCtx.clips = this.clips;
            frameCtx.reflection = this.reflections.activeReflection;
            frameCtx.lightmap = this.lightmaps.activeLightmap;
            frameCtx.highlightColor = this.highlightColor;
            frameCtx.desatParams = this.desatParams;
            frameCtx.fogParams = this.fogParams;
            frameCtx.fogColor = this.fogColor;
            frameCtx.fogMode = this.fogMode;
            frameCtx.fogEnabled = this.fogEnabled;
            frameCtx.xrayColor = this.xrayColor;
            frameCtx.scissorTestEnabled = false;
            frameCtx.depthTest = SceneJS.DEPTH_TEST_FLAGS.ENABLED;
            frameCtx.backfaces = true;
            frameCtx.frontface = SceneJS.PROPERTY_FLAGS.CCW;
            frameCtx.picking = !!params.pickObject || !!params.pickTriangle || !!params.pickRegion;
            frameCtx.pickObject = !!params.pickObject;
            frameCtx.pickTriangle = !!params.pickTriangle;
            frameCtx.pickRegion = !!params.pickRegion;
            frameCtx.pickIndex = 1;
            frameCtx.textureUnit = 0;
            frameCtx.lineWidth = 1;
            frameCtx.transparent = 0;
            frameCtx.ambientColor = this._ambientColor;
            frameCtx.canvasResolution = frameCtx.canvasResolution || new Float32Array(2);
            frameCtx.canvasResolution[0] = this._canvas.canvas.width;
            frameCtx.canvasResolution[1] = this._canvas.canvas.height;
            frameCtx.aspect = this._canvas.canvas.width / this._canvas.canvas.height;
            frameCtx.texture = null;
            frameCtx.hasNormalMap = false;
            frameCtx.regionMapUVLayerIdx = -1;
            frameCtx.drawElements = 0;
            frameCtx.drawArrays = 0;
            frameCtx.useProgram = 0;
            frameCtx.bindTexture = 0;
            frameCtx.bindArray = 0;
            frameCtx.pickViewMatrix = params.pickViewMatrix;
            frameCtx.pickProjMatrix = params.pickProjMatrix;
            frameCtx.discardOpaque = false;
            frameCtx.outputFormat = 0;
            frameCtx.depthBuffer = null;
            frameCtx.addBlend = false;

            var VAO = gl.getExtension("OES_vertex_array_object");
            frameCtx.VAO = (VAO) ? VAO : null;

            if (SceneJS.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_standard_derivatives"]) { // For normal mapping w/o precomputed tangents
                gl.getExtension("OES_standard_derivatives");
            }

            gl.viewport(this.viewport[0], this.viewport[1], frameCtx.canvasResolution[0], frameCtx.canvasResolution[1]);

            gl.enable(gl.DEPTH_TEST);
            gl.frontFace(gl.CCW);
            gl.disable(gl.CULL_FACE);
            gl.depthMask(true);

            if (this.transparent || frameCtx.picking) {
                gl.clearColor(0, 0, 0, 0);
            } else {
                gl.clearColor(this._ambientColor[0], this._ambientColor[1], this._ambientColor[2], 1.0);
            }

            var i;
            var len;
            var object;

            if (params.custom) {
                var renderMode = params.custom.renderMode;
                var objects = params.custom.objects;
                resetChunkCache(renderMode);
                for(i = 0; i < objects.length; i++) {
                    object = objects[i];
                    drawObject(frameCtx, object, renderMode);
                }
            } else if (params.pickObject) {
                resetChunkCache("pick");

                var pickListLen = 0;

                if (params.clear) {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }

                for (i = 0, len = this._numOpaqueObjects; i < len; i++) {
                    object = this._opaqueObjects[i];
                    if (object.properties.getFlag(SceneJS.PROPERTY_FLAGS.PICKING)) {
                        this._pickLookup[pickListLen++] = i;
                        drawObject(frameCtx, object, "pick");
                    }
                }

                for (i = 0, len = this._numTransparentObjects; i < len; i++) {
                    object = this._transparentObjects[i];
                    if (object.properties.getFlag(SceneJS.PROPERTY_FLAGS.PICKING)) {
                        this._pickLookup[pickListLen++] = this._numOpaqueObjects + i;
                        drawObject(frameCtx, object, "pick");
                    }
                }

            } else if (params.pickTriangle && params.object) {
                if (params.clear) {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }

                resetChunkCache("pickTriangle");
                drawObject(frameCtx, params.object, "pickTriangle");
            }  else if (params.pickRegion) {
                resetChunkCache("pick");

                if (params.clear) {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }

                if (params.object) {
                    drawObject(frameCtx, params.object, "pick");
                } else {
                    var pickListLen = 0;
                    if (params.pickRegion) {
                        for (i = 0, len = this._numOpaqueObjects; i < len; i++) {
                            object = this._opaqueObjects[i];
                            if (object.properties.getFlag(SceneJS.PROPERTY_FLAGS.PICKING)) {
                                this._pickLookup[pickListLen++] = i;
                                drawObject(frameCtx, object, "pick");
                            }
                        }

                        for (i = 0, len = this._numTransparentObjects; i < len; i++) {
                            object = this._transparentObjects[i];
                            if (object.properties.getFlag(SceneJS.PROPERTY_FLAGS.PICKING)) {
                                this._pickLookup[pickListLen++] = this._numOpaqueObjects + i;
                                drawObject(frameCtx, object, "pick");
                            }
                        }
                    }
                }

            } else { // Render scene
                resetChunkCache("draw");
                resetChunkCache("xray");

                var startTime = Date.now();
                var opaqueOnly = params.opaqueOnly;

                var postProcessing = (this.transparencyMode === SceneJS.TRANSPARENCY_FLAGS.WEIGHTED_OIT &&
                    this._numTransparentObjects > 0) ||
                    this.postProcessPipelineOpaque.length > 0 || 
                    this.postProcessPipelineFinal.length > 0;

                
                if (postProcessing) {
                    this.mainFramebuffer.bind();
                }

                if (params.clear) {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }

                for (i = 0, len = this._numOpaqueObjects; i < len; i++) { // Render opaque objects
                    var object = this._opaqueObjects[i];

                    if (object.properties.flags & SceneJS.PROPERTY_FLAGS.XRAY) {
                        drawObject(frameCtx, object, "xray");
                    } else {
                        drawObject(frameCtx, object, "draw");
                    }
                }

                if (postProcessing) {
                    this.mainFramebuffer.unbind();
                }

                if (this.postProcessPipelineOpaque.length > 0) {
                    gl.disable(gl.DEPTH_TEST);
                    gl.frontFace(gl.CCW);
                    gl.disable(gl.CULL_FACE);
                }

                for (var i = 0, len = this.postProcessPipelineOpaque.length; i < len; ++i) {
                    var pp = this.postProcessPipelineOpaque[i];

                    if (pp.framebuffer) {
                        pp.framebuffer.bind();
                    }

                    pp.draw(frameCtx);

                    if (pp.framebuffer) {
                        pp.framebuffer.unbind();
                    }
                }

                if (this.postProcessPipelineOpaque.length > 0) {
                    gl.enable(gl.DEPTH_TEST);
                    gl.frontFace(gl.CCW);
                    gl.disable(gl.CULL_FACE);
                    frameCtx.depthTest = SceneJS.DEPTH_TEST_FLAGS.ENABLED;
                    frameCtx.backfaces = SceneJS.PROPERTY_FLAGS.BACKFACES;
                    frameCtx.frontface = SceneJS.PROPERTY_FLAGS.CCW;
                    frameCtx.addBlend = false;
                }

                if (this._numTransparentObjects > 0) {
                    resetChunkCache("draw");
                    resetChunkCache("xray");

                    if (postProcessing && !(this.transparencyMode === SceneJS.TRANSPARENCY_FLAGS.WEIGHTED_OIT)) {
                        this.mainFramebuffer.bind();
                    }

                    if (this.depthSort) {
                        this._transparentObjects.sort(sortDepth);
                    }

                    frameCtx.discardOpaque = true;

                    if (this.transparencyMode & SceneJS.TRANSPARENCY_FLAGS.ALPHA_BLEND) {
                        var modeNoDepthMask = !!(this.transparencyMode & SceneJS.TRANSPARENCY_FLAGS.ALPHA_NO_DEPTH_MASK);

                        gl.enable(gl.BLEND);

                        if (this.transparencyMode === SceneJS.TRANSPARENCY_FLAGS.ADD_ALPHA) {
                            gl.blendFunc(gl.ONE, gl.ONE);
                        } else {
                            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        }

                        var NO_DEPTH_MASK_FLAG = SceneJS.PROPERTY_FLAGS.NO_DEPTH_MASK;

                        if (modeNoDepthMask) {
                            gl.depthMask(false);
                        }

                        for (i = 0; i < this._numTransparentObjects; i++) {
                            var object = this._transparentObjects[i];
                            var perObjectNoDepthMask = !modeNoDepthMask && (object.properties.flags & NO_DEPTH_MASK_FLAG);
                            if (perObjectNoDepthMask) {
                                gl.depthMask(false);
                            }

                            if (object.properties.flags & SceneJS.PROPERTY_FLAGS.XRAY) {
                                drawObject(frameCtx, object, "xray");
                            } else {
                                drawObject(frameCtx, object, "draw");
                            }

                            if (perObjectNoDepthMask) {
                                gl.depthMask(true);
                            }
                        }

                        gl.disable(gl.BLEND);
                        gl.depthMask(true);
                    } else if (this.transparencyMode === SceneJS.TRANSPARENCY_FLAGS.WEIGHTED_OIT) {
                        resetChunkCache("depth");

                        screenTexelOffset[0] = 1 / frameCtx.canvasResolution[0]; 
                        screenTexelOffset[1] = 1 / frameCtx.canvasResolution[1]; 

                        this.oitDepthBuffer.bind();
                        gl.clear(gl.DEPTH_BUFFER_BIT);
                        gl.colorMask(false, false, false, false);
                        for (i = 0; i < this._numTransparentObjects; i++) {
                            drawObject(frameCtx, this._transparentObjects[i], "depth");
                        }
                        gl.colorMask(true, true, true, true);
                        this.oitDepthBuffer.unbind();

                        gl.clearColor(0, 0, 0, 1);
                        gl.enable(gl.BLEND);
                        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA)
                        gl.depthMask(false);

                        this.oitAccumulateFramebuffer.bind();
                        gl.clear(gl.COLOR_BUFFER_BIT);
                        
                        frameCtx.outputFormat = 1;
                        frameCtx.depthBuffer = this.oitDepthBuffer.getDepthTarget();
                        
                        for (i = 0; i < this._numTransparentObjects; i++) {
                            var object = this._transparentObjects[i];

                            if (object.properties.flags & SceneJS.PROPERTY_FLAGS.XRAY) {
                                drawObject(frameCtx, object, "xray");
                            } else {
                                drawObject(frameCtx, object, "draw");
                            }   
                        }

                        this.oitAccumulateFramebuffer.unbind();

                        gl.disable(gl.DEPTH_TEST);
                        gl.frontFace(gl.CCW);
                        gl.disable(gl.CULL_FACE);
                        this.mainFramebuffer.bind();
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        this.oitPostprocess.setUniform("uTexelOffset", screenTexelOffset);
                        this.oitPostprocess.draw(frameCtx);
                        this.mainFramebuffer.unbind();

                        gl.disable(gl.BLEND);
                        gl.depthMask(true);   
                    } else if (this.transparencyMode === SceneJS.TRANSPARENCY_FLAGS.ALPHA_TO_COVERAGE) {
                        gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);

                        for (i = 0; i < this._numTransparentObjects; i++) {
                            var object = this._transparentObjects[i];

                            if (object.properties.flags & SceneJS.PROPERTY_FLAGS.XRAY) {
                                drawObject(frameCtx, object, "xray");
                            } else {
                                drawObject(frameCtx, object, "draw");
                            }   
                        }

                        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    if (postProcessing && !(this.transparencyMode === SceneJS.TRANSPARENCY_FLAGS.WEIGHTED_OIT)) {
                        this.mainFramebuffer.unbind();
                    }
                    
                }

                if (postProcessing) {
                    gl.disable(gl.DEPTH_TEST);
                    gl.frontFace(gl.CCW);
                    gl.disable(gl.CULL_FACE);

                    if (this.postProcessPipelineFinal.length > 0) {
                        for (var i = 0, len = this.postProcessPipelineFinal.length; i < len; ++i) {
                            var pp = this.postProcessPipelineFinal[i];

                            if (pp.framebuffer) {
                                pp.framebuffer.bind();
                            }

                            pp.draw(frameCtx);

                            if (pp.framebuffer) {
                                pp.framebuffer.unbind();
                            }
                        }   
                    } else {
                        this.blitPostprocess.draw(frameCtx);
                    }
                }

                var endTime = Date.now();

                this.stats.frame.drawElements = frameCtx.drawElements;
                this.stats.frame.drawArrays = frameCtx.drawArrays;
                this.stats.frame.useProgram = frameCtx.useProgram;
                this.stats.frame.bindTexture = frameCtx.bindTexture;
                this.stats.frame.bindArray = frameCtx.bindArray;
                this.stats.frame.drawChunks = this._drawListLen;
            }

            if (frameCtx.VAO) {
                frameCtx.VAO.bindVertexArrayOES(null);
                for (i = 0; i < 10; i++) {
                    gl.disableVertexAttribArray(i);
                }
            }
        };
    })();

    SceneJS_Display.prototype.readPixels = function (entries, size, opaqueOnly) {

        if (this._canvas.canvas.width == 0 || this._canvas.canvas.height == 0) {
            // Canvas hidden
            return;
        }

        if (!this._readPixelBuf) {
            this._readPixelBuf = new SceneJS._webgl.Framebuffer({canvas: this._canvas});
        }

        this._readPixelBuf.bind();

        this._readPixelBuf.clear();

        this.prepareScene();
        this.render({
            force: true,
            opaqueOnly: opaqueOnly
        });

        var entry;
        var color;

        for (var i = 0; i < size; i++) {

            entry = entries[i] || (entries[i] = {});

            color = this._readPixelBuf.read(entry.x, entry.y);

            entry.r = color[0];
            entry.g = color[1];
            entry.b = color[2];
            entry.a = color[3];
        }

        this._readPixelBuf.unbind();
    };

    SceneJS_Display.prototype.destroy = function () {
        this._programFactory.destroy();
    };
})();

;/**
 * @class Manages creation, sharing and recycle of {@link SceneJS_ProgramSource} instances
 * @private
 */
(function () {
    "use strict";

    var DISPLAY_FLAGS = SceneJS.DISPLAY_FLAGS;
    var TEXTURE_FLAGS = SceneJS.TEXTURE_FLAGS;
    var CUBEMAP_FLAGS = SceneJS.CUBEMAP_FLAGS;
    var PROPERTY_FLAGS = SceneJS.PROPERTY_FLAGS;
    var COLOR_MOD_FLAGS = SceneJS.COLOR_MOD_FLAGS;

    var FRAG_HIGHP_SUPPORTED = SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION === "highp";
    var TEXTURE_LOD_SUPPORTED = SceneJS.WEBGL_INFO.textureLODSupported;

    window.SceneJS_ProgramSourceFactory = new (function () {

            var cache = {}; // Source codes are shared across all scenes

            var states; // Cache rendering state
            var object;
            var phongMaterial;
            var metallicMaterial;
            var gammaInputPhong;
            var diffuseFresnel;
            var specularFresnel;
            var alphaFresnel;
            var transparencyFresnel;
            var reflectFresnel;
            var emitFresnel;
            var fragmentFresnel;
            var fresnel;
            var texturing;// True when rendering state contains textures
            var phongReflectionMapping;
            var phongLightMapping;
            var pbrReflectionMapping;
            var pbrLightMapping;
            var normals;// True when rendering state contains normals
            var solid;
            var skybox;  // True when object should be treated as a skybox
            var billboard;
            var normalMapping;
            var swizzledNormalMapping;
            var autoTangents;
            var clipping;
            var morphing;
            var regionMapping;
            var regionInteraction;
            var points;
            var roundPoints;
            var perspectivePoints;
            var scaleRotationPoints;
            var uvTranslatePoints;
            var quantizedPositions;
            var octNormals;
            var quantizedUVs;
            var fogEnabled;
            var fogMode;
            var colorModRange;
            var colorMods;
            var colorModifiers;
            var colorModsScalarFresnel; // Need fresnel function when this is true
            var colorModsColorFresnel; // Need fresnel function when this is true
            var opacityModsScalarFresnel; // Need fresnel function when this is true;
            var opacityModRange;
            var opacityMods;
            var opacityModifiers;
            var alphaTest;
            var stochasticAlpha;
            var fragmentShaderHeader;
            var fragmentShaderFooter;
            var maxPointSizeStr = Math.floor(SceneJS.WEBGL_INFO.MAX_POINT_SIZE).toFixed(1);

            var src = ""; // Accumulates source code as it's being built

            this.setMaxPointSize = function (val) {
                val = Math.min(val, SceneJS.WEBGL_INFO.MAX_POINT_SIZE);
                maxPointSizeStr = Math.floor(val).toFixed(1);
            };

            /**
             * Get sourcecode for a program to render the given states
             */
            this.getSource = function (hash, _states, _object) {

                var source = cache[hash];
                if (source) {
                    source.useCount++;
                    return source;
                }

                states = _states;
                object = _object;

                phongMaterial = states.material.workflow === SceneJS.Material.PHONG;
                metallicMaterial = states.material.workflow === SceneJS.Material.METALLIC;
                gammaInputPhong = _states.gammaInputPhong;
                diffuseFresnel = states.fresnel.diffuse;
                specularFresnel = states.fresnel.specular;
                alphaFresnel = states.fresnel.alpha;
                reflectFresnel = states.fresnel.reflect;
                emitFresnel = states.fresnel.emit;
                fragmentFresnel = states.fresnel.fragment;
                transparencyFresnel = states.fresnel.transparency;
                fresnel = diffuseFresnel || specularFresnel || alphaFresnel || transparencyFresnel || reflectFresnel || emitFresnel || fragmentFresnel;
                texturing = hasTextures(states);
                phongReflectionMapping = hasReflectionMap(states);
                phongLightMapping = hasLightMap(states);
                pbrReflectionMapping = hasPBRReflectionMap(states);
                pbrLightMapping = hasPBRLightMap(states);
                normals = hasNormals(states);
                clipping = states.clips.clips.length > 0 && !!(states.properties.flags & PROPERTY_FLAGS.CLIPPING);
                solid = clipping && !!(states.properties.flags & PROPERTY_FLAGS.SOLID);
                skybox = !!(states.properties.flags & PROPERTY_FLAGS.SKYBOX);
                billboard = !!(states.properties.flags & PROPERTY_FLAGS.BILLBOARD);
                normalMapping = hasNormalMap(states);
                swizzledNormalMapping = hasSwizzledNormalMap(states);
                autoTangents = normalMapping && _states.autoTangents && SceneJS.WEBGL_INFO.standardDerivativesSupported;
                morphing = !!states.morphGeometry.targets;
                regionMapping = hasRegionMap();
                regionInteraction = regionMapping && states.regionMap.mode !== "info";
                points = states.geometry.primitiveName === "points";
                perspectivePoints = !!(states.properties.flags & PROPERTY_FLAGS.PERSPECTIVE_POINTS);
                scaleRotationPoints = !!(states.geometry.pointScaleRotationBuf);
                uvTranslatePoints = !!(states.geometry.pointUVTranslateBuf);
                roundPoints = !!(states.properties.flags & PROPERTY_FLAGS.ROUND_POINTS);
                quantizedPositions = !!(states.geometry.compressedPositions || states.morphGeometry.compressedPositions);
                octNormals = !!(states.geometry.compressedNormals || states.morphGeometry.compressedNormals);
                quantizedUVs = !!(states.geometry.compressedUVs || states.morphGeometry.compressedUVs);
                fogEnabled = states.fogEnabled;
                fogMode = states.fogMode;
                colorModRange = states.properties.colorModRange;
                colorMods = states.properties.colorModifiers.length > 0;
                colorModifiers = states.properties.colorModifiers;
                colorModsScalarFresnel = needColorModsScalarFresnel();
                colorModsColorFresnel = needColorModsColorFresnel();
                opacityModsScalarFresnel = needOpacityModsScalarFresnel();
                opacityModRange = states.properties.opacityModRange;
                opacityMods = states.properties.opacityModifiers.length > 0;
                opacityModifiers = states.properties.opacityModifiers;
                alphaTest = (states.transparencyMode & SceneJS.TRANSPARENCY_FLAGS.TWO_PASS) && object.isPartiallyOpaque();
                stochasticAlpha = !!(states.properties.flags & PROPERTY_FLAGS.STOCHASTIC_ALPHA);
                fragmentShaderHeader = states.properties.fragmentShaderHeader || null;
                fragmentShaderFooter = states.properties.fragmentShaderFooter || null;

                source = {
                    hash: hash,
                    pickVertexSrc: vertexPicking(),
                    pickFragmentSrc: fragmentPicking(),
                    pickTriangleVertexSrc: vertexPicking(true),
                    pickTriangleFragmentSrc: fragmentPicking(true),
                    drawVertexSrc: vertexRendering(),
                    drawFragmentSrc: fragmentRendering(),
                    xrayVertexSrc: vertexXRay(),
                    xrayFragmentSrc: fragmentXRay(),
                    depthVertexSrc: vertexDepth(),
                    depthFragmentSrc: fragmentDepth(),
                    drawTextureVertexSrc: vertexDrawTexture(),
                    drawTextureFragmentSrc: fragmentDrawTexture(),
                    useCount: 0
                };

                cache[hash] = source;

                return source;
            };

            function needColorModsScalarFresnel() {
                var mods = states.properties.colorModifiers;
                for (var i = 0, len = mods.length; i < len; i++) {
                    if (mods[i].value.isScalarFresnel) {
                        return true;
                    }
                }
                return false;
            }

            function needColorModsColorFresnel() {
                var mods = states.properties.colorModifiers;
                for (var i = 0, len = mods.length; i < len; i++) {
                    if (mods[i].value.isColorFresnel) {
                        return true;
                    }
                }
                return false;
            }

            function needOpacityModsScalarFresnel() {
                var mods = states.properties.opacityModifiers;
                for (var i = 0, len = mods.length; i < len; i++) {
                    if (mods[i].value.isScalarFresnel) {
                        return true;
                    }
                }
                return false;
            }


            /**
             * Releases program source code
             */
            this.putSource = function (hash) {
                var source = cache[hash];
                if (source) {
                    if (--source.useCount == 0) {
                        cache[source.hash] = null;
                    }
                }
            };

            function vertexPicking(triangle) {

                begin();

                add("attribute vec4 SCENEJS_aVertex;");
                if (triangle) {
                    add("attribute vec4 SCENEJS_aTriColor;");
                    add("varying vec4 SCENEJS_vTriColor;");
                }
                add("uniform mat4 SCENEJS_uMMatrix;");
                add("uniform mat4 SCENEJS_uVMatrix;");
                add("uniform mat4 SCENEJS_uPMatrix;");

                if (points) {
                    add("uniform float SCENEJS_uPointSize;");
                    if (scaleRotationPoints) {
                        add("attribute vec2 SCENEJS_aPointScaleRotation;");
                    }
                }

                if (quantizedPositions) {
                    add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
                }

                add("varying vec4 SCENEJS_vWorldVertex;");

                if (regionMapping) {
                    add("attribute vec2 SCENEJS_aRegionMapUV;");
                    add("varying vec2 SCENEJS_vRegionMapUV;");
                }

                if (morphing) {
                    add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
                    if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                        add("attribute vec4 SCENEJS_aMorphVertex;");
                    }

                    if (quantizedPositions) {
                        add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
                    }
                }

                add("void main(void) {");

                if (quantizedPositions) {
                    add("    vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
                } else {
                    add("    vec4 modelVertex = SCENEJS_aVertex;");
                }

                if (morphing) {
                    if (states.morphGeometry.targets[0].vertexBuf) {
                        if (quantizedPositions) {
                            add("  modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        } else {
                            add("  modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        }
                    }
                }
                add("  SCENEJS_vWorldVertex = SCENEJS_uMMatrix * modelVertex; ");

                add("mat4 vPosMatrix = SCENEJS_uVMatrix;");

                if (skybox) {
                    add("vPosMatrix[3].xyz = vec3(0.0);");
                }

                add("  vec4 viewVertex =  vPosMatrix * SCENEJS_vWorldVertex;");
                add("  gl_Position =  SCENEJS_uPMatrix * viewVertex;");

                if (regionMapping) {
                    add("SCENEJS_vRegionMapUV = SCENEJS_aRegionMapUV;");
                }

                if (triangle) {
                    add("SCENEJS_vTriColor = SCENEJS_aTriColor;");
                }

                if (points) {
                    add("gl_PointSize = SCENEJS_uPointSize;");
                    if (perspectivePoints) {
                        add("gl_PointSize *= 20.0 / length(viewVertex.xyz);");
                    }
                    if (scaleRotationPoints) {
                        add("gl_PointSize *= SCENEJS_aPointScaleRotation.x;");
                    }
                    add("gl_PointSize = min(gl_PointSize, " + maxPointSizeStr + ");");
                }

                add("}");

                return end();
            }

            function fragmentPicking(triangle) {

                begin();

                add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");

                add("varying vec4 SCENEJS_vWorldVertex;");

                if (triangle) {
                    add("varying vec4  SCENEJS_vTriColor;");
                } else {
                    add("uniform float  SCENEJS_uPickMode;");                   // Z-pick mode when true else colour-pick
                    add("uniform vec4  SCENEJS_uPickColor;");                   // Used in colour-pick mode
                }

                if (clipping) {
                    for (var i = 0; i < states.clips.clips.length; i++) {
                        add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
                        if (states.clips.clips[i].fade) {
                            add("uniform float SCENEJS_uClipFadeDistance" + i + ";");
                        }
                    }
                }

                if (regionMapping) {
                    add("varying vec2 SCENEJS_vRegionMapUV;");
                    add("uniform sampler2D SCENEJS_uRegionMapSampler;");
                }

                add("void main(void) {");

                if (clipping) {

                    if (states.clips.clipDiscard) {
                        add("float distOff = 0.0;");
                    }
                    if (states.clips.clipFade) {
                        add("float distAlpha = 0.0;");
                    }

                    for (var i = 0; i < states.clips.clips.length; i++) {
                        if (states.clips.clips[i].fade) {
                            //max obsrved normalized distance from alpha plane (normalized to max fade distance)
                            add("distAlpha = max(distAlpha, (dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w) / SCENEJS_uClipFadeDistance" + i + ");");
                        } else {
                            //max observed distance from clipping plane
                            add("distOff = max(distOff, dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w);");
                        }
                    }

                    if (states.clips.clipDiscard) {
                        // discard  fragment if beyond any clip
                        add("if (distOff > 0.0) { discard; }");
                    }

                    if (states.clips.clipFade) {
                        // set transparency proportionally to distance
                        // TODO: Requires drawn object to be transparent flag.
                        add("if (distAlpha > 1.0) { discard; }")
                    }

                }
                if (triangle) {
                    add("gl_FragColor = SCENEJS_vTriColor;  ");
                } else {
                    add("    if  (SCENEJS_uPickMode == 0.0) {");  // Pick object
                    add("          gl_FragColor = SCENEJS_uPickColor;  ");
                    add("    } else {"); // Pick region
                    if (regionMapping) {
                        add("          gl_FragColor = texture2D(SCENEJS_uRegionMapSampler, vec2(SCENEJS_vRegionMapUV.s, SCENEJS_vRegionMapUV.t));");
                    } else {
                        add("          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
                    }
                    add("    }");
                }
                add("}");

                return end();
            }

            function vertexDrawTexture() {

                begin();

                add("attribute vec4 SCENEJS_aVertex;");
                add("uniform mat4 SCENEJS_uMMatrix;");
                add("uniform mat4 SCENEJS_uVMatrix;");
                add("uniform mat4 SCENEJS_uPMatrix;");

                if (quantizedPositions) {
                    add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
                }

                var drawUVIndex = 0;
                var drawUVBuf = null;
                var drawLayer = null;
                if (texturing) {
                    drawLayer = states.texture.layers[states.texture.drawLayerIndex];
                    if (drawLayer) {
                        drawUVIndex = drawLayer.uvLayerIdx || 0;
                    }
                    if (states.geometry.uvBufs) {
                        drawUVBuf = states.geometry.uvBufs[drawUVIndex];
                    }
                    if (drawUVBuf) {
                        add("varying vec2 SCENEJS_vUVCoord" + drawUVIndex + ";");
                        add("attribute vec2 SCENEJS_aUVCoord" + drawUVIndex + ";");
                        if (quantizedUVs) {
                            add("uniform mat3 SCENEJS_uDecodeUVMatrix" + drawUVIndex + ";")
                        }
                    }
                }

                add("varying vec4 SCENEJS_vWorldVertex;");

                if (morphing) {
                    add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
                    if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                        add("attribute vec4 SCENEJS_aMorphVertex;");
                    }

                    if (quantizedPositions) {
                        add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
                    }
                }

                add("void main(void) {");

                if (quantizedPositions) {
                    add("    vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
                } else {
                    add("    vec4 modelVertex = SCENEJS_aVertex;");
                }

                if (morphing) {
                    if (states.morphGeometry.targets[0].vertexBuf) {
                        if (quantizedPositions) {
                            add("  modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        } else {
                            add("  modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        }
                    }
                }
                add("  SCENEJS_vWorldVertex = SCENEJS_uMMatrix * modelVertex; ");

                add("mat4 vPosMatrix = SCENEJS_uVMatrix;");

                add("  vec4 viewVertex =  vPosMatrix * SCENEJS_vWorldVertex;");
                add("  gl_Position =  SCENEJS_uPMatrix * viewVertex;");

                if (texturing && drawUVBuf) {
                    if (quantizedUVs) {
                        add("SCENEJS_vUVCoord" + drawUVIndex + " = (SCENEJS_uDecodeUVMatrix" + drawUVIndex + " * vec3(SCENEJS_aUVCoord" + drawUVIndex + ", 1.0)).xy;");
                    } else {
                        add("SCENEJS_vUVCoord" + drawUVIndex + " = SCENEJS_aUVCoord" + drawUVIndex + ";");
                    }
                }

                add("}");

                return end();
            }

            function fragmentDrawTexture() {

                begin();

                add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");
                var drawUVIndex = 0;
                var drawUVBuf = null;
                var drawLayer = null;
                if (texturing) {
                    drawLayer = states.texture.layers[states.texture.drawLayerIndex];
                    if (drawLayer) {
                        drawUVIndex = drawLayer.uvLayerIdx || 0;
                    }
                    if (states.geometry.uvBufs) {
                        drawUVBuf = states.geometry.uvBufs[drawUVIndex];
                    }
                    if (drawUVBuf) {
                        add("uniform sampler2D SCENEJS_uDrawSampler;");
                        add("varying vec2 SCENEJS_vUVCoord" + drawUVIndex + ";");
                    }
                }

                add("void main(void) {");
                add("vec4 color = vec4(0.0);");
                if (texturing && drawUVBuf && drawLayer) {
                    add("vec2 textureCoord;");
                    add("textureCoord = SCENEJS_vUVCoord" + drawUVIndex + ";");
                    if (drawLayer.compressed) {
                        add("   textureCoord.y = 1.0 - textureCoord.y;");
                    }
                    add("if(textureCoord.x != -1.0) {");
                    add("   color = texture2D(SCENEJS_uDrawSampler, textureCoord);");
                    add("}");
                }
                add("gl_FragColor = color;");
                add("}");

                return end();
            }

            function hasRegionMap() {
                if (!states.regionMap.empty) {
                    return hasUVs();
                }
                return false;
            }

            function hasTextures() {
                if (states.texture.layers && states.texture.layers.length > 0) {
                    return hasUVs();
                }
                return false;
            }

            function hasUVs() {
                if (states.geometry.primitiveName === "points") {
                    return true;
                }
                if (states.geometry.uvBufs) { // TODO only if there is at least one defined member in this array
                    return true;
                }
                if (states.morphGeometry.targets && (states.morphGeometry.targets[0].uvBuf || states.morphGeometry.targets[0].uvBuf2)) {
                    return true;
                }
                return false;
            }

            function hasReflectionMap(states) {
                if (!states.properties.getFlag(PROPERTY_FLAGS.REFLECTIVE)) {
                    return false;
                }
                if (!states.geometry.normalBuf) {
                    return false;
                }
                if (!states.cubemap.layers) {
                    return false;
                }
                for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                    if (states.cubemap.layers[i].applyTo === CUBEMAP_FLAGS.reflect) {
                        return true;
                    }
                }
                return false;
            }

            function hasLightMap(states) {
                if (!states.geometry.normalBuf) {
                    return false;
                }
                if (!states.cubemap.layers) {
                    return false;
                }
                for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                    if (states.cubemap.layers[i].applyTo === CUBEMAP_FLAGS.light) {
                        return true;
                    }
                }
                return false;
            }

            function hasPBRReflectionMap(states) {
                if (states.material.workflow !== SceneJS.Material.METALLIC) {
                    return false;
                }
                if (!states.properties.getFlag(PROPERTY_FLAGS.REFLECTIVE)) {
                    return false;
                }
                if (!states.geometry.normalBuf) {
                    return false;
                }
                if (states.reflections.activeReflection) {
                    return true;
                }
                return false;
            }

            function hasPBRLightMap(states) {
                if (states.material.workflow !== SceneJS.Material.METALLIC) {
                    return false;
                }
                if (!states.geometry.normalBuf) {
                    return false;
                }
                if (states.lightmaps.activeLightmap) {
                    return true;
                }
                return false;
            }

            function hasNormals(states) {
                if (states.geometry.normalBuf) {
                    return true;
                }
                if (states.morphGeometry.targets && states.morphGeometry.targets[0].normalBuf) {
                    return true;
                }
                return false;
            }

            function hasNormalMap(states) {
                if (states.texture) {
                    var layers = states.texture.layers;
                    if (!layers) {
                        return false;
                    }
                    for (var i = 0, len = layers.length; i < len; i++) {
                        if (layers[i].flags & TEXTURE_FLAGS.normals) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function hasSwizzledNormalMap(states) {
                if (states.texture) {
                    var layers = states.texture.layers;
                    if (!layers) {
                        return false;
                    }
                    for (var i = 0, len = layers.length; i < len; i++) {
                        if (layers[i].flags & TEXTURE_FLAGS.swizzledNormals) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function vertexRendering() {

                var i;
                var uvBufs;

                begin();

                add("uniform mat4 SCENEJS_uMMatrix;");             // Model matrix

                if (FRAG_HIGHP_SUPPORTED) {
                    add("uniform mat4 SCENEJS_uVMatrix;");             // View matrix
                } else {
                    add("uniform mediump mat4 SCENEJS_uVMatrix;");             // View matrix
                }

                add("uniform mat4 SCENEJS_uPMatrix;");             // Projection matrix

                add("attribute vec4 SCENEJS_aVertex;");            // Model coordinates

                if (FRAG_HIGHP_SUPPORTED) {
                    add("uniform vec3 SCENEJS_uWorldEye;");            // World-space eye position
                } else {
                    add("uniform mediump vec3 SCENEJS_uWorldEye;");
                }

                add("varying vec3 SCENEJS_vViewEyeVec;");          // View-space vector from origin to eye

                if (points) {
                    add("uniform float SCENEJS_uPointSize;");
                    if (scaleRotationPoints) {
                        add("attribute vec2 SCENEJS_aPointScaleRotation;");
                        add("varying float SCENEJS_vPointRotation;");
                    }
                    if (uvTranslatePoints) {
                        add("attribute vec2 SCENEJS_aPointUVTranslate;");
                        // add("varying vec2 SCENEJS_vPointUVScale;");
                        add("varying vec2 SCENEJS_vPointUVTranslate;");
                    }
                }

                if (quantizedPositions) {
                    add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
                }

                if (normals) {
                    add("attribute vec3 SCENEJS_aNormal;");        // Normal vectors
                    add("uniform   mat4 SCENEJS_uMNMatrix;");      // Model normal matrix

                    add("varying   vec3 SCENEJS_vViewNormal;");    // Output view-space vertex normal

                    if (phongReflectionMapping || phongLightMapping || pbrReflectionMapping || pbrLightMapping) {
                        add("varying   vec3 SCENEJS_vWorldNormal;");    // Output view-space vertex normal
                    }

                    if (normalMapping && !autoTangents) {
                        add("attribute vec3 SCENEJS_aTangent;"); // Pass through to frag
                        add("varying   vec3 SCENEJS_vTangent;");
                    }
                }

                if (texturing) {

                    uvBufs = states.geometry.uvBufs;

                    if (uvBufs) {
                        for (var i = 0, len = uvBufs.length; i < len; i++) {
                            if (uvBufs[i]) {
                                add("attribute vec2 SCENEJS_aUVCoord" + i + ";");
                                if (quantizedUVs) {
                                    add("uniform mat3 SCENEJS_uDecodeUVMatrix" + i + ";")
                                }
                            }
                        }
                    }
                }

                if (states.geometry.colorBuf) {
                    add("attribute vec4 SCENEJS_aVertexColor;");
                    add("varying vec4 SCENEJS_vColor;");               // Varying for fragment texturing
                }

                if (clipping || normals || colorModRange || opacityModRange) {
                    add("varying vec4 SCENEJS_vWorldVertex;");         // Varying for fragment clip or world pos hook
                }

                if (stochasticAlpha) {
                    add("varying vec4 SceneJS_vModelVertex;");
                }

                add("varying vec4 SCENEJS_vViewVertex;");              // Varying for fragment view clip hook

                if (texturing) {                                            // Varyings for fragment texturing

                    uvBufs = states.geometry.uvBufs;

                    if (uvBufs) {
                        for (i = 0, len = uvBufs.length; i < len; i++) {
                            if (uvBufs[i]) {
                                add("varying vec2 SCENEJS_vUVCoord" + i + ";");
                            }
                        }
                    }
                }

                if (regionInteraction) {
                    add("attribute vec2 SCENEJS_aRegionMapUV;");
                    add("varying vec2 SCENEJS_vRegionMapUV;");
                }

                if (morphing) {
                    add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
                    if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                        add("attribute vec4 SCENEJS_aMorphVertex;");
                    }
                    if (normals) {
                        if (states.morphGeometry.targets[0].normalBuf) {
                            add("attribute vec3 SCENEJS_aMorphNormal;");
                        }
                    }
                    if (normalMapping && !autoTangents) {
                        //if (states.morphGeometry.targets[0].normalBuf) {
                        add("attribute vec3 SCENEJS_aMorphTangent;");
                        // }
                    }

                    if (quantizedPositions) {
                        add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
                    }
                }

                if (billboard) {

                    // Billboarding function which modifies the rotation
                    // elements of the given matrix

                    add("void billboard(inout mat4 mat) {");
                    add("   mat[0].xyz = vec3(1.0, 0.0, 0.0);");
                    add("   mat[1].xyz = vec3(0.0, 1.0, 0.0);");
                    add("   mat[2].xyz = vec3(0.0, 0.0, 1.0);");
                    add("}");
                }

                if (octNormals) {
                    add("vec3 octDecode(vec2 oct) {");
                    add("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                    add("    if (v.z < 0.0) {");
                    add("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                    add("    }");
                    add("    return normalize(v);");
                    add("}");
                }

                add("void main(void) {");

                if (normalMapping && !autoTangents) {
                    add("vec3 modelTangent = SCENEJS_aTangent;");
                }


                if (quantizedPositions) {
                    add("  vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
                } else {
                    add("  vec4 modelVertex = SCENEJS_aVertex; ");
                }

                if (octNormals) {
                    add("  vec4 modelNormal = vec4(octDecode(SCENEJS_aNormal.xy), 0.0); ");
                } else if (normals) {
                    add("  vec4 modelNormal = vec4(SCENEJS_aNormal, 0.0); ");
                }

                // Morphing - morph targets are in same model space as the geometry
                if (morphing) {
                    if (states.morphGeometry.targets[0].vertexBuf) {
                        if (quantizedPositions) {
                            add("  modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        } else {
                            add("  modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        }
                    }
                    if (normals) {
                        if (states.morphGeometry.targets[0].normalBuf) {
                            if (octNormals) {
                                add("  modelNormal = vec4( mix(modelNormal.xyz, octDecode(SCENEJS_aMorphNormal.xy), SCENEJS_uMorphFactor), 0.0); ");
                            } else {
                                add("  modelNormal = vec4( mix(modelNormal.xyz, SCENEJS_aMorphNormal, SCENEJS_uMorphFactor), 0.0); ");
                            }
                        }
                    }
                    if (normalMapping && !autoTangents) {
                        add("  modelTangent = mix(modelTangent, SCENEJS_aMorphTangent, SCENEJS_uMorphFactor); ");
                    }
                }

                if (stochasticAlpha) {
                    add("SceneJS_vModelVertex = modelVertex;;");
                }

                add("mat4 modelMatrix = SCENEJS_uMMatrix;");
                add("mat4 viewMatrix = SCENEJS_uVMatrix;");

                if (normals) {
                    add("mat4 modelNormalMatrix = SCENEJS_uMNMatrix;");
                }

                add("vec4 worldVertex;");
                add("vec4 viewVertex;");

                if (skybox) {
                    add("viewMatrix[3].xyz = vec3(0.0);");
                }

                if (billboard) {

                    // Since billboard effect is not preserved
                    // in the product of two billboarded matrices,
                    // we need to get the product of the model and
                    // view matrices and billboard that

                    add("   mat4 modelViewMatrix =  viewMatrix * modelMatrix;");

                    add("   billboard(modelMatrix);");
                    add("   billboard(viewMatrix);");
                    add("   billboard(modelViewMatrix);");

                    if (normals) {
                        add("   billboard(modelNormalMatrix);");
                    }

                    add("   worldVertex = modelMatrix * modelVertex;");
                    add("   viewVertex = modelViewMatrix * modelVertex;");

                } else {

                    add("  worldVertex = modelMatrix * modelVertex;");
                    add("  viewVertex  = viewMatrix * worldVertex; ");
                }

                if (normals) {
                    add("  vec3 worldNormal = (modelNormalMatrix * modelNormal).xyz; ");
                    add("  SCENEJS_vViewNormal = (viewMatrix * vec4(worldNormal, 0.0)).xyz;");
                    if (phongReflectionMapping || phongLightMapping || pbrReflectionMapping || pbrLightMapping) {
                        add("SCENEJS_vWorldNormal = worldNormal;");
                    }
                }

                if (clipping || normals || colorModRange || opacityModRange) {
                    add("  SCENEJS_vWorldVertex = worldVertex;");
                }

                add("  SCENEJS_vViewVertex = viewVertex;");

                add("  gl_Position = SCENEJS_uPMatrix * viewVertex;");

                if (normalMapping && !autoTangents) {
                    add("SCENEJS_vTangent = modelTangent;");
                }

                add("SCENEJS_vViewEyeVec = ((viewMatrix * vec4(SCENEJS_uWorldEye, 1.0)).xyz  - viewVertex.xyz);");

                if (texturing) {

                    uvBufs = states.geometry.uvBufs;

                    if (uvBufs) {
                        for (i = 0, len = uvBufs.length; i < len; i++) {
                            if (uvBufs[i]) {
                                if (quantizedUVs) {
                                    add("SCENEJS_vUVCoord" + i + " = (SCENEJS_uDecodeUVMatrix" + i + " * vec3(SCENEJS_aUVCoord" + i + ", 1.0)).xy;");
                                } else {
                                    add("SCENEJS_vUVCoord" + i + " = SCENEJS_aUVCoord" + i + ";");
                                }
                            }
                        }
                    }
                }

                if (states.geometry.colorBuf) {
                    add("SCENEJS_vColor = SCENEJS_aVertexColor;");
                }

                if (regionInteraction) {
                    add("SCENEJS_vRegionMapUV = SCENEJS_aRegionMapUV;");
                }

                if (points) {
                    add("gl_PointSize = SCENEJS_uPointSize;");
                    if (perspectivePoints) {
                        add("gl_PointSize *= 20.0 / length(viewVertex.xyz);");
                    }
                    if (scaleRotationPoints) {
                        add("SCENEJS_vPointRotation = SCENEJS_aPointScaleRotation.y;");
                        add("gl_PointSize *= SCENEJS_aPointScaleRotation.x;");
                    }
                    if (uvTranslatePoints) {
                        add("SCENEJS_vPointUVTranslate = SCENEJS_aPointUVTranslate;");
                    }
                    add("gl_PointSize = min(gl_PointSize, " + maxPointSizeStr + ");");
                }

                add("}");

                return end();
            }


            /*-----------------------------------------------------------------------------------------------------------------
             * Rendering Fragment shader
             *---------------------------------------------------------------------------------------------------------------*/

            function fragmentRendering() {

                var diffuseFresnel = states.fresnel.diffuse;
                var specularFresnel = states.fresnel.specular;
                var alphaFresnel = states.fresnel.alpha;
                var transparencyFresnel = states.fresnel.transparency;
                var reflectFresnel = states.fresnel.reflect;
                var emitFresnel = states.fresnel.emit;
                var fragmentFresnel = states.fresnel.fragment;
                var gammaOutput = metallicMaterial;

                begin();

                if ((normalMapping && autoTangents) || stochasticAlpha) {
                    add("#extension GL_OES_standard_derivatives : enable");
                }

                if (TEXTURE_LOD_SUPPORTED) {
                    add("#extension GL_EXT_shader_texture_lod : enable");
                }

                if (fragmentShaderHeader) {
                    add(fragmentShaderHeader);
                }
                add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");

                add("uniform sampler2D SCENEJS_uDepthBuffer;");
                add("uniform vec2 SCENEJS_uCanvasRes;");

                //--------------------------------------------------------------------------------
                // GAMMA INPUT CORRECTION
                //--------------------------------------------------------------------------------

                if (metallicMaterial || gammaInputPhong) {
                    add("vec4 sRGBToLinear( in vec4 value ) {");
                    add("  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );");
                    add("}");
                }

                if (alphaTest) {
                    add("uniform bool SCENEJS_uDiscardOpaque;")
                }

                if (stochasticAlpha) {
                    add("float hash(vec2 v) {");
                    add("    return fract(1.0e4 * sin(17.0 * v.x + 0.1 * v.y) * (0.1 + abs(sin(13.0 * v.y + v.x))));");
                    add("}");

                    add("float hash3D(vec3 v) {");
                    add("    return hash(vec2(hash(v.xy), v.z));");
                    add("}");
                }

                if (metallicMaterial) {

                    //--------------------------------------------------------------------------------------------------------------
                    // PBR Shading functions
                    //--------------------------------------------------------------------------------------------------------------

                    add("#define PI 3.14159265359");
                    add("#define RECIPROCAL_PI 0.31830988618");
                    add("#define RECIPROCAL_PI2 0.15915494");
                    add("#define EPSILON 1e-6");

                    add("#define saturate(a) clamp( a, 0.0, 1.0 )");

                    add("vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {");
                    add("   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );");
                    add("}");

                    add("struct IncidentLight {");
                    add("   vec3 color;");
                    add("   vec3 direction;");
                    add("};");

                    add("struct ReflectedLight {");
                    add("   vec3 diffuse;");
                    add("   vec3 specular;");
                    add("};");

                    add("struct Geometry {");
                    add("   vec3 position;");
                    add("   vec3 viewNormal;");
                    add("   vec3 worldNormal;");
                    add("   vec3 viewEyeDir;");
                    add("};");

                    add("struct Material {");
                    add("   vec3    diffuseColor;");
                    add("   float   specularRoughness;");
                    add("   vec3    specularColor;");
                    add("   float   shine;"); // Only used for Phong
                    add("};");

                    // Metallic PBR BRDF

                    if (pbrLightMapping) {

                        // Light mapping function

                        add("void computePBRLightMapping(const in samplerCube lightMap, const in float intensity, const in vec3 normal, const in Material material, inout ReflectedLight reflectedLight) {");
                        add("   reflectedLight.diffuse += (sRGBToLinear(textureCube(lightMap, normal)).rgb * PI) * (RECIPROCAL_PI * material.diffuseColor) * intensity;");
                        add("}");
                    }

                    if (pbrReflectionMapping) {

                        // Reflection mapping function

                        add("float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {"); // Effectively "blurs" reflection map lookup in proportion to roughness
                        add("   float r = ggxRoughness + 0.0001;");
                        add("   return (2.0 / (r * r) - 2.0);");
                        add("}");

                        add("float getSpecularMIPLevel(const in float blinnShininessExponent, float maxMipLevels) {");
                        add("   float desiredMIPLevel = maxMipLevels - 0.79248 - 0.5 * log2( (blinnShininessExponent * blinnShininessExponent) + 1.0 );");
                        add("   return clamp( desiredMIPLevel, 0.0, maxMipLevels );");
                        add("}");

                        add("vec3 getLightProbeIndirectRadiance(const in samplerCube reflectMap, const in vec3 reflectVec, const in float blinnShininessExponent, float maxMipLevels) {");
                        add("   float mipLevel = getSpecularMIPLevel(blinnShininessExponent, maxMipLevels);"); //TODO: a random factor - fix this
                        if (TEXTURE_LOD_SUPPORTED) {
                            add("   vec3 envMapColor = sRGBToLinear(textureCubeLodEXT(reflectMap, reflectVec, mipLevel)).rgb;");
                        } else {
                            add("   vec3 envMapColor = sRGBToLinear(textureCube(reflectMap, reflectVec, mipLevel)).rgb;");
                        }
                        add("   return envMapColor;");
                        add("}");

                        add("vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
                        add("   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));");
                        add("   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);");
                        add("   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);");
                        add("   vec4 r = roughness * c0 + c1;");
                        add("   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;");
                        add("   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;");
                        add("   return specularColor * AB.x + AB.y;");
                        add("}");

                        add("void computePBRReflectionMapping(const in samplerCube reflectMap, const in float intensity, const in mat4 viewMatrix, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight, float maxMipLevel) {");
                        add("   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);");
                        add("   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);");
                        add("   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);");
                        add("   vec3 radiance               = getLightProbeIndirectRadiance(reflectMap, reflectVec, blinnExpFromRoughness, maxMipLevel);");
                        add("   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);");
                        add("   reflectedLight.specular     += radiance * specularBRDFContrib * intensity;");
                        add("}");
                    }

                    // Lighting function

                    add("vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {");
                    add("   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );");
                    add("   return ( 1.0 - specularColor ) * fresnel + specularColor;");
                    add("}");

                    add("float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {");
                    add("   float a2 = alpha * alpha;");
                    add("   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
                    add("   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
                    add("   return 1.0 / ( gl * gv );");
                    add("}");

                    add("float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {");
                    add("   float a2 = ( alpha * alpha );");
                    add("   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * ( dotNV * dotNV ) );");
                    add("   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * ( dotNL * dotNL ) );");
                    add("   return 0.5 / max( gv + gl, EPSILON );");
                    add("}");

                    add("float D_GGX(const in float alpha, const in float dotNH) {");
                    add("   float a2 = ( alpha * alpha );");
                    add("   float denom = ( dotNH * dotNH ) * ( a2 - 1.0 ) + 1.0;");
                    add("   return RECIPROCAL_PI * a2 / ( denom * denom );");
                    add("}");

                    add("vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {");
                    add("   float alpha = ( roughness * roughness );");
                    add("   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );");
                    add("   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );");
                    add("   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );");
                    add("   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );");
                    add("   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );");
                    add("   vec3  F = F_Schlick( specularColor, dotLH );");
                    add("   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );");
                    add("   float D = D_GGX( alpha, dotNH );");
                    add("   return F * (G * D);");
                    add("}");

                    add("void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {");
                    add("   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));");
                    add("   vec3 irradiance = dotNL * incidentLight.color * PI;");
                    add("   reflectedLight.diffuse  += irradiance * (RECIPROCAL_PI * material.diffuseColor);");
                    add("   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);");
                    add("}");

                } // (metallicMaterial)

                //--------------------------------------------------------------------------------------------------------------
                // Geometry inputs
                //--------------------------------------------------------------------------------------------------------------

                if (clipping || normals || colorModRange || opacityModRange) {
                    add("varying vec4 SCENEJS_vWorldVertex;");  // World-space position
                }

                if (stochasticAlpha) {
                    add("varying vec4 SceneJS_vModelVertex;");
                }

                add("varying vec4 SCENEJS_vViewVertex;");       // View-space position

                if (states.geometry.colorBuf) {
                    add("varying vec4 SCENEJS_vColor;");        // Vertex color
                }

                if (texturing) {

                    if (normalMapping) {

                        if (autoTangents) {
                            add("vec3 perturbNormal2Arb( sampler2D sampler, vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");
                            add("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");
                            add("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");
                            add("      vec2 st0 = dFdx( uv.st );");
                            add("      vec2 st1 = dFdy( uv.st );");
                            add("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");
                            add("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");
                            add("      vec3 N = normalize( surf_norm );");
                            add("      vec3 mapN = texture2D( sampler, uv ).xyz * 2.0 - 1.0;");
                            add("      mat3 tsn = mat3( S, T, N );");
                            add("      return normalize( tsn * mapN );");
                            add("}");

                            if (swizzledNormalMapping) {
                                add("vec3 perturbNormal2ArbSwz( sampler2D sampler, vec3 eye_pos, vec3 surf_norm, vec2 uv ) {");
                                add("      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );");
                                add("      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );");
                                add("      vec2 st0 = dFdx( uv.st );");
                                add("      vec2 st1 = dFdy( uv.st );");
                                add("      vec3 S = normalize( q0 * st1.t - q1 * st0.t );");
                                add("      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );");
                                add("      vec3 N = normalize( surf_norm );");
                                // unpacked swizzled normal data: x,y from a,g; recover z
                                add("      vec3 v_norm = vec3(texture2D(sampler, uv).ag * 2.0 - 1.0, 0.0);");
                                add("      v_norm.z = sqrt(max(1.0 - dot(v_norm.xy, v_norm.xy), 0.0));");
                                add("      mat3 tsn = mat3( S, T, N );");
                                add("      return normalize( tsn * v_norm );");
                                add("}");
                            }
                        } else {
                            add("varying vec3 SCENEJS_vTangent;");

                            // additional variables to support swizzled normal data
                            if (swizzledNormalMapping) {
                                add("vec4 swizzledNormalMap;");
                                add("vec3 vNormal;");
                            }
                        }
                    }

                    var uvBufs = states.geometry.uvBufs;        // UVs
                    if (uvBufs) {
                        for (var i = 0, len = uvBufs.length; i < len; i++) {
                            if (uvBufs[i]) {
                                add("varying vec2 SCENEJS_vUVCoord" + i + ";");
                            }
                        }
                    }
                }

                //--------------------------------------------------------------------------------------------------------------
                // Transform inputs
                //--------------------------------------------------------------------------------------------------------------

                add("uniform mat4 SCENEJS_uVMatrix;");          // View matrix
                add("uniform mat4 SCENEJS_uMMatrix;");          // Model matrix

                //--------------------------------------------------------------------------------------------------------------
                // Camera / view-space inputs
                //--------------------------------------------------------------------------------------------------------------

                add("uniform vec3 SCENEJS_uWorldEye;");
                add("varying vec3 SCENEJS_vViewEyeVec;");                  // Direction of world-space vertex from eye

                //--------------------------------------------------------------------------------------------------------------
                // Material inputs
                //--------------------------------------------------------------------------------------------------------------

                // Common to all material workflows:

                add("uniform vec4  SCENEJS_uMaterialColor;");
                add("uniform vec4  SCENEJS_uMaterialEmitColor;");

                if (texturing) {

                    // Texture samplers

                    for (var i = 0, len = states.texture.layers.length; i < len; i++) {
                        var layer = states.texture.layers[i];
                        add("uniform sampler2D SCENEJS_uSampler" + i + ";");
                        if (layer.matrix) {
                            add("uniform mat4 SCENEJS_uLayer" + i + "Matrix;");
                        }
                        add("uniform float SCENEJS_uLayer" + i + "BlendFactor;");
                    }
                }

                // Fresnels

                if (diffuseFresnel || specularFresnel || alphaFresnel || transparencyFresnel || emitFresnel ||
                    fragmentFresnel || reflectFresnel || colorModsScalarFresnel || colorModsColorFresnel || opacityModsScalarFresnel) {

                    src.push("float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {");
                    src.push("    float fr = abs(dot(eyeDir, normal));");
                    src.push("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");
                    src.push("    return pow(finalFr, power);");
                    src.push("}");

                    if (diffuseFresnel) {
                        add("uniform vec4 SCENEJS_uDiffuseFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uDiffuseFresnelEdgeColor;");
                        add("uniform float SCENEJS_uDiffuseFresnelPower;");
                    }

                    if (specularFresnel) {
                        add("uniform vec4 SCENEJS_uSpecularFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uSpecularFresnelEdgeColor;");
                        add("uniform float SCENEJS_uSpecularFresnelPower;");
                    }

                    if (alphaFresnel) {
                        add("uniform vec4 SCENEJS_uAlphaFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uAlphaFresnelEdgeColor;");
                        add("uniform float SCENEJS_uAlphaFresnelPower;");
                    }

                    if (transparencyFresnel) {
                        add("uniform vec4 SCENEJS_uTransparencyFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uTransparencyFresnelEdgeColor;");
                        add("uniform float SCENEJS_uTransparencyFresnelPower;");
                    }

                    if (reflectFresnel) {
                        add("uniform vec4 SCENEJS_uReflectFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uReflectFresnelEdgeColor;");
                        add("uniform float SCENEJS_uReflectFresnelPower;");
                    }

                    if (emitFresnel) {
                        add("uniform vec4 SCENEJS_uEmitFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uEmitFresnelEdgeColor;");
                        add("uniform float SCENEJS_uEmitFresnelPower;");
                    }

                    if (fragmentFresnel) {
                        add("uniform vec4 SCENEJS_uFragmentFresnelCenterColor;");
                        add("uniform vec4 SCENEJS_uFragmentFresnelEdgeColor;");
                        add("uniform float SCENEJS_uFragmentFresnelPower;");
                    }
                }

                // Blinn-Phong material workflow:

                if (phongMaterial) {
                    add("uniform vec3  SCENEJS_uAmbientColor;");
                    add("uniform vec4  SCENEJS_uMaterialSpecularColor;");
                    add("uniform float SCENEJS_uMaterialShine;");
                }

                // Metal-roughness PBR material workflow:

                if (metallicMaterial) {
                    add("uniform vec4 SCENEJS_uMetalRoughSpecularf0;");
                }

                //--------------------------------------------------------------------------------------------------------------
                // Lighting inputs
                //--------------------------------------------------------------------------------------------------------------

                if (normals) {

                    add("uniform vec2  SCENEJS_uXrayParams;"); // x = glassfactor, y = murkiness

                    if (phongReflectionMapping || phongLightMapping) {

                        // Environment map

                        for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                            var layer = states.cubemap.layers[i];
                            add("uniform samplerCube SCENEJS_uCubeMapSampler" + i + ";");
                            add("uniform float SCENEJS_uCubeMapIntensity" + i + ";");
                            add("uniform float SCENEJS_uCubeMapMipLevels" + i + ";");
                        }
                    }

                    if (pbrReflectionMapping) {
                        add("uniform samplerCube SCENEJS_uPBRReflectionMapSampler;");
                        add("uniform float SCENEJS_uPBRReflectionMapIntensity;");
                        add("uniform float SCENEJS_uPBRReflectionMapMipLevels;");
                    }

                    if (pbrLightMapping) {
                        add("uniform samplerCube SCENEJS_uPBRLightMapSampler;");
                        add("uniform float SCENEJS_uPBRLightMapIntensity;");
                        add("uniform float SCENEJS_uPBRLightMapMipLevels;");
                    }

                    add("varying vec3 SCENEJS_vViewNormal;");

                    if (phongReflectionMapping || phongLightMapping || pbrReflectionMapping || pbrLightMapping) {
                        add("varying vec3 SCENEJS_vWorldNormal;");
                    }

                    for (var i = 0; i < states.lights.length; i++) {

                        var light = states.lights[i];

                        add("uniform vec3  SCENEJS_uLightColor" + i + ";");

                        if (light.mode == "dir") {
                            add("uniform vec3 SCENEJS_uLightDir" + i + ";");
                        }

                        if (light.mode == "point") {
                            add("uniform vec3  SCENEJS_uLightAttenuation" + i + ";");
                            add("uniform vec3 SCENEJS_uLightPos" + i + ";");
                        }

                        if (light.mode == "spot") {
                            add("uniform vec3  SCENEJS_uLightAttenuation" + i + ";");
                            add("uniform vec3 SCENEJS_uLightPos" + i + ";");
                            add("uniform vec3 SCENEJS_uLightDir" + i + ";");
                            add("uniform float SCENEJS_uInnerCone" + i + ";");
                            add("uniform float SCENEJS_uOuterCone" + i + ";");
                        }
                    }
                }

                //--------------------------------------------------------------------------------------------------------------
                // Effects inputs
                //--------------------------------------------------------------------------------------------------------------

                if (colorMods) {
                    var cmi = 0;
                    var cmods = states.properties.colorModifiers;
                    var len = cmods.length;
                    var colorMod;
                    for (cmi = 0; cmi < len; cmi++) {
                        colorMod = cmods[cmi];

                        if (colorMod.value.isColorFresnel || colorMod.value.isScalarFresnel) {
                            add("uniform vec4 SCENEJS_uColorModFresnelEdge" + cmi + ";");
                            add("uniform vec4 SCENEJS_uColorModFresnelCenter" + cmi + ";");
                            add("uniform float SCENEJS_uColorModFresnelPower" + cmi + ";");

                        } else {
                            // color modification value
                            if (colorMod.applyTo === COLOR_MOD_FLAGS.TINT) {
                                add("uniform vec3 SCENEJS_uColorModification" + cmi + ";");
                            } else {
                                add("uniform float SCENEJS_uColorModification" + cmi + ";");
                            }
                        }

                        // per-color-modification range; [center.x, center.y, center.z, radius]
                        if (colorMod.range) {
                            add("uniform vec3 SCENEJS_uColorModCenter" + cmi + ";");
                            add("uniform vec2 SCENEJS_uColorModRadius" + cmi + ";"); // x = min, y = max - min
                        }
                    }
                }

                if (opacityMods) {
                    var omi = 0;
                    var omods = states.properties.opacityModifiers;
                    var len = omods.length;
                    var opacityMod;
                    for (omi = 0; omi < len; omi++) {
                        opacityMod = omods[omi];

                        // Fresnel for opacity
                        if (opacityMod.value.isScalarFresnel) {
                            add("uniform vec4 SCENEJS_uOpacityModFresnelEdge" + omi + ";");
                            add("uniform vec4 SCENEJS_uOpacityModFresnelCenter" + omi + ";");
                            add("uniform float SCENEJS_uOpacityModFresnelPower" + omi + ";");

                        } else {
                            // opacity modification value
                            add("uniform float SCENEJS_uOpacityModification" + omi + ";");
                        }

                        // per-opacity-modification range; [center.x, center.y, center.z, radius]
                        if (opacityMod.range) {
                            add("uniform vec3 SCENEJS_uOpacityModCenter" + omi + ";");
                            add("uniform vec2 SCENEJS_uOpacityModRadius" + omi + ";"); // x = min, y = max - min
                        }
                    }
                }

                if (fogEnabled) {
                    add("uniform vec4   SCENEJS_uFogParams;"); // x = start, y = end, z = min, w = max
                    add("uniform vec4   SCENEJS_uFogColor;"); // RGB = color, a = density
                }

                if (regionInteraction) {
                    add("varying vec2 SCENEJS_vRegionMapUV;");
                    add("uniform sampler2D SCENEJS_uRegionMapSampler;");
                    add("uniform vec3 SCENEJS_uRegionMapRegionColor;");
                    add("uniform vec3 SCENEJS_uRegionMapHighlightFactor;");
                    add("uniform float SCENEJS_uRegionMapHideAlpha;");
                }

                if (clipping) {
                    if (solid) {
                        add("uniform vec3  SCENEJS_uSolidColor;");
                    }
                    for (var i = 0; i < states.clips.clips.length; i++) {
                        add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
                        if (states.clips.clips[i].fade) {
                            add("uniform float SCENEJS_uClipFadeDistance" + i + ";");
                        }
                    }
                }

                add("uniform float SCENEJS_uOutputFormat;");

                add("#define RGB_YCOCG mat3(0.25, 0.5, -0.25, 0.5, 0.0, 0.5, 0.25, -0.5, -0.25)")

                if (points) {
                    if (scaleRotationPoints) {
                        add("varying float SCENEJS_vPointRotation;");
                    }
                    if (uvTranslatePoints) {
                        add("uniform vec2 SCENEJS_uPointUVScale;");
                        add("varying vec2 SCENEJS_vPointUVTranslate;");
                    }
                }

                if (gammaOutput) {
                    src.push("vec4 linearToGamma( in vec4 value, in float gammaFactor ) {");
                    src.push("    return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );");
                    src.push("}");
                }

                //--------------------------------------------------------------------------------------------------------------
                // MAIN
                //--------------------------------------------------------------------------------------------------------------

                add("void main(void) {");

                // World-space arbitrary clipping planes
                if (clipping) {

                    if (states.clips.clipDiscard) {
                        add("float distOff = 0.0;");
                    }
                    if (states.clips.clipFade) {
                        add("float distAlpha = 0.0;");
                    }

                    for (var i = 0; i < states.clips.clips.length; i++) {
                        if (states.clips.clips[i].fade) {
                            //max obsrved normalized distance from alpha plane (normalized to max fade distance)
                            add("distAlpha = max(distAlpha, (dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w) / SCENEJS_uClipFadeDistance" + i + ");");
                        } else {
                            //max observed distance from clipping plane
                            add("distOff = max(distOff, dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w);");
                        }
                    }
                    if (states.clips.clipDiscard) {
                        // discard  fragment if beyond any clip
                        add("if (distOff > 0.0) { discard; }");
                    }
                    if (states.clips.clipFade) {
                        // set transparency proportionally to distance
                        // TODO: Requires drawn object to be transparent flag.
                        add("if (distAlpha > 1.0) { discard; }")
                    }


                    if (solid) {
                        add("if (gl_FrontFacing == false) {");
                        add("   gl_FragColor = vec4(SCENEJS_uSolidColor, 1.0);");
                        add("   return;");
                        add("}");
                    }
                }

                // Rounded points

                if (points && roundPoints) {
                    add("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
                    add("float r = dot(cxy, cxy);");
                    add("if (r > 1.0) {");
                    add("   discard;");
                    add("}");
                }

                if (normals) {
                    add("vec3 worldEyeVec = normalize(SCENEJS_uWorldEye - SCENEJS_vWorldVertex.xyz);");            // World-space eye position
                }

                // Unpack material channels

                if (states.geometry.colorBuf) {
                    add("  vec3  color   = SCENEJS_vColor.rgb;");
                    add("  float colorAlpha  = SCENEJS_vColor.a;");
                } else {
                    add("  vec3  color   = SCENEJS_uMaterialColor.rgb;")
                }
                add("  float alpha = SCENEJS_uMaterialColor.a;");

                add("  float emit          = SCENEJS_uMaterialEmitColor.a;");
                add("  vec3  emitColor     = SCENEJS_uMaterialEmitColor.rgb;");
                add("  float occlusion     = 1.0;");

                if (states.geometry.colorBuf) {
                    add("alpha *= colorAlpha;");
                }

                add("float transparency  = 1.0 - alpha;");

                if (phongMaterial) {
                    add("  vec3  ambientColor  = SCENEJS_uAmbientColor;");
                    add("  float specular      = SCENEJS_uMaterialSpecularColor.a;");
                    add("  vec3  specularColor = SCENEJS_uMaterialSpecularColor.rgb;");
                    add("  float shine         = SCENEJS_uMaterialShine;");
                }

                if (metallicMaterial) {
                    add("  vec3  ambientColor  = vec3(0.2, 0.2, 0.2);");  // HACK
                    add("  float metallic      = SCENEJS_uMetalRoughSpecularf0.r;");
                    add("  float roughness     = SCENEJS_uMetalRoughSpecularf0.g;");
                    add("  float specularF0    = SCENEJS_uMetalRoughSpecularf0.b;");
                }

                // Geometry

                if (normals) {
                    add("float attenuation = 1.0;");
                    if (normalMapping) {
                        add("vec3 viewNormalVec = vec3(0.0, 0.0, 0.0);");
                    } else {
                        add("vec3 viewNormalVec = normalize(SCENEJS_vViewNormal);");
                    }
                    add("vec3 viewEyeVec = normalize(SCENEJS_vViewEyeVec);");

                    add("  float glassfactor = SCENEJS_uXrayParams.x;");
                    add("  float murkiness = SCENEJS_uXrayParams.y;");

                    add("if (transparency > 0.0) {");
                    add("  alpha = 1.0 - transparency;");
                    add("  float gf = (glassfactor  * (murkiness - abs(dot(SCENEJS_vViewNormal, vec3(0.0, 0.0, -1.0)))));");
                    add("  alpha = max(alpha, gf);");
                    add("  transparency = 1.0 - alpha;");
                    add("}");
                }

                if (normals && normalMapping && !autoTangents) {
                    add("mat3 mat =  mat3(SCENEJS_uVMatrix * SCENEJS_uMMatrix);");
                    add("vec3 n = normalize(SCENEJS_vViewNormal);");
                    add("vec3 t = normalize(mat * SCENEJS_vTangent);");
                    add("vec3 b = normalize(cross(SCENEJS_vViewNormal, mat * SCENEJS_vTangent));");
                    add("mat3 TBN = mat3(t, b, n);");
                }

                if (texturing) {

                    add("vec2 textureCoord;");

                    // ------------ Texture maps ------------------------------------

                    var firstAlpha = true; // applies to first alpha or first transparency
                    var firstColor = true;
                    var firstOcclusion = true;
                    var firstEmit = true;
                    var firstSpecular = true;
                    var firstShine = true;
                    var firstMetallic = true;
                    var firstRoughness = true;
                    var firstMetallicRoughness = true;
                    var firstNormal = true;

                    if (points) {
                        add("vec2 pointCoord = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);");
                        add("vec2 centerCoord = vec2(0.5);");
                        if (uvTranslatePoints) {
                            add("centerCoord = SCENEJS_vPointUVTranslate + SCENEJS_uPointUVScale * 0.5;");
                            add("pointCoord = pointCoord * SCENEJS_uPointUVScale + SCENEJS_vPointUVTranslate;");
                        }
                        if (scaleRotationPoints) {
                            add("vec2 pivot = pointCoord - centerCoord;");
                            add("float c = cos(SCENEJS_vPointRotation);");
                            add("float s = sin(SCENEJS_vPointRotation);");
                            add("pointCoord.x = c * pivot.x + s * pivot.y + centerCoord.x;");
                            add("pointCoord.y = c * pivot.y - s * pivot.x + centerCoord.y;");
                        }
                    }

                    for (var i = 0, len = states.texture.layers.length; i < len; i++) {
                        var layer = states.texture.layers[i];
                        var uvLayerIndex = layer.uvLayerIdx || 0;
                        var uvBufs = states.geometry.uvBufs;

                        if (uvBufs && uvBufs[uvLayerIndex]) {
                            add("textureCoord = SCENEJS_vUVCoord" + uvLayerIndex + ";");
                        } else if (points) {
                            add("textureCoord = pointCoord;");
                        } else {
                            SceneJS.log.warn("Texture layer applyTo='uv' but geometry has no UV coordinates for layer " + uvLayerIndex);
                            continue;
                        }

                        if (layer.matrix) {
                            add("textureCoord=(SCENEJS_uLayer" + i + "Matrix * vec4(textureCoord, 1.0, 1.0)).xy;");
                        }

                        if (layer.compressed) {
                            add("textureCoord.y = 1.0 - textureCoord.y;");
                        }

                        /* Alpha from Texture
                         * Operations must be done in 'alpha' space, but true alpha is stored in transparency variable (alpha = 1.0 - transparency).
                         * Convert to alpha before doing opteration. Convert back to transparency after operation;
                         */
                        if (layer.flags & TEXTURE_FLAGS.alpha) {
                            if (firstAlpha) {
                                add("transparency = mix(transparency, 1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                firstAlpha = false;
                            } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                add("alpha = 1.0 - transparency;");
                                add("alpha *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                                add("transparency = 1.0 - alpha;");
                            } else if (layer.flags & TEXTURE_FLAGS.add) {
                                add("alpha = 1.0 - transparency;");
                                add("alpha += SCENEJS_uLayer" + i + "BlendFactor * (texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                                add("transparency = 1.0 - alpha;");
                            } else if (layer.flags & TEXTURE_FLAGS.over) {
                                add("alpha = 1.0 - transparency;");
                                add("alpha = mix(alpha, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                add("transparency = 1.0 - alpha;");
                            }
                        }

                        if (layer.flags & TEXTURE_FLAGS.transparency) {
                            if (firstAlpha) {
                                add("transparency = mix(transparency, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                firstAlpha = false;
                            } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                add("transparency *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                            } else if (layer.flags & TEXTURE_FLAGS.add) {
                                add("transparency += SCENEJS_uLayer" + i + "BlendFactor * (texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                            } else if (layer.flags & TEXTURE_FLAGS.over) {
                                add("transparency = mix(transparency, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                            }
                        }

                        if (layer.flags & TEXTURE_FLAGS.occlusion) {
                            if (firstOcclusion) {
                                add("occlusion = mix(occlusion, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                firstOcclusion = false;
                            } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                add("occlusion *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                            } else if (layer.flags & TEXTURE_FLAGS.add) {
                                add("occlusion += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;")
                            } else if (layer.flags & TEXTURE_FLAGS.over) {
                                add("occlusion = mix(occlusion, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                            }
                        }

                        if (phongMaterial) {

                            if (gammaInputPhong) {

                                if (layer.flags & TEXTURE_FLAGS.baseColor) {
                                    if (firstColor) {
                                        add("color = mix(color, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                        firstColor = false;
                                    } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                        add("color *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb);");
                                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                                        add("color += SCENEJS_uLayer" + i + "BlendFactor * sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb;")
                                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                                        add("color = mix(color, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                    }
                                }

                                if (layer.flags & TEXTURE_FLAGS.emit) {
                                    if (firstEmit) {
                                        add("emitColor = mix(emitColor, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                        firstEmit = false;
                                    } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                        add("emitColor *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb);");
                                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                                        add("emitColor += SCENEJS_uLayer" + i + "BlendFactor * sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb;");
                                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                                        add("emitColor = mix(emitColor, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                    }
                                }

                            } else {

                                if (layer.flags & TEXTURE_FLAGS.baseColor) {
                                    if (firstColor) {
                                        if (layer.flags & TEXTURE_FLAGS.conditionalAlpha) {
                                            // conditionalAlpha: blend 2 textures with the alpha channel achieved from the second texture
                                            // only if uv.x is not -1. Use primarily for applying a draw texture.
                                            add("if(textureCoord.x != -1.0) {");
                                            add("   vec4 color" + i + " = texture2D(SCENEJS_uSampler" + i + ", textureCoord);");
                                            add("   color = mix(color, color" + i + ".rgb, color" + i + ".a * SCENEJS_uLayer" + i + "BlendFactor);");
                                            add("}");
                                        } else {
                                            add("color = mix(color, texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                        }
                                        firstColor = false;
                                    } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                        add("color *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb);");
                                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                                        add("color += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb;")
                                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                                        add("color = mix(color, texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                    } else if (layer.flags & TEXTURE_FLAGS.conditionalAlpha) {
                                        add("if(textureCoord.x != -1.0) {");
                                        add("vec4 color" + i + " = texture2D(SCENEJS_uSampler" + i + ", textureCoord);");
                                        add("color = mix(color, color" + i + ".rgb, color" + i + ".a * SCENEJS_uLayer" + i + "BlendFactor);");
                                        add("}");
                                    }
                                }

                                if (layer.flags & TEXTURE_FLAGS.emit) {
                                    if (firstEmit) {
                                        add("emitColor = mix(emitColor, texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                        firstEmit = false;
                                    } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                        add("emitColor *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb);");
                                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                                        add("emitColor += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb;");
                                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                                        add("emitColor = mix(emitColor, texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                    }
                                }
                            }

                            if ((layer.flags & TEXTURE_FLAGS.specular) && normals) {
                                if (firstSpecular) {
                                    add("specular = mix(specular, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                    firstSpecular = false;
                                } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                    add("specular *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                                } else if (layer.flags & TEXTURE_FLAGS.add) {
                                    add("specular += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                                } else if (layer.flags & TEXTURE_FLAGS.over) {
                                    add("specular = mix(specular, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                }
                            }

                            if (layer.flags & TEXTURE_FLAGS.shine) {
                                if (firstShine) {
                                    add("shine = mix((shine, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                    firstShine = false;
                                } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                    add("shine *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                                } else if (layer.flags & TEXTURE_FLAGS.add) {
                                    add("shine += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                                } else if (layer.flags & TEXTURE_FLAGS.over) {
                                    add("shine = mix((shine, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                }
                            }
                        }

                        if (metallicMaterial) {

                            if (layer.flags & TEXTURE_FLAGS.baseColor) {
                                if (firstColor) {
                                    add("color = mix(color, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                    firstColor = false;
                                } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                    add("color *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb);");
                                } else if (layer.flags & TEXTURE_FLAGS.add) {
                                    add("color += SCENEJS_uLayer" + i + "BlendFactor * sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb;")
                                } else if (layer.flags & TEXTURE_FLAGS.over) {
                                    add("color = mix(color, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                }
                            }

                            if (layer.flags & TEXTURE_FLAGS.emit) {
                                if (firstEmit) {
                                    add("emitColor = mix(emitColor, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                    firstEmit = false;
                                } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                    add("emitColor *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb);");
                                } else if (layer.flags & TEXTURE_FLAGS.add) {
                                    add("emitColor += SCENEJS_uLayer" + i + "BlendFactor * sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb;");
                                } else if (layer.flags & TEXTURE_FLAGS.over) {
                                    add("emitColor = mix(emitColor, sRGBToLinear(texture2D(SCENEJS_uSampler" + i + ", textureCoord)).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                                }
                            }

                            if (layer.flags & TEXTURE_FLAGS.metallic) {
                                if (firstMetallic) {
                                    add("metallic = mix(metallic, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                    firstMetallic = false;
                                } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                    add("metallic *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                                } else if (layer.flags & TEXTURE_FLAGS.add) {
                                    add("metallic += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                                } else if (layer.flags & TEXTURE_FLAGS.over) {
                                    add("metallic = mix(metallic, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                }
                            }

                            if (layer.flags & TEXTURE_FLAGS.roughness) {
                                if (firstRoughness) {
                                    add("roughness = mix(roughness, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                    firstRoughness = false;
                                } else if (layer.flags & TEXTURE_FLAGS.multiply) {
                                    add("roughness *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                                } else if (layer.flags & TEXTURE_FLAGS.add) {
                                    add("roughness += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                                } else if (layer.flags & TEXTURE_FLAGS.over) {
                                    add("roughness = mix(roughness, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                                }
                            }
                        }

                        if ((layer.flags & TEXTURE_FLAGS.normals) && normals) {
                            var op;
                            // support normal maps compressed with DXT5nm
                            var layerSwizzled = layer.flags & TEXTURE_FLAGS.swizzledNormals;
                            // SEE:
                            //  http://wiki.polycount.com/wiki/Normal_Map_Compression#DXT5nm_Compression
                            //  https://github.com/castano/nvidia-texture-tools/wiki/NormalMapCompression
                            //  http://realtimecollisiondetection.net/blog/?p=28
                            if (layer.flags & TEXTURE_FLAGS.add) {
                                op = firstNormal ? "=" : "+=";

                                if (autoTangents) {
                                    if (layerSwizzled) {
                                        if (layer.compressed) {
                                            add("viewNormalVec " + op + " perturbNormal2ArbSwz( SCENEJS_uSampler" + i + ", SCENEJS_vViewVertex.xyz, SCENEJS_vViewNormal, textureCoord ) * SCENEJS_uLayer" + i + "BlendFactor;");
                                        } else {
                                            add("viewNormalVec " + op + " perturbNormal2ArbSwz( SCENEJS_uSampler" + i + ", SCENEJS_vViewVertex.xyz, SCENEJS_vViewNormal, vec2(textureCoord.x, 1.0 - textureCoord.y) ) * SCENEJS_uLayer" + i + "BlendFactor;");
                                        }
                                    } else {
                                        add("viewNormalVec " + op + " perturbNormal2Arb( SCENEJS_uSampler" + i + ", SCENEJS_vViewVertex.xyz, SCENEJS_vViewNormal, textureCoord ) * SCENEJS_uLayer" + i + "BlendFactor;");
                                    }
                                } else {
                                    if (layerSwizzled) {
                                        // textureCoord.y may have been flipped above
                                        if (layer.compressed) {
                                            add("swizzledNormalMap = texture2D(SCENEJS_uSampler" + i + ", textureCoord);");
                                        } else {
                                            add("swizzledNormalMap = texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y));");
                                        }
                                        // unpack swizzled normals
                                        // get x and y from alpha and green, scaled to [-1, 1]
                                        add("vNormal = vec3(swizzledNormalMap.ag * 2.0 - 1.0, 0.0);");
                                        // recover z; (x^2 + y^2 + z^2 = 1)
                                        add("vNormal.z = sqrt(max(1.0 - dot(vNormal.xy, vNormal.xy), 0.0));");
                                        add("viewNormalVec " + op + " (TBN * normalize(vNormal)) * SCENEJS_uLayer" + i + "BlendFactor;");
                                    } else {
                                        add("viewNormalVec " + op + " (TBN * normalize(texture2D(SCENEJS_uSampler" + i + ", textureCoord).xyz * 2.0 - 1.0)) * SCENEJS_uLayer" + i + "BlendFactor;");
                                    }
                                }
                            } else {
                                if (autoTangents) {
                                    if (layerSwizzled) {
                                        if (layer.compressed) {
                                            add("viewNormalVec " + op + " perturbNormal2ArbSwz( SCENEJS_uSampler" + i + ", SCENEJS_vViewVertex.xyz, SCENEJS_vViewNormal, textureCoord ) * SCENEJS_uLayer" + i + "BlendFactor;");
                                        } else {
                                            add("viewNormalVec " + op + " perturbNormal2ArbSwz( SCENEJS_uSampler" + i + ", SCENEJS_vViewVertex.xyz, SCENEJS_vViewNormal, vec2(textureCoord.x, 1.0 - textureCoord.y) ) * SCENEJS_uLayer" + i + "BlendFactor;");
                                        }
                                    } else {
                                        add("viewNormalVec = mix(viewNormalVec, (perturbNormal2Arb(SCENEJS_uSampler" + i + ", SCENEJS_vViewVertex.xyz, SCENEJS_vViewNormal, textureCoord).xyz), SCENEJS_uLayer" + i + "BlendFactor);");
                                    }
                                } else {
                                    if (layerSwizzled) {
                                        // textureCoord.y may have been flipped above
                                        if (layer.compressed) {
                                            add("swizzledNormalMap = texture2D(SCENEJS_uSampler" + i + ", textureCoord);");
                                        } else {
                                            add("swizzledNormalMap = texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y));");
                                        }
                                        // unpack swizzled normals
                                        // get x and y from alpha and green, scaled to [-1, 1]
                                        add("vNormal = vec3(swizzledNormalMap.ag * 2.0 - 1.0, 0.0);");
                                        // recover z; (x^2 + y^2 + z^2 = 1)
                                        add("vNormal.z = sqrt(max(1.0 - dot(vNormal.xy, vNormal.xy), 0.0));");
                                        add("viewNormalVec = mix(viewNormalVec, TBN * normalize(vNormal), SCENEJS_uLayer" + i + "BlendFactor);");
                                    } else {
                                        add("viewNormalVec = mix(viewNormalVec, TBN * normalize(texture2D(SCENEJS_uSampler" + i + ", textureCoord).xyz * 2.0 - 1.0), SCENEJS_uLayer" + i + "BlendFactor);");
                                    }
                                }
                            }

                            firstNormal = false;
                        }
                    }

                    if (normalMapping) {
                        add("viewNormalVec = normalize(viewNormalVec);")
                    }
                }

                add("vec4 fragColor;");

                if (normals) {

                    add("vec3 viewLightDir;");

                    if (phongMaterial) {

                        //--------------------------------------------------------------------------------------------------
                        // Phong lighting
                        //--------------------------------------------------------------------------------------------------

                        add("vec3 lightValue = vec3(0.0, 0.0, 0.0);");
                        add("vec3 specularValue  = vec3(0.0, 0.0, 0.0);");
                        add("vec3 viewLightVec;");
                        add("float dotN;");
                        add("float spotDirRatio;");
                        add("float lightDist;");

                        if (phongReflectionMapping) {

                            add("float reflectFactor = 1.0;");

                            if (reflectFresnel) {
                                add("float reflectFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uReflectFresnelEdgeColor.a,  SCENEJS_uReflectFresnelCenterColor.a, SCENEJS_uReflectFresnelPower);");

                                if (reflectFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                    add("reflectFactor *= mix(SCENEJS_uReflectFresnelEdgeColor.b, SCENEJS_uReflectFresnelCenterColor.b, reflectFresnel);");
                                } else if (reflectFresnel.blendMode & TEXTURE_FLAGS.add) {
                                    add("reflectFactor += mix(SCENEJS_uReflectFresnelEdgeColor.b, SCENEJS_uReflectFresnelCenterColor.b, reflectFresnel);");
                                }
                            }

                            add("vec3 envLookup = reflect(-viewEyeVec, viewNormalVec);");

                            add("vec4 envColor;");
                            for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                                var layer = states.cubemap.layers[i];
                                if (layer.applyTo === SceneJS.CUBEMAP_FLAGS.reflect) {
                                    add("envColor = textureCube(SCENEJS_uCubeMapSampler" + i + ", envLookup);");
                                    add("color = mix(color, envColor.rgb, reflectFactor * specular * SCENEJS_uCubeMapIntensity" + i + ");");
                                }
                            }
                        }

                        var light;

                        for (var i = 0, len = states.lights.length; i < len; i++) {
                            light = states.lights[i];

                            if (light.mode == "ambient") {
                                continue;
                            }

                            if (light.mode == "point") {
                                if (light.space == "world") {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;"); // Vector from World coordinate to light pos
                                    add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");
                                } else {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos
                                }
                                add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");
                                add("lightDist = length( SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");
                                add("attenuation = 1.0 - (" +
                                    "  SCENEJS_uLightAttenuation" + i + ".x + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");
                                if (light.diffuse) {
                                    add("      lightValue += dotN * SCENEJS_uLightColor" + i + " * attenuation;");
                                }
                                if (light.specular) {
                                    add("    specularValue += specularColor * SCENEJS_uLightColor" + i + " * specular * pow(max(dot(reflect(normalize(-viewLightVec), -viewNormalVec), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine) * attenuation;");
                                }
                            }

                            if (light.mode == "spot") {

                                add("viewLightDir = SCENEJS_uLightDir" + i + ";");

                                if (light.space == "world") {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;"); // Vector from World coordinate to light pos
                                    add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");
                                    add("viewLightDir = vec3(SCENEJS_uVMatrix * vec4(viewLightDir, 0.0)).xyz;");
                                } else {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos
                                }

                                add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");
                                add("spotDirRatio = 1.0 - max(dot(normalize(viewLightDir), normalize(-viewLightVec)), 0.0);");
                                add("lightDist = length( SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");
                                add("attenuation = 1.0 - (" +
                                    "  SCENEJS_uLightAttenuation" + i + ".x + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");

                                // Attenuations due to spotlight cones
                                add("attenuation *= 1.0 - clamp((spotDirRatio - SCENEJS_uInnerCone" + i + ") / max(SCENEJS_uOuterCone" + i + " - SCENEJS_uInnerCone" + i + ", 0.0001), 0.0, 1.0);");
                                if (light.diffuse) {
                                    add("      lightValue += dotN * SCENEJS_uLightColor" + i + " * attenuation;");
                                }
                                if (light.specular) {
                                    add("    specularValue += specularColor * SCENEJS_uLightColor" + i + " * specular * pow(max(dot(reflect(normalize(-viewLightVec), -viewNormalVec), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine) * attenuation;");
                                }
                            }

                            if (light.mode == "dir") {
                                if (light.space == "world") {
                                    add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");
                                    add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");

                                } else {
                                    add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");
                                }
                                add("viewLightVec = -viewLightVec;");
                                add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");
                                if (light.diffuse) {
                                    add("lightValue += dotN * SCENEJS_uLightColor" + i + ";");
                                }
                                if (light.specular) {
                                    add("specularValue += specularColor * SCENEJS_uLightColor" + i + " * specular * pow(max(dot(reflect(normalize(-viewLightVec), -viewNormalVec), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine);");
                                }
                            }
                        }

                        //--------------------------------------------------------------------------------
                        // PHONG FRESNELS
                        //--------------------------------------------------------------------------------

                        if (diffuseFresnel) {
                            add("float diffuseFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uDiffuseFresnelEdgeColor.a, SCENEJS_uDiffuseFresnelCenterColor.a, SCENEJS_uDiffuseFresnelPower);");
                            if (diffuseFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("color.rgb *= mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                            } else if (diffuseFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("color.rgb += mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                            }
                        }

                        if (specularFresnel) {
                            add("float specFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uSpecularFresnelEdgeColor.a, SCENEJS_uSpecularFresnelCenterColor.a, SCENEJS_uSpecularFresnelPower);");
                            if (specularFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("specularValue.rgb *= mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                            } else if (specularFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("specularValue.rgb += mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                            }
                        }

                        if (alphaFresnel) {
                            // We could convert to alpha and do in alpha space, or do in transparency space
                            // Transparency Calculation for "multiply": t = 1 + mix(afe,afc,af) - t*mix(afe,afc,af)
                            // Transparency Calculation for "add": t = t - mix(afe,afc,af)
                            add("float alphaFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uAlphaFresnelEdgeColor.a, SCENEJS_uAlphaFresnelCenterColor.a, SCENEJS_uAlphaFresnelPower);");
                            add("alpha = 1.0 - transparency;");
                            if (alphaFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("alpha *= mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                            } else if (alphaFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("alpha += mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                            }
                            add("transparency = 1.0 -alpha;");
                        }

                        if (transparencyFresnel) {
                            add("float transparencyFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uTransparencyFresnelEdgeColor.a, SCENEJS_uTransparencyFresnelCenterColor.a, SCENEJS_uTransparencyFresnelPower);");
                            if (transparencyFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("transparency *= mix(SCENEJS_uTransparencyFresnelEdgeColor.r, SCENEJS_uTransparencyFresnelCenterColor.r, transparencyFresnel);");
                            } else if (transparencyFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("transparency += mix(SCENEJS_uTransparencyFresnelEdgeColor.r, SCENEJS_uTransparencyFresnelCenterColor.r, transparencyFresnel);");
                            }
                        }

                        if (emitFresnel) {
                            add("float emitFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uEmitFresnelEdgeColor.a, SCENEJS_uEmitFresnelCenterColor.a, SCENEJS_uEmitFresnelPower);");
                            if (emitFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("emitColor.rgb *= mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                            } else if (emitFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("emitColor.rgb += mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                            }
                        }

                        //--------------------------------------------------------------------------------
                        // COMBINE PHONG TERMS
                        //--------------------------------------------------------------------------------

                        add("alpha = 1.0 - transparency;");
                        add("fragColor = vec4((specularValue.rgb + color.rgb * (lightValue.rgb + ambientColor.rgb)) + (emit * emitColor.rgb), alpha);");

                    } //phongMaterial


                    if (metallicMaterial) {

                        //--------------------------------------------------------------------------------------------------
                        // PBR lighting
                        //--------------------------------------------------------------------------------------------------

                        // PREPARE INPUTS FOR SHADER FUNCTIONS

                        add("IncidentLight  light;");
                        add("Material       material;");
                        add("Geometry       geometry;");
                        add("ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));");

                        add("float dielectricSpecular   = 0.16 * specularF0 * specularF0;");
                        add("material.diffuseColor      = color * (1.0 - dielectricSpecular) * (1.0 - metallic);");
                        add("float realRoughness = sqrt(roughness);"); // Convert from perceptual roughness
                        add("material.specularRoughness = clamp(realRoughness, 0.04, 1.0);");
                        add("material.specularColor     = mix(vec3(dielectricSpecular), color, metallic);");

                        // GEOMETRY

                        add("geometry.position = SCENEJS_vViewVertex.xyz;");

                        if (phongLightMapping) {
                            add("geometry.worldNormal = normalize(SCENEJS_vWorldNormal);");
                        }

                        add("geometry.viewNormal = viewNormalVec;");
                        add("geometry.viewEyeDir = -normalize(SCENEJS_vViewVertex.xyz);");

                        // REFLECTION MAPPING

                        if (pbrReflectionMapping) {
                            add("computePBRReflectionMapping(SCENEJS_uPBRReflectionMapSampler, SCENEJS_uPBRReflectionMapIntensity, SCENEJS_uVMatrix, geometry, material, reflectedLight, SCENEJS_uPBRReflectionMapMipLevels);");
                        }

                        // LIGHT MAPPING

                        if (pbrLightMapping) {

                            var lightmap = states.lightmaps.activeLightmap;
                            if (lightmap.space === "world") {
                                add("computePBRLightMapping(SCENEJS_uPBRLightMapSampler, SCENEJS_uPBRLightMapIntensity, geometry.worldNormal, material, reflectedLight);");
                            } else {
                                add("computePBRLightMapping(SCENEJS_uPBRLightMapSampler, SCENEJS_uPBRLightMapIntensity, geometry.viewNormal, material, reflectedLight);");
                            }
                        }

                        //--------------------------------------------------------------------------------
                        // CALL PBR SHADING FUNCTION FOR EACH LIGHT
                        //--------------------------------------------------------------------------------

                        add("vec3 lightValue = vec3(0.0, 0.0, 0.0);");
                        add("vec3 specularValue  = vec3(0.0, 0.0, 0.0);");
                        add("vec3 viewLightVec;");
                        add("float dotN;");
                        add("float spotDirRatio;");
                        add("float lightDist;");

                        var light;

                        for (var i = 0, len = states.lights.length; i < len; i++) {

                            light = states.lights[i];

                            if (light.mode == "ambient") {
                                continue;
                            }

                            if (light.mode == "dir") {
                                if (light.space == "world") {
                                    add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");
                                    add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;"); // Transform to View space
                                } else {
                                    add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");
                                }
                                add("viewLightVec = -viewLightVec;");
                                add("light.direction = viewLightVec;");
                                add("light.color = SCENEJS_uLightColor" + i + ";");

                                add("computePBRLighting(light, geometry, material, reflectedLight);");
                            }

                            if (light.mode == "point") {
                                if (light.space == "world") {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;");
                                    add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;"); // Transform to View space
                                } else {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos
                                }
                                add("lightDist = length(viewLightVec);");
                                add("attenuation = 1.0 - (" +
                                    "  SCENEJS_uLightAttenuation" + i + ".x + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");
                                add("light.direction = normalize(viewLightVec);");
                                add("light.color = SCENEJS_uLightColor" + i + " * attenuation;");

                                add("computePBRLighting(light, geometry, material, reflectedLight);");
                            }

                            if (light.mode == "spot") {
                                add("viewLightDir = SCENEJS_uLightDir" + i + ";");
                                if (light.space == "world") {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;");
                                    add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;"); // Transform to View space
                                    add("viewLightDir = vec3(SCENEJS_uVMatrix * vec4(viewLightDir, 0.0)).xyz;");
                                } else {
                                    add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos
                                }
                                add("spotDirRatio = 1.0 - max(dot(normalize(viewLightDir), normalize(-viewLightVec)), 0.0);");
                                add("lightDist = length(SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");
                                add("attenuation = 1.0 - (" +
                                    "  SCENEJS_uLightAttenuation" + i + ".x + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                                    "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");
                                add("attenuation *= 1.0 - clamp((spotDirRatio - SCENEJS_uInnerCone" + i + ") / max(SCENEJS_uOuterCone" + i + " - SCENEJS_uInnerCone" + i + ", 0.0001), 0.0, 1.0);");
                                add("light.direction = normalize(viewLightVec);");
                                add("light.color = SCENEJS_uLightColor" + i + " * attenuation;");

                                add("computePBRLighting(light, geometry, material, reflectedLight);");
                            }
                        }

                        //--------------------------------------------------------------------------------
                        // PBR FRESNELS
                        //--------------------------------------------------------------------------------

                        if (diffuseFresnel) {
                            add("float diffuseFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uDiffuseFresnelEdgeColor.a, SCENEJS_uDiffuseFresnelCenterColor.a, SCENEJS_uDiffuseFresnelPower);");
                            if (diffuseFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("reflectedLight.diffuse *= mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                            } else if (diffuseFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("reflectedLight.diffuse += mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                            }
                        }

                        if (specularFresnel) {
                            add("float specFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uSpecularFresnelEdgeColor.a, SCENEJS_uSpecularFresnelCenterColor.a, SCENEJS_uSpecularFresnelPower);");
                            if (specularFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("reflectedLight.specular *= mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                            } else if (specularFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("reflectedLight.specular += mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                            }
                        }

                        if (alphaFresnel) {
                            // We could convert to alpha and do in alpha space, or do in transparency space
                            // Transparency Calculation for "multiply": t = 1 + mix(afe,afc,af) - t*mix(afe,afc,af)
                            // Transparency Calculation for "add": t = t - mix(afe,afc,af)
                            add("float alphaFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uAlphaFresnelEdgeColor.a, SCENEJS_uAlphaFresnelCenterColor.a, SCENEJS_uAlphaFresnelPower);");
                            add("alpha = 1.0 - transparency;");
                            if (alphaFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("alpha *= mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                            } else if (alphaFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("alpha += mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                            }
                            add("transparency = 1.0 - alpha;");
                        }

                        if (transparencyFresnel) {
                            add("float transparencyFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uTransparencyFresnelEdgeColor.a, SCENEJS_uTransparencyFresnelCenterColor.a, SCENEJS_uTransparencyFresnelPower);");
                            if (transparencyFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("transparency *= mix(SCENEJS_uTransparencyFresnelEdgeColor.r, SCENEJS_uTransparencyFresnelCenterColor.r, transparencyFresnel);");
                            } else if (transparencyFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("transparency += mix(SCENEJS_uTransparencyFresnelEdgeColor.r, SCENEJS_uTransparencyFresnelCenterColor.r, transparencyFresnel);");
                            }
                        }

                        if (emitFresnel) {
                            add("float emitFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uEmitFresnelEdgeColor.a, SCENEJS_uEmitFresnelCenterColor.a, SCENEJS_uEmitFresnelPower);");
                            if (emitFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                                add("emitColor.rgb *= mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                            } else if (emitFresnel.blendMode & TEXTURE_FLAGS.add) {
                                add("emitColor.rgb += mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                            }
                        }

                        //--------------------------------------------------------------------------------
                        // COMBINE PBR TERMS
                        //--------------------------------------------------------------------------------

                        add("vec3 outgoingLight = (occlusion * reflectedLight.diffuse) + (occlusion * reflectedLight.specular) + (emit * emitColor);");
                        add("alpha = 1.0 - transparency;");
                        add("fragColor = vec4(outgoingLight, alpha);");

                    } // metallicMaterial

                } else { // No normals

                    add("alpha = 1.0 - transparency;");
                    add("fragColor = vec4((color.rgb + (emit * color.rgb)) *  (vec3(1.0, 1.0, 1.0) + ambientColor.rgb), alpha);");
                }

                if (opacityMods) {
                    var omi = 0;
                    var omods = states.properties.opacityModifiers;
                    var len = omods.length;
                    var hasOpacityFresnel = false;
                    var hasOpacityRange = false;
                    add("float opacity;");
                    for (omi = 0; omi < len; omi++) {
                        opacityMod = omods[omi];
                        if (opacityMod.value.isScalarFresnel) {
                            if (!hasOpacityFresnel) {
                                add("float opacityModFresnel;");
                                hasOpacityFresnel = true;
                            }
                            add("opacityModFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uOpacityModFresnelEdge" + omi + ".a, " + "SCENEJS_uOpacityModFresnelCenter" + omi + ".a, SCENEJS_uOpacityModFresnelPower" + omi + ");");
                            add("opacity = mix(SCENEJS_uOpacityModFresnelEdge" + omi + ".r, SCENEJS_uOpacityModFresnelCenter" + omi + ".r, opacityModFresnel);");
                        } else {
                            add("opacity =  SCENEJS_uOpacityModification" + omi + ";");
                        }
                        if (opacityMod.range) {
                            if (!hasOpacityRange) {
                                add("float opacityModFactor;");
                                hasOpacityRange = true;
                            }
                            add("opacityModFactor = 1.0 - clamp((length(SCENEJS_vWorldVertex.xyz - SCENEJS_uOpacityModCenter" + omi + ") - SCENEJS_uOpacityModRadius" + omi + ".x) / SCENEJS_uOpacityModRadius" + omi + ".y, 0.0, 1.0);");
                            add("opacity = mix(1.0, opacity, opacityModFactor);");
                        }
                        add("fragColor.a *= opacity;");
                    }
                }

                if (clipping && states.clips.clipFade) {
                    add("fragColor.a *= 1.0 - max(distAlpha, 0.0);");
                }

                //--------------------------------------------------------------------------------
                // Effects post-applied to shaded fragments
                //--------------------------------------------------------------------------------

                if (regionInteraction) {

                    // Region map highlighting

                    add("vec3 regionColor = texture2D(SCENEJS_uRegionMapSampler, vec2(SCENEJS_vRegionMapUV.s, SCENEJS_vRegionMapUV.t)).rgb;");
                    add("float tolerance = 0.01;");
                    add("vec3 colorDelta = abs(SCENEJS_uRegionMapRegionColor - regionColor);");
                    if (states.regionMap.mode === "highlight" || states.regionMap.mode === "hide") {
                        add("if (max(colorDelta.x, max(colorDelta.y, colorDelta.z)) < tolerance) {");
                        if (states.regionMap.mode === "highlight") {
                            add("  fragColor.rgb *= SCENEJS_uRegionMapHighlightFactor;");
                        } else {
                            // mode = "hide"
                            add("  fragColor.a = SCENEJS_uRegionMapHideAlpha;");
                        }
                        add("}");
                    } else {
                        // mode = "isolate"
                        add("if (max(colorDelta.x, max(colorDelta.y, colorDelta.z)) > tolerance) {");
                        add("  fragColor.a = SCENEJS_uRegionMapHideAlpha;");
                        add("}");
                    }
                }

                if (alphaTest) {
                    add("if (SCENEJS_uDiscardOpaque && fragColor.a >= 1.0) { discard; }");
                    add("if (!SCENEJS_uDiscardOpaque && fragColor.a < 1.0) { discard; }");
                }

                if (stochasticAlpha) {
                    add("{");
                    add("    float maxDeriv = max(length(dFdx(SceneJS_vModelVertex.xy)), length(dFdy(SceneJS_vModelVertex.xy)));");
                    add("    float pixScale = 1.0 / maxDeriv;");
                    add("    vec2 pixScales = vec2( exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))) );");
                    add("    vec2 alpha = vec2(hash3D(floor(pixScales.x * SceneJS_vModelVertex.xyz)), hash3D(floor(pixScales.y * SceneJS_vModelVertex.xyz)));");
                    add("    float lerpFactor = fract(log2(pixScale));");
                    add("    float x = (1.0 - lerpFactor) * alpha.x + lerpFactor * alpha.y;");
                    add("    float a = min(lerpFactor, 1.0 - lerpFactor);");
                    add("    vec3 cases = vec3(");
                    add("        x * x / (2.0 * a * (1.0 - a)), ");
                    add("        (x - 0.5 * a)/(1.0 - a), ");
                    add("        1.0 - ((1.0 - x) * (1.0 - x) / (2.0 * a * (1.0 - a)))");
                    add("    );");
                    add("    float aThresh = (x < (1.0 - a)) ? ((x < a) ? cases.x : cases.y) : cases.z;");
                    add("    aThresh = clamp(aThresh, 1.0e-6, 1.0);");
                    add("    if (fragColor.a < aThresh) {");
                    add("        discard;");
                    add("    } else {");
                    add("        fragColor.a = 1.0;");
                    add("    }");
                    add("}");
                }

                // Color Modification Sequence
                if (colorModifiers.length > 0) {
                    add("float colorModFresnel;");
                    add("float saturation;");
                    add("float contrast;");
                    add("float brightness;");
                    add("float colorModFactor;");
                    add("vec3 tintColor;");

                    var calculatedLuma = false;
                    var cmi = 0, len = colorModifiers.length;
                    var colorMod;
                    for (cmi = 0; cmi < len; cmi++) {

                        colorMod = colorModifiers[cmi];

                        // attenuate color modification by range, if applicable
                        if (colorMod.range) {
                            add("colorModFactor = 1.0 - clamp((length(SCENEJS_vWorldVertex.xyz - SCENEJS_uColorModCenter" + cmi + ") - SCENEJS_uColorModRadius" + cmi + ".x) / SCENEJS_uColorModRadius" + cmi + ".y, 0.0, 1.0);");
                        }

                        // apply color modifications

                        if (colorMod.applyTo === COLOR_MOD_FLAGS.SATURATION) {

                            //------------------------------------------------------------------------------------------
                            // Saturation
                            //------------------------------------------------------------------------------------------

                            if (!calculatedLuma) {
                                add("float L = dot(vec3(0.3, 0.59, 0.11), fragColor.rgb);");
                                calculatedLuma = true;
                            }

                            if (colorMod.value.isScalarFresnel) {
                                add("colorModFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uColorModFresnelEdge" + cmi + ".a, " + "SCENEJS_uColorModFresnelCenter" + cmi + ".a, SCENEJS_uColorModFresnelPower" + cmi + ");");
                                add("saturation = mix(SCENEJS_uColorModFresnelEdge" + cmi + ".r, SCENEJS_uColorModFresnelCenter" + cmi + ".r, colorModFresnel);");
                            } else {
                                add("saturation = SCENEJS_uColorModification" + cmi + ";");
                            }

                            if (colorMod.range) {
                                add("saturation *= colorModFactor;");
                            }
                            add("fragColor.rgb -= saturation * (L - fragColor.rgb);");

                        } else if (colorMod.applyTo === COLOR_MOD_FLAGS.CONTRAST) {

                            //------------------------------------------------------------------------------------------
                            // Contrast
                            //------------------------------------------------------------------------------------------

                            if (colorMod.value.isScalarFresnel) {
                                add("colorModFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uColorModFresnelEdge" + cmi + ".a, " + "SCENEJS_uColorModFresnelCenter" + cmi + ".a, SCENEJS_uColorModFresnelPower" + cmi + ");");
                                add("contrast = mix(SCENEJS_uColorModFresnelEdge" + cmi + ".r, SCENEJS_uColorModFresnelCenter" + cmi + ".r, colorModFresnel);");
                            } else {
                                add("contrast = SCENEJS_uColorModification" + cmi + ";");
                            }

                            if (colorMod.range) {
                                add("contrast = mix(1.0, contrast, colorModFactor);");
                            }
                            add("fragColor.rgb = (fragColor.rgb - 0.5) * contrast + 0.5;");

                        } else if (colorMod.applyTo === COLOR_MOD_FLAGS.BRIGHTNESS) {

                            //------------------------------------------------------------------------------------------
                            // Brightness
                            //------------------------------------------------------------------------------------------

                            if (colorMod.value.isScalarFresnel) {
                                add("colorModFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uColorModFresnelEdge" + cmi + ".a, " + "SCENEJS_uColorModFresnelCenter" + cmi + ".a, SCENEJS_uColorModFresnelPower" + cmi + ");");
                                add("brightness = mix(SCENEJS_uColorModFresnelEdge" + cmi + ".r, SCENEJS_uColorModFresnelCenter" + cmi + ".r, colorModFresnel);");
                            } else {
                                add("brightness = SCENEJS_uColorModification" + cmi + ";");
                            }
                            if (colorMod.range) {
                                add("brightness *= colorModFactor;");
                            }
                            add("fragColor.rgb += brightness;");

                        } else if (colorMod.applyTo === COLOR_MOD_FLAGS.TINT) {

                            //------------------------------------------------------------------------------------------
                            // Tint
                            //------------------------------------------------------------------------------------------

                            if (colorMod.value.isColorFresnel) {
                                add("colorModFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uColorModFresnelEdge" + cmi + ".a, " + "SCENEJS_uColorModFresnelCenter" + cmi + ".a, SCENEJS_uColorModFresnelPower" + cmi + ");");
                                add("tintColor = mix(SCENEJS_uColorModFresnelEdge" + cmi + ".rgb, SCENEJS_uColorModFresnelCenter" + cmi + ".rgb, colorModFresnel);");
                                if (colorMod.range) {
                                    add("tintColor = mix(vec3(1.0), tintColor, colorModFactor);");
                                }
                            } else {
                                add("tintColor = SCENEJS_uColorModification" + cmi + ";");
                                if (colorMod.range) {
                                    add("tintColor = mix(vec3(1.0), tintColor, colorModFactor);");
                                }
                            }
                            add("fragColor.rgb *= tintColor;");
                        }
                    }
                }

                if (fogEnabled) {
                    add("vec3 fogColor = SCENEJS_uFogColor.rgb;");
                    add("float fogDensity = SCENEJS_uFogColor.a;");
                    add("float fogStart = SCENEJS_uFogParams.x;");
                    add("float fogEnd = SCENEJS_uFogParams.y;");
                    add("float fogMin = SCENEJS_uFogParams.z;");
                    add("float fogMax = SCENEJS_uFogParams.w;");
                    if (fogMode === DISPLAY_FLAGS.FOG_LINEAR) {
                        add("float fog = (length(SCENEJS_vViewVertex.xyz) - fogStart) / (fogEnd - fogStart);");
                    } else {
                        add("float fogAttenuation = fogDensity * max(length(SCENEJS_vViewVertex.xyz) - fogStart, 0.0);");
                        if (fogMode === DISPLAY_FLAGS.FOG_EXP2) {
                            add("fogAttenuation = fogAttenuation * fogAttenuation;");
                        }
                        add("float fog = 1.0 - exp(-fogAttenuation);");

                    }
                    add("fog = clamp(fog, fogMin, fogMax);");
                    add("fragColor.rgb = mix(fragColor.rgb, fogColor, fog);");
                }

                if (fragmentFresnel) {
                    add("float fragmentFresnel = fresnel(viewEyeVec, viewNormalVec, SCENEJS_uFragmentFresnelEdgeColor.a, SCENEJS_uFragmentFresnelCenterColor.a, SCENEJS_uFragmentFresnelPower);");

                    if (fragmentFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                        add("fragColor.rgb *= mix(SCENEJS_uFragmentFresnelEdgeColor.rgb, SCENEJS_uFragmentFresnelCenterColor.rgb, fragmentFresnel);");
                    } else if (fragmentFresnel.blendMode & TEXTURE_FLAGS.add) {
                        add("fragColor.rgb += mix(SCENEJS_uFragmentFresnelEdgeColor.rgb, SCENEJS_uFragmentFresnelCenterColor.rgb, fragmentFresnel);");
                    }
                }

                // Ensure compositing is done properly for pre-multiplied alpha
                if (gammaOutput) {
                    src.push("fragColor = linearToGamma(fragColor, 2.2);");
                }

                if (!stochasticAlpha) {
                    add("fragColor.rgb *= fragColor.a;");
                }

                add("fragColor = clamp(fragColor, 0.0, 1.0);");
                add("fragColor.a = max(max(fragColor.r, fragColor.g), max(fragColor.b, fragColor.a));");

                if (fragmentShaderFooter) {
                    add(fragmentShaderFooter);
                } else {
                    add("if (SCENEJS_uOutputFormat == 0.0) {");
                    add("    gl_FragColor = fragColor;");
                    add("} else if (SCENEJS_uOutputFormat == 1.0) {");
                    add("    vec2 uv = gl_FragCoord.xy / SCENEJS_uCanvasRes;")
                    add("    float fragZ = gl_FragCoord.z - texture2D(SCENEJS_uDepthBuffer, uv).r;")
                    add("    float d = 1.0 - fragZ * 0.99;");
                    add("    float d4 = d * d * d * d;");
                    add("    float d16 = d4 * d4 * d4 * d4;");
                    add("    float a2 = fragColor.a * fragColor.a;");
                    add("    float a4 = a2 * a2;");
                    add("    float depthWeight = 256.0 * d4 * a2 + 4096.0 * d16 * d16 * a4;");
                    add("    float w = clamp(depthWeight, 0.0001, 1e4);");
                    add("    vec3 ycocg = RGB_YCOCG * (fragColor.rgb * w);")
                    add("    bool checkerboard = mod(gl_FragCoord.x, 2.0) == mod(gl_FragCoord.y, 2.0);")
                    add("    gl_FragColor = vec4(ycocg.r, checkerboard ? ycocg.g : ycocg.b, fragColor.a * w, fragColor.a);");
                    add("}");
                }

                add("}");

                return end();
            }

            function vertexXRay() {
                begin();
                add("uniform mat4 SCENEJS_uMMatrix;");
                if (FRAG_HIGHP_SUPPORTED) {
                    add("uniform mat4 SCENEJS_uVMatrix;");
                    add("uniform vec3 SCENEJS_uWorldEye;");
                } else {
                    add("uniform mediump mat4 SCENEJS_uVMatrix;");
                    add("uniform mediump vec3 SCENEJS_uWorldEye;");
                }
                add("uniform mat4 SCENEJS_uPMatrix;");
                add("attribute vec4 SCENEJS_aVertex;");
                if (points) {
                    add("uniform float SCENEJS_uPointSize;");
                    if (scaleRotationPoints) {
                        add("attribute vec2 SCENEJS_aPointScaleRotation;");
                    }
                }
                if (quantizedPositions) {
                    add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
                }

                add("varying vec4 SCENEJS_vViewVertex;");

                if (normals) {
                    add("attribute vec3 SCENEJS_aNormal;");
                    add("uniform   mat4 SCENEJS_uMNMatrix;");
                    add("varying   vec3 SCENEJS_vViewNormal;");
                }

                if (clipping) {
                    add("varying vec4 SCENEJS_vWorldVertex;");
                }
                if (stochasticAlpha) {
                    add("varying vec4 SceneJS_vModelVertex;");
                }

                if (morphing) {
                    add("uniform float SCENEJS_uMorphFactor;");
                    if (states.morphGeometry.targets[0].vertexBuf) {
                        add("attribute vec4 SCENEJS_aMorphVertex;");
                    }
                    if (normals) {
                        if (states.morphGeometry.targets[0].normalBuf) {
                            add("attribute vec3 SCENEJS_aMorphNormal;");
                        }
                    }
                    if (quantizedPositions) {
                        add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
                    }
                }
                if (billboard) {
                    add("void billboard(inout mat4 mat) {");
                    add("   mat[0].xyz = vec3(1.0, 0.0, 0.0);");
                    add("   mat[1].xyz = vec3(0.0, 1.0, 0.0);");
                    add("   mat[2].xyz = vec3(0.0, 0.0, 1.0);");
                    add("}");
                }
                if (octNormals) {
                    add("vec3 octDecode(vec2 oct) {");
                    add("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
                    add("    if (v.z < 0.0) {");
                    add("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
                    add("    }");
                    add("    return normalize(v);");
                    add("}");
                }
                add("void main(void) {");
                if (quantizedPositions) {
                    add("vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
                } else {
                    add("vec4 modelVertex = SCENEJS_aVertex; ");
                }
                if (octNormals) {
                    add("vec4 modelNormal = vec4(octDecode(SCENEJS_aNormal.xy), 0.0); ");
                } else if (normals) {
                    add("vec4 modelNormal = vec4(SCENEJS_aNormal, 0.0); ");
                }
                if (morphing) {
                    if (states.morphGeometry.targets[0].vertexBuf) {
                        if (quantizedPositions) {
                            add("modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        } else {
                            add("modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        }
                    }
                    if (normals) {
                        if (states.morphGeometry.targets[0].normalBuf) {
                            if (octNormals) {
                                add("modelNormal = vec4( mix(modelNormal.xyz, octDecode(SCENEJS_aMorphNormal.xy), SCENEJS_uMorphFactor), 0.0); ");
                            } else {
                                add("modelNormal = vec4( mix(modelNormal.xyz, SCENEJS_aMorphNormal, SCENEJS_uMorphFactor), 0.0); ");
                            }
                        }
                    }
                }

                if (stochasticAlpha) {
                    add("SceneJS_vModelVertex = modelVertex;");
                }

                add("mat4 modelMatrix = SCENEJS_uMMatrix;");
                add("mat4 viewMatrix = SCENEJS_uVMatrix;");
                if (normals) {
                    add("mat4 modelNormalMatrix = SCENEJS_uMNMatrix;");
                }
                add("vec4 worldVertex;");
                add("vec4 viewVertex;");
                if (skybox) {
                    add("viewMatrix[3].xyz = vec3(0.0);");
                }
                if (billboard) {
                    add("mat4 modelViewMatrix =  viewMatrix * modelMatrix;");
                    add("billboard(modelMatrix);");
                    add("billboard(viewMatrix);");
                    add("billboard(modelViewMatrix);");
                    if (normals) {
                        add("billboard(modelNormalMatrix);");
                    }
                    add("worldVertex = modelMatrix * modelVertex;");
                    add("viewVertex = modelViewMatrix * modelVertex;");
                } else {
                    add("worldVertex = modelMatrix * modelVertex;");
                    add("viewVertex  = viewMatrix * worldVertex; ");
                }

                add("SCENEJS_vViewVertex = viewVertex;");

                if (normals) {
                    add("vec3 worldNormal = (modelNormalMatrix * modelNormal).xyz; ");
                    add("SCENEJS_vViewNormal = (viewMatrix * vec4(worldNormal, 0.0)).xyz;");
                }
                if (clipping) {
                    add("SCENEJS_vWorldVertex = worldVertex;");
                }
                add("gl_Position = SCENEJS_uPMatrix * viewVertex;");
                if (points) {
                    add("gl_PointSize = SCENEJS_uPointSize;");
                    if (perspectivePoints) {
                        add("gl_PointSize *= 20.0 / length(viewVertex.xyz);");
                    }
                    if (scaleRotationPoints) {
                        add("gl_PointSize *= SCENEJS_aPointScaleRotation.x;");
                    }
                    add("gl_PointSize = min(gl_PointSize, " + maxPointSizeStr + ");");
                }
                add("}");
                return end();
            }

            function fragmentXRay() {
                begin();
                if (stochasticAlpha) {
                    add("#extension GL_OES_standard_derivatives : enable");
                }
                if (fragmentShaderHeader) {
                    add(fragmentShaderHeader);
                }

                add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");

                add("#define EDGE_ALPHA 0.9");
                add("#define CENTER_ALPHA 0.0");
                add("#define EDGE_BIAS 0.0");
                add("#define CENTER_BIAS 0.6");

                add("uniform sampler2D SCENEJS_uDepthBuffer;");
                add("uniform vec2 SCENEJS_uCanvasRes;");

                add("varying vec4 SCENEJS_vViewVertex;");

                if (clipping) {
                    add("varying vec4 SCENEJS_vWorldVertex;");
                    if (solid) {
                        add("uniform vec3 SCENEJS_uSolidColor;");
                    }

                    for (var i = 0; i < states.clips.clips.length; i++) {
                        add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
                        if (states.clips.clips[i].fade) {
                            add("uniform float SCENEJS_uClipFadeDistance" + i + ";");
                        }
                    }
                }
                if (stochasticAlpha) {
                    add("varying vec4 SceneJS_vModelVertex;");
                }
                if (normals) {
                    add("uniform vec3 SCENEJS_uXrayColor;");
                    add("varying vec3 SCENEJS_vViewNormal;");
                }
                if (fogEnabled) {
                    add("uniform vec4   SCENEJS_uFogParams;"); // x = start, y = end, z = min, w = max
                    add("uniform vec4   SCENEJS_uFogColor;"); // RGB = color, a = density
                }

                add("uniform float SCENEJS_uOutputFormat;");

                add("#define RGB_YCOCG mat3(0.25, 0.5, -0.25, 0.5, 0.0, 0.5, 0.25, -0.5, -0.25)")

                if (alphaTest) {
                    add("uniform bool SCENEJS_uDiscardOpaque;")
                }

                if (stochasticAlpha) {
                    add("float hash(vec2 v) {");
                    add("    return fract(1.0e4 * sin(17.0 * v.x + 0.1 * v.y) * (0.1 + abs(sin(13.0 * v.y + v.x))));");
                    add("}");

                    add("float hash3D(vec3 v) {");
                    add("    return hash(vec2(hash(v.xy), v.z));");
                    add("}");
                }

                add("void main(void) {");
                add("vec4 fragColor = vec4(1.0);");
                if (clipping) {
                    if (states.clips.clipDiscard) {
                        add("float distOff = 0.0;");
                    }
                    if (states.clips.clipFade) {
                        add("float distAlpha = 0.0;");
                    }
                    for (var i = 0; i < states.clips.clips.length; i++) {
                        if (states.clips.clips[i].fade) {
                            //max obsrved normalized distance from alpha plane (normalized to max fade distance)
                            add("distAlpha = max(distAlpha, (dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w) / SCENEJS_uClipFadeDistance" + i + ");");
                        } else {
                            //max observed distance from clipping plane
                            add("distOff = max(distOff, dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w);");
                        }
                    }
                    if (states.clips.clipDiscard) {
                        // discard  fragment if beyond any clip
                        add("if (distOff > 0.0) { discard; }");
                    }
                    if (states.clips.clipFade) {
                        // set transparency proportionally to distance
                        // TODO: Requires drawn object to be transparent flag.
                        add("if (distAlpha > 1.0) { discard; }")
                    }
                }

                if (points && roundPoints) {
                    add("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
                    add("float r = dot(cxy, cxy);");
                    add("if (r > 1.0) {");
                    add("   discard;");
                    add("}");
                }


                if (normals) {
                    add("float fr = abs(dot(normalize(-SCENEJS_vViewVertex.xyz), normalize(SCENEJS_vViewNormal)));");
                    add("float fresnelFactor = clamp((fr - EDGE_BIAS) / (CENTER_BIAS - EDGE_BIAS), 0.0, 1.0);");
                    add("fragColor.rgb = SCENEJS_uXrayColor;");
                    add("fragColor.a = mix(EDGE_ALPHA, CENTER_ALPHA, fresnelFactor);");
                }

                if (clipping && states.clips.clipFade) {
                    add("fragColor.a *= (1.0 - distAlpha);")
                }

                if (alphaTest) {
                    add("if (SCENEJS_uDiscardOpaque && fragColor.a >= 1.0) { discard; }");
                    add("if (!SCENEJS_uDiscardOpaque && fragColor.a < 1.0) { discard; }");
                }

                if (stochasticAlpha) {
                    add("{");
                    add("    float maxDeriv = max(length(dFdx(SceneJS_vModelVertex.xy)), length(dFdy(SceneJS_vModelVertex.xy)));");
                    add("    float pixScale = 1.0 / maxDeriv;");
                    add("    vec2 pixScales = vec2( exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))) );");
                    add("    vec2 alpha = vec2(hash3D(floor(pixScales.x * SceneJS_vModelVertex.xyz)), hash3D(floor(pixScales.y * SceneJS_vModelVertex.xyz)));");
                    add("    float lerpFactor = fract(log2(pixScale));");
                    add("    float x = (1.0 - lerpFactor) * alpha.x + lerpFactor * alpha.y;");
                    add("    float a = min(lerpFactor, 1.0 - lerpFactor);");
                    add("    vec3 cases = vec3(");
                    add("        x * x / (2.0 * a * (1.0 - a)), ");
                    add("        (x - 0.5 * a)/(1.0 - a), ");
                    add("        1.0 - ((1.0 - x) * (1.0 - x) / (2.0 * a * (1.0 - a)))");
                    add("    );");
                    add("    float aThresh = (x < (1.0 - a)) ? ((x < a) ? cases.x : cases.y) : cases.z;");
                    add("    aThresh = clamp(aThresh, 1.0e-6, 1.0);");
                    add("    if (fragColor.a < aThresh) {");
                    add("        discard;");
                    add("    } else {");
                    add("        fragColor.a = 1.0;");
                    add("    }");
                    add("}");
                }

                if (fogEnabled) {
                    add("vec3 fogColor = SCENEJS_uFogColor.rgb;");
                    add("float fogDensity = SCENEJS_uFogColor.a;");
                    add("float fogStart = SCENEJS_uFogParams.x;");
                    add("float fogEnd = SCENEJS_uFogParams.y;");
                    add("float fogMin = SCENEJS_uFogParams.z;");
                    add("float fogMax = SCENEJS_uFogParams.w;");
                    if (fogMode === DISPLAY_FLAGS.FOG_LINEAR) {
                        add("float fog = (length(SCENEJS_vViewVertex.xyz) - fogStart) / (fogEnd - fogStart);");
                    } else {
                        add("float fogAttenuation = fogDensity * max(length(SCENEJS_vViewVertex.xyz) - fogStart, 0.0);");
                        if (fogMode === DISPLAY_FLAGS.FOG_EXP2) {
                            add("fogAttenuation = fogAttenuation * fogAttenuation;");
                        }
                        add("float fog = 1.0 - exp(-fogAttenuation);");
                    }
                    add("fog = clamp(fog, fogMin, fogMax);");
                    add("fragColor.rgb = mix(fragColor.rgb, fogColor, fog);");
                }

                add("fragColor.rgb *= fragColor.a;");

                // Ensure compositing is done properly for pre-multiplied alpha
                add("fragColor = clamp(fragColor, 0.0, 1.0);");
                add("fragColor.a = max(max(fragColor.r, fragColor.g), max(fragColor.b, fragColor.a));")

                if (fragmentShaderFooter) {
                    add(fragmentShaderFooter);
                } else {
                    add("if (SCENEJS_uOutputFormat == 0.0) {");
                    add("    gl_FragColor = fragColor;");
                    add("} else if (SCENEJS_uOutputFormat == 1.0) {");
                    add("    vec2 uv = gl_FragCoord.xy / SCENEJS_uCanvasRes;")
                    add("    float fragZ = gl_FragCoord.z - texture2D(SCENEJS_uDepthBuffer, uv).r;")
                    add("    float d = 1.0 - fragZ * 0.99;");
                    add("    float d4 = d * d * d * d;");
                    add("    float d16 = d4 * d4 * d4 * d4;");
                    add("    float a2 = fragColor.a * fragColor.a;");
                    add("    float a4 = a2 * a2;");
                    add("    float depthWeight = 256.0 * d4 * a2 + 4096.0 * d16 * d16 * a4;");
                    add("    float w = clamp(depthWeight, 0.0001, 1e4);");
                    add("    vec3 ycocg = RGB_YCOCG * (fragColor.rgb * w);")
                    add("    bool checkerboard = mod(gl_FragCoord.x, 2.0) == mod(gl_FragCoord.y, 2.0);")
                    add("    gl_FragColor = vec4(ycocg.r, checkerboard ? ycocg.g : ycocg.b, fragColor.a * w, fragColor.a);");
                    add("}");
                }

                add("}");

                //        console.log(src.join("\n"));
                return end();
            }

            function vertexDepth() {

                begin();

                add("attribute vec4 SCENEJS_aVertex;");
                add("uniform mat4 SCENEJS_uMMatrix;");
                add("uniform mat4 SCENEJS_uVMatrix;");
                add("uniform mat4 SCENEJS_uPMatrix;");

                if (points) {
                    add("uniform float SCENEJS_uPointSize;");
                    if (scaleRotationPoints) {
                        add("attribute vec2 SCENEJS_aPointScaleRotation;");
                    }
                }

                if (quantizedPositions) {
                    add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
                }

                add("varying vec4 SCENEJS_vWorldVertex;");

                if (morphing) {
                    add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
                    if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                        add("attribute vec4 SCENEJS_aMorphVertex;");
                    }

                    if (quantizedPositions) {
                        add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
                    }
                }

                add("void main(void) {");

                if (quantizedPositions) {
                    add("    vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
                } else {
                    add("    vec4 modelVertex = SCENEJS_aVertex;");
                }

                if (morphing) {
                    if (states.morphGeometry.targets[0].vertexBuf) {
                        if (quantizedPositions) {
                            add("  modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        } else {
                            add("  modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                        }
                    }
                }
                add("  SCENEJS_vWorldVertex = SCENEJS_uMMatrix * modelVertex; ");

                add("mat4 vPosMatrix = SCENEJS_uVMatrix;");

                if (skybox) {
                    add("vPosMatrix[3].xyz = vec3(0.0);");
                }

                add("  vec4 viewVertex =  vPosMatrix * SCENEJS_vWorldVertex;");
                add("  gl_Position =  SCENEJS_uPMatrix * viewVertex;");

                if (points) {
                    add("gl_PointSize = SCENEJS_uPointSize;");
                    if (perspectivePoints) {
                        add("gl_PointSize *= 20.0 / length(viewVertex.xyz);");
                    }
                    if (scaleRotationPoints) {
                        add("gl_PointSize *= SCENEJS_aPointScaleRotation.x;");
                    }
                    add("gl_PointSize = min(gl_PointSize, " + maxPointSizeStr + ");");
                }

                add("}");

                return end();
            }

            function fragmentDepth() {

                begin();

                add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");

                add("varying vec4 SCENEJS_vWorldVertex;");

                if (clipping) {
                    for (var i = 0; i < states.clips.clips.length; i++) {
                        add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
                        if (states.clips.clips[i].fade) {
                            add("uniform float SCENEJS_uClipFadeDistance" + i + ";");
                        }
                    }
                }

                add("void main(void) {");

                if (clipping) {

                    if (states.clips.clipDiscard) {
                        add("float distOff = 0.0;");
                    }
                    if (states.clips.clipFade) {
                        add("float distAlpha = 0.0;");
                    }

                    for (var i = 0; i < states.clips.clips.length; i++) {
                        if (states.clips.clips[i].fade) {
                            //max obsrved normalized distance from alpha plane (normalized to max fade distance)
                            add("distAlpha = max(distAlpha, (dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w) / SCENEJS_uClipFadeDistance" + i + ");");
                        } else {
                            //max observed distance from clipping plane
                            add("distOff = max(distOff, dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) + SCENEJS_uClipNormalAndDist" + i + ".w);");
                        }
                    }

                    if (states.clips.clipDiscard) {
                        // discard  fragment if beyond any clip
                        add("if (distOff > 0.0) { discard; }");
                    }

                    if (states.clips.clipFade) {
                        // set transparency proportionally to distance
                        // TODO: Requires drawn object to be transparent flag.
                        add("if (distAlpha > 1.0) { discard; }")
                    }

                }
                add("   gl_FragColor = vec4(gl_FragCoord.zzz, 1.0);")
                add("}");

                return end();
            }


            // Start fresh program source
            function begin() {
                src = [];
            }

            // Append to program source
            function add(txt) {
                src.push(txt || "");
            }

            // Finish building program source
            function end() {
                return src.join("\n");
            }

        }

    )();
})();
;/**
 * @class Manages creation, sharing and recycle of {@link SceneJS_Program} instances
 * @private
 */

(function () {
    "use strict";

    var SceneJS_ProgramFactory = window.SceneJS_ProgramFactory = function(stats, cfg) {

        this.stats = stats;

        this._canvas = cfg.canvas;

        this._programs = {};
    };

    /**
     * Gets a program to render the given states
     */
    SceneJS_ProgramFactory.prototype.getProgram = function(hash, vertexSrc, fragmentSrc) {

        var program = this._programs[hash];

        if (!program) {
            program = new SceneJS._webgl.Program(this.stats, this._canvas.gl, hash, vertexSrc, fragmentSrc);
            this._programs[hash] = program;

            this.stats.state.programs++;
        }

        program.useCount++;

        return program;
    };

    /**
     * Releases a program back to the shader factory
     */
    SceneJS_ProgramFactory.prototype.putProgram = function(program) {

        if (--program.useCount <= 0) {

            program.destroy();

            delete this._programs[program.hash];

            this.stats.state.programs--;
        }
    };

    /**
     * Notifies this shader factory that the WebGL context has been restored after previously being lost
     */
    SceneJS_ProgramFactory.prototype.webglRestored = function() {

        var gl = this._canvas.gl;
        var program;

        for (var id in this._programs) {
            if (this._programs.hasOwnProperty(id)) {
                this._programs[id].build(gl);
            }
        }
    };

    /**
     * Destroys this shader factory
     */
    SceneJS_ProgramFactory.prototype.destroy = function() {
    };

})();
;/**
 * @class An object within a {@link SceneJS_Display}
 * @private
 */
 /*
 NOTE: vec2s are being created when getting geometry UVs.
 */

(function () {
    "use strict";

    var SceneJS_Object = window.SceneJS_Object = function(id) {

        /**
         * ID for this objects, unique among all objects in the display
         * @type Number
         */
        this.id = id;

        /**
         * Hash code for this object, unique among all objects in the display
         * @type String
         */
        this.hash = null;

        /**
         * State sort key, computed from {@link #layer}, {@link #program} and {@link #texture}
         * @type Number
         */
        this.sortKey = 0;
        this.sortTieBreaker = 0;

        /**
         * Sequence of state chunks applied to render this object
         * @type {[SceneJS_Chunk]} chunks
         */
        this.chunkSets = {};

        /**
         * Number of state chunks applied to render this object
         * @type Number
         */
        this.chunksLen = 0;

        /**
         * Shader programs that render this object, also used for (re)computing {@link #sortKey}
         * @type SceneJS_Program
         */
        this.program = null;

        /**
         * State core for the {@link SceneJS.Layer} that this object was compiled from, used for (re)computing {@link #sortKey} and visibility cull
         */
        this.layer = null;

         /**
         * State core for the {@link SceneJS.Texture} that this object was compiled from, used for (re)computing {@link #sortKey}
         */
        this.texture = null;

        /**
         * State core for the {@link SceneJS.Flags} that this object was compiled from, used for visibility cull
         */
        this.properties = null;

        /**
        *   Used to calculate the depth for depth sorting
        */
        this.centroid = null;
    };

    var tempVec3 = new vec3.create();

    var pair1 = vec2.create();
    var pair2 = vec2.create();
    var pair3 = vec2.create();

    var geoVec1 = vec3.create();
    var geoVec2 = vec3.create();
    var geoVec3 = vec3.create();
    var a1 = vec3.create();
    var b1 = vec3.create();
    var c1 = vec3.create();
    var a2 = vec3.create();
    var b2 = vec3.create();
    var c2 = vec3.create();

    var homogeneousCoord1 = vec4.create();
    var homogeneousCoord2 = vec4.create();
    var homogeneousCoord3 = vec4.create();

    SceneJS_Object.prototype.getDepth = function() {
        if (!this.centroid) {
            this.centroid = this._calculateCentroid(this);
        }

        var modelMatrix = this.modelTransform.matrix;
        var viewMatrix = this.viewMatrix;

        var viewCentroid = vec3.transformMat4(tempVec3, this.centroid, modelMatrix);

        return -(viewMatrix[2]  * viewCentroid[0] + 
                 viewMatrix[6]  * viewCentroid[1] + 
                 viewMatrix[10] * viewCentroid[2] +
                 viewMatrix[14]);
    };

    SceneJS_Object.prototype.isTransparent = function() {
        return !this.properties.stochasticAlpha && !!(this.properties.transparent ||
            this.properties.opacityModifiers.length > 0 ||
            this.texture.transparent ||
            this.geometry.transparent || 
            this.fresnel.transparent ||
            this.material.transparent ||
            this.regionMap.transparent);
    };

    SceneJS_Object.prototype.isPartiallyOpaque = function() {
        return this.properties.partiallyOpaque || 
               (!this.properties.transparent && 
                   (this.fresnel.partiallyOpaque || 
                    this.texture.transparent));
    };


    SceneJS_Object.prototype.getKdTree = function() {
        var indices = this.geometry.arrays.indices;
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return this.morphGeometry.getKdTree(indices);
        } else {
            return this.geometry.getKdTree();
        }
    };

    SceneJS_Object.prototype.getPositions = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key1].positions;
        } else {
            return this.geometry.arrays.positions;
        }
    };

    SceneJS_Object.prototype.getPositionDecodeMat = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key1].positionDecodeMat;
        } else {
            return this.geometry.positionDecodeMat;
        }
    };

    SceneJS_Object.prototype.getFrameEndPositions = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key2].positions;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.getFrameEndPositionDecodeMat = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key2].positionDecodeMat;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.getNormals = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key1].normals;
        } else {
            return this.geometry.arrays.normals;
        }
    };

    SceneJS_Object.prototype.getFrameEndNormals = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key2].normals;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.getIndices = function() {
        return this.geometry.arrays.indices || null;
    };

    SceneJS_Object.prototype.getMorphFactor = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return this.morphGeometry.factor;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.cartesianToBarycentric = function(triangleIndex, point, barycentric) {
        // get euclidean coordinates for each triangle vertex
        this.getTrianglePositionOnSurface(triangleIndex, geoVec1, geoVec2, geoVec3);
        SceneJS_math_cartesianToBarycentric(point, geoVec1, geoVec2, geoVec3, barycentric);
    }

    // Convert an euclidean point from local space to world space
    SceneJS_Object.prototype.getPointInWorldSpace = function(point, a) {

        // convert vec3 to vec4 because transformations are on homogeneous coordinates
        homogeneousCoord1.set(point);
        homogeneousCoord1[3] = 1;

        // apply world transformation matrix
        vec4.transformMat4(homogeneousCoord1, homogeneousCoord1, this.modelTransform.matrix);

        // convert vec4 back to vec3
        a.set(homogeneousCoord1.subarray(0, 3));
    }

    // Object triangle vertex indices
    SceneJS_Object.prototype.getTriangleIndices = function(triangleIndex, out) {
        var indices = this.geometry.arrays.indices;
        if (indices) {
            out[0] = indices[triangleIndex];
            out[1] = indices[triangleIndex + 1];
            out[2] = indices[triangleIndex + 2];
        } else {
            out[0] = triangleIndex;
            out[1] = triangleIndex + 1;
            out[2] = triangleIndex + 2;
        }
    }

    // Object Space Position of a point on a particular triangle of a shape at the current time.
    SceneJS_Object.prototype.barycentricToCartesian = function(triangleIndex, barycentric, a) {
        barycentric = barycentric || [1/3, 1/3, 1/3];
        this.getTrianglePositionOnSurface(triangleIndex, geoVec1, geoVec2, geoVec3); // triangle positions for each vertex of triangle
        SceneJS_math_barycentricToCartesian(barycentric, geoVec1, geoVec2, geoVec3, a);
    }

    // Object Space Positions of each vertex of a triangle of a shape at the current time.
    SceneJS_Object.prototype.getTrianglePositionOnSurface = function(triangleIndex, a, b, c) {
        var indices = this.geometry.arrays.indices;
          if (!this.geometry && !this.morphGeometry){
            return;
        }

        var ia, ib, ic;
        if (indices) {
            ia = indices[triangleIndex];
            ib = indices[triangleIndex + 1];
            ic = indices[triangleIndex + 2];
        } else {
            ia = triangleIndex;
            ib = triangleIndex + 1;
            ic = triangleIndex + 2;
        }
        

        if (this.morphGeometry.targets && this.morphGeometry.targets.length > 0) {
            getMorphTrianglePositions(this.morphGeometry, ia, ib, ic, a, b, c);
        } else {
            getGeometryTrianglePositions(this.geometry, ia, ib, ic, a, b, c);
        }
    }

    // Normal vector of any point on a particular triangle of a shape at the current time
    SceneJS_Object.prototype.normalFromBarycentric = function(triangleIndex, barycentric, a) {
        barycentric = barycentric || [1/3, 1/3, 1/3];
        var gotNormals = this.normalFromCartesian(triangleIndex, geoVec1, geoVec2, geoVec3);
        if (!gotNormals) {
            return false;
        }
        vec3.scale(a, geoVec1, barycentric[0]);
        vec3.add(a, a, vec3.scale(b1, geoVec2, barycentric[1]));
        vec3.add(a, a, vec3.scale(b1, geoVec3, barycentric[2]));
        return true;
    }

    // Normal vector for each vertex on a particular triangle of a shape at the current time
    SceneJS_Object.prototype.normalFromCartesian = function(triangleIndex, a, b, c) {
        if (!this.geometry && !this.morphGeometry){
          return;
        }
        var indices = this.geometry.arrays.indices;

        var ia, ib, ic;
        if (indices) {
            ia = indices[triangleIndex];
            ib = indices[triangleIndex + 1];
            ic = indices[triangleIndex + 2];
        } else {
            ia = triangleIndex;
            ib = triangleIndex + 1;
            ic = triangleIndex + 2;
        }
        
        if (this.morphGeometry.targets && this.morphGeometry.targets.length > 0) {
            return getMorphTriangleNormals(this.morphGeometry, ia, ib, ic, a, b, c);
        } else {
            return getGeometryTriangleNormals(this.geometry, ia, ib, ic, a, b, c);
        }
    }

    SceneJS_Object.prototype.uvFromBarycentric = function(triangleIndex, barycentric, a) {
        //NOTE: a is a javascript array of vec2s
        if (!this.geometry || !this.geometry.arrays.uvs || this.geometry.arrays.uvs.length <= 0) {
            return;
        }

        var indices = this.geometry.arrays.indices;

        var ia, ib, ic;
        if (indices) {
            ia = indices[triangleIndex];
            ib = indices[triangleIndex + 1];
            ic = indices[triangleIndex + 2];
        } else {
            ia = triangleIndex;
            ib = triangleIndex + 1;
            ic = triangleIndex + 2;
        }
        var layerIndex;
        for (layerIndex = 0; layerIndex < this.geometry.arrays.uvs.length; layerIndex++) {
            _getTriangleUVFromGeometry(this.geometry, layerIndex, ia, ib, ic, geoVec1, geoVec2, geoVec3);
            var uv = vec2.create();
            vec2.scale(uv, geoVec1, barycentric[0]);
            vec2.add(uv, uv, vec2.scale(pair1, geoVec2, barycentric[1]));
            vec2.add(uv, uv, vec2.scale(pair2, geoVec3, barycentric[2]));
            a.push(uv);
        }
    }

    // Get UV pairs for each triangle vertex for each uv-layer.
    SceneJS_Object.prototype.uvFromCartesian = function(triangleIndex, a, b, c) {
        // NOTE: a,b,c are javascript arrays of vec2 pairs
        if (!this.geometry || !this.geometry.arrays.uvs || this.geometry.arrays.uvs.length <= 0) {
            return;
        }
        var indices = this.geometry.arrays.indices;
        var ia, ib, ic;
        if (indices) {
            ia = indices[triangleIndex];
            ib = indices[triangleIndex + 1];
            ic = indices[triangleIndex + 2];
        } else {
            ia = triangleIndex;
            ib = triangleIndex + 1;
            ic = triangleIndex + 2;
        }
        var auvs = [];
        var buvs = [];
        var cuvs = [];
        var layerIndex;
        for (layerIndex = 0; layerIndex < this.geometry.arrays.uvs.length; layerIndex++) {
            _getTriangleUVFromGeometry(triangleIndex, layerIndex, ia, ib, ic, geoVec1, geoVec2, geoVec3);
            var _uv1 = vec2.create();
            var _uv2 = vec2.create();
            var _uv3 = vec3.create();

            _uv1[0] = geoVec1[0];
            _uv1[1] = geoVec1[1];
            _uv2[0] = geoVec2[0];
            _uv2[1] = geoVec2[1];
            _uv3[0] = geoVec3[0];
            _uv3[1] = geoVec3[1];
            auvs.push(_uv1);
            buvs.push(_uv2);
            cuvs.push(_uv3);
        }
    }

    SceneJS_Object.prototype._calculateCentroid = function() {

        var centroid = vec3.create();

        var positions = this.geometry.arrays.positions;

        var xmin = Infinity;
        var ymin = Infinity;
        var zmin = Infinity;
        var xmax = -Infinity;
        var ymax = -Infinity;
        var zmax = -Infinity;

        var min = Math.min;
        var max = Math.max;

        for (var i = 0, len = positions.length / 3; i < len; ++i) {
            getGeometryPosition(this.geometry, i, tempVec3);
            var x = tempVec3[0];
            var y = tempVec3[1];
            var z = tempVec3[2];

            xmin = min(x, xmin);
            ymin = min(y, ymin);
            zmin = min(z, zmin);
            xmax = max(x, xmax);
            ymax = max(y, ymax);
            zmax = max(z, zmax);
        }

        centroid[0] = 0.5 * (xmin + xmax);
        centroid[1] = 0.5 * (ymin + ymax);
        centroid[2] = 0.5 * (zmin + zmax);

        return centroid;
    };

    // Get the model-space coordinates for each vertex of a surface triangle, from current morph geometry
    function getMorphTrianglePositions(morph, ia, ib, ic, a, b, c) {
        var ia3 = ia * 3;
        var ib3 = ib * 3;
        var ic3 = ic * 3;
        var positions1 = morph.targets[morph.key1].positions;
        var positions2 = morph.targets[morph.key2].positions;
        var decodeMat1 = morph.targets[morph.key1].positionDecodeMat;
        var decodeMat2 = morph.targets[morph.key2].positionDecodeMat;

        if (morph.compressedPositions) {
            SceneJS_math_decompressPosition(a1, positions1.subarray(ia3, ia3 + 3), decodeMat1);
            SceneJS_math_decompressPosition(a2, positions2.subarray(ia3, ia3 + 3), decodeMat2);
            SceneJS_math_decompressPosition(b1, positions1.subarray(ib3, ib3 + 3), decodeMat1);
            SceneJS_math_decompressPosition(b2, positions2.subarray(ib3, ib3 + 3), decodeMat2);
            SceneJS_math_decompressPosition(c1, positions1.subarray(ic3, ic3 + 3), decodeMat1);
            SceneJS_math_decompressPosition(c2, positions2.subarray(ic3, ic3 + 3), decodeMat2);
        } else {
            a1.set(positions1.subarray(ia3, ia3 + 3));
            a2.set(positions2.subarray(ia3, ia3 + 3));
            b1.set(positions1.subarray(ib3, ib3 + 3));
            b2.set(positions2.subarray(ib3, ib3 + 3));
            c1.set(positions1.subarray(ic3, ic3 + 3));
            c2.set(positions2.subarray(ic3, ic3 + 3));
        }

        vec3.lerp(a, a1, a2, morph.factor);
        vec3.lerp(b, b1, b2, morph.factor);
        vec3.lerp(c, c1, c2, morph.factor);
    };

    // Get the model-space coordinates for each vertex of a surface triangle, from current geometry
    function getGeometryTrianglePositions(geo, ia, ib, ic, a, b, c) {
      var positions = geo.arrays.positions;
      var positionDecodeMat = geo.positionDecodeMat;

      var ia3 = ia * 3;
      var ib3 = ib * 3;
      var ic3 = ic * 3;

      a[0] = positions[ia3];
      a[1] = positions[ia3 + 1];
      a[2] = positions[ia3 + 2];

      b[0] = positions[ib3];
      b[1] = positions[ib3 + 1];
      b[2] = positions[ib3 + 2];

      c[0] = positions[ic3];
      c[1] = positions[ic3 + 1];
      c[2] = positions[ic3 + 2];

      if (positionDecodeMat) {
          SceneJS_math_decompressPosition(a, a, positionDecodeMat);
          SceneJS_math_decompressPosition(b, b, positionDecodeMat);
          SceneJS_math_decompressPosition(c, c, positionDecodeMat);
      }
    }

    function getGeometryPosition(geo, i, p) {
      var positions = geo.arrays.positions;
      var positionDecodeMat = geo.positionDecodeMat;

      var index = i * 3;

      p[0] = positions[index];
      p[1] = positions[index + 1];
      p[2] = positions[index + 2];

      if (positionDecodeMat) {
          SceneJS_math_decompressPosition(p, p, positionDecodeMat);
      }
    }

    // Get the normal vector for each vertex of a surface triangle from current morph geometry
    function getMorphTriangleNormals(morph, ia, ib, ic, a, b, c) {
        var iax, ibx, icx;
        var normals1 = morph.targets[morph.key1].normals;
        var normals2 = morph.targets[morph.key2].normals;
        if (morph.compressedNormals) {
            iax = ia * 2;
            ibx = ib * 2;
            icx = ic * 2;
            SceneJS_math_octDecodeVec2(normals1.subarray(iax, iax + 2), a1);
            SceneJS_math_octDecodeVec2(normals2.subarray(iax, iax + 2), a2);
            SceneJS_math_octDecodeVec2(normals1.subarray(ibx, ibx + 2), b1);
            SceneJS_math_octDecodeVec2(normals2.subarray(ibx, ibx + 2), b2);
            SceneJS_math_octDecodeVec2(normals1.subarray(icx, icx + 2), c1);
            SceneJS_math_octDecodeVec2(normals2.subarray(icx, icx + 2), c2);
        } else {
            iax = ia * 3;
            ibx = ib * 3;
            icx = ic * 3;
            a1.set(normals1.subarray(iax, iax + 3));
            a2.set(normals2.subarray(iax, iax + 3));
            b1.set(normals1.subarray(ibx, ibx + 3));
            b2.set(normals2.subarray(ibx, ibx + 3));
            c1.set(normals1.subarray(icx, icx + 3));
            c2.set(normals2.subarray(icx, icx + 3));
        }
        vec3.lerp(a, a1, a2, morph.factor);
        vec3.lerp(b, b1, b2, morph.factor);
        vec3.lerp(c, c1, c2, morph.factor);
        return true; // normals exist
    }

    // Get the normal vector for each vertex of a surface triangle from the current geometry
    function getGeometryTriangleNormals(geo, ia, ib, ic, a, b, c) {
        var normals = geo.arrays.normals;
        var iax, ibx, icx;
        if (!normals) {
            a = a.set([0,0,0]);
            b = b.set([0,0,0]);
            c = c.set([0,0,0]);
            return false; // no normals exist
        }
        if (geo.compressedNormals) {

            var iax = ia * 2;
            var ibx = ib * 2;
            var icx = ic * 2;

            var encna = normals.subarray(iax, iax + 2);
            var encnb = normals.subarray(ibx, ibx + 2);
            var encnc = normals.subarray(icx, icx + 2);

            SceneJS_math_octDecodeVec2(normals.subarray(iax, iax + 2), a);
            SceneJS_math_octDecodeVec2(normals.subarray(ibx, ibx + 2), b);
            SceneJS_math_octDecodeVec2(normals.subarray(icx, icx + 2), c);

        } else {
            iax = ia*3;
            ibx = ib*3;
            icx = ic*3;
            a[0] = normals[iax];
            a[1] = normals[iax + 1];
            a[2] = normals[iax + 2];

            b[0] = normals[ibx];
            b[1] = normals[ibx + 1];
            b[2] = normals[ibx + 2];

            c[0] = normals[icx];
            c[1] = normals[icx + 1];
            c[2] = normals[icx + 2];

        }
        return true;
    }

    // Get the uv array (length 2) for specified uv-layer  for each vertex of a surface triangle from geometry
    function _getTriangleUVFromGeometry(geo, layer, ia, ib, ic, a, b, c) {
        var ia2 = ia * 2;
        var ib2 = ib * 2;
        var ic2 = ic * 2;
        var uvs = geo.arrays.uvs[layer]; // get uvs for layer

        // get uv-pairs for each triangle vertex:
        a[0] = uvs[ia2];
        a[1] = uvs[ia2 + 1];
        b[0] = uvs[ib2];
        b[1] = uvs[ib2 + 1];
        c[0] = uvs[ic2];
        c[1] = uvs[ic2 + 1];

        if (geo.compressedUVs) {
            var uvDecodeMat = geo.uvDecodeMats[layer];
            SceneJS_math_decompressUV(a, a, uvDecodeMat);
            SceneJS_math_decompressUV(b, b, uvDecodeMat);
            SceneJS_math_decompressUV(c, c, uvDecodeMat);
        }
    }

})();

;/**
 * @class An object within a {@link SceneJS_Display}
 * @private
 */

(function() {
    "use strict";

    var quadVSSource = [
        "attribute vec2 aPosition;",
        "varying vec2 vUV;",
        "void main() {",
        "    vUV = aPosition * 0.5 + 0.5;",
        "    gl_Position = vec4(aPosition, 0.0, 1.0);",
        "}"
    ].join("\n");

    var quadPositions = new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        1, 1
    ]);

    window.SceneJS_PostProcess = function(stats, gl, fragmentSource, options) {
        options = options || {};

        this.gl = gl;

        this.uniformIndices = {};
        this.uniformHandles = [];
        this.uniformValues = [];

        this.textureIndices = {};
        this.samplerNames = [];
        this.textures = [];

        this.positionBuffer = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, quadPositions, quadPositions.length, 2, gl.STATIC_DRAW);

        this.program = new SceneJS._webgl.Program(stats, gl, "post-process", quadVSSource, fragmentSource);
        this.positionsAttribute = this.program.getAttribute("aPosition");

        this.uniformCount = 0;
        this.textureCount = 0;

        this.clear = !!options.clear;
    };

    SceneJS_PostProcess.prototype.setUniform = function(name, value) {
        var index = this.uniformIndices[name];

        if (index === undefined) {
            index = this.uniformIndices[name] = this.uniformCount++; 
            this.uniformHandles.push(this.program.getUniform(name));
        }

        this.uniformValues[index] = value;
    };

    SceneJS_PostProcess.prototype.setTexture = function(name, texture) {
        var index = this.textureIndices[name];

        if (index === undefined) {
            index = this.textureIndices[name] = this.textureCount++; 
            this.samplerNames.push(name);
        }

        this.textures[index] = texture;
    };

    SceneJS_PostProcess.prototype.draw = function(frameCtx) {
        if (frameCtx.VAO) {
            frameCtx.VAO.bindVertexArrayOES(null);
        }

        this.program.bind();
        this.positionsAttribute.bindArrayBuffer(this.positionBuffer);

        for (var i = 0; i < this.uniformCount; ++i) {
            this.uniformHandles[i].setValue(this.uniformValues[i]);
        }

        for (var i = 0; i < this.textureCount; ++i) {
            this.program.bindTexture(this.samplerNames[i], this.textures[i], i);
        }

        if (this.clear) {
            this.gl.clearColor(0, 0, 0, 0);
            this.gl.clearDepth(1);
            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        }

//        this.gl.CheckFramebufferStatus(this.positionBuffer);
        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
    };

    SceneJS_PostProcess.prototype.destroy = function() {
        this.positionBuffer.destroy();
        this.positionBuffer = null;
        this.program.destroy();
        this.program = null;
    };

    SceneJS_PostProcess.prototype.webglRestored = function(gl) {
        this.gl = gl;
        this.positionBuffer = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, quadPositions, quadPositions.length, 2, gl.STATIC_DRAW);
        this.program.build(gl);
        this.positionsAttribute = this.program.getAttribute("aPosition");

        for (var name in this.uniformIndices) {
            var i = this.uniformIndices[name];
            this.uniformHandles[i] = this.program.getUniform(name);
        }
    };
})();


;/**
 * @class An object within a {@link SceneJS_Display}
 * @private
 */

(function() {
    "use strict";

    window.SceneJS_PostProcessStage = function(display, cfg) {
        this.id = cfg.id;
        this.display = display;
        this.postProcess = display._postProcessTypes[cfg.type];
        this.uniforms = cfg.uniforms;
        this.framebuffer = null;
        if (cfg.framebuffer) {
            this.framebuffer = display.framebuffers[cfg.framebuffer];
        }

        this.textures = {};
        for (var sampler in cfg.textures) {
            var texture = cfg.textures[sampler];
            var framebufferId = texture.framebuffer;
            var target = texture.target;
            var data = texture.data;
            var gl = display._canvas.gl;
            var framebuffer;

            if (framebufferId) {
                framebuffer = display.framebuffers[framebufferId];

                if (!framebuffer) {
                    console.error("Framebuffer not found: " + framebufferId);
                    continue;
                }

                if (target === "color") {
                    this.textures[sampler] = framebuffer.getColorTarget(texture.attachment || 0);
                } else if (target === "depth") {
                    this.textures[sampler] = framebuffer.getDepthTarget();
                } else {
                    console.error("Invalid target: " + target);
                    continue;
                }
                
            } else if (data) {
                // Values input as typed array

                var tex = gl.createTexture();
                var format = texture.format !== undefined ? gl[texture.format] : gl.RGBA; 
                var type = texture.type !== undefined ? gl[texture.type] : gl.UNSIGNED_BYTE; 
                var minFilter = texture.minFilter !== undefined ? gl[texture.minFilter] : gl.NEAREST; 
                var magFilter = texture.magFilter !== undefined ? gl[texture.magFilter] : gl.NEAREST; 
                var wrapS = texture.wrapS !== undefined ? gl[texture.wrapS] : gl.CLAMP_TO_EDGE; 
                var wrapT = texture.wrapT !== undefined ? gl[texture.wrapT] : gl.CLAMP_TO_EDGE; 
                
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, format, texture.width, texture.height, 0, format, type, data);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);

                this.textures[sampler] = {
                    texture: tex,
                    gl: gl,
                    bind: function (unit) {
                        if (this.texture) {
                            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                            this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                            return true;
                        }
                        return false;
                    },
                    unbind: function (unit) {
                        if (this.texture) {
                            this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
                        }
                    },
                    destroy: function() {
                        if (this.texture) {
                            this.gl.deleteTexture(this.texture);
                            this.texture = null;
                        }
                    }
                };

                gl.bindTexture(gl.TEXTURE_2D, null);
            }
        }

    };

    SceneJS_PostProcessStage.prototype.setUniform = function(name, value) {
        this.uniforms[name] = value;
        this.display.imageDirty = true;
    };

    SceneJS_PostProcessStage.prototype.draw = function(frameCtx) {
        for (var uniform in this.uniforms) {
            this.postProcess.setUniform(uniform, this.uniforms[uniform]);
        }

        for (var texture in this.textures) {
            this.postProcess.setTexture(texture, this.textures[texture]);
        }

        this.postProcess.draw(frameCtx);
    };

    SceneJS_PostProcessStage.prototype.destroy = function() {

        for (var texture in this.textures) {
            if (typeof this.textures[texture].destroy === "function") {
                this.textures[texture].destroy();
            }
            this.textures[texture] = null;
        }

    };

})();


;(function() {
    "use strict";

    var SceneJS_ChunkFactory = window.SceneJS_ChunkFactory = function() {
        this._chunks = {};
        this._numericIds = 1;
        this.chunkTypes = SceneJS_ChunkFactory.chunkTypes;
    };

    SceneJS_ChunkFactory.chunkTypes = {};

    SceneJS_ChunkFactory.addChunkType = function(type, chunkClass) {
        SceneJS_ChunkFactory.chunkTypes[type] = chunkClass;
    };

    SceneJS_ChunkFactory.prototype.getChunk = function(chunkId, type, program, cores) {
        var chunkClass = SceneJS_ChunkFactory.chunkTypes[type];
        if (!chunkClass) {
            throw "chunk type not supported: '" + type + "'";
        }
        var chunk = this._chunks[chunkId];
        if (chunk) {
            chunk.useCount++;
            return chunk;
        }
        chunk = new chunkClass(chunkId, this._numericIds++, program, cores);
        chunk.useCount = 1;
        this._chunks[chunkId] = chunk;
        return chunk;
    };

    SceneJS_ChunkFactory.prototype.putChunk = function (chunk) {
        if (chunk.useCount === 0) {
            return;
        }
        if (--chunk.useCount <= 0) {
            if (chunk.recycle) {
                chunk.recycle();
            }
            delete this._chunks[chunk.id];
        }
    };

    SceneJS_ChunkFactory.prototype.webglRestored = function () {
        var chunk;
        for (var chunkId in this._chunks) {
            if (this._chunks.hasOwnProperty(chunkId)) {
                chunk = this._chunks[chunkId];
                if (chunk && chunk.build) {
                    chunk.build();
                }
            }
        }
    };

})();

;(function () {
    "use strict";

    var DrawChunk = function (id, numericId, program, cores) {

        this.id = id;
        this.numericId = numericId;
        this.program = program;

        cores = cores || [];

        for (var i = 0, len = cores.length; i < len; ++i) {
            if (cores[i] && cores[i].empty) {
                cores[i] = null;
            }
        }

        this.cores = cores;
        this.handles = {};

        // As we apply a list of state chunks in a {@link SceneJS_Display}, we track the ID of each chunk
        // in order to avoid redundantly re-applying the same chunk.
        // We don't want that for draw chunks however, because they contain GL drawElements calls,
        // which we need to do for each object.
        this.unique = true;

        this.build();
    };

    DrawChunk.prototype.build = function () {

        this.core = this.cores[0];

        this.handles.draw = {};

        this.handles.xray = {};

        this.handles.pick = {
            uPickColor: this.program.pick.getUniform("SCENEJS_uPickColor")
        };

        this.handles.depth = {};

        this.handles.drawTexture = {};  
    };

    DrawChunk.prototype.draw = function (renderMode, frameCtx) {

        var core = this.core;
        var handles = this.handles[renderMode];
        var gl = this.program.gl;

        if (frameCtx.pickTriangle) {

            var pickColors = core.getPickColors();

            if (pickColors) {
                gl.drawArrays(core.primitive, 0, pickColors.numItems / 4); // rgba per vertex
            }

        } else {
            if (frameCtx.pickObject) {

                if (handles.uPickColor) {

                    var a = frameCtx.pickIndex >> 24 & 0xFF;
                    var b = frameCtx.pickIndex >> 16 & 0xFF;
                    var g = frameCtx.pickIndex >> 8 & 0xFF;
                    var r = frameCtx.pickIndex & 0xFF;

                    frameCtx.pickIndex++;

                    handles.uPickColor.setValue([r / 255, g / 255, b / 255, a / 255]);
                }
            }

            if (core.indexBuf) {
                gl.drawElements(core.primitive, core.indexBuf.numItems, core.indexBuf.itemType, 0);
            } else {
                gl.drawArrays(core.primitive, 0, core.vertexBuf.numItems / 3);
            }
        }

        frameCtx.transparent = false;
    };

    SceneJS_ChunkFactory.addChunkType("draw", DrawChunk);
})();
;(function () {
    "use strict";

    var FLAGS = SceneJS.PROPERTY_FLAGS;
    var DEPTH_TEST_FLAGS = SceneJS.DEPTH_TEST_FLAGS;

    var tempVec4 = vec4.create();

    var ObjectChunk = function (id, numericId, program, cores) {

        this.id = id;
        this.numericId = numericId;
        this.program = program;

        cores = cores || [];

        for (var i = 0, len = cores.length; i < len; ++i) {
            if (cores[i] && cores[i].empty) {
                cores[i] = null;
            }
        }

        this.cores = cores;
        this.handles = {};
        this.unique = true;

        this.build();
    };

    ObjectChunk.prototype.build = function () {

        this.propertiesCore = this.cores[0];
        this.xformCore = this.cores[1];

        var draw = this.program.draw;
        var xray = this.program.xray;
        var pick = this.program.pick;
        var pickTriangle = this.program.pickTriangle;
        var depth = this.program.depth;
        var drawTexture = this.program.drawTexture;

        var drawHandles = this.handles.draw = {};
        var xrayHandles = this.handles.xray = {};
        var pickHandles = this.handles.pick = {};
        var pickTriangleHandles = this.handles.pickTriangle = {};
        var depthHandles = this.handles.depth = {};
        var drawTextureHandles = this.handles.drawTexture = {};

        drawHandles.uDiscardOpaque = draw.getUniform("SCENEJS_uDiscardOpaque");
        drawHandles.uOutputFormat = draw.getUniform("SCENEJS_uOutputFormat");

        xrayHandles.uDiscardOpaque = xray.getUniform("SCENEJS_uDiscardOpaque");
        xrayHandles.uOutputFormat = xray.getUniform("SCENEJS_uOutputFormat");

        if (this.propertiesCore) {

            drawHandles.uSolidColor = draw.getUniform("SCENEJS_uSolidColor");
            drawHandles.uXrayParams = draw.getUniform("SCENEJS_uXrayParams");
            xrayHandles.uSolidColor = xray.getUniform("SCENEJS_uSolidColor");

            depthHandles.uClipping = depth.getUniform("SCENEJS_uClipping");

            drawHandles.uColorModifications = new Array(this.propertiesCore.colorModifiers.length);
            drawHandles.uColorModCenters = new Array(this.propertiesCore.colorModifiers.length);
            drawHandles.uColorModRadii = new Array(this.propertiesCore.colorModifiers.length);

            drawHandles.uColorModFresnels = new Array(this.propertiesCore.colorModifiers.length);

            for (var cmi = 0, len = this.propertiesCore.colorModifiers.length; cmi < len; cmi++) {
                var colorMod = this.propertiesCore.colorModifiers[cmi];
                var value = colorMod.value;
                drawHandles.uColorModifications[cmi] = draw.getUniform("SCENEJS_uColorModification" + cmi);
                if (value.isColorFresnel || value.isScalarFresnel) {
                    drawHandles.uColorModFresnels[cmi] = {
                        edge: draw.getUniform("SCENEJS_uColorModFresnelEdge" + cmi),
                        center: draw.getUniform("SCENEJS_uColorModFresnelCenter" + cmi),
                        power: draw.getUniform("SCENEJS_uColorModFresnelPower" + cmi)
                    };
                }
                drawHandles.uColorModCenters[cmi] = draw.getUniform("SCENEJS_uColorModCenter" + cmi);
                drawHandles.uColorModRadii[cmi] = draw.getUniform("SCENEJS_uColorModRadius" + cmi);
            }

            drawHandles.uOpacityModifications = new Array(this.propertiesCore.opacityModifiers.length);
            drawHandles.uOpacityModCenters = new Array(this.propertiesCore.opacityModifiers.length);
            drawHandles.uOpacityModRadii = new Array(this.propertiesCore.opacityModifiers.length);
            drawHandles.uOpacityModFresnels = new Array(this.propertiesCore.opacityModifiers.length);
            for (var omi = 0, len = this.propertiesCore.opacityModifiers.length; omi < len; ++omi) {
                var opacityMod = this.propertiesCore.opacityModifiers[omi];
                drawHandles.uOpacityModifications[omi] = draw.getUniform("SCENEJS_uOpacityModification" + omi);
                if (opacityMod.value.isScalarFresnel) {
                    drawHandles.uOpacityModFresnels[omi] = {
                        edge: draw.getUniform("SCENEJS_uOpacityModFresnelEdge" + omi),
                        center: draw.getUniform("SCENEJS_uOpacityModFresnelCenter" + omi),
                        power: draw.getUniform("SCENEJS_uOpacityModFresnelPower" + omi)
                    }
                }
                drawHandles.uOpacityModCenters[omi] = draw.getUniform("SCENEJS_uOpacityModCenter" + omi);
                drawHandles.uOpacityModRadii[omi] = draw.getUniform("SCENEJS_uOpacityModRadius" + omi);
            }
        }

        if (this.xformCore) {
            drawHandles.uMatLocation = draw.getUniform("SCENEJS_uMMatrix");
            drawHandles.uNormalMatLocation = draw.getUniform("SCENEJS_uMNMatrix");

            xrayHandles.uMatLocation = xray.getUniform("SCENEJS_uMMatrix");
            xrayHandles.uNormalMatLocation = xray.getUniform("SCENEJS_uMNMatrix");

            pickHandles.uMatLocation = pick.getUniform("SCENEJS_uMMatrix");

            pickTriangleHandles.uMatLocation = pickTriangle.getUniform("SCENEJS_uMMatrix");

            depthHandles.uMatLocation = depth.getUniform("SCENEJS_uMMatrix");

            drawTextureHandles.uMatLocation = drawTexture.getUniform("SCENEJS_uMMatrix");
        }
    };

    ObjectChunk.prototype.draw = function (renderMode, frameCtx) {

        var gl = this.program.gl;
        var picking = frameCtx.picking;
        var handles = this.handles[renderMode];

        if (handles.uDiscardOpaque) {
            handles.uDiscardOpaque.setValue(frameCtx.discardOpaque);
        }

        if (handles.uOutputFormat) {
            handles.uOutputFormat.setValue(frameCtx.outputFormat);
        }

        if (this.propertiesCore) {

            var depthTest = this.propertiesCore.depthTest;

            if (frameCtx.depthTest != depthTest) {
                if (depthTest == DEPTH_TEST_FLAGS.ALWAYS_PASS) {
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.ALWAYS);
                } else if (depthTest == DEPTH_TEST_FLAGS.DISABLED) {
                    gl.disable(gl.DEPTH_TEST);
                } else {
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LESS);
                }
                frameCtx.depthTest = depthTest;
            }

            var frontfaceCCW = this.propertiesCore.flags & FLAGS.CCW;

            if (frameCtx.frontface != frontfaceCCW) {
                if (frontfaceCCW) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frameCtx.frontface = frontfaceCCW;
            }

            // color modifications with optional modification range definition
            if (handles.uColorModifications) {
                for (var cmi = 0, len = this.propertiesCore.colorModifiers.length; cmi < len; ++cmi) {

                    var colorMod = this.propertiesCore.colorModifiers[cmi];
                    var value = colorMod.value;

                    if (handles.uColorModifications[cmi]) {
                        handles.uColorModifications[cmi].setValue(value);
                    }

                    var uColorModFresnel = handles.uColorModFresnels[cmi];
                    if (uColorModFresnel) {
                        if (value.isColorFresnel) {
                            if (uColorModFresnel.edge) {
                                tempVec4[0] = value.edge[0];
                                tempVec4[1] = value.edge[1];
                                tempVec4[2] = value.edge[2];
                                tempVec4[3] = value.edgeBias;
                                uColorModFresnel.edge.setValue(tempVec4);
                            }
                            if (uColorModFresnel.center) {
                                tempVec4[0] = value.center[0];
                                tempVec4[1] = value.center[1];
                                tempVec4[2] = value.center[2];
                                tempVec4[3] = value.centerBias;
                                uColorModFresnel.center.setValue(tempVec4);
                            }
                            if (uColorModFresnel.power) {
                                uColorModFresnel.power.setValue(value.power);
                            }
                        } else if (value.isScalarFresnel) {
                            if (uColorModFresnel.edge) {
                                tempVec4[0] = value.edge;
                                tempVec4[3] = value.edgeBias;
                                uColorModFresnel.edge.setValue(tempVec4);
                            }
                            if (uColorModFresnel.center) {
                                tempVec4[0] = value.center;
                                tempVec4[3] = value.centerBias;
                                uColorModFresnel.center.setValue(tempVec4);
                            }
                            if (uColorModFresnel.power) {
                                uColorModFresnel.power.setValue(value.power);
                            }
                        }
                    }

                    if (handles.uColorModCenters[cmi]) {
                        handles.uColorModCenters[cmi].setValue(colorMod.range.center);
                    }
                    if (handles.uColorModRadii[cmi]) {
                        handles.uColorModRadii[cmi].setValue(colorMod.range.radius);
                    }
                }
            }

            if (handles.uOpacityModifications) {
                for (var omi = 0, len = this.propertiesCore.opacityModifiers.length; omi < len; ++omi) {

                    var opacityMod = this.propertiesCore.opacityModifiers[omi];
                    var value = opacityMod.value;

                    if (handles.uOpacityModifications[omi]) {
                        handles.uOpacityModifications[omi].setValue(value);
                    }

                    var uOpacityModFresnel = handles.uOpacityModFresnels[omi];
                    if (uOpacityModFresnel) {
                        if (uOpacityModFresnel.edge) {
                            tempVec4[0] = value.edge;
                            tempVec4[3] = value.edgeBias;
                            uOpacityModFresnel.edge.setValue(tempVec4);
                        }
                        if (uOpacityModFresnel.center) {
                            tempVec4[0] = value.center;
                            tempVec4[3] = value.centerBias;
                            uOpacityModFresnel.center.setValue(tempVec4);
                        }
                        if (uOpacityModFresnel.power) {
                            uOpacityModFresnel.power.setValue(value.power);
                        }
                    }

                    if (handles.uOpacityModCenters[omi]) {
                        handles.uOpacityModCenters[omi].setValue(opacityMod.range.center);
                    }
                    if (handles.uOpacityModRadii[omi]) {
                        handles.uOpacityModRadii[omi].setValue(opacityMod.range.radius);
                    }
                }
            }

            if (handles.uSolidColor) {
                handles.uSolidColor.setValue(this.propertiesCore.solidColor);
            }

            if (handles.uXrayParams) {
                handles.uXrayParams.setValue(this.propertiesCore.xrayParams);
            }
        }

        if (this.xformCore) {
            if (handles.uMatLocation) {
                handles.uMatLocation.setValue(this.xformCore.matrix);
            }

            if (handles.uNormalMatLocation) {
                handles.uNormalMatLocation.setValue(this.xformCore.normalMatrix);
            }
        }
    };

    SceneJS_ChunkFactory.addChunkType("object", ObjectChunk);
})();
;(function () {
    "use strict";

    var GeometryChunk = function (id, numericId, program, cores) {

        this.id = id;
        this.numericId = numericId;
        this.program = program;

        cores = cores || [];

        for (var i = 0, len = cores.length; i < len; ++i) {
            if (cores[i] && cores[i].empty) {
                cores[i] = null;
            }
        }

        this.cores = cores;
        this.handles = {};
        this.VAOs = {
            draw: null,
            pick: null,
            pickTriangle: null,
            xray: null,
            depth: null,
            drawTexture: null
        };

        this.build();
    };

    GeometryChunk.prototype.build = function () {

        this.core = this.cores[0];
        this.core2 = this.cores[1];

        var draw = this.program.draw;

        var uvLength = 0;
        if(this.core2.uvBufs) {
            uvLength = this.core2.uvBufs.length;
        }

        this.handles.draw = {
            aRegionMapUV: draw.getAttribute("SCENEJS_aRegionMapUV"),
            aVertex: draw.getAttribute("SCENEJS_aVertex"),
            aNormal: draw.getAttribute("SCENEJS_aNormal"),
            aUV: new Array(uvLength),
            uDecodeUV: new Array(uvLength),
            aTangent: draw.getAttribute("SCENEJS_aTangent"),
            aColor: draw.getAttribute("SCENEJS_aVertexColor"),

            aMorphVertex: draw.getAttribute("SCENEJS_aMorphVertex"),
            aMorphNormal: draw.getAttribute("SCENEJS_aMorphNormal"),
            aMorphTangent: draw.getAttribute("SCENEJS_aMorphTangent"),
            aPointScaleRotation: draw.getAttribute("SCENEJS_aPointScaleRotation"),
            aPointUVTranslate: draw.getAttribute("SCENEJS_aPointUVTranslate"),
            uPointUVScale: draw.getUniform("SCENEJS_uPointUVScale"),
            uMorphFactor: draw.getUniform("SCENEJS_uMorphFactor"),
            uPointSize: draw.getUniform("SCENEJS_uPointSize"),
            uDecodePositions: draw.getUniform("SCENEJS_uDecodePositionMatrix"),
            uDecodeMorphPos: draw.getUniform("SCENEJS_uDecodeMorphPosMatrix"),
        };

        for (var i = 0; i < uvLength; i++) {
            this.handles.draw.aUV[i] = draw.getAttribute("SCENEJS_aUVCoord" + i);
            this.handles.draw.uDecodeUV[i] = draw.getUniform("SCENEJS_uDecodeUVMatrix" + i);
        }

        var xray = this.program.xray;

        this.handles.xray = {
            aVertex: xray.getAttribute("SCENEJS_aVertex"),
            aNormal: xray.getAttribute("SCENEJS_aNormal"),
            aMorphVertex: xray.getAttribute("SCENEJS_aMorphVertex"),
            aMorphNormal: xray.getAttribute("SCENEJS_aMorphNormal"),
            aPointScaleRotation: xray.getAttribute("SCENEJS_aPointScaleRotation"),
            uMorphFactor: xray.getUniform("SCENEJS_uMorphFactor"),
            uPointSize: xray.getUniform("SCENEJS_uPointSize"),
            uDecodePositions: xray.getUniform("SCENEJS_uDecodePositionMatrix"),
            uDecodeMorphPos: xray.getUniform("SCENEJS_uDecodeMorphPosMatrix")
        };

        var pick = this.program.pick;

        this.handles.pick = {
            aRegionMapUV: pick.getAttribute("SCENEJS_aRegionMapUV"),
            aVertex: pick.getAttribute("SCENEJS_aVertex"),
            aMorphVertex: pick.getAttribute("SCENEJS_aMorphVertex"),
            aPointScaleRotation: pick.getAttribute("SCENEJS_aPointScaleRotation"),
            uMorphFactor: pick.getUniform("SCENEJS_uMorphFactor"),
            uPointSize: pick.getUniform("SCENEJS_uPointSize"),
            uDecodePositions: pick.getUniform("SCENEJS_uDecodePositionMatrix"),
            uDecodeMorphPos: pick.getUniform("SCENEJS_uDecodeMorphPosMatrix")
        };

        var pickTriangle = this.program.pickTriangle;

        this.handles.pickTriangle = {
            aVertex: pickTriangle.getAttribute("SCENEJS_aVertex"),
            aTriColor: pickTriangle.getAttribute("SCENEJS_aTriColor"),
            aMorphVertex: pickTriangle.getAttribute("SCENEJS_aMorphVertex"),
            aPointScaleRotation: pickTriangle.getAttribute("SCENEJS_aPointScaleRotation"),
            uMorphFactor: pickTriangle.getUniform("SCENEJS_uMorphFactor"),
            uPointSize: pickTriangle.getUniform("SCENEJS_uPointSize"),
            uDecodePositions: pickTriangle.getUniform("SCENEJS_uDecodePositionMatrix"),
            uDecodeMorphPos: pickTriangle.getUniform("SCENEJS_uDecodeMorphPosMatrix")
        };

        var depth = this.program.depth;

        this.handles.depth = {
            aVertex: depth.getAttribute("SCENEJS_aVertex"),
            aMorphVertex: depth.getAttribute("SCENEJS_aMorphVertex"),
            aPointScaleRotation: depth.getAttribute("SCENEJS_aPointScaleRotation"),
            uMorphFactor: depth.getUniform("SCENEJS_uMorphFactor"),
            uPointSize: depth.getUniform("SCENEJS_uPointSize"),
            uDecodePositions: depth.getUniform("SCENEJS_uDecodePositionMatrix"),
            uDecodeMorphPos: depth.getUniform("SCENEJS_uDecodeMorphPosMatrix")
        };

        var drawTexture = this.program.drawTexture;
        
        this.handles.drawTexture = {
            aVertex: drawTexture.getAttribute("SCENEJS_aVertex"),
            aUV: new Array(uvLength),
            uDecodeUV: new Array(uvLength),
            aMorphVertex: drawTexture.getAttribute("SCENEJS_aMorphVertex"),
            uMorphFactor: drawTexture.getUniform("SCENEJS_uMorphFactor"),
            uDecodePositions: drawTexture.getUniform("SCENEJS_uDecodePositionMatrix"),
            uDecodeMorphPos: drawTexture.getUniform("SCENEJS_uDecodeMorphPosMatrix")
        };

        for (var i = 0; i < uvLength; i++) {
            this.handles.drawTexture.aUV[i] = drawTexture.getAttribute("SCENEJS_aUVCoord" + i);
            this.handles.drawTexture.uDecodeUV[i] = drawTexture.getUniform("SCENEJS_uDecodeUVMatrix" + i);
        }

        for (var renderMode in this.VAOs) {
            this.VAOs[renderMode] = {
                VAO: null,
                morphKey1: -1,
                morphKey2: -1
            };
        }

    };

    GeometryChunk.prototype.recycle = function () {
        var VAOExt = this.program.gl.getExtension("OES_vertex_array_object");
        if (VAOExt) {
            for (var renderMode in this.VAOs) {
                if (this.VAOs[renderMode].VAO) {
                    VAOExt.deleteVertexArrayOES(this.VAOs[renderMode].VAO);
                    this.VAOs[renderMode].VAO = null;
                }
                this.VAOs[renderMode].morphKey1 = -1;
                this.VAOs[renderMode].morphKey2 = -1;
            }
        }
    };

    GeometryChunk.prototype.morphDraw = function (handles, VAO, frameCtx) {

        VAO.morphKey1 = this.core.key1;
        VAO.morphKey2 = this.core.key2;

        var key1 = this.core.key1;
        var key2 = this.core.key2;

        var target1 = this.core.targets[key1]; // Keys will update
        var target2 = this.core.targets[key2];

        if (handles.aMorphVertex) {
            handles.aVertex.bindArrayBuffer(target1.vertexBuf);
            handles.aMorphVertex.bindArrayBuffer(target2.vertexBuf);
            frameCtx.bindArray += 2;

        } else if (handles.aVertex) {
            handles.aVertex.bindArrayBuffer(this.core2.vertexBuf);
            frameCtx.bindArray++;
        }

        if (handles.aMorphNormal) {
            handles.aNormal.bindArrayBuffer(target1.normalBuf);
            handles.aMorphNormal.bindArrayBuffer(target2.normalBuf);
            frameCtx.bindArray += 2;

        } else if (handles.aNormal) {
            handles.aNormal.bindArrayBuffer(this.core2.normalBuf);
            frameCtx.bindArray++;
        }

        if (handles.aMorphTangent || handles.aTangent) {

            // Bind tangent arrays from geometry and morphGeometry

            // Use the first UV layer since tangents should be the same for all UV layouts.

            if (frameCtx.hasNormalMap) {
                if (handles.aMorphTangent) {
                    handles.aTangent.bindArrayBuffer(
                        this.core.getTangents(key1, this.core2.arrays.indices, this.core2.arrays.uvs[0],
                            this.core2.positionDecodeMat, this.core2.compressedUVs && this.core2.uvDecodeMats[0])
                    );
                    handles.aMorphTangent.bindArrayBuffer(
                        this.core.getTangents(key2, this.core2.arrays.indices, this.core2.arrays.uvs[0],
                            this.core2.positionDecodeMat, this.core2.compressedUVs && this.core2.uvDecodeMats[0])
                    );
                    frameCtx.bindArray += 2;

                }
            }
        }

        // Bind UV layer from geometry

        if (handles.aUV) {
            var uvBuf;
            for (var i = 0, len = handles.aUV.length; i < len; i++) {
                uvBuf = this.core2.uvBufs[i];
                if (uvBuf && handles.aUV[i]) {
                    handles.aUV[i].bindArrayBuffer(uvBuf);
                    frameCtx.bindArray++;
                }
            }
        }

        if (handles.aColor) {
            handles.aColor.bindArrayBuffer(this.core2.colorBuf);
            frameCtx.bindArray++;
        }
    };

    GeometryChunk.prototype.updateGeoUniforms = function (handles) {
        if (handles.uDecodePositions) {
            handles.uDecodePositions.setValue(this.core2.positionDecodeMat);
        }
    };

    GeometryChunk.prototype.updateMorphUniforms = function (handles) {
        var key1 = this.core.key1;
        var key2 = this.core.key2;

        var target1 = this.core.targets[key1]; // Keys will update
        var target2 = this.core.targets[key2];

        if (handles.uDecodePositions) {
            handles.uDecodePositions.setValue(target1.positionDecodeMat);
        }

        if (handles.uDecodeMorphPos) {
            handles.uDecodeMorphPos.setValue(target2.positionDecodeMat);
        }

        if (handles.uMorphFactor) {
            handles.uMorphFactor.setValue(this.core.factor); // Bind LERP factor
        }
    };

    GeometryChunk.prototype.draw = function (renderMode, frameCtx) {
        var handles = this.handles[renderMode];
        var VAO = this.VAOs[renderMode];

        var doMorph = this.core.targets && this.core.targets.length;

        if (handles.uPointSize) {
            handles.uPointSize.setValue(this.core2.pointSize);
        }

        if (handles.uPointUVScale) {
            handles.uPointUVScale.setValue(this.core2.pointUVScale);
        }

        if (handles.uDecodeUV) {
            for (var i = 0, len = handles.uDecodeUV.length; i < len; i++) {
                if (handles.uDecodeUV[i]) {
                    handles.uDecodeUV[i].setValue(this.core2.uvDecodeMats[i]);
                }
            }
        }

        if (doMorph) {
            this.updateMorphUniforms(handles);
        } else {
            this.updateGeoUniforms(handles);
        }

        if (frameCtx.pickTriangle) {

            if (doMorph) {
                if (handles.aMorphVertex) {

                    var pickPositionsBuf = this.core.getPickPositions(this.core.key1, this.core2.arrays.indices);
                    if (pickPositionsBuf) {
                        handles.aVertex.bindArrayBuffer(pickPositionsBuf);
                    }

                    pickPositionsBuf = this.core.getPickPositions(this.core.key2, this.core2.arrays.indices);
                    if (pickPositionsBuf) {
                        handles.aMorphVertex.bindArrayBuffer(pickPositionsBuf);
                    }

                    if (handles.aTriColor) {
                        handles.aTriColor.bindArrayBuffer(this.core2.getPickColors());
                    }

                } else if (handles.aVertex) {

                    handles.aVertex.bindArrayBuffer(this.core2.vertexBuf);

                    this.core2.indexBuf.bind();
                }
            } else {

                if (handles.aVertex) {
                    handles.aVertex.bindArrayBuffer(this.core2.getPickPositions());
                }

                if (handles.aTriColor) {
                    handles.aTriColor.bindArrayBuffer(this.core2.getPickColors());
                }

            }

            return;
        }

        if (VAO.VAO && frameCtx.VAO) { // Workaround for https://github.com/xeolabs/scenejs/issues/459
            frameCtx.VAO.bindVertexArrayOES(VAO.VAO);
            if (doMorph) {
                if (VAO.morphKey1 == this.core.key1 && VAO.morphKey2 == this.core.key2) {
                    return;
                }
            } else {
                return;
            }
        } else if (frameCtx.VAO) {
            // Start creating a new VAO by switching to the default VAO, which doesn't have attribs enabled.
            frameCtx.VAO.bindVertexArrayOES(null);
            VAO.VAO = frameCtx.VAO.createVertexArrayOES();
            frameCtx.VAO.bindVertexArrayOES(VAO.VAO);
        }

        if (doMorph) {
            this.morphDraw(handles, VAO, frameCtx);
        } else {
            if (handles.aVertex) {
                handles.aVertex.bindArrayBuffer(this.core2.vertexBuf);
                frameCtx.bindArray++;
            }
            if (handles.aNormal) {
                handles.aNormal.bindArrayBuffer(this.core2.normalBuf);
                frameCtx.bindArray++;
            }
            if (handles.aUV) {
                var uvBuf;
                for (var i = 0, len = handles.aUV.length; i < len; i++) {
                    uvBuf = this.core2.uvBufs[i];
                    if (uvBuf && handles.aUV[i]) {
                        handles.aUV[i].bindArrayBuffer(uvBuf);
                        frameCtx.bindArray++;
                    }
                }
            }
            if (handles.aColor) {
                handles.aColor.bindArrayBuffer(this.core2.colorBuf);
                frameCtx.bindArray++;
            }

            if (handles.aPointScaleRotation) {
                handles.aPointScaleRotation.bindArrayBuffer(this.core2.pointScaleRotationBuf);
                frameCtx.bindArray++;                
            }

            if (handles.aPointUVTranslate) {
                handles.aPointUVTranslate.bindArrayBuffer(this.core2.pointUVTranslateBuf);
                frameCtx.bindArray++;
            }

            if (handles.aTangent) {

                // In the texture chunk we remembered which UV layer we're using for the normal
                // map so that we can lazy-generate the tangents from the appropriate UV layer
                // in the geometry chunk.

                // Just use the first UV layer to generate tangest since it should be the same
                // for all layouts.

                if (frameCtx.hasNormalMap) {
                    handles.aTangent.bindArrayBuffer(this.core2.getTangents(0));
                    frameCtx.bindArray++;
                }
            }
        }

        if (handles.aRegionMapUV) {
            var regionMapUVLayerIdx = frameCtx.regionMapUVLayerIdx; // Set by regionMapChunk
            if (regionMapUVLayerIdx >= 0) {
                var uvBufs = this.core2.uvBufs;
                if (regionMapUVLayerIdx < uvBufs.length) {
                    handles.aRegionMapUV.bindArrayBuffer(uvBufs[regionMapUVLayerIdx]);
                    frameCtx.bindArray++;
                }
            }
        }

        if (this.core2.indexBuf) {
            this.core2.indexBuf.bind();
        }
    };

    SceneJS_ChunkFactory.addChunkType("geometry", GeometryChunk);

})();
;(function () {
    "use strict";

    var MaterialChunk = function (id, numericId, program, cores) {

        this.id = id;
        this.numericId = numericId;
        this.program = program;

        cores = cores || [];

        for (var i = 0, len = cores.length; i < len; ++i) {
            if (cores[i] && cores[i].empty) {
                cores[i] = null;
            }
        }

        this.cores = cores;
        this.handles = {};

        this.build();
    };

    MaterialChunk.prototype.build = function () {

        this.materialCore = this.cores[0];
        this.textureCore = this.cores[1];
        this.fresnelCore = this.cores[2];
        this.cubemapCore = this.cores[3];

        var draw = this.program.draw;
        var drawHandles = this.handles.draw = {};
        var drawTexture = this.program.drawTexture;
        var drawTextureHandles = this.handles.drawTexture = {};

        if (this.materialCore) {
            drawHandles.uMaterialBaseColor = draw.getUniform("SCENEJS_uMaterialColor");
            drawHandles.uMaterialSpecularColor = draw.getUniform("SCENEJS_uMaterialSpecularColor");
            drawHandles.uMaterialEmitColor = draw.getUniform("SCENEJS_uMaterialEmitColor");
            drawHandles.uMaterialShine = draw.getUniform("SCENEJS_uMaterialShine");
            drawHandles.uMetalRoughSpecularf0 = draw.getUniform("SCENEJS_uMetalRoughSpecularf0");
        }

        if (this.textureCore) {
            drawHandles.uTexSampler = [];
            drawHandles.uTexMatrix = [];
            drawHandles.uTexBlendFactor = [];

            var layers = this.textureCore.layers;

            if (layers) {

                var layer;
                var draw = this.program.draw;

                for (var i = 0, len = layers.length; i < len; i++) {

                    layer = layers[i];

                    drawHandles.uTexSampler[i] = "SCENEJS_uSampler" + i;
                    drawHandles.uTexMatrix[i] = draw.getUniform("SCENEJS_uLayer" + i + "Matrix");
                    drawHandles.uTexBlendFactor[i] = draw.getUniform("SCENEJS_uLayer" + i + "BlendFactor");
                }
            
                drawTextureHandles.uDrawSampler = "SCENEJS_uDrawSampler";
            }
        }

        if (this.fresnelCore) {
            var fresnelCore = this.fresnelCore;

            if (fresnelCore.diffuse) {
                drawHandles.uDiffuseFresnelCenterColor = draw.getUniform("SCENEJS_uDiffuseFresnelCenterColor");
                drawHandles.uDiffuseFresnelEdgeColor = draw.getUniform("SCENEJS_uDiffuseFresnelEdgeColor");
                drawHandles.uDiffuseFresnelPower = draw.getUniform("SCENEJS_uDiffuseFresnelPower");
            }

            if (fresnelCore.specular) {
                drawHandles.uSpecularFresnelCenterColor = draw.getUniform("SCENEJS_uSpecularFresnelCenterColor");
                drawHandles.uSpecularFresnelEdgeColor = draw.getUniform("SCENEJS_uSpecularFresnelEdgeColor");
                drawHandles.uSpecularFresnelPower = draw.getUniform("SCENEJS_uSpecularFresnelPower");
            }

            if (fresnelCore.alpha) {
                drawHandles.uAlphaFresnelCenterColor = draw.getUniform("SCENEJS_uAlphaFresnelCenterColor");
                drawHandles.uAlphaFresnelEdgeColor = draw.getUniform("SCENEJS_uAlphaFresnelEdgeColor");
                drawHandles.uAlphaFresnelPower = draw.getUniform("SCENEJS_uAlphaFresnelPower");
            }

            if (fresnelCore.transparency) {
                drawHandles.uTransparencyFresnelCenterColor = draw.getUniform("SCENEJS_uTransparencyFresnelCenterColor");
                drawHandles.uTransparencyFresnelEdgeColor = draw.getUniform("SCENEJS_uTransparencyFresnelEdgeColor");
                drawHandles.uTransparencyFresnelPower = draw.getUniform("SCENEJS_uTransparencyFresnelPower");
            }

            if (fresnelCore.reflect) {
                drawHandles.uReflectFresnelCenterColor = draw.getUniform("SCENEJS_uReflectFresnelCenterColor");
                drawHandles.uReflectFresnelEdgeColor = draw.getUniform("SCENEJS_uReflectFresnelEdgeColor");
                drawHandles.uReflectFresnelPower = draw.getUniform("SCENEJS_uReflectFresnelPower");
            }

            if (fresnelCore.emit) {
                drawHandles.uEmitFresnelCenterColor = draw.getUniform("SCENEJS_uEmitFresnelCenterColor");
                drawHandles.uEmitFresnelEdgeColor = draw.getUniform("SCENEJS_uEmitFresnelEdgeColor");
                drawHandles.uEmitFresnelPower = draw.getUniform("SCENEJS_uEmitFresnelPower");
            }

            if (fresnelCore.fragment) {
                drawHandles.uFragmentFresnelCenterColor = draw.getUniform("SCENEJS_uFragmentFresnelCenterColor");
                drawHandles.uFragmentFresnelEdgeColor = draw.getUniform("SCENEJS_uFragmentFresnelEdgeColor");
                drawHandles.uFragmentFresnelPower = draw.getUniform("SCENEJS_uFragmentFresnelPower");
            }
        }

        if (this.cubemapCore) {
            var layers = this.cubemapCore.layers;
            drawHandles.uCubeMapSampler = new Array(layers.length);
            drawHandles.uCubeMapIntensity = new Array(layers.length);
            drawHandles.uCubeMapMipLevels = new Array(layers.length);
            if (layers) {
                var layer;
                var draw = this.program.draw;
                for (var i = 0, len = layers.length; i < len; i++) {
                    layer = layers[i];
                    drawHandles.uCubeMapSampler[i] = "SCENEJS_uCubeMapSampler" + i;
                    drawHandles.uCubeMapIntensity[i] = draw.getUniform("SCENEJS_uCubeMapIntensity" + i);
                    drawHandles.uCubeMapMipLevels[i] = draw.getUniform("SCENEJS_uCubeMapMipLevels" + i);
                }
            }
        }

    };

    MaterialChunk.prototype.draw = function (rendertype, frameCtx) {

        var gl = this.program.gl;
        var handles = this.handles[rendertype];

        if (this.materialCore) {
            if (handles.uMaterialBaseColor) {
                handles.uMaterialBaseColor.setValue(this.materialCore.baseColor);
            }

            if (handles.uMaterialSpecularColor) {
                handles.uMaterialSpecularColor.setValue(this.materialCore.specularColor);
            }

            if (handles.uMaterialEmitColor) {
                handles.uMaterialEmitColor.setValue(this.materialCore.emitColor);
            }

            if (handles.uMaterialSpecular) {
                handles.uMaterialSpecular.setValue(this.materialCore.specular);
            }

            if (handles.uMaterialShine) {
                handles.uMaterialShine.setValue(this.materialCore.shine);
            }

            if (handles.uMaterialEmit) {
                handles.uMaterialEmit.setValue(this.materialCore.emit);
            }

            if (handles.uMaterialAlpha) {
                handles.uMaterialAlpha.setValue(this.materialCore.alpha);
            }

            if (handles.uMetalRoughSpecularf0) {
                handles.uMetalRoughSpecularf0.setValue(this.materialCore.metalRoughspecularf0);
            }
        }

        if (this.textureCore) {
            frameCtx.hasNormalMap = false;

            var layers = this.textureCore.layers;

            if (layers) {

                var program = this.program[rendertype];
                var layer;

                if (handles.uTexSampler) {
                    for (var i = 0, len = layers.length; i < len; i++) {

                        layer = layers[i];

                        if (handles.uTexSampler[i] && layer.texture) {    // Lazy-loads

                            program.bindTexture(handles.uTexSampler[i], layer.texture, frameCtx.textureUnit);
                            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

                            frameCtx.bindTexture++;

                            if (layer._matrixDirty && layer.buildMatrix) {
                                layer.buildMatrix.call(layer);
                            }

                            if (handles.uTexMatrix && handles.uTexMatrix[i]) {
                                handles.uTexMatrix[i].setValue(layer.matrixAsArray);
                            }

                            if (handles.uTexBlendFactor && handles.uTexBlendFactor[i]) {
                                handles.uTexBlendFactor[i].setValue(layer.blendFactor);
                            }

                            frameCtx.hasNormalMap = frameCtx.hasNormalMap || layer.isNormalMap;

                        }
                    }
                }

                if (handles.uDrawSampler) {
                    var drawLayerIndex = this.textureCore.drawLayerIndex;
                    var drawLayer = layers[drawLayerIndex];
                    program.bindTexture(handles.uDrawSampler, drawLayer.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
                }
            }
            
            frameCtx.texture = this.textureCore;
        }

        if (this.fresnelCore) {
            var fresnelCore = this.fresnelCore;

            if (fresnelCore.diffuse) {

                if (handles.uDiffuseFresnelCenterColor) {
                    handles.uDiffuseFresnelCenterColor.setValue(fresnelCore.diffuse.centerColor);
                }

                if (handles.uDiffuseFresnelEdgeColor) {
                    handles.uDiffuseFresnelEdgeColor.setValue(fresnelCore.diffuse.edgeColor);
                }

                if (handles.uDiffuseFresnelPower) {
                    handles.uDiffuseFresnelPower.setValue(fresnelCore.diffuse.power);
                }
            }

            if (fresnelCore.specular) {

                if (handles.uSpecularFresnelCenterColor) {
                    handles.uSpecularFresnelCenterColor.setValue(fresnelCore.specular.centerColor);
                }

                if (handles.uSpecularFresnelEdgeColor) {
                    handles.uSpecularFresnelEdgeColor.setValue(fresnelCore.specular.edgeColor);
                }

                if (handles.uSpecularFresnelPower) {
                    handles.uSpecularFresnelPower.setValue(fresnelCore.specular.power);
                }
            }

            if (fresnelCore.alpha) {

                if (handles.uAlphaFresnelCenterColor) {
                    handles.uAlphaFresnelCenterColor.setValue(fresnelCore.alpha.centerColor);
                }

                if (handles.uAlphaFresnelEdgeColor) {
                    handles.uAlphaFresnelEdgeColor.setValue(fresnelCore.alpha.edgeColor);
                }

                if (handles.uAlphaFresnelPower) {
                    handles.uAlphaFresnelPower.setValue(fresnelCore.alpha.power);
                }
            }

            if (fresnelCore.transparency) {
                if (handles.uTransparencyFresnelCenterColor) {
                    handles.uTransparencyFresnelCenterColor.setValue(fresnelCore.transparency.centerColor);
                }
                if (handles.uTransparencyFresnelEdgeColor) {
                    handles.uTransparencyFresnelEdgeColor.setValue(fresnelCore.transparency.edgeColor);
                }
                if (handles.uTransparencyFresnelPower) {
                    handles.uTransparencyFresnelPower.setValue(fresnelCore.transparency.power);
                }
            }

            if (fresnelCore.reflect) {

                if (handles.uReflectFresnelCenterColor) {
                    handles.uReflectFresnelCenterColor.setValue(fresnelCore.reflect.centerColor);
                }

                if (handles.uReflectFresnelEdgeColor) {
                    handles.uReflectFresnelEdgeColor.setValue(fresnelCore.reflect.edgeColor);
                }

                if (handles.uReflectFresnelPower) {
                    handles.uReflectFresnelPower.setValue(fresnelCore.reflect.power);
                }
            }

            if (fresnelCore.emit) {

                if (handles.uEmitFresnelCenterColor) {
                    handles.uEmitFresnelCenterColor.setValue(fresnelCore.emit.centerColor);
                }

                if (handles.uEmitFresnelEdgeColor) {
                    handles.uEmitFresnelEdgeColor.setValue(fresnelCore.emit.edgeColor);
                }

                if (handles.uEmitFresnelPower) {
                    handles.uEmitFresnelPower.setValue(fresnelCore.emit.power);
                }
            }

            if (fresnelCore.fragment) {

                if (handles.uFragmentFresnelCenterColor) {
                    handles.uFragmentFresnelCenterColor.setValue(fresnelCore.fragment.centerColor);
                }

                if (handles.uFragmentFresnelEdgeColor) {
                    handles.uFragmentFresnelEdgeColor.setValue(fresnelCore.fragment.edgeColor);
                }

                if (handles.uFragmentFresnelPower) {
                    handles.uFragmentFresnelPower.setValue(fresnelCore.fragment.power);
                }
            }
        }

        if (this.cubemapCore) {
            var layers = this.cubemapCore.layers;
            if (layers) {
                var layer;
                var program = this.program[rendertype];
                if (handles.uCubeMapSampler) {
                    for (var i = 0, len = layers.length; i < len; i++) {
                        layer = layers[i];
                        if (handles.uCubeMapSampler[i] && layer.texture) {
    
                            program.bindTexture(handles.uCubeMapSampler[i], layer.texture, frameCtx.textureUnit);
                            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
    
                            if (handles.uCubeMapIntensity[i]) {
                                handles.uCubeMapIntensity[i].setValue(layer.intensity);
                            }

                            if (handles.uCubeMapMipLevels[i]) {
                                handles.uCubeMapMipLevels[i].setValue(layer.mipLevels);
                            }
                        }
                    }
                }
            }
        }
    };

    SceneJS_ChunkFactory.addChunkType("material", MaterialChunk);
})();
;(function () {
    "use strict";

    var ProgramChunk = function (id, numericId, program, cores) {

        this.id = id;
        this.numericId = numericId;
        this.program = program;

        cores = cores || [];

        for (var i = 0, len = cores.length; i < len; ++i) {
            if (cores[i] && cores[i].empty) {
                cores[i] = null;
            }
        }

        this.cores = cores;
        this.handles = {};
        this.numLights = 0;
        this.numClips = 0;

        this.build();
    };

    ProgramChunk.prototype.build = function () {

        var draw = this.program.draw;
        var xray = this.program.xray;
        var pick = this.program.pick;
        var pickTriangle = this.program.pickTriangle;
        var depth = this.program.depth;
        var drawTexture = this.program.drawTexture;

        this.handles.draw = {
            uPMatrix: draw.getUniform("SCENEJS_uPMatrix"),
            uvMatrix: draw.getUniform("SCENEJS_uVMatrix"),
            uWorldEye: draw.getUniform("SCENEJS_uWorldEye"),
            uFogParams: draw.getUniform("SCENEJS_uFogParams"), // x = start, y = end, z = min, w = max
            uFogColor: draw.getUniform("SCENEJS_uFogColor"), // RGB = color, a = density
            uCanvasRes: draw.getUniform("SCENEJS_uCanvasRes"),
            uAmbientColor: draw.getUniform("SCENEJS_uAmbientColor"),
            uLightColor: [],
            uLightDir: [],
            uLightPos: [],
            uLightCutOff: [],
            uLightSpotExp: [],
            uLightAttenuation: [],
            uInnerCone: [],
            uOuterCone: [],
            uClipNormalAndDist: [],
            uClipFadeDistance: [],
            uPBRLightMapIntensity: draw.getUniform("SCENEJS_uPBRLightMapIntensity"),
            uPBRLightMapMipLevels: draw.getUniform("SCENEJS_uPBRLightMapMipLevels"),
            uPBRReflectionMapIntensity: draw.getUniform("SCENEJS_uPBRReflectionMapIntensity"),
            uPBRReflectionMapMipLevels: draw.getUniform("SCENEJS_uPBRReflectionMapMipLevels")
        };

        var program = this.program;
        this.numLights = 0;

        while (true) {
            var colorUniform = draw.getUniform("SCENEJS_uLightColor" + this.numLights);
            if (!colorUniform) {
                break;
            }
            this.handles.draw.uLightColor[this.numLights] = colorUniform;
            this.handles.draw.uLightPos[this.numLights] = program.draw.getUniform("SCENEJS_uLightPos" + this.numLights);
            this.handles.draw.uLightDir[this.numLights] = program.draw.getUniform("SCENEJS_uLightDir" + this.numLights);
            this.handles.draw.uLightAttenuation[this.numLights] = program.draw.getUniform("SCENEJS_uLightAttenuation" + this.numLights);
            this.handles.draw.uInnerCone[this.numLights] = program.draw.getUniform("SCENEJS_uInnerCone" + this.numLights);
            this.handles.draw.uOuterCone[this.numLights] = program.draw.getUniform("SCENEJS_uOuterCone" + this.numLights);
            ++this.numLights;
        }

        this.handles.xray = {
            uPMatrix: xray.getUniform("SCENEJS_uPMatrix"),
            uvMatrix: xray.getUniform("SCENEJS_uVMatrix"),
            uWorldEye: xray.getUniform("SCENEJS_uWorldEye"),
            uFogParams: xray.getUniform("SCENEJS_uFogParams"), // x = start, y = end, z = min, w = max
            uFogColor: xray.getUniform("SCENEJS_uFogColor"), // RGB = color, a = density
            uXrayColor: xray.getUniform("SCENEJS_uXrayColor"),
            uClipNormalAndDist: [],
            uClipFadeDistance: []
        };

        this.handles.pick = {
            pickMode: pick.getUniform("SCENEJS_uPickMode"),
            uPMatrix: pick.getUniform("SCENEJS_uPMatrix"),
            uvMatrix: pick.getUniform("SCENEJS_uVMatrix"),
            uClipNormalAndDist: [],
            uClipFadeDistance: []
        };

        this.handles.pickTriangle = {
            uPMatrix: pickTriangle.getUniform("SCENEJS_uPMatrix"),
            uvMatrix: pickTriangle.getUniform("SCENEJS_uVMatrix"),
            uClipNormalAndDist: [],
            uClipFadeDistance: []
        };

        this.handles.depth = {
            uPMatrix: depth.getUniform("SCENEJS_uPMatrix"),
            uvMatrix: depth.getUniform("SCENEJS_uVMatrix"),
            uClipNormalAndDist: [],
            uClipFadeDistance: []
        };

        this.handles.drawTexture = {
            uPMatrix: drawTexture.getUniform("SCENEJS_uPMatrix"),
            uvMatrix: drawTexture.getUniform("SCENEJS_uVMatrix"),
            uClipNormalAndDist: [],
            uClipFadeDistance: []
        };

        this.numClips = 0;
        while (true) {
            var clipUniform = draw.getUniform("SCENEJS_uClipNormalAndDist" + this.numClips);
            if (!clipUniform) {
                break;
            }

            this.handles.draw.uClipNormalAndDist[this.numClips] = clipUniform;
            this.handles.draw.uClipFadeDistance[this.numClips] = draw.getUniform("SCENEJS_uClipFadeDistance" + this.numClips);

            this.handles.xray.uClipNormalAndDist[this.numClips] = xray.getUniform("SCENEJS_uClipNormalAndDist" + this.numClips);
            this.handles.xray.uClipFadeDistance[this.numClips] = xray.getUniform("SCENEJS_uClipFadeDistance" + this.numClips);

            this.handles.pick.uClipNormalAndDist[this.numClips] = pick.getUniform("SCENEJS_uClipNormalAndDist" + this.numClips);
            this.handles.pick.uClipFadeDistance[this.numClips] = pick.getUniform("SCENEJS_uClipFadeDistance" + this.numClips);

            this.handles.pickTriangle.uClipNormalAndDist[this.numClips] = pickTriangle.getUniform("SCENEJS_uClipNormalAndDist" + this.numClips);
            this.handles.pickTriangle.uClipFadeDistance[this.numClips] = pickTriangle.getUniform("SCENEJS_uClipFadeDistance" + this.numClips);

            this.handles.depth.uClipNormalAndDist[this.numClips] = depth.getUniform("SCENEJS_uClipNormalAndDist" + this.numClips);
            this.handles.depth.uClipFadeDistance[this.numClips] = depth.getUniform("SCENEJS_uClipFadeDistance" + this.numClips);

            this.handles.drawTexture.uClipNormalAndDist[this.numClips] = drawTexture.getUniform("SCENEJS_uClipNormalAndDist" + this.numClips);
            this.handles.drawTexture.uClipFadeDistance[this.numClips] = drawTexture.getUniform("SCENEJS_uClipFadeDistance" + this.numClips);

            ++this.numClips;
        }

        var gl = draw.gl;

        var dummyTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, dummyTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));

        this.dummyDepthTexture = {
            texture: dummyTexture,
            gl: gl,
            bind: function (unit) {
                if (this.texture) {
                    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
                    return true;
                }
                return false;
            },
            unbind: function (unit) {
                if (this.texture) {
                    this.gl.activeTexture(this.gl.TEXTURE0 + unit);
                    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
                }
            },
            destroy: function () {
                if (this.texture) {
                    this.gl.deleteTexture(this.texture);
                    this.texture = null;
                }
            }
        };

        gl.bindTexture(gl.TEXTURE_2D, null);

    };

    ProgramChunk.prototype.draw = function (renderMode, frameCtx) {

        this.program[renderMode].bind();
        var handles = this.handles[renderMode];

        frameCtx.textureUnit = 0;

        var gl = this.program.gl;
        if (handles.depthMode) {
            handles.depthMode.setValue(frameCtx.depthMode);
        }
        if (!frameCtx.VAO) {
            for (var i = 0; i < 10; i++) {
                gl.disableVertexAttribArray(i);
            }
        }

        if (handles.uPMatrix) {
            handles.uPMatrix.setValue(frameCtx.projectionMatrix);
        }

        if (handles.uvMatrix) {
            handles.uvMatrix.setValue(frameCtx.viewMatrix);
        }

        if (handles.uWorldEye) {
            handles.uWorldEye.setValue(frameCtx.cameraEye);
        }

        if (handles.uAmbientColor) {
            handles.uAmbientColor.setValue(frameCtx.ambientColor);
        }

        if (handles.uLightColor) {
            for (var i = 0; i < this.numLights; ++i) {
                var light = frameCtx.lights[i];

                if (handles.uLightColor[i]) {
                    handles.uLightColor[i].setValue(light.color);
                }

                if (handles.uLightPos[i]) {
                    handles.uLightPos[i].setValue(light.pos);

                    if (handles.uLightAttenuation[i]) {
                        handles.uLightAttenuation[i].setValue(light.attenuation);
                    }
                }

                if (handles.uLightDir[i]) {
                    handles.uLightDir[i].setValue(light.dir);
                }

                if (handles.uInnerCone[i]) {
                    handles.uInnerCone[i].setValue(light.innerCone);
                }

                if (handles.uOuterCone[i]) {
                    handles.uOuterCone[i].setValue(light.outerCone);
                }

            }
        }

        if (this.numClips > 0) {
            for (var i = 0; i < this.numClips; ++i) {
                var clip = frameCtx.clips.clips[i];

                if (handles.uClipNormalAndDist[i]) {
                    handles.uClipNormalAndDist[i].setValue(clip.normalAndDist);
                }

                if (handles.uClipFadeDistance[i]) {
                    handles.uClipFadeDistance[i].setValue(clip.fadeDistance);
                }
            }
        }

        if (frameCtx.reflection && frameCtx.reflection.texture) {
            this.program[renderMode].bindTexture("SCENEJS_uPBRReflectionMapSampler", frameCtx.reflection.texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
            frameCtx.bindTexture++;

            if (handles.uPBRReflectionMapIntensity) {
                handles.uPBRReflectionMapIntensity.setValue(frameCtx.reflection.intensity);
            }
            if (handles.uPBRReflectionMapMipLevels) {
                handles.uPBRReflectionMapMipLevels.setValue(frameCtx.reflection.mipLevels);
            }
        }

        if (frameCtx.lightmap && frameCtx.lightmap.texture) {

            this.program[renderMode].bindTexture("SCENEJS_uPBRLightMapSampler", frameCtx.lightmap.texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
            frameCtx.bindTexture++;

            if (handles.uPBRLightMapIntensity) {
                handles.uPBRLightMapIntensity.setValue(frameCtx.lightmap.intensity);
            }
            if (handles.uPBRLightMapMipLevels) {
                handles.uPBRLightMapMipLevels.setValue(frameCtx.lightmap.mipLevels);
            }
        }

        if (handles.uFogParams) {
            handles.uFogParams.setValue(frameCtx.fogParams);
        }

        if (handles.uFogColor) {
            handles.uFogColor.setValue(frameCtx.fogColor);
        }

        if (handles.uXrayColor) {
            handles.uXrayColor.setValue(frameCtx.xrayColor);
        }

        var depthBuffer = frameCtx.depthBuffer || this.dummyDepthTexture;
        this.program[renderMode].bindTexture("SCENEJS_uDepthBuffer", depthBuffer, frameCtx.textureUnit);
        frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
        frameCtx.bindTexture++;

        if (handles.uCanvasRes) {
            handles.uCanvasRes.setValue(frameCtx.canvasResolution);
        }

        if (handles.pickMode) {
            if (frameCtx.pickObject) {
                handles.pickMode.setValue(0.0); // Pick object
            } else {
                handles.pickMode.setValue(2.0); // Pick region
            }
        }

        frameCtx.useProgram++;
    };

    SceneJS_ChunkFactory.addChunkType("program", ProgramChunk);
})();
;(function () {
    "use strict";

    var RegionMapChunk = function (id, numericId, program, cores) {

        this.id = id;
        this.numericId = numericId;
        this.program = program;

        cores = cores || [];

        for (var i = 0, len = cores.length; i < len; ++i) {
            if (cores[i] && cores[i].empty) {
                cores[i] = null;
            }
        }

        this.cores = cores;
        this.handles = {};

        this.build();
    };

    RegionMapChunk.prototype.build = function () {

        this.core = this.cores[0];

        this.handles.draw = {
            uRegionMapRegionColor: this.program.draw.getUniform("SCENEJS_uRegionMapRegionColor"),
            uRegionMapHighlightFactor: this.program.draw.getUniform("SCENEJS_uRegionMapHighlightFactor"),
            uRegionMapHideAlpha: this.program.draw.getUniform("SCENEJS_uRegionMapHideAlpha")
        };
        
        this.sampleName = "SCENEJS_uRegionMapSampler";
    };

    RegionMapChunk.prototype.draw = function (renderMode, frameCtx) {

        var texture = this.core.texture;
        var handles = this.handles[renderMode] || {};

        if (texture) {
            frameCtx.regionData = this.core.regionData;

            this.program.draw.bindTexture(this.sampleName, texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

            if (handles.uRegionMapRegionColor) {
                handles.uRegionMapRegionColor.setValue(this.core.regionColor);
            }

            if (handles.uRegionMapHighlightFactor) {
                handles.uRegionMapHighlightFactor.setValue(this.core.highlightFactor);
            }

            if (handles.uRegionMapHideAlpha) {
                handles.uRegionMapHideAlpha.setValue(this.core.hideAlpha);
            }

            frameCtx.regionMapUVLayerIdx = this.core.uvLayerIdx;

        } else {

            frameCtx.regionMapUVLayerIdx = -1;
        }
    };

    SceneJS_ChunkFactory.addChunkType("regionMap", RegionMapChunk);
})();
;/**
 * Box geometry node type
 *
 * @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/box",
 *      xSize: 10,
 *      ySize: 20,
 *      zSize: 1.5,
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/box", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        var x, y, z;
        if (params.size) {
            x = params.size[0];
            y = params.size[1];
            z = params.size[2];
        } else {
            // Deprecated
            x = params.xSize || 1;
            y = params.ySize || 1;
            z = params.zSize || 1;
        }

        var coreId = "geometry/box_" + x + "_" + y + "_" + z + (params.wire ? "wire" : "_solid");

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type:"geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry
        return {
            type:"geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:new Float32Array([
                x, y, z, -x, y, z, -x, -y, z, x, -y, z, // v0-v1-v2-v3 front
                x, y, z, x, -y, z, x, -y, -z, x, y, -z, // v0-v3-v4-v5 right
                x, y, z, x, y, -z, -x, y, -z, -x, y, z, // v0-v5-v6-v1 top
                -x, y, z, -x, y, -z, -x, -y, -z, -x, -y, z, // v1-v6-v7-v2 left
                -x, -y, -z, x, -y, -z, x, -y, z, -x, -y, z, // v7-v4-v3-v2 bottom
                x, -y, -z, -x, -y, -z, -x, y, -z, x, y, -z // v4-v7-v6-v5 back
            ]),
            normals:new Float32Array([
                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v1-v2-v3 front
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v0-v5-v6-v1 top
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v1-v6-v7-v2 left
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v7-v4-v3-v2 bottom
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1     // v4-v7-v6-v5 back
            ]),
            uv:new Float32Array([
                x, y, 0, y, 0, 0, x, 0, // v0-v1-v2-v3 front
                0, y, 0, 0, x, 0, x, y, // v0-v3-v4-v5 right
                x, 0, x, y, 0, y, 0, 0, // v0-v5-v6-v1 top
                x, y, 0, y, 0, 0, x, 0, // v1-v6-v7-v2 left
                0, 0, x, 0, x, y, 0, y, // v7-v4-v3-v2 bottom
                0, 0, x, 0, x, y, 0, y    // v4-v7-v6-v5 back
            ]),
            indices:[
                0, 1, 2, 0, 2, 3, // front
                4, 5, 6, 4, 6, 7, // right
                8, 9, 10, 8, 10, 11, // top
                12, 13, 14, 12, 14, 15, // left
                16, 17, 18, 16, 18, 19, // bottom
                20, 21, 22, 20, 22, 23   // back
            ]
        };
    }
})();
;/**
 * Quad geometry node type
 *
 *  @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/quad",
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/quad", {
        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        // TODO: support size properties like 'geometry/plane'

        var coreId = "geometry/quad" + (params.wire ? "wire" : "_solid");

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry
        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:[ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0 ],
            normals:[ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
            uv:[ 1, 1, 0, 1, 0, 0, 1, 0 ],
            indices:[ 0, 1, 2, 0, 2, 3 ]
        };
    }
})();;/**
 * Sphere geometry node type
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/sphere",
 *      latitudeBands: 30, // Default
 *      longitudeBands: 30, // Default
 *      radius: 1, // Default
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/sphere", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        // Thanks awfully to: http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere

        var latitudeBands = params.latitudeBands || 30;
        var longitudeBands = params.longitudeBands || 30;
        var radius = params.radius || 1;

        var coreId = "geometry/sphere_" + (params.wire ? "wire" : "_solid") + radius + "_" + longitudeBands + "_" + latitudeBands;

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry

        var positions = [];
        var normals = [];
        var uvs = [];
        for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = longNumber / longitudeBands;
                var v = latNumber / latitudeBands;

                normals.push(x);
                normals.push(y);
                normals.push(z);
                uvs.push(u);
                uvs.push(v);
                positions.push(radius * x);
                positions.push(radius * y);
                positions.push(radius * z);
            }
        }

        var indices = [];
        for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indices.push(first + 1);
                indices.push(second + 1);
                indices.push(second);
                indices.push(first + 1);
                indices.push(second);
                indices.push(first);
            }
        }

        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId : coreId,
            positions : new Float32Array(positions),
            normals: new Float32Array(normals),
            uv : new Float32Array(uvs),
            indices : indices // Type will be decided internally
        };
    }
})();;/**
 * Plane geometry node type
 *
 * @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/plane",
 *      width: 10,
 *      height: 20,
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/plane", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        var width = params.width || 1.0;
        var height = params.height || 1.0;

        var widthSegments = params.widthSegments || 1;
        var heightSegments = params.heightSegments || 1;

        var coreId = "geometry/plane_" + (params.wire == true ? "wire_" : "") + height + "_" + widthSegments + "_" + heightSegments;

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry

        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        var ix, iz;
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        var gridX = widthSegments;
        var gridZ = heightSegments;

        var gridX1 = gridX + 1;
        var gridZ1 = gridZ + 1;

        var segWidth = width / gridX;
        var segHeight = height / gridZ;

        var x;
        var y;

        for (iz = 0; iz < gridZ1; iz++) {
            for (ix = 0; ix < gridX1; ix++) {

                x = ix * segWidth - halfWidth;
                y = iz * segHeight - halfHeight;

                positions.push(x);
                positions.push(-y);
                positions.push(0);

                normals.push(0);
                normals.push(0);
                normals.push(1);

                uvs.push(ix / gridX);
                uvs.push(1 - iz / gridZ);
            }
        }

        var a;
        var b;
        var c;
        var d;

        for (iz = 0; iz < gridZ; iz++) {
            for (ix = 0; ix < gridX; ix++) {

                a = ix + gridX1 * iz;
                b = ix + gridX1 * ( iz + 1 );
                c = ( ix + 1 ) + gridX1 * ( iz + 1 );
                d = ( ix + 1 ) + gridX1 * iz;

                indices.push(a);
                indices.push(b);
                indices.push(c);

                indices.push(c);
                indices.push(d);
                indices.push(a);
            }
        }

        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:new Float32Array(positions),
            normals:new Float32Array(normals),
            uv:new Float32Array(uvs),
            indices:indices
        };
    }
})();
;/******************************************************************************

This is a binary tree based bin packing algorithm that is more complex than
the simple Packer (packer.js). Instead of starting off with a fixed width and
height, it starts with the width and height of the first block passed and then
grows as necessary to accomodate each subsequent block. As it grows it attempts
to maintain a roughly square ratio by making 'smart' choices about whether to
grow right or down.

When growing, the algorithm can only grow to the right OR down. Therefore, if
the new block is BOTH wider and taller than the current target then it will be
rejected. This makes it very important to initialize with a sensible starting
width and height. If you are providing sorted input (largest first) then this
will not be an issue.

A potential way to solve this limitation would be to allow growth in BOTH
directions at once, but this requires maintaining a more complex tree
with 3 children (down, right and center) and that complexity can be avoided
by simply chosing a sensible starting block.

Best results occur when the input blocks are sorted by height, or even better
when sorted by max(width,height).

Inputs:
------

  blocks: array of any objects that have .w and .h attributes

Outputs:
-------

  marks each block that fits with a .fit attribute pointing to a
  node with .x and .y coordinates

Example:
-------

  var blocks = [
    { w: 100, h: 100 },
    { w: 100, h: 100 },
    { w:  80, h:  80 },
    { w:  80, h:  80 },
    etc
    etc
  ];

  var packer = new GrowingPacker();
  packer.fit(blocks);

  for(var n = 0 ; n < blocks.length ; n++) {
    var block = blocks[n];
    if (block.fit) {
      Draw(block.fit.x, block.fit.y, block.w, block.h);
    }
  }


******************************************************************************/
-function (exports) {

var GrowingPacker = exports.GrowingPacker = function() { };

GrowingPacker.prototype = {

  fit: function(blocks) {
    var n, node, block, len = blocks.length;
    var w = len > 0 ? blocks[0].w : 0;
    var h = len > 0 ? blocks[0].h : 0;
    this.root = { x: 0, y: 0, w: w, h: h };
    for (n = 0; n < len ; n++) {
      block = blocks[n];
      if (node = this.findNode(this.root, block.w, block.h))
        block.fit = this.splitNode(node, block.w, block.h);
      else
        block.fit = this.growNode(block.w, block.h);
    }
  },

  findNode: function(root, w, h) {
    if (root.used)
      return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);
    else if ((w <= root.w) && (h <= root.h))
      return root;
    else
      return null;
  },

  splitNode: function(node, w, h) {
    node.used = true;
    node.down  = { x: node.x,     y: node.y + h, w: node.w,     h: node.h - h };
    node.right = { x: node.x + w, y: node.y,     w: node.w - w, h: h          };
    return node;
  },

  growNode: function(w, h) {
    var canGrowDown  = (w <= this.root.w);
    var canGrowRight = (h <= this.root.h);

    var shouldGrowRight = canGrowRight && (this.root.h >= (this.root.w + w)); // attempt to keep square-ish by growing right when height is much greater than width
    var shouldGrowDown  = canGrowDown  && (this.root.w >= (this.root.h + h)); // attempt to keep square-ish by growing down  when width  is much greater than height

    if (shouldGrowRight)
      return this.growRight(w, h);
    else if (shouldGrowDown)
      return this.growDown(w, h);
    else if (canGrowRight)
     return this.growRight(w, h);
    else if (canGrowDown)
      return this.growDown(w, h);
    else
      return null; // need to ensure sensible root starting size to avoid this happening
  },

  growRight: function(w, h) {
    this.root = {
      used: true,
      x: 0,
      y: 0,
      w: this.root.w + w,
      h: this.root.h,
      down: this.root,
      right: { x: this.root.w, y: 0, w: w, h: this.root.h }
    };
    if (node = this.findNode(this.root, w, h))
      return this.splitNode(node, w, h);
    else
      return null;
  },

  growDown: function(w, h) {
    this.root = {
      used: true,
      x: 0,
      y: 0,
      w: this.root.w,
      h: this.root.h + h,
      down:  { x: 0, y: this.root.h, w: this.root.w, h: h },
      right: this.root
    };
    if (node = this.findNode(this.root, w, h))
      return this.splitNode(node, w, h);
    else
      return null;
  }

}

}(typeof window !== 'undefined' ? window : module.exports);;/**
 * @namespace The core engine namespace.
 */
(function () {
    "use strict";

    var Human = window.Human = {};

    var VERSION = "17.1.3";
    VERSION = VERSION.indexOf("ENGINE_VERSION") > 0 ? "qa" : VERSION;

    var API_VERSION = "2.0.1";
    API_VERSION = API_VERSION.indexOf("API_VERSION") > 0 ? "qa" : API_VERSION;


    /**
     * Engine version.
     *
     * @memberof Human
     * @name VERSION
     * @property
     * @type {string}
     */
    Human.VERSION = VERSION;
    Human.API_VERSION = API_VERSION;

    /** True when this engine instance is running on the Web
     *
     * @type {boolean}
     * @memberof Human
     */
    Human.deployed = !( window.location.hostname.match(/(localhost|192\.168\.11\.\d{1,3})/) ||
        window.location.protocol === "file:" );

     /** The language used for content requests.
     *
     * @type {string}
     * @memberof Human
     */
    Human.locale = "en-US";

    Human.timer = window.performance || window.Date;

    Human.stats = {
        trackingDownloadSize: false,
        jsonDownloadTotal: 0,
        geometryDownloadTotal: 0,
        textureDownloadTotal: 0,
        jsonDownloadSizes: {},
        geometryDownloadSizes: {},
        textureDownloadSizes: {},
        loadSequence: {
            startTime: Human.timer.now(),
            moduleRequest: 0,
            moduleLoaded: 0,
            assetsRequested: 0,
            assetsLoaded: 0,
            texturesRequested: 0,
            texturesLoaded: 0
        },
        loadTimes: {
            preModule: 0,
            moduleDownload: 0,
            preAsset: 0,
            assetDownload: 0,
            preTexture: 0,
            textureDownload: 0
        },
        trackDownloadSize: function() {
            if (window.pako) {
                this.trackingDownloadSize = true;
            }
        }
    };

    /* IDs of nodes in the document and scene graph
     */
    Human.canvasId = "theCanvas";
    Human.annotationCanvasId = "annotationCanvas";
    Human.containerId = "container";

    Human.XML_HTTP_JSON_SUPPORTED = (function() {
        var request = new XMLHttpRequest();
        request.open("GET", "/");
        request.responseType = "json";
        return request.responseType === "json";
    })();

    Human.ELEMENT_REMOVE_SUPPORTED = typeof Element.prototype.remove === "function";

    /*-----------------------------------------------------------------------------------------------------------------
     * Error management
     *---------------------------------------------------------------------------------------------------------------*/

    /**
     * Signals non-fatal error.
     * @memberof Human
     */
    Human.error = function (name, msg) {
        if (msg === undefined) {
            msg = name;
            name = "ERROR";
        }
        return Human._error("HUMAN", name, msg, false);
    };

    /**
     * Signals fatal error.
     * @memberof Human
     */
    Human.fatalError = function (name, msg) {
        if (msg === undefined) {
            msg = name;
            name = "ERROR";
        }
        return Human._error("HUMAN", name, msg, true);
    };

    Human._error = function (type, name, msg, fatal) {

        Human.events.fire("error", {
            type: type,
            name: name,
            message: msg,
            fatal: fatal,
            log: Human.log.messages.join("\n"),
            stack: Human.utils.getStackTrace(),
            webglInfo: SceneJS.WEBGL_INFO
        });

        return msg;
    };

})();
;/**
 * @class Base class for the various engine modules.
 *
 * @constructor
 */

(function() {
    "use strict";

    Human.Component = function () {

    };


    Human.Component.prototype = {

        _init:function (ctx) {

            this._ctx = ctx;

            this._handleMap = new Human.utils.Map(); // Subscription handle pool
            this._topicSubs = {}; // A [handle -> callback] map for each topic name
            this._handleTopics = {}; // Maps handles to topic names
            this._topicPubs = {}; // Maps topics to publications
        },

        /**
         * Publishes to a topic.
         *
         * Immediately notifies existing subscriptions to that topic, retains the publication to give to
         * any subsequent notifications on that topic as they are made.
         *
         * This is called internally by proxies. Only they create publications, which are subscribed
         * to by client code.
         *
         * @param topic Publication topic
         * @param pub The publication
         * @param once True to publish once ie. not retain
         * @private
         */
        publish:function (topic, pub, once) {
            if (!once) {
                this._topicPubs[topic] = pub; // Save notification
            }
            var subsForTopic = this._topicSubs[topic];
            if (subsForTopic) { // Notify subscriptions
                for (var handle in subsForTopic) {
                    if (subsForTopic.hasOwnProperty(handle)) {
                        subsForTopic[handle].call(this, pub);
                    }
                }
            }
        },

        /**
         * Listen for data changes at a particular location on this component.
         *
         * <p>This is the primary way to read data from the Human API. Your callback will be triggered for
         * the initial data and again whenever the data changes. Use {@link #unsubscribe} to stop receiving updates.</p>
         *
         * <p>The callback is be called with this component as scope.</p>
         *
         * @param {String} topic Publication location
         * @param {Function(data)} callback Called when fresh data is available at the location
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        on:function (topic, callback) {
            var subsForTopic = this._topicSubs[topic];
            if (!subsForTopic) {
                subsForTopic = {};
                this._topicSubs[topic] = subsForTopic;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subsForTopic[handle] = callback;
            this._handleTopics[handle] = topic;
            var pub = this._topicPubs[topic];
            if (pub) { // A publication exists, notify callback immediately
                callback.call(this, pub);
            }
            return handle;
        },

        /**
         * Unsubscribes from a publication on this proxy that was previously made with {@link #on}.
         * @param handle Publication handle
         */
        off:function (handle, fn) {
            var topic;
            var topicSubs;
            if (fn) {
                topic = handle;
                topicSubs = this._topicSubs[topic];
                for (var h in topicSubs) {
                    if (topicSubs[h] === fn) {
                        handle = h;
                        break;
                    }
                }
            } else {
                topic = this._handleTopics[handle];
            }
            if (topic) {
                delete this._handleTopics[handle];
                topicSubs = this._topicSubs[topic];
                if (topicSubs) {
                    delete topicSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
            }
        },

        /**
         * Listens for exactly one data update at the specified location, and then stops listening.
         * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
         * @param {String} topic Data location to listen to
         * @param {Function(data)} callback Called when fresh data is available at the location
         */
        once:function (topic, callback) {
            var self = this;
            var sub = this.on(topic,
                function (pub) {
                    self.off(sub);
                    callback(pub);
                });
        }
    };

})();

;
/**
 * @namespace Math functions
 * @private
 */

(function() {
    "use strict";

    var HumanMath = Human.math = {
        X_AXIS: vec3.fromValues(1, 0, 0),
        Y_AXIS: vec3.fromValues(0, 1, 0),
        Z_AXIS: vec3.fromValues(0, 0, 1),
        VEC3_ZEROS: vec3.fromValues(0, 0, 0),
        VEC3_ONES: vec3.fromValues(1, 1, 1),
        TO_RADIANS: Math.PI / 180.0
    };

    var tempVec3a = vec3.create();
    var tempVec3b = vec3.create();

    HumanMath.clamp = function(u, min, max) {
        return (u < min) ? min : ((u > max) ? max : u);
    };

    HumanMath.nextPowerOf2 = function(n) {
        return Math.pow(2, Math.ceil( Math.log(n) / Math.log(2))); 
    };

    HumanMath.sign = function(n) {
        if (n > 0) {
            return 1;
        }

        if (n < 0) {
            return -1;
        }

        return 0;
    };

    HumanMath.lerpScalar = function(t, t1, t2, s1, s2) {
        var f = (t - t1) / (t2 - t1);

        return s1 + (f * (s2 - s1));
    };

    /**
     *
     */
    HumanMath.lerpVec3 = function(t, t1, t2, p1, p2, dest) {
        dest = dest || vec3.create();
        var f = (t - t1) / (t2 - t1);

        dest[0] = p1[0] + (f * (p2[0] - p1[0]));
        dest[1] = p1[1] + (f * (p2[1] - p1[1]));
        dest[2] = p1[2] + (f * (p2[2] - p1[2]));

        return dest;
    };

    HumanMath.triangleNormal = function(v1, v2, v3, n) {
        var e1 = tempVec3a;
        var e2 = tempVec3b;

        vec3.subtract(e1, v2, v1);
        vec3.subtract(e2, v3, v1);
        vec3.cross(n, e1, e2);
        vec3.normalize(n, n);

        return n;
    };


    /**
     * @return short rotation from r1 to r2
     */
    HumanMath.getShortRotation = function (r1, r2) {
        var flip = r2 > r1 ? 1 : -1;
        var gap = (r2 - r1) * flip;
        gap = (gap + Math.PI) % (Math.PI * 2) - Math.PI;
        return gap * flip;
    };

    /**
     * f: [0, 1]
     * r1, r2 : [-PI, PI]
     */
    HumanMath.lerpRadian = function (f, r1, r2) {
        var gap = HumanMath.getShortRotation(r1, r2);
        var result = r1 + f * gap;
        return result;
    };

    /**
     *
     */
    HumanMath.lerpVec3Cylindrical = function(t, t1, t2, p1, p2, dest) {
        dest = dest || vec3.create();
        var f = (t - t1) / (t2 - t1);

        dest[0] = p1[0] + (f * (p2[0] - p1[0]));
        dest[1] = HumanMath.lerpRadian(f, p1[1], p2[1]);
        dest[2] = p1[2] + (f * (p2[2] - p1[2]));

        return dest;
    };

    // Faster than a full transform because we know it's a scale and a translation
    Human.math.decompressPosition = function(out, position, decodeMatrix) {
        out[0] = position[0] * decodeMatrix[0]  + decodeMatrix[12];
        out[1] = position[1] * decodeMatrix[5]  + decodeMatrix[13];
        out[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];
    };

    // Faster than a full transform because we know it's a scale and a translation
    Human.math.decompressUV = function(out, position, decodeMatrix) {
        out[0] = position[0] * decodeMatrix[0]  + decodeMatrix[6];
        out[1] = position[1] * decodeMatrix[4]  + decodeMatrix[7];
    };

    /**
     *
     */
    Human.math.vec3ObjToArray = function(v, dest) {
        var result = dest || vec3.create();

        result[0] = v.x || 0;
        result[1] = v.y || 0;
        result[2] = v.z || 0;

        return result;
    };

    /**
     *
     */
    Human.math.vec3ArrayToObj = function(v) {
        return { x: v[0], y: v[1], z: v[2] };
    };

    /** cartesian coordinate (x,y,z) to cylindrical coordinate (r, theta, h)
     * x - left, y - up, z - in (right hand)
     * r = x^2 + z^2
     * theta = atan2(x, z)
     * h = y
     */
    HumanMath.cartesianToCylindrical = function (v, dest) {
        var result = dest || vec3.create();

        result[0] = Math.sqrt( v[0] * v[0] + v[2] * v[2]);
        result[1] = Math.atan2( v[0], v[2] );
        result[2] = v[1];

        return result;
    };

    /** cylindrical coordinate (r, theta, h) to cartesian coordinate (x,y,z)
     * x - left, y - up, z - in (right hand)
     * x = r * sin(theta)
     * y = h
     * z = r * cos(theta)
     */
    HumanMath.cylindricalToCartesian = function (v, dest) {
        var result = dest || vec3.create();

        result[0] = v[0] * Math.sin(v[1]);
        result[1] = v[2];
        result[2] = v[0] * Math.cos(v[1]);

        return result;
    };

    /** @private
     *
     * @param min
     * @param max
     */
    HumanMath.AxisBox3 = function(min, max) {
        this.verts = [
            [min[0], min[1], min[2]],
            [max[0], min[1], min[2]],
            [max[0], max[1], min[2]],
            [min[0], max[1], min[2]],

            [min[0], min[1], max[2]],
            [max[0], min[1], max[2]],
            [max[0], max[1], max[2]],
            [min[0], max[1], max[2]]
        ];
    };

    /**
     * Note: Assume 0 <= t <= 1
     */
    HumanMath.easeOut = function (t, b, c) {
        var ts = t * t;
        var tc = ts * t;
        return b + c * (-1 * ts * ts + 4 * tc + -6 * ts + 4 * t);
    };

    /**
     * Note: Assume 0 <= t <= 1
     */
    HumanMath.easeIn = function (t, b, c) {
        return 1 - HumanMath.easeOut(1 - t, b, c);
    };

    /**
     * Note: Assume 0 <= t <= 1
     */
    HumanMath.easeInOut = function (t, b, c) {
        if (t < 0.5) {
            return HumanMath.easeIn(2 * t, b, c) / 2;
        } else {
            return HumanMath.easeOut(2 * t - 1, b, c) * 0.5 + 0.5;
        }
    };

    /**
     *
     */
    HumanMath.getBoundaryCenter = function(boundary, dest) {
        var r = dest || vec3.create();

        r[0] = (boundary.xmax + boundary.xmin ) * 0.5;
        r[1] = (boundary.ymax + boundary.ymin ) * 0.5;
        r[2] = (boundary.zmax + boundary.zmin ) * 0.5;

        return r;
    };
    /**
     *
     */
    var diag = vec3.create();
    HumanMath.getBoundaryDiag = function(boundary) {

        diag[0] = boundary.xmax - boundary.xmin;
        diag[1] = boundary.ymax - boundary.ymin;
        diag[2] = boundary.zmax - boundary.zmin;

        return vec3.length(diag);
    };

    var scaleMat = mat4.create();
    var rotateZMat = mat4.create();
    var rotateYMat = mat4.create();
    var rotateXMat = mat4.create();
    var result = mat4.create();

    HumanMath.buildRotationScaleMat3 = function(out, rotate, scale) {
        rotate = rotate || this.VEC3_ZEROS;
        scale = scale || this.VEC3_ONES;

        mat4.fromScaling(scaleMat, scale);
        mat4.fromZRotation(rotateZMat, rotate[2] * this.TO_RADIANS);
        mat4.fromYRotation(rotateYMat, rotate[1] * this.TO_RADIANS);
        mat4.fromXRotation(rotateXMat, rotate[0] * this.TO_RADIANS);


        mat4.multiply(result, rotateXMat, scaleMat);
        mat4.multiply(result, rotateYMat, result);
        mat4.multiply(result, rotateZMat, result);

        return mat3.fromMat4(out, result);
    };

})();
;/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/
(function() {
  "use strict";

    // math-inlining.
  var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // a zero coordinate, which is surprisingly useful
      ZERO = {x:0,y:0,z:0};


  // Bezier utils 
  var bezierUtils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.0640568928626056260850430826247450385909,
      0.0640568928626056260850430826247450385909,
      -0.1911188674736163091586398207570696318404,
      0.1911188674736163091586398207570696318404,
      -0.3150426796961633743867932913198102407864,
      0.3150426796961633743867932913198102407864,
      -0.4337935076260451384870842319133497124524,
      0.4337935076260451384870842319133497124524,
      -0.5454214713888395356583756172183723700107,
      0.5454214713888395356583756172183723700107,
      -0.6480936519369755692524957869107476266696,
      0.6480936519369755692524957869107476266696,
      -0.7401241915785543642438281030999784255232,
      0.7401241915785543642438281030999784255232,
      -0.8200019859739029219539498726697452080761,
      0.8200019859739029219539498726697452080761,
      -0.8864155270044010342131543419821967550873,
      0.8864155270044010342131543419821967550873,
      -0.9382745520027327585236490017087214496548,
      0.9382745520027327585236490017087214496548,
      -0.9747285559713094981983919930081690617411,
      0.9747285559713094981983919930081690617411,
      -0.9951872199970213601799974097007368118745,
      0.9951872199970213601799974097007368118745
    ],

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.1279381953467521569740561652246953718517,
      0.1279381953467521569740561652246953718517,
      0.1258374563468282961213753825111836887264,
      0.1258374563468282961213753825111836887264,
      0.1216704729278033912044631534762624256070,
      0.1216704729278033912044631534762624256070,
      0.1155056680537256013533444839067835598622,
      0.1155056680537256013533444839067835598622,
      0.1074442701159656347825773424466062227946,
      0.1074442701159656347825773424466062227946,
      0.0976186521041138882698806644642471544279,
      0.0976186521041138882698806644642471544279,
      0.0861901615319532759171852029837426671850,
      0.0861901615319532759171852029837426671850,
      0.0733464814110803057340336152531165181193,
      0.0733464814110803057340336152531165181193,
      0.0592985849154367807463677585001085845412,
      0.0592985849154367807463677585001085845412,
      0.0442774388174198061686027482113382288593,
      0.0442774388174198061686027482113382288593,
      0.0285313886289336631813078159518782864491,
      0.0285313886289336631813078159518782864491,
      0.0123412297999871995468056670700372915759,
      0.0123412297999871995468056670700372915759
    ],

    arcfn: function(t, derivativeFn) {
      var d = derivativeFn(t);
      var l = d.x*d.x + d.y*d.y;
      if(typeof d.z !== "undefined") {
        l += d.z*d.z;
      }
      return sqrt(l);
    },

    length: function(derivativeFn) {
      var z=0.5,sum=0,len=bezierUtils.Tvalues.length,i,t;
      for(i=0; i<len; i++) {
        t = z * bezierUtils.Tvalues[i] + z;
        sum += bezierUtils.Cvalues[i] * bezierUtils.arcfn(t,derivativeFn);
      }
      return z * sum;
    },

    map: function(v, ds,de, ts,te) {
      var d1 = de-ds, d2 = te-ts, v2 =  v-ds, r = v2/d1;
      return ts + d2*r;
    },

    lerp: function(r, v1, v2) {
      var ret = {
        x: v1.x + r*(v2.x-v1.x),
        y: v1.y + r*(v2.y-v1.y)
      };
      if(!!v1.z && !!v2.z) {
        ret.z =  v1.z + r*(v2.z-v1.z);
      }
      return ret;
    },

    pointToString: function(p) {
      var s = p.x+"/"+p.y;
      if(typeof p.z !== "undefined") {
        s += "/"+p.z;
      }
      return s;
    },

    pointsToString: function(points) {
      return "[" + points.map(bezierUtils.pointToString).join(", ") + "]";
    },

    angle: function(o,v1,v2) {
      var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1*dy2 - dy1*dx2,
          m1 = sqrt(dx1*dx1+dy1*dy1),
          m2 = sqrt(dx2*dx2+dy2*dy2),
          dot;
      dx1/=m1; dy1/=m1; dx2/=m2; dy2/=m2;
      dot = dx1*dx2 + dy1*dy2;
      return atan2(cross, dot);
    },

    dist: function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return sqrt(dx*dx+dy*dy);
    },

    abcratio: function(t, n) {
      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var bottom = pow(t,n) + pow(1-t,n), top = bottom - 1;
      return abs(top/bottom);
    },

    projectionratio: function(t, n) {
      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var top = pow(1-t, n), bottom = pow(t,n) + top;
      return top/bottom;
    },

    align: function(points, line) {
      var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y-ty, line.p2.x-tx),
          d = function(v) {
            return {
              x: (v.x-tx)*cos(a) - (v.y-ty)*sin(a),
              y: (v.x-tx)*sin(a) + (v.y-ty)*cos(a)
            };
          };
      return points.map(d);
    }

  };
  
  //--------------------------------------


  /**
   * Bezier curve constructor. The constructor argument can be one of three things:
   *
   * 1. array/4 of {x:..., y:..., z:...}, z optional
   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
   *
   */
  var Bezier = Human.math.bezier = function(coords) {
    var args = (coords && coords.forEach) ? coords : [].slice.call(arguments);
    var coordlen = false;
    if(typeof args[0] === "object") {
      coordlen = args.length;
      var newargs = [];
      args.forEach(function(point) {
        ['x','y','z'].forEach(function(d) {
          if(typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }
    var higher = false;
    var len = args.length;
    if (coordlen) {
      if(coordlen>4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if(len!==6 && len!==8 && len!==9 && len!==12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    var _3d = (!higher && (len === 9 || len === 12)) || (coords && coords[0] && typeof coords[0].z !== "undefined");
    this._3d = _3d;
    var points = [];
    for(var idx=0, step=(_3d ? 3 : 2); idx<len; idx+=step) {
      var point = {
        x: args[idx],
        y: args[idx+1]
      };
      if(_3d) { point.z = args[idx+2]; }
      points.push(point);
    }
    this.order = points.length - 1;
    this.points = points;
    var dims = ['x','y'];
    if(_3d) {dims.push('z');}
    this.dims = dims;
    this.dimlen = dims.length;
    (function(curve) {
      var a = bezierUtils.align(points, {p1:points[0], p2:points[curve.order]});
      for(var i=0; i<a.length; i++) {
        if(abs(a[i].y) > 0.0001) {
          curve._linear = false;
          return;
        }
      }
      curve._linear = true;
    }(this));
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  };

  function getABC(n,S,B,E,t) {
    if(typeof t === "undefined") { t = 0.5; }
    var u = bezierUtils.projectionratio(t,n),
        um = 1-u,
        C = {
          x: u*S.x + um*E.x,
          y: u*S.y + um*E.y
        },
        s = bezierUtils.abcratio(t,n),
        A = {
          x: B.x + (B.x-C.x)/s,
          y: B.y + (B.y-C.y)/s
        };
    return { A:A, B:B, C:C };
  }

  Bezier.quadraticFromPoints = function(p1,p2,p3, t) {
    if(typeof t === "undefined") { t = 0.5; }
    // shortcuts, although they're really dumb
    if(t===0) { return new Bezier(p2,p2,p3); }
    if(t===1) { return new Bezier(p1,p2,p2); }
    // real fitting.
    var abc = getABC(2,p1,p2,p3,t);
    return new Bezier(p1, abc.A, p3);
  };

  Bezier.cubicFromPoints = function(S,B,E, t,d1) {
    if(typeof t === "undefined") { t = 0.5; }
    var abc = getABC(3,S,B,E,t);
    if(typeof d1 === "undefined") { d1 = bezierUtils.dist(B,abc.C); }
    var d2 = d1 * (1-t)/t;

    var selen = bezierUtils.dist(S,E),
        lx = (E.x-S.x)/selen,
        ly = (E.y-S.y)/selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
    // derivation of new hull coordinates
    var e1  = { x: B.x - bx1, y: B.y - by1 },
        e2  = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1  = { x: A.x + (e1.x-A.x)/(1-t), y: A.y + (e1.y-A.y)/(1-t) },
        v2  = { x: A.x + (e2.x-A.x)/(t), y: A.y + (e2.y-A.y)/(t) },
        nc1 = { x: S.x + (v1.x-S.x)/(t), y: S.y + (v1.y-S.y)/(t) },
        nc2 = { x: E.x + (v2.x-E.x)/(1-t), y: E.y + (v2.y-E.y)/(1-t) };
    // ...done
    return new Bezier(S,nc1,nc2,E);
  };


  Bezier.prototype = {
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return bezierUtils.pointsToString(this.points);
    },
    update: function() {
      // one-time compute derivative coordinates
      this.dpoints = [];
      for(var p=this.points, d=p.length, c=d-1; d>1; d--, c--) {
        var list = [];
        for(var j=0, dpt; j<c; j++) {
          dpt = {
            x: c * (p[j+1].x - p[j].x),
            y: c * (p[j+1].y - p[j].y)
          };
          if(this._3d) {
            dpt.z = c * (p[j+1].z - p[j].z);
          }
          list.push(dpt);
        }
        this.dpoints.push(list);
        p = list;
      }
      this.computedirection();
    },
    computedirection: function() {
      var points = this.points;
      var angle = bezierUtils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    },
    length: function() {
      return bezierUtils.length(this.derivative.bind(this));
    },
    _lut: [],
    getLUT: function(steps) {
      steps = steps || 100;
      if (this._lut.length === steps) { return this._lut; }
      this._lut = [];
      for(var t=0; t<=steps; t++) {
        this._lut.push(this.compute(t/steps));
      }
      return this._lut;
    },
    on: function(point, error) {
      error = error || 5;
      var lut = this.getLUT(), hits = [], c, t=0;
      for(var i=0; i<lut.length; i++) {
        c = lut[i];
        if (bezierUtils.dist(c,point) < error) {
          hits.push(c);
          t += i / lut.length;
        }
      }
      if(!hits.length) {return false;}
      return t /= hits.length;
    },
    get: function(t) {
      return this.compute(t);
    },
    point: function(idx) {
      return this.points[idx];
    },
    compute: function(t) {
      // shortcuts
      if(t===0) { return this.points[0]; }
      if(t===1) { return this.points[this.order]; }

      var p = this.points;
      var mt = 1-t;
      var ret;

      // linear?
      if(this.order===1) {
        ret = {
          x: mt*p[0].x + t*p[1].x,
          y: mt*p[0].y + t*p[1].y
        };
        if (this._3d) { ret.z = mt*p[0].z + t*p[1].z; }
        return ret;
      }

      // quadratic/cubic curve?
      if(this.order<4) {
        var mt2 = mt*mt,
            t2 = t*t,
            a,b,c,d = 0;
        if(this.order===2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt*t*2;
          c = t2;
        }
        else if(this.order===3) {
          a = mt2*mt;
          b = mt2*t*3;
          c = mt*t2*3;
          d = t*t2;
        }
        ret = {
          x: a*p[0].x + b*p[1].x + c*p[2].x + d*p[3].x,
          y: a*p[0].y + b*p[1].y + c*p[2].y + d*p[3].y
        };
        if(this._3d) {
          ret.z = a*p[0].z + b*p[1].z + c*p[2].z + d*p[3].z;
        }
        return ret;
      }

      // higher order curves: use de Casteljau's computation
      var dCpts = JSON.parse(JSON.stringify(this.points));
      while(dCpts.length > 1) {
        for (var i=0; i<dCpts.length-1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i+1].x - dCpts[i].x) * t,
            y: dCpts[i].y + (dCpts[i+1].y - dCpts[i].y) * t
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i+1].z - dCpts[i].z) * t;
          }
        }
        dCpts.splice(dCpts.length-1, 1);
      }
      return dCpts[0];
    },
    derivative: function(t) {
      var mt = 1-t,
          a,b,c=0,
          p = this.dpoints[0];
      if(this.order===2) { p = [p[0], p[1], ZERO]; a = mt; b = t; }
      if(this.order===3) { a = mt*mt; b = mt*t*2; c = t*t; }
      var ret = {
        x: a*p[0].x + b*p[1].x + c*p[2].x,
        y: a*p[0].y + b*p[1].y + c*p[2].y
      };
      if(this._3d) {
        ret.z = a*p[0].z + b*p[1].z + c*p[2].z;
      }
      return ret;
    }
  };

}());
;(function() {
    "use strict";

    var Intersections = Human.math.intersections = {};

    var EPSILON = 1e-8;

    var tempVec3a = vec3.create();
    var tempVec3b = vec3.create();

    // NOTE(Tarek): 5 different rays tests
    // to account for potential numerical errors
    var POINT_POLYHEDRON_RAY_DIRS = [
        new Float32Array([1, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([-1, 0, 0]),
        new Float32Array([0, -1, 0])
    ];

    // Test weather point p is in bounding box defined
    // by min/max
    Intersections.pointAabb = function(p, min, max) {
        if (p[0] < min[0]) {
            return false;
        }

        if (p[0] > max[0]) {
            return false;
        }

        if (p[1] < min[1]) {
            return false;
        }

        if (p[1] > max[1]) {
            return false;
        }

        if (p[2] < min[2]) {
            return false;
        }

        if (p[2] > max[2]) {
            return false;
        }

        return true;
    };

    // Test whether bounding box defined by minA/maxA intersects
    // the one defined by minB/maxB
    Intersections.aabbAabb = function(minA, maxA, minB, maxB) {
        if (maxA[0] < minB[0]) {
            return false;
        }

        if (maxB[0] < minA[0]) {
            return false;
        }

        if (maxA[1] < minB[1]) {
            return false;
        }

        if (maxB[1] < minA[1]) {
            return false;
        }

        if (maxA[2] < minB[2]) {
            return false;
        }

        if (maxB[2] < minA[2]) {
            return false;
        }

        return true;
    };

    // Test whether ray defined by origin/direct intersects
    // the AABB defined by min/max.
    // If an array of two elements is provided in result, result[0] will
    // be set to tmin (where origin + tmin * direction is the near
    // intersection point with the AABB), and result[1] will be set
    // to tmax (where origin + tmax * direction is the far
    // intersection point with the AABB).
    Intersections.rayAabb = function(origin, direction, min, max, result) {
        var tmin = 0;
        var tmax = Number.POSITIVE_INFINITY;

        var fabs = Math.abs;
        var fmin = Math.min;
        var fmax = Math.max;

        for (var i = 0; i < 3; ++i) {
            if (fabs(direction[i]) < EPSILON) {
                if (origin[i] < min[i] || origin[i] > max[i]) {
                    return false;
                }
            } else {
                var t1 = (min[i] - origin[i]) / direction[i];
                var t2 = (max[i] - origin[i]) / direction[i];

                if (t1 > t2) {
                    var tmp = t1;
                    t1 = t2;
                    t2 = tmp;
                }

                tmin = fmax(tmin, t1);
                tmax = fmin(tmax, t2);

                if (tmin > tmax) {
                    return false;
                }
            }
        }

        if (result) {
            result[0] = tmin;
            result[1] = tmax;
        }

        return true;
    };


    // Test if the ray defined by origin/direction intersects the triangle
    // defined by v1/v2/v3. If an object is provided in results, the following
    // properties will be set:
    // - u, v, w: the barycentric coords of the intersection point
    // - t: origin + t * direction is the point of intersection

    var e1 = new Float32Array(3);
    var e2 = new Float32Array(3);
    var s = new Float32Array(3);
    var p = new Float32Array(3);
    var q = new Float32Array(3);

    // From: http://dl.acm.org/citation.cfm?id=272315
    Intersections.rayTriangle = function(origin, direction, v1, v2, v3, result) {

        vec3.sub(e1, v2, v1);
        vec3.sub(e2, v3, v1);
        vec3.cross(p, direction, e2);

        var det = vec3.dot(p, e1);

        if (det > -EPSILON && det < EPSILON) {
            return false;
        }

        var invDet = 1 / det;
        vec3.sub(s, origin, v1);
        var u = invDet * vec3.dot(p, s);

        if (u < 0 || u > 1) {
            return false;
        }

        vec3.cross(q, s, e1);
        var v = invDet * vec3.dot(q, direction);

        if (v < 0 || u + v > 1) {
            return false;
        }

        var t = invDet * vec3.dot(q, e2);

        if (t < EPSILON) {
            return false;
        }

        if (result && t < result.t) {
            result.u = u;
            result.v = v;
            result.w = 1 - u - v;
            result.t = t;
        }

        return true;

    };

    // Basic idea: cast a ray from the point of interest outward and
    // count the number of intersections with the mesh. If it's an odd
    // number, the point was inside the mesh, even number means it was
    // outside. Five different rays are cast to account for potential
    // numerical errors. A kdTree is used speed up queries. KdTree node
    // format:
    //   {
    //       triangles: [NUMBER, NUMBER, ...],    // Indices of triangles in this leaf node (null if not leaf node)
    //       left: kdTreeNode,                    // Left subtree (null if leaf node)
    //       right: kdTreeNode,                   // Right subtree (null if leaf node)
    //       bb: {                                // Bounding box of triangles in this node and its subtrees.
    //           min: VEC3,
    //           max: VEC3
    //       }
    //   }
    //
    Intersections.pointPolyhedron = function(p, geometry) {
        var inside = 0;
        var outside = 0;

        var drawable = geometry.getObject();

        if (!drawable) {
            return false;
        }

        for (var i = 0, len = POINT_POLYHEDRON_RAY_DIRS.length; i < len; ++i) {
            if (rayKdTreeCountIntersections(
                    p,
                    POINT_POLYHEDRON_RAY_DIRS[i],
                    drawable.getKdTree(),
                    drawable
                ) % 2 === 1) {
                ++inside;
            } else {
                ++outside;
            }
        }

        return inside > outside;
    };

    // Check if the ray defined by origin/direction intersects the polyhedron
    // defined by the SceneJS geometry node, geometry. If an intersect is found,
    // the following data is provided in the returned result object:
    // - u, v, w: the barycentric coords of the intersection point
    // - t: origin + t * direction is the point of intersection
    // - triangleIndex: the index of the triangle in the mesh description
    Intersections.rayPolyhedron = function(origin, direction, geometry, result) {
        var drawable = geometry.getObject();

        if (!drawable) {
            return null;
        }

        result = result || {
            t: Number.POSITIVE_INFINITY,
            u: 0,
            v: 0,
            w: 0,
            triangleIndex: -1
        };

        if (rayKdTreeCountIntersections(
              origin,
              direction,
              drawable.getKdTree(),
              drawable,
              result
            ) > 0) {
            return result;
        } else {
            return null;
        }
    };


    // Test which side of a plane the plane defined by normal n and distance d
    // the AABB defined by min/max is on.
    // 1: completely inside, -1: completely outside, 0: intersect
    Intersections.planeAabb = function(n, d, min, max) {
        
        var negx = max[0];
        var negy = max[1];
        var negz = max[2];

        if (n[0] >= 0) {
            negx = min[0];
        }

        if (n[1] >= 0) {
            negy = min[1];
        }

        if (n[2] >= 0) {
            negz = min[2];
        }

        if (negx * n[0] + negy * n[1] + negz * n[2] + d > 0) {
            return -1;
        }

        var posx = min[0];
        var posy = min[1];
        var posz = min[2];

        if (n[0] >= 0) {
            posx = max[0];
        }

        if (n[1] >= 0) {
            posy = max[1];
        }

        if (n[2] >= 0) {
            posz = max[2];
        }

        if (posx * n[0] + posy * n[1] + posz * n[2] + d > 0) {
            return 0;
        }

        return 1;

    };

    Intersections.planesAabb = function(planes, min, max, details) {
        var result = 1; // Inside
        var numPlanes = planes.length;

        for (var i = 0; i < numPlanes; ++i) {
            var plane = planes[i];
            var test = this.planeAabb(plane.n, plane.d, min, max);

            if (details) {
                details[i] = test;
            }

            if (test < 1) {
                result = test;
            }

            if (result === -1) {
                break;
            }
        }

        if (details && i < numPlanes) {
            // NOTE(Tarek): details might be reused so
            //   clear out any previous results.
            for (var j = 5; j > i; --j) {
                details[j] = undefined;
            }
        }

        return result;
    };

    // Test if a point is inside a Human object
    // First test point against object AABB.
    // If that passes, perform full point-in-polyhedron
    // test against object's kd-tree

    var toModel = mat4.create();
    var toModel3x3 = mat3.create();
    var modelPoint = vec3.create();
    var modelOrigin = vec3.create();
    var modelDirection = vec3.create();
    var boundaryMin = vec3.create();
    var boundaryMax = vec3.create();

    Intersections.pointObject = function(p, objectId) {
        var object = Human.scene.objects[objectId];

        var boundary = object.getBoundary();
        boundaryMin[0] = boundary.xmin;
        boundaryMin[1] = boundary.ymin;
        boundaryMin[2] = boundary.zmin;

        boundaryMax[0] = boundary.xmax;
        boundaryMax[1] = boundary.ymax;
        boundaryMax[2] = boundary.zmax;

        if (!this.pointAabb(p, boundaryMin, boundaryMax)) {
            return false;
        }

        mat4.invert(toModel, object.getWorldMatrix());
        vec3.transformMat4(modelPoint, p, toModel);

        for (var i = 0, len = object.renderables.length; i < len; ++i) {
            var renderable = object.renderables[i];
            boundary = renderable.boundary;
            boundaryMin[0] = boundary.xmin;
            boundaryMin[1] = boundary.ymin;
            boundaryMin[2] = boundary.zmin;

            boundaryMax[0] = boundary.xmax;
            boundaryMax[1] = boundary.ymax;
            boundaryMax[2] = boundary.zmax;

            if (!this.pointAabb(modelPoint, boundaryMin, boundaryMax)) {
                continue;
            }

            var geometry = renderable.geometryNode;

            if (!geometry) {
                continue;
            }

            if (this.pointPolyhedron(modelPoint, geometry)) {
                return true;
            }
        }

        return false;
    };

    // Test ray defined by origin/direction against an
    // object's AABB. If result is provide, it will
    // include the same data as rayAabb
    Intersections.rayObjectAabb = function(origin, direction, objectId, result) {
        var object = Human.scene.objects[objectId];

        var boundary = object.getBoundary();
        boundaryMin[0] = boundary.xmin;
        boundaryMin[1] = boundary.ymin;
        boundaryMin[2] = boundary.zmin;

        boundaryMax[0] = boundary.xmax;
        boundaryMax[1] = boundary.ymax;
        boundaryMax[2] = boundary.zmax;

        return this.rayAabb(origin, direction, boundaryMin, boundaryMax, result);
    };

    // Test if the ray defined by origin/direction intersects a Human object
    // First test against object AABB.
    // If that passes, perform full ray-polyhedron
    // test against object's kd-tree
    Intersections.rayObject = function(origin, direction, objectId, result, renderableTest) {
        var object = Human.scene.objects[objectId];

        if (!this.rayObjectAabb(origin, direction, objectId)) {
            return null;
        }

        mat4.invert(toModel, object.getWorldMatrix());
        vec3.transformMat4(modelOrigin, origin, toModel);

        mat3.fromMat4(toModel3x3, toModel);
        vec3.transformMat3(modelDirection, direction, toModel3x3);

        for (var i = 0, len = object.renderables.length; i < len; ++i) {
            var renderable = object.renderables[i];
            if (renderableTest && !renderableTest(renderable)) {
                continue;
            }
            var boundary = renderable.boundary;
            boundaryMin[0] = boundary.xmin;
            boundaryMin[1] = boundary.ymin;
            boundaryMin[2] = boundary.zmin;

            boundaryMax[0] = boundary.xmax;
            boundaryMax[1] = boundary.ymax;
            boundaryMax[2] = boundary.zmax;

            if (!this.rayAabb(modelOrigin, modelDirection, boundaryMin, boundaryMax)) {
                continue;
            }

            var geometry = renderable.geometryNode;

            if (!geometry) {
                continue;
            }

            var hit = this.rayPolyhedron(modelOrigin, modelDirection, geometry, result);

            if (hit) {
                return hit;
            }
        }

        

        return null;
    };

    // Test if the ray defined by origin/direction interesects any object AABBs
    // in the scene. Returns an array of intersection results, which include
    // tmin, tmax, and the object, sorted by tmin.
    // The function objectTest will be called on each object
    // traversed to filter them out of the traversal (if objectTest returns false
    // the object will be excluded from consideration)
    Intersections.raySceneAabb = function(origin, direction, objectTest) {
        var results = [];

        raySceneKdTreeNode(origin, direction, Human.scene.getKdTree(), objectTest, results);

        if (results.length > 0) {
            results.sort(rayAabbResultSort);
            return results;
        } else {
            return null;
        }

    };

    // Test if the ray defined by origin/direction interesects any objects
    // in the scene. Returns an array of intersection results, which include
    // the following data:
    // - u, v, w: the barycentric coords of the intersection point
    // - t: origin + t * direction is the point of intersection
    // - triangleIndex: the index of the triangle in the object's mesh description
    // - objectId: the object's objectId
    // Results are sorted by tmin.
    // The function objectTest will be called on each object
    // traversed to filter them out of the traversal (if objectTest returns false
    // the object will be excluded from consideration)
    Intersections.rayScene = function(origin, direction, objectTest, renderableTest) {
        var results = [];

        var aabbResults = this.raySceneAabb(origin, direction, objectTest);

        if (aabbResults) {
            for (var i = 0, len = aabbResults.length; i < len; ++i) {
                var objectId = aabbResults[i].object.objectId;

                var result = {
                    t: Number.POSITIVE_INFINITY,
                    u: 0,
                    v: 0,
                    w: 0,
                    triangleIndex: -1,
                    objectId: objectId
                };

                if (this.rayObject(origin, direction, objectId, result, renderableTest)) {
                    results.push(result);
                }
            }
        }

        if (results.length > 0) {
            results.sort(rayIntersectResultSort);
            return results;
        } else {
            return null;
        }

    };
    
    Intersections.spherePolyhedron = function(geometry, center, radius) {
        var min = tempVec3a;
        var max = tempVec3b;

        min[0] = center[0] - radius;
        min[1] = center[1] - radius;
        min[2] = center[2] - radius;

        max[0] = center[0] + radius;
        max[1] = center[1] + radius;
        max[2] = center[2] + radius;
        //sphere should be object space
        return shapePolyhedron(geometry, 
            function(kdTreeNode) {
                return Intersections.aabbAabb(kdTreeNode.bb.min, kdTreeNode.bb.max, min, max);
            },
            function(v1, v2, v3) {
                return triangleSphere(v1, v2, v3, center, radius);
            }
        );
    };

    Intersections.sphereInPolyhedron = function(geometry, center, radius) {
        //sphere should be object space
        var min = tempVec3a;
        var max = tempVec3b;

        min[0] = center[0] - radius;
        min[1] = center[1] - radius;
        min[2] = center[2] - radius;

        max[0] = center[0] + radius;
        max[1] = center[1] + radius;
        max[2] = center[2] + radius;
        //sphere should be object space
        return shapePolyhedron(geometry,
            function(kdTreeNode) {
                return Intersections.aabbAabb(kdTreeNode.bb.min, kdTreeNode.bb.max, min, max);
            },
            function(v1, v2, v3) {
                return triangleInSphere(v1, v2, v3, center, radius);
            }
        );
    };

    // Traverse a mesh kdTree and count the number of intersections.
    function rayKdTreeCountIntersections(origin, direction, kdTreeNode, drawable, result) {
        if (!Intersections.rayAabb(origin, direction, kdTreeNode.bb.min, kdTreeNode.bb.max)) {
            return 0;
        }

        if (kdTreeNode.triangles) {
            var triangles = kdTreeNode.triangles;
            var intersections = 0;
            for (var t = 0, len = triangles.length; t < len; ++t) {
                // Get the three vertices of the triangle
                drawable.getTrianglePositionOnSurface(triangles[t] * 3, v1, v2, v3);

                // Perform triangle intersection test.
                if (Intersections.rayTriangle(origin, direction, v1, v2, v3, result)) {
                    if (result) {
                        result.triangleIndex = triangles[t];
                    }
                    ++intersections;
                }

            }

            return intersections;
        } else {
            return rayKdTreeCountIntersections(origin, direction, kdTreeNode.left, drawable, result) +
                rayKdTreeCountIntersections(origin, direction, kdTreeNode.right, drawable, result);
        }
    }

    // Traverse scene kdTree and check for intersections with object AABBs
    var rayAabbResult = new Float32Array(2);

    function raySceneKdTreeNode(origin, direction, kdTreeNode, objectTest, results) {

        if (!kdTreeNode.left) {

            var objects = kdTreeNode.objects;

            for (var i = 0, len = objects.length; i < len; ++i) {
                var object = objects[i];
                var objectId = object.objectId;

                if (objectTest && !objectTest(object)) {
                    continue;
                }

                if (Intersections.rayObjectAabb(origin, direction, objectId, rayAabbResult)) {
                    results.push({
                        object: object,
                        tmin: rayAabbResult[0],
                        tmax: rayAabbResult[1]
                    });
                }
            }

            return results;
        }

        if (!Intersections.rayAabb(origin, direction, kdTreeNode.bb.min, kdTreeNode.bb.max)) {
            return results;
        }

        raySceneKdTreeNode(origin, direction, kdTreeNode.left, objectTest, results);
        raySceneKdTreeNode(origin, direction, kdTreeNode.right, objectTest, results);

        return results;
    }

    function rayIntersectResultSort(a, b) {
        return a.t - b.t;
    }

    function rayAabbResultSort(a, b) {
        return a.tmin - b.tmin;
    }

    var v1 = new Float32Array(3);
    var v2 = new Float32Array(3);
    var v3 = new Float32Array(3);
    var nodesToIntersect = [];
    

    // Takes geometry node and tests against arbitrary shape defined by two test functions
    // returns list of triangle indices that intersect the shape.
    // coarseTest: function (kdTreeNode)
    // fineTest: function (v1, v2, v2) 
    function shapePolyhedron (geometry, coarseTest, fineTest) {
        
        var triangleList = [];
        var drawable = geometry.getObject();

        if (!drawable) {
            return triangleList;
        }

        nodesToIntersect.length = 0;
        nodesToIntersect.push(drawable.getKdTree());
        
        while (nodesToIntersect.length > 0) {
            var node = nodesToIntersect.pop();
            if(!coarseTest(node)){
                continue;
            }
            if(node.left) {
                nodesToIntersect.push(node.left);
            }
            if(node.right) {
                nodesToIntersect.push(node.right);
            }
            if(node.triangles) {
                for (var t = 0, len = node.triangles.length; t < len; ++t) {
                    drawable.getTrianglePositionOnSurface(node.triangles[t] * 3, v1, v2, v3);
                    if(fineTest(v1, v2, v3)){
                        triangleList.push(node.triangles[t]);
                    }
                }
            }
        }

        return triangleList;
    }

    var ac = new Float32Array(3);
    var ab = new Float32Array(3);
    var abXac = new Float32Array(3);
    var toCircumsphereCenter = new Float32Array(3);
    var tempa = new Float32Array(3);
    var tempb = new Float32Array(3);
    var ccs = new Float32Array(3);
    var sub = new Float32Array(3);

    function triangleSphere(v1, v2, v3, center, radius) {

        //http://realtimecollisiondetection.net/blog/?p=103
        //https://gamedev.stackexchange.com/questions/60630/how-do-i-find-the-circumcenter-of-a-triangle-in-3d

        vec3.subtract(ac, v3, v1);
        vec3.subtract(ab, v2, v1);
        vec3.cross(abXac, ab, ac);
        
        // this is the vector from a TO the circumsphere center
        // Vector3f toCircumsphereCenter = (abXac.cross( ab )*ac.len2() + ac.cross( abXac )*ab.len2()) / (2.f*abXac.len2()) ;

        vec3.cross(tempa, abXac, ab);
        var aclen2 = vec3.length(ac);
        aclen2 *= aclen2;
        vec3.scale(tempa, tempa, aclen2);

        vec3.cross(tempb, ac, abXac);
        var ablen2 = vec3.length(ab);
        ablen2 *= ablen2;
        vec3.scale(tempb, tempb, ablen2);

        vec3.add(tempa, tempa, tempb);

        var abXaclen2 = vec3.length(abXac);
        abXaclen2 *= abXaclen2;
        vec3.scale(toCircumsphereCenter, tempa, 1.0 / (2.0 * abXaclen2));

        var circumsphereRadius = vec3.length(toCircumsphereCenter) ;
        
        // The 3 space coords of the circumsphere center then:
        vec3.add(ccs, v1, toCircumsphereCenter);

        vec3.subtract(sub, center, ccs);
        var dist = vec3.length(sub);
        if(dist <= circumsphereRadius + radius) {
            return true;
        }

        return false;
    }

    function triangleInSphere(v1, v2, v3, center, radius) {
        var r2 = radius * radius;
        var dx = v1[0] - center[0];
        var dy = v1[1] - center[1];
        var dz = v1[2] - center[2];
        var d2 = dx * dx + dy * dy + dz * dz;
        if (d2 > r2) {
            return false;
        }
        dx = v2[0] - center[0];
        dy = v2[1] - center[1];
        dz = v2[2] - center[2];
        d2 = dx * dx + dy * dy + dz * dz;
        if (d2 > r2) {
            return false;
        }
        dx = v3[0] - center[0];
        dy = v3[1] - center[1];
        dz = v3[2] - center[2];
        d2 = dx * dx + dy * dy + dz * dz;
        if (d2 > r2) {
            return false;
        }
        return true;
    }

})();;/** @namespace
 * @private
 */

(function() {
    "use strict";

    Human.utils = Human.utils || {};

    var hexMap = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];

    var PVR_MAGIC_NUMBER = 1347834371;

    Human.utils.leftPad = function (value, padding, width) { 
        while (value.length < width) {
            value = padding + value;
        }

        return value;
    };

    Human.utils.toHexString = function (value) {
        var out = "";
        while (value > 0) {
            out = hexMap[value & 0xF] + out;
            value >>= 4;
        }

        return out;
    };

    Human.utils.floatRGBToHexString = function (r, g, b) {
        var rHex = this.leftPad(this.toHexString(Math.floor(r * 255)), "0", 2); 
        var gHex = this.leftPad(this.toHexString(Math.floor(g * 255)), "0", 2);
        var bHex = this.leftPad(this.toHexString(Math.floor(b * 255)), "0", 2);
        
        return "#" + rHex + gHex + bHex;
    };

    /**
     * Tests if the given object is an array (including typed arrays)
     */
    Human.utils.isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length')) &&
                typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     * Tests if the given object is a simple object
     */
    Human.utils.isObject = function (testObject) {
        return !!testObject && Object.prototype.toString.call(testObject) === "[object Object]";
    };

    /**
     * Tests if the argument is of a primitive type
     */
    Human.utils.isPrimitive = function (value) {
        return  value === null || !!(typeof value).match(/^(string|number|boolean|undefined)$/);
    };

    /* Tests if the given value is a string.
     */
    Human.utils.isString = function (value) {
        return (typeof value === "string" || value instanceof String);
    };

    /* Filters elements from an array in place.
     */
    Human.utils.filterInPlace = function filter(array, fn) {
        var skip = 0;

        for (var i = 0, len = array.length; i < len; i++) {
            if (!fn(array[i])) {
                skip++;
                continue;
            }
            array[i - skip] = array[i];
        }

        array.length = array.length - skip;

        return array;
    };

    /**
     * Return a string representing the current call stack
     */
    Human.utils.getStackTrace = function() {
        var error = new Error();
        var stack;
        if (error.stack) {
            stack = error.stack;
        } else {
            try {
                throw error;
            } catch (e) {
                stack = e.stack;
            }
        }

        return stack || null;
    };

    /**
     * @private
     * @param childObj
     * @param parentObj
     */
    Human.utils.extend = function (childObj, parentObj) {
        var TmpObj = function () {
        };
        TmpObj.prototype = parentObj.prototype;
        childObj.prototype = new TmpObj();
        childObj.prototype.constructor = childObj;
    };

    /** Add properties of o to o2, overwriting them on o2 if already there
     */
    Human.utils.apply = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2 where undefined or null on o2
     * @private
     */
    Human.utils.applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] === undefined || o2[name] === null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };

    Human.utils.applyIf2 = function (p, q) {
        p = p || {};
        var r = {};
        for (var key in q) {
            if (q.hasOwnProperty(key)) {
                r[key] = p[key] !== undefined ? p[key] : q[key];
            }
        }
        return r;
    };

    /** Returns shallow copy of object
     * @private
     */
    Human.utils.shallowClone = function (o) {
        var o2 = {};
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /** Returns deep clone of JSON-like ojbect
     */
    Human.utils.deepClone = function(o) {
        if (o === null || o === undefined || typeof(o) === "string" || typeof(o) === "number" || typeof(o) === "boolean") {
            return o;
        }

        var out;

        if (Array.isArray(o)) {
            out = new Array(o.length);
            for (var i = 0, len = o.length; i < len; ++i) {
                out[i] = Human.utils.deepClone(o[i]);
            }
            return out;
        }
        
        out = {};
        for (var key in o){
            out[key] = Human.utils.deepClone(o[key]);
        }

        return out;
    };

    /**
     * Returns true if given map has no items
     * @private
     */
    Human.utils.isEmpty = function (map) {
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Gets directory from given path
     * @private
     */
    Human.utils.getDir = function (path) {
        var i = path.lastIndexOf("/");
        return (i > -1) ? path.substring(0, i > 0 ? i + 1 : 0) : "";
    };

    /**
     * Run function asynchronously (i.e. wait for next exec context)
     * @private
     */
    Human.utils.async = function(fn) {
        setTimeout(fn, 0);
    };

    /**
     * Null function
     * @private
     */
    Human.utils.noop = function () {
    };

    /**
     * Gets keys on given map in array
     * @private
     */
    Human.utils.getKeys = function (map) {
        var keys = [];
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    /**
     * Returns new universally unique ID
     * @private
     */
    Human.utils.createUUID = function () {
        var data = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
        var data2 = ["8", "9", "A", "B"];
        var uuid = [];
        for (var i = 0; i < 38; i++) {
            switch (i) {
                case 8:
                    uuid.push("-");
                    break;
                case 13:
                    uuid.push("-");
                    break;
                case 18:
                    uuid.push("-");
                    break;
                case 14:
                    uuid.push("4");
                    break;
                case 19:
                    uuid.push(data2[Math.round(Math.random() * 3)]);
                    break;
                default:
                    uuid.push(data[Math.round(Math.random() * 15)]);
                    break;
            }
        }
        return uuid.join("");
    };

    /**
     * Look up interval in sorted array where value x resides.
     * Returns both left-index,left-value, right-index, right-value.
     * Out of Bounds cases:
     *   - if target < first item in sequence return [null,null,0,sequence[0]]
     *   - if target > last item in sequence return [end,sequence[end], null, null]
     *
     * @param lessThan(value, element) : function that returns true if value < element
     *    - value is of whatever type you pass to target.
     *    - element is the type of an element in the sequence.
     *
    */

    function defaultCompare(arrayElement, target){
        if (arrayElement < target){
            return -1;
        } else if (arrayElement > target){
            return 1;
        } else {
            return 0;
        }
    }

    Human.utils.binarySearch = function (array, target, compare, result){
        compare = compare || defaultCompare;
        result = result || {
            index1: null,
            index2: null,
            value1: null,
            value2: null
        };

        var lowIndex = 0;
        var highIndex = array.length - 1;
        var mid, value1, value2;

        // Boundary Cases
        if (compare(array[0], target) > 0) {
            result.index1 = null;
            result.value1 = null;
            result.index2 = 0;
            result.value2 = array[0];
            return result;
        } else if (compare(array[highIndex], target) < 0){
            result.index1 = highIndex;
            result.value1 = array[highIndex];
            result.index2 = null;
            result.value2 = null;
            return result;
        }

        // Do Bisection Search
        while (lowIndex <= highIndex){
            mid = Math.floor((lowIndex + highIndex) / 2);
            value1 = array[mid];
            value2 = array[mid + 1];

            if (compare(value1, target) <= 0 && compare(value2, target) >= 0){
                result.index1 = mid;
                result.index2 = mid + 1;
                result.value1 = value1;
                result.value2 = value2;
                return result;
            } else if (compare(value1, target) > 0) {
                highIndex = mid - 1;
            } else {
                lowIndex = mid + 1;
            }
        }
    };

    /**
     * Converts binary buffer to string
     * @private
     */
    Human.utils.atos = function(buffer, index, length) {
        index = index || 0;
        length = length || buffer.byteLength;
        var view = new Uint8Array(buffer, index, length);
        var str = new TextDecoder("utf-8").decode(view);
        return str;
    };

    /**
     * Converts binary buffer to JSON
     * @private
     */
    Human.utils.atoj = function(buffer, index, length) {
        return JSON.parse(Human.utils.atos(buffer, index, length));
    };

    /**
     * Benchmark a function.
     * @private
     */
    Human.utils.benchmark = function(fn, iterations) {
        iterations = iterations || 10000000;

        var t = performance.now();

        for (var i = 0; i < iterations; i++) {
            fn();
        }

        t = performance.now() - t;

        console.log("Total time: " + t.toFixed(3) + "ms");
        console.log("Time / operation: " + (t / iterations).toExponential(3) + "ms");
    };

    /**
     * Make n random objects visible
     * @private
     */
    Human.utils.setRandomVisibleObjects = function(n) {
        var objectIds = Object.keys(Human.scene.objects).filter(function(o) {
            return Human.scene.objects[o].isLeaf();
        });

        var showObjectIds = {};

        for (var i = 0; i < n; i++) {
            var j = Math.floor(Math.random() * objectIds.length);
            showObjectIds[objectIds.splice(j, 1)] = true;
        }

        Human.scene.setEnabledObjects({objectIds: showObjectIds, replace: true});
    };

    /**
    * Load text data
    */
    Human.utils.getText = function (src, callback, error) {
        networkGet(src, "text", callback, error);
    };

    /**
    * Load json data
    */
    if (Human.XML_HTTP_JSON_SUPPORTED) {
        Human.utils.getJSON = function (src, callback, error) {
            networkGet(src, "json", callback, error);
        };
    } else {
        // IE nonsense
        Human.utils.getJSON = function (src, callback, error) {
            this.getText(src, function(text) {
                callback(JSON.parse(text));
            }, error);
        };
    }

    /**
    * Load binary data
    */
    Human.utils.getBinary = function (src, callback, error) {
        networkGet(src, "arraybuffer", callback, error);
    };

    // Stolen from jQuery
    Human.utils.elementVisible = function (e) {
        return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
    };

    if (Human.ELEMENT_REMOVE_SUPPORTED) {
        Human.utils.removeElement = function (e) {
            e.remove();
        };
    } else {
        // IE nonsense
        Human.utils.removeElement = function (e) {
            if (e.parentNode !== null) {
                e.parentNode.removeChild(e);
            }
        };
    }

    Human.utils.boundaryToScreen = function(boundary) {
        var xmin = Number.POSITIVE_INFINITY;
        var xmax = Number.NEGATIVE_INFINITY;
        var ymin = Number.POSITIVE_INFINITY;
        var ymax = Number.NEGATIVE_INFINITY;

        var v1 = [boundary.xmin, boundary.ymin, boundary.zmin, 1];
        var v2 = [boundary.xmin, boundary.ymin, boundary.zmax, 1];
        var v3 = [boundary.xmin, boundary.ymax, boundary.zmin, 1];
        var v4 = [boundary.xmin, boundary.ymax, boundary.zmax, 1];
        var v5 = [boundary.xmax, boundary.ymin, boundary.zmin, 1];
        var v6 = [boundary.xmax, boundary.ymin, boundary.zmax, 1];
        var v7 = [boundary.xmax, boundary.ymax, boundary.zmin, 1];
        var v8 = [boundary.xmax, boundary.ymax, boundary.zmax, 1];

        var viewMatrix = Human.renderer.getViewMat();
        var projMatrix = Human.renderer.getProjMat();

        var viewProj = mat4.create();
        mat4.multiply(viewProj, projMatrix, viewMatrix);

        vec4.transformMat4(v1, v1, viewProj);
        xmin = Math.min(xmin, v1[0] / v1[3]);
        xmax = Math.max(xmax, v1[0] / v1[3]);
        ymin = Math.min(ymin, v1[1] / v1[3]);
        ymax = Math.max(ymax, v1[1] / v1[3]);

        vec4.transformMat4(v2, v2, viewProj);
        xmin = Math.min(xmin, v2[0] / v2[3]);
        xmax = Math.max(xmax, v2[0] / v2[3]);
        ymin = Math.min(ymin, v2[1] / v2[3]);
        ymax = Math.max(ymax, v2[1] / v2[3]);

        vec4.transformMat4(v3, v3, viewProj);
        xmin = Math.min(xmin, v3[0] / v3[3]);
        xmax = Math.max(xmax, v3[0] / v3[3]);
        ymin = Math.min(ymin, v3[1] / v3[3]);
        ymax = Math.max(ymax, v3[1] / v3[3]);

        vec4.transformMat4(v4, v4, viewProj);
        xmin = Math.min(xmin, v4[0] / v4[3]);
        xmax = Math.max(xmax, v4[0] / v4[3]);
        ymin = Math.min(ymin, v4[1] / v4[3]);
        ymax = Math.max(ymax, v4[1] / v4[3]);

        vec4.transformMat4(v5, v5, viewProj);
        xmin = Math.min(xmin, v5[0] / v5[3]);
        xmax = Math.max(xmax, v5[0] / v5[3]);
        ymin = Math.min(ymin, v5[1] / v5[3]);
        ymax = Math.max(ymax, v5[1] / v5[3]);

        vec4.transformMat4(v6, v6, viewProj);
        xmin = Math.min(xmin, v6[0] / v6[3]);
        xmax = Math.max(xmax, v6[0] / v6[3]);
        ymin = Math.min(ymin, v6[1] / v6[3]);
        ymax = Math.max(ymax, v6[1] / v6[3]);

        vec4.transformMat4(v7, v7, viewProj);
        xmin = Math.min(xmin, v7[0] / v7[3]);
        xmax = Math.max(xmax, v7[0] / v7[3]);
        ymin = Math.min(ymin, v7[1] / v7[3]);
        ymax = Math.max(ymax, v7[1] / v7[3]);

        vec4.transformMat4(v8, v8, viewProj);
        xmin = Math.min(xmin, v8[0] / v8[3]);
        xmax = Math.max(xmax, v8[0] / v8[3]);
        ymin = Math.min(ymin, v8[1] / v8[3]);
        ymax = Math.max(ymax, v8[1] / v8[3]);

        var canvas = Human.renderer.canvas.canvas[0];

        var canvasXMin = (xmin * 0.5 + 0.5) * canvas.width;
        var canvasXMax = (xmax * 0.5 + 0.5) * canvas.width;
        var canvasYMin = canvas.height - (ymax * 0.5 + 0.5) * canvas.height;
        var canvasYMax = canvas.height - (ymin * 0.5 + 0.5) * canvas.height;

        var pixelCoverage = (canvasXMax - canvasXMin) * (canvasYMax - canvasYMin);

        return {
            min: [canvasXMin, canvasYMin],
            max: [canvasXMax, canvasYMax],
            pixelCoverage: pixelCoverage
        };
    };

    Human.utils.visibleAssetReport = function() {
        var report = {
            totalVertices: 0,
            totalTriangles: 0,
            objectStats: {},
            geometryStats: {},
            textureStats: {},
            objectsByTrianglesPerPixel: null,
            objectsByTexelsPerPixel: null,
            geometriesByTriangleCount: null,
            texturesBySize: null,
        };

        var objects = Human.scene.objects;

        var objectIds = Object.keys(Human.scene.enabledObjects).filter(function(objectId) {
            return !!Human.scene.objects[objectId].geometry && !!Human.scene.objects[objectId].material;
        });

        report.objectsByTrianglesPerPixel = new Array(objectIds.length);
        report.objectsByTexelsPerPixel = new Array(objectIds.length);

        var geometryStats = report.geometryStats;
        var textureStats = report.textureStats;

        for (var i = 0, len = objectIds.length; i < len; ++i) {
            var objectId = objectIds[i];
            var object = objects[objectId];
            var geometry = object.geometry._core.arrays;
            var vertices = geometry.positions.length / 3;
            var triangles = geometry.indices.length / 3;
            var materialTextures = object.material.textures || [];
            var objectTextures = new Array(materialTextures.length);

            for (var t = 0; t < materialTextures.length; ++t) {
                var texture = materialTextures[t]._core;
                var src = texture.compressedSrc || texture.src || texture.uri;

                objectTextures[t] = textureStats[src] = textureStats[src] || {
                    src: src,
                    width: texture.width,
                    height: texture.height,
                    objectIds: [],
                    count: 0,
                    atlasSharing: 0,
                    atlas: false,
                    adjustedTexels: texture.width * texture.height
                };

                textureStats[src].count++;

                var atlasNew = true;
                for (var o = 0, oLen = textureStats[src].objectIds.length; o < oLen; ++o) {
                    var otherGeometryId = objects[textureStats[src].objectIds[o]].geometryId;

                    if (otherGeometryId !== object.geometryId) {
                        textureStats[src].atlas = true;
                    }

                    if (otherGeometryId === object.geometryId) {
                        atlasNew = false;
                    }
                }

                if (atlasNew) {
                    textureStats[src].atlasSharing++;
                }

                textureStats[src].objectIds.push(objectId);
            }

            // NOTE(TAREK): There seems to be a bug in boundary calculations.
            // They aren't always updated with the transforms.
            object._setBoundaryDirty();
            var canvasBounds = Human.utils.boundaryToScreen(object.getBoundary());

            report.totalVertices += vertices;
            report.totalTriangles += triangles;

            report.objectsByTexelsPerPixel[i] = report.objectsByTrianglesPerPixel[i] = report.objectStats[objectId] = {
                objectId: objectId,
                vertices: vertices,
                triangles: triangles,
                textures: objectTextures,
                canvasBounds: {
                    min: canvasBounds.min,
                    max: canvasBounds.max
                },
                pixelCoverage: canvasBounds.pixelCoverage,
                trianglesPerPixel: triangles / canvasBounds.pixelCoverage,
                texelsPerPixel: 0
            };

            geometryStats[object.geometryId] = geometryStats[object.geometryId] || {
                geometryId: object.geometryId,
                vertices: vertices,
                triangles: triangles,
                totalVertices: 0,
                totalTriangles: 0,
                objectIds: [],
                count: 0
            };

            geometryStats[object.geometryId].count++;
            geometryStats[object.geometryId].totalVertices += vertices;
            geometryStats[object.geometryId].totalTriangles += triangles;
            geometryStats[object.geometryId].objectIds.push(objectId);
        }


        Object.keys(textureStats).forEach(function(src) {
            var texture = textureStats[src];
            if (texture.atlas) {
                texture.adjustedTexels /= texture.atlasSharing;
            }
        });

        report.objectsByTrianglesPerPixel.sort(function(a, b) {
            return b.trianglesPerPixel - a.trianglesPerPixel;
        });

        report.objectsByTexelsPerPixel.filter(function(object) {
            return object.textures.length > 0;
        }).forEach(function(object) {
            var textures = object.textures;

            textures.sort(function(a, b) {
                return b.adjustedTexels - a.adjustedTexels;
            });

            object.texelsPerPixel = object.textures[0].adjustedTexels / object.pixelCoverage;
        });
        report.objectsByTexelsPerPixel.sort(function(a, b) {
            return b.texelsPerPixel - a.texelsPerPixel;
        });

        report.geometriesByTriangleCount = Object.keys(geometryStats).map(function(geometryId) {
            return geometryStats[geometryId];
        }).sort(function(a, b) {
            return b.triangles * b.count - a.triangles * a.count;
        });

        report.texturesBySize = Object.keys(textureStats).map(function(src) {
            return textureStats[src];
        }).sort(function(a, b) {
            return b.adjustedTexels - a.adjustedTexels;
        });

        return report;
    };

    Human.utils.textGzipSize = function(str) {
        if (window.pako) {
            var binary = new TextEncoder().encode(str);
            return pako.deflate(binary).byteLength;
        }

        return 0;
    };

    Human.utils.binaryGzipSize = function(data) {
        if (window.pako) {
            var binary = new Uint8Array(data);
            return pako.deflate(binary).byteLength;
        }

        return 0;
    };

    Human.utils.drawKdTree = function(kdTree, node) {
        kdTreeGeo(kdTree, node);
    };

    Human.utils.kdTreeStats = function(kdTree) {
        var stats = {
            numNodes: 0,
            numLeaves: 0,
            numObjects: 0,
            averageLeafObjects: 0,
            depthSum: 0,
            averageDepth: 0
        };

        kdTreeStats(kdTree, 0, stats);
        stats.averageDepth = stats.depthSum / stats.numLeaves;
        stats.averageLeafObjects = stats.numObjects / stats.numLeaves;

        return stats;
    };

    Human.utils.loadScript = function(path, onLoadFunc) {
        var head = document.getElementsByTagName('head')[0];
        var element = document.createElement('script');
        element.type = 'text/javascript';
        element.src = path;
        if (onLoadFunc !== null) {
            element.onload = onLoadFunc;
        }
        head.appendChild(element);
    };

    function networkGet(src, type, callback, error) {
        function defaultOnload() {
            if (request.status === 200) {
                callback(request.response);
            } else if (error) {
                error(new Error("Failed network request (" + src + "): " + request.status + " - " + request.statusText));
            }
        }

        // offline get doesn't check response code, assumes valid content exists
        // offline get can falsely report existence of compressed pvr textures and needs to fail
        function offlineOnload() {
            var didFail = src.endsWith("-etc1.pvr") && new DataView(request.response).getInt32(0) !== PVR_MAGIC_NUMBER;
            if (didFail) {
                error(new Error("Failed offline PVR get request: " + request.status + " - " + request.statusText));
            } else {
                callback(request.response);
            }
        }

        var request = new XMLHttpRequest();
        request.open("GET", src, true);
        request.timeout = 0;
        request.responseType = type;
        request.onerror = function() {
            error(new Error("Failed request (" + src + "): " + request.status + " - " +  request.statusText));
        };
        request.onload = window.localContentOnly ? offlineOnload : defaultOnload;

        request.send(null);
    }

    function kdTreeGeo(kdTreeNode, graphNode) {
        if (!kdTreeNode) {
            return;
        }

        var min = kdTreeNode.bb.min;
        var max = kdTreeNode.bb.max;

        var minX = min[0];
        var minY = min[1];
        var minZ = min[2];

        var maxX = max[0];
        var maxY = max[1];
        var maxZ = max[2];

        graphNode.addNode({
            type: "geometry",
            primitive: "lines",
            positions: [
                minX, maxY, minZ,
                maxX, maxY, minZ,

                maxX, maxY, minZ,
                maxX, minY, minZ,

                maxX, minY, minZ,
                minX, minY, minZ,

                minX, minY, minZ,
                minX, maxY, minZ,

                minX, maxY, minZ,
                minX, maxY, maxZ,

                maxX, maxY, minZ,
                maxX, maxY, maxZ,

                minX, minY, minZ,
                minX, minY, maxZ,

                maxX, minY, minZ,
                maxX, minY, maxZ,

                minX, maxY, maxZ,
                maxX, maxY, maxZ,

                maxX, maxY, maxZ,
                maxX, minY, maxZ,

                maxX, minY, maxZ,
                minX, minY, maxZ,

                minX, minY, maxZ,
                minX, maxY, maxZ
            ]
        });

        kdTreeGeo(kdTreeNode.left, graphNode);
        kdTreeGeo(kdTreeNode.right, graphNode);
    }

    function kdTreeStats(kdTreeNode, depth, stats) {
        depth++;
        stats.numNodes++;

        var items = kdTreeNode.triangles || kdTreeNode.objects;

        if (items) {
            stats.numLeaves++;
            stats.numObjects += items.length;
            stats.depthSum += depth;
        } else {
            kdTreeStats(kdTreeNode.left, depth, stats);
            kdTreeStats(kdTreeNode.right, depth, stats);
        }
    }
})();
;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */
Human.utils.Map = function (items, _baseId) {
    "use strict";

    /**
     * @property Items in this map
     */
    this.items = items || [];


    var baseId = _baseId || 0;
    var lastUniqueId = baseId;
    // Attach id number to make unique
    if (typeof baseId !== "number") {
        lastUniqueId = baseId + "0";
    }

    /**
     * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
     * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
     *
     * id = myMap.addItem("foo") // ID internally generated
     *
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     *
     */
    this.addItem = function () {

        var item;

        if (arguments.length === 2) {

            var id = arguments[0];

            item = arguments[1];

            if (this.items[id]) { // Won't happen if given ID is string
                throw "ID clash: '" + id + "'";
            }

            this.items[id] = item;

            return id;

        } else {

            while (true) {

                item = arguments[0];

                // Last unique id is either # or prefix + #
                var findId;
                if (typeof baseId === "number") {
                    findId = lastUniqueId++;
                } else {
                    findId = baseId + parseInt(lastUniqueId.substr(baseId.length));
                    lastUniqueId = baseId + (parseInt(lastUniqueId.substr(baseId.length)) + 1);
                }

                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    /**
     * Removes the item of the given ID from the map and returns it
     */
    this.removeItem = function (id) {
        var item = this.items[id];

        if (item !== undefined) {
            // Remove id from item list
            delete this.items[id];
            // Update last unique id -- prevents holes
            lastUniqueId = id;
        }

        return item;
    };
};;
/**
 * A fast pool of reusable ids
 */
Human.utils.IDPool = function(cfg) {
    "use strict";

    cfg = cfg || {};

    var prefix = cfg.prefix || "id";
    var prefixLen = prefix.length;
    var idNums = [];
    var clientIds = {};    // IDs explicitly supplied by client
    var internalIds = {};  // IDs internally generated

    /** Gets new ID
     */
    this.getId = function(clientId) {
        if (clientId) {
            // Explicit user-supplied ID
            if (clientIds[clientId] || internalIds[clientId]) {
                throw "ID already in use: " + clientId;
            }
            clientIds[clientId] = true;
            return clientId;
        }
        var internalId;
        // Try to find hole in ID nums
        for (var i = 0, len = idNums.length; i < len; i++) {
            if (!idNums[i]) {
                internalId = prefix + i;
                if (!clientIds[internalId]) { // Don't clobber user ID
                    idNums[i] = true;
                    internalIds[internalId] = true;
                    return internalId;
                }
            }
        }
        // No hole found in ID nums - append new one
        idNums.push(true);
        internalId = prefix + (idNums.length - 1);
        internalIds[internalId] = true;
        return internalId;
    };

    /** Returns true if given ID in use
     *
     * @param id
     * @return {Boolean}
     */
    this.containsId = function(id) {
        return clientIds[id] !== undefined || internalIds[id] !== undefined;
    };

    /** Releases ID to the pool for reuse
     */
    this.putId = function(id) {
        if (clientIds[id]) {
            delete clientIds[id];
        } else if (internalIds[id]) {
            // Additional check to make sure that id exists in pool

            idNums[parseInt(id.substr(prefixLen))] = false;
            delete internalIds[id];
        }
    };

};
;/* Tools for advanced selection from any knowledge graph.
* Lexer, Parser, SetOperations
*
* Lexer: Turn an expression into tokens of accessors and logical conjunctions.
* Parser: Sort tokens according to order of operations.
* SetOperations: Wrappers for common logical set operations
*
* GraphMatcher: Get graph terms matching accessor/conjunction queries. This requires a graph object with an 'access' function to access the graph nodes implied or pointed to by accessor.
*/

(function () {
    "use strict";
    var HumanSelection = Human.utils.selection = {};

    // LEXER ===================================================================
    var Lexer = function(defunct){
        if (typeof defunct !== "function") {
            this.defunct = Lexer.defunct;
        } else {
            this.defunct = function(){return false;};
        }
        this.tokens = [];
        this.rules = [];
        this.remove = 0;
        this.state = 0;
        this.index = 0;
        this.input = "";
    };

    Lexer.prototype.addRule = function (pattern, action, start) {
          var global = pattern.global;

          if (!global) {
              var flags = "g";
              if (pattern.multiline) {flags += "m";}
              if (pattern.ignoreCase) {flags += "i";}
              pattern = new RegExp(pattern.source, flags);
          }

          if (Object.prototype.toString.call(start) !== "[object Array]") {start = [0];}

          this.rules.push({
              pattern: pattern,
              global: global,
              action: action,
              start: start
          });

          return this;
      };

    Lexer.prototype.setInput = function (input) {
        this.remove = 0;
        this.state = 0;
        this.index = 0;
        this.tokens.length = 0;
        this.input = input;
        return this;
    };

    Lexer.prototype.lex = function () {
        if (this.tokens.length) {return this.tokens.shift();}

        this.reject = true;
        var token;
        while (this.index <= this.input.length) {
            var matches = this.scan().splice(this.remove);
            var index = this.index;

            while (matches.length) {
                if (this.reject) {
                    var match = matches.shift();
                    var result = match.result;
                    var length = match.length;
                    this.index += length;
                    this.reject = false;
                    this.remove++;

                    token = match.action.apply(this, result);
                    if (this.reject) {this.index = result.index;}
                    else if (typeof token !== "undefined") {
                        switch (Object.prototype.toString.call(token)) {
                        case "[object Array]":
                            this.tokens = token.slice(1);
                            token = token[0];
                            /* falls through */
                        default:
                            if (length) {this.remove = 0;}
                            return token;
                        }
                    }
                } else {break;}
            }

            var input = this.input;

            if (index < input.length) {
                if (this.reject) {
                    this.remove = 0;
                    token = this.defunct.call(this, input.charAt(this.index++));
                    if (typeof token !== "undefined") {
                        if (Object.prototype.toString.call(token) === "[object Array]") {
                            this.tokens = token.slice(1);
                            return token[0];
                        } else {return token;}
                    }
                } else {
                    if (this.index !== index) {this.remove = 0;}
                    this.reject = true;
                }
            } else if (matches.length) {
                this.reject = true;
            }

            else {break;}
        }
    };

    Lexer.prototype.scan = function() {
        var matches = [];
        var index = 0;

        var state = this.state;
        var lastIndex = this.index;
        var input = this.input;

        for (var i = 0, length = this.rules.length; i < length; i++) {
            var rule = this.rules[i];
            var start = rule.start;
            var states = start.length;

            if ((!states || start.indexOf(state) >= 0) ||
                (state % 2 && states === 1 && !start[0])) {
                var pattern = rule.pattern;
                pattern.lastIndex = lastIndex;
                var result = pattern.exec(input);

                if (result && result.index === lastIndex) {
                    var j = matches.push({
                        result: result,
                        action: rule.action,
                        length: result[0].length
                    });

                    if (rule.global) {index = j;}

                    while (--j > index) {
                        var k = j - 1;

                        if (matches[j].length > matches[k].length) {
                            var temple = matches[j];
                            matches[j] = matches[k];
                            matches[k] = temple;
                        }
                    }
                }
            }
        }
        return matches;
    };

    // PARSER ==================================================================
    // Parser taken from here https://gist.github.com/aaditmshah/6683499
    var Parser = function(table){
        this.table = table;
    };

    Parser.prototype.parse = function(input){
        var length = input.length, table = this.table, output = [], stack = [];
        var index = 0;
        var token;
        while (index < length) {
            token = input[index++];
            switch (token) {
            case "(":
              stack.unshift(token);
              break;
            case ")":
              while (stack.length) {
                  token = stack.shift();
                  if (token === "(") {break;}
                  else {output.push(token);}
              }

              if (token !== "(") {
                  throw new Error("Mismatched parentheses.");
              }
              break;
            default:
              if (table.hasOwnProperty(token)) {
                  while (stack.length) {
                      var punctuator = stack[0];

                      if (punctuator === "(") {break;}

                      var operator = table[token],
                          precedence = operator.precedence,
                          antecedence = table[punctuator].precedence;

                      if (precedence > antecedence ||
                          precedence === antecedence &&
                          operator.associativity === "right") {break;}
                      else {output.push(stack.shift());}
                  }

                  stack.unshift(token);
              } else {output.push(token);}
            }
        }

        while (stack.length) {
            token = stack.shift();
            if (token !== "(") {output.push(token);}
        }

        return output;
    };

    // SET OPERATIONS  =========================================================
    var uidList = [], uid;

    // This can be extended to compare membership based on other attributes
    uidList.push(uid = function(){return this;});

    var SetOperations = {};

    // Performs set membership analysis between two sets a and b and passes results to arbitrary evaluator function.
    function process(a, b, evaluator) {
        // Create a histogram of 'a'.
        var hist = Object.create(null), out = [], ukey, k;
        a.forEach(function(value) {
          ukey = uid.call(value);
          if(!hist[ukey]) {
            hist[ukey] = { value: value, freq: 1 };
          }
        });
        // Merge 'b' into the histogram.
        b.forEach(function(value) {
          ukey = uid.call(value);
          if (hist[ukey]) {
            if (hist[ukey].freq === 1) {
                hist[ukey].freq = 3;
            }
          } else {
            hist[ukey] = { value: value, freq: 2 };
          }
        });
        // Call the given evaluator.
        if (evaluator) {
          for (k in hist) {
            if (evaluator(hist[k].freq)) {out.push(hist[k].value);}
          }
          return out;
        } else {
          return hist;
        }
    }

    // Join two sets together.
    // Set.union([1, 2, 2], [2, 3]) => [1, 2, 3]
    SetOperations.union = function(a, b) {
        return process(a, b, function() {
            return true;
        });
    };

    // Return items common to both sets.
    // Set.intersection([1, 1, 2], [2, 2, 3]) => [2]
    SetOperations.intersection = function(a, b) {
        return process(a, b, function(freq) {
            return freq === 3;
        });
    };

    // Symmetric difference. Items from either set that
    // are not in both sets.
    // Set.difference([1, 1, 2], [2, 3, 3]) => [1, 3]
    SetOperations.difference = function(a, b) {
        return process(a, b, function(freq) {
            return freq < 3;
        });
    };

    // Relative complement. Items from 'b' which are
    // not also in 'a'.
    // Set.complement([1, 2, 2], [2, 2, 3]) => [3]
    SetOperations.complement = function(a, b) {
        return process(a, b, function(freq) {
            return freq === 1;
        });
    };

    // Returns true if both sets are equivalent, false otherwise.
    // Set.equals([1, 1, 2], [1, 2, 2]) => true
    // Set.equals([1, 1, 2], [1, 2, 3]) => false
    SetOperations.equals = function(a, b) {
        var max = 0, min = Math.pow(2, 53), key, hist = process(a, b);
        for (key in hist) {
            max = Math.max(max, hist[key].freq);
            min = Math.min(min, hist[key].freq);
        }
        return min === 3 && max === 3;
    };

    var MATCH_STRING_PARSE_CONFIG = {
        "<AND>": {precedence:1, associativity: "left"},
        "<OR>": {precedence:1, associativity: "left"},
        "<XOR>": {precedence:1, associativity: "left"},
        "<NOT>": {precedence:1, associativity: "left"}
    };

    var MATCH_STRING_OPERATORS = {
        '<AND>': function(a,b) {return a && b;},
        '<OR>': function(a,b) {return a || b;},
        '<NOT>': function(a) { return !a;}
    };

    // Match any string according to rules.
    HumanSelection.StringMatcher = function(){
        this.lexer = new Lexer(function(){return false;});
        this.parser = new Parser(MATCH_STRING_PARSE_CONFIG);
        this.operators = MATCH_STRING_OPERATORS;

        this.lexer.addRule(/[A-z0-9]+/i, function(lexeme){
          return lexeme;
        });
        this.lexer.addRule(/(<[A-Z]+>)/,function(lexeme){
          return lexeme;
        });
        this.lexer.addRule(/[\(\+\-\*\/\)]/, function (lexeme) {
          return lexeme; // punctuation (i.e. "(", "+", "-", "*", "/", ")")
        });
    };

    // Get parsed tokens from query
    HumanSelection.StringMatcher.prototype.parse = function(query) {
        this.lexer.setInput(query);
        var tokens = [], token = this.lexer.lex();
        while (token){
            tokens.push(token);
            token = this.lexer.lex();
        }
        return this.parser.parse(tokens);
    };

    // Returns true if the query matches string term
    HumanSelection.StringMatcher.prototype.match = function(term, query) {
        var queryTokens = this.parse(query);

        var stack = [], a,b;
        queryTokens.forEach(function(c){
            if (this.operators.hasOwnProperty(c)) {
                if (c!=="<NOT>"){
                    // takes only one token
                    a = stack.pop();
                    stack.push(this.operators[c](a));
                } else {
                    // takes two tokens
                    b = stack.pop();
                    a = stack.pop();
                    stack.push(this.operators[c](a,b));
                }
            } else {
                c = "(" + c + ")";
                stack.push(!!term.match(new RegExp(c, 'i')));
            }
        });
        return stack[0];
    };

    var MATCH_GRAPH_PARSE_CONFIG = {
        "<AND>": {precedence:1, associativity: "left"},
        "<OR>": {precedence:1, associativity: "left"},
        "<XOR>": {precedence:1, associativity: "left"},
        "<NOT>": {precedence:1, associativity: "left"}
    };

    var MATCH_GRAPH_OPERATORS = {
        '<AND>': function(a, b) {
          return SetOperations.intersection(a,b);
        },
        '<OR>': function(a, b) {
          return SetOperations.union(a,b);
        },
        '<XOR>': function(a,b) {
          return SetOperations.difference(a,b);
        },
        '<NOT>': function(a, b) {
          return SetOperations.complement(a,b);
        }
    };

    //
    HumanSelection.GraphMatcher = function(){
        this.lexer = new Lexer(function(){return false;});
        this.parser = new Parser(MATCH_GRAPH_PARSE_CONFIG);
        this.operators = MATCH_GRAPH_OPERATORS;
        this.lexer.addRule(/[A-z0-9\-]+/i, function(lexeme){
            return lexeme;
        });
        this.lexer.addRule(/(<[A-Z]+>)/,function(lexeme){
            return lexeme;
        });
        this.lexer.addRule(/[\(\)]/, function (lexeme) {
            return lexeme; // punctuation (i.e. "(", ")" )
        });
    };

    HumanSelection.GraphMatcher.prototype.parse = function(query) {
        this.lexer.setInput(query);
        var tokens = [], token = this.lexer.lex();
        while (token) {
            tokens.push(token);
            token = this.lexer.lex();
        }
        return this.parser.parse(tokens);
    };

    // Returns array of graph nodes that match query term by subsumption.
    HumanSelection.GraphMatcher.prototype.match = function(graph, query) {
        var queryTokens = this.parse(query);
        var stack = [], a, b;
        var self = this;
        queryTokens.forEach(function(c){
            if (self.operators.hasOwnProperty(c)) {
                // do operation
                b = stack.pop();
                a = stack.pop();
                if (!Array.isArray(a)) {
                    a = graph.access(a);
                }
                if (!Array.isArray(b)) {
                    b = graph.access(b);
                }
                stack.push(self.operators[c](a,b));
            } else {
                if (!Array.isArray(c)) {
                    stack.push(graph.access(c));
                } else {
                    stack.push(c);
                }
            }
        });
        return stack[0];
    };

})();
;/**
 * @namespace Provides methods for sending and subscribing events.
 */
(function () {
    "use strict";

    var HumanEvents = Human.events = {};

    var eventBinders = {};

    var DEFAULT_EVENT_CHANNEL = 0;

    var eventChannels = [
        {} // Default channel
    ];

    var enabledEventChannels = {};

    var remembered = {};

    var suspendEvents = false;   // If set to true, events will be blocked.

    /**
     * Injects a factory function which creates bindings for a given event type. This enables an event source
     * to decide when to fire events based on an event-specific mask that may be optionally given to the .onEvent method.
     *
     * <h3>Works like this:</h3>
     *
     * Human.events.addBinder(
     *      "my-event-type",
     *      function(mask, fn) {  // The factory function
     *
     *          // Creates bindings where fn will be called
     *          // by event source, passing event to it,
     *          // when criteria in mask are met.
     *
     *      });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.addBinder = function (eventName, eventBinder) {
        (eventBinders[eventName] || (eventBinders[eventName] = [])).push(eventBinder);
    };

    /**
     * Creates an event channel. Events can be fired on these channels,
     * which can be selectively enabled/disabled for efficient dynamic event
     * subscription/unsubsubscription.
     *
     * <h3>Example:</h3>
     * <pre>
     *     var myNewChannel = createEventChannel({
     *        enabled: true
     *     });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.createChannel = function (cfg) {
        var channel = eventChannels.length;
        eventChannels.push({});
        if (cfg && cfg.enabled) {
            HumanEvents.enableChannel(channel, cfg.enabled);
        }
        return channel;
    };

    /**
     * Enable or disable an event channel.
     *
     * @memberof Human.events
     */
    HumanEvents.enableChannel = function (channel, enable) {
        enabledEventChannels[channel] = enable;
    };

    /**
     * Registers a handler for a type of engine event.
     *
     * <p>The handler can be registered with an optional priority number which specifies the order it is
     * called among the other handler already registered for the event.</p>
     *
     * <p>So, with n being the number of handlers registered for the given event:</p>
     * <ul>
     * <li>(priority <= 0)      - handler will be the first called</li>
     * <li>(priority >= n)      - handler will be the last called</li>
     * <li>(0 < priority < n)   - handler will be called at the order given by the priority</li>
     *
     * @param channel - Optional channel name, falls back on default channel when omitted
     * @param type Event type - one of the values in SceneJS._eventModule
     * @param fn - Handler function that will accept whatever parameter object accompanies the event
     * @param priority - Optional priority number (see above)
     * @memberof Human.events
     */
    HumanEvents.onEvent = HumanEvents.on = function () {
        var channel;
        var type;
        var fn;
        var options;
        if (typeof arguments[0] === "number") {
            channel = arguments[0];
            if (channel > eventChannels.length - 1) {
                Human.log.error("Human_event.onEvent", "Channel not created: " + channel +
                    " - should be created first with Human.events.createChannel");
                return;
            }
            type = arguments[1];
            fn = arguments[2];
            options = arguments[3];
        } else if (typeof arguments[0] === "object") {
            var params = arguments[0];
            type = params.type;
            fn = params.fn;
            // Masked subscriptions not (yet) channeled or prioritised
            var binders = eventBinders[type];
            if (binders) {
                var mask = params.mask || {};
                for (var i = 0, len = binders.length; i < len; i++) {
                    binders[i](mask, fn);
                }
            }
            channel = (params.channel !== undefined && params.channel !== null) ? params.channel : DEFAULT_EVENT_CHANNEL;
            options = params.options;
        } else {
            channel = DEFAULT_EVENT_CHANNEL;
            type = arguments[0];
            fn = arguments[1];
            options = arguments[2];
        }
        enabledEventChannels[channel] = (options && options.enable !== undefined && options.enable !== null) ? options.enable : true;
        options = options || {};
        var subscriberLists = eventChannels[channel];
        if (!subscriberLists) {
            subscriberLists = eventChannels[channel] = {};
        }
        var list = subscriberLists[type];
        if (!list) {
            list = [];
            subscriberLists[type] = list;
        }
        var handler = {
            fn: fn,
            priority: (options.priority === undefined) ? list.length : options.priority,
            once: options.once
        };
        for (i = 0; i < list.length; i++) {
            if (list[i].priority > handler.priority) {
                list.splice(i, 0, handler);
                return;
            }
        }
        list.push(handler);
        if (remembered[type]) {
            handler.fn(remembered[type]);
        }
    };

    /** Single-shot event subscribe
     *
     * @param type
     * @param ok
     */
    HumanEvents.once = function (type, ok) {
        HumanEvents.on(type, ok, { once: true });
    };

    /**
     * Fire an event.
     * @param {String} type Event type name
     * @param {{}} [params] Map of parameters to accompany the event - must be JSON-serializable.
     * @memberof Human.events
     */
    HumanEvents.fireEvent = HumanEvents.fire = function (type, params, remember) {
        if (suspendEvents) {
            return;
        }

        var subscriberLists;
        var list;
        for (var channel = 0, numChannels = eventChannels.length; channel < numChannels; channel++) {
            if (enabledEventChannels[channel]) {
                subscriberLists = eventChannels[channel];
                list = subscriberLists[type];
                if (list) {
                    if (!params) {
                        params = {};
                    }
                    var toRemove;
                    var handler;
                    for (var i = 0, len = list.length; i < len; i++) {
                        handler = list[i];
                        // A handler could be undefined by this time,
                        // should we ever unEvent it before we get here.
                        if (handler) {
                            try {
                                handler.fn(params);
                                if (handler.once) {
                                    if (!toRemove) {
                                        toRemove = [];
                                    }
                                    toRemove.push(i);
                                }
                            } catch(exception) {
                                Human.log.error(exception);
                            }
                        }
                    }
                    if (toRemove) {
                        for (i = toRemove.length - 1; i >= 0; i--) {
                            list.splice(toRemove[i], 1);
                        }
                    }
                }
            }
        }
        if (remember) {
            remembered[type] = params;
        }
    };

    HumanEvents.blockEvents = function(fn) {
        suspendEvents = true;
        try {
            fn();
        } catch (e) {
            Human.log.error(e.message);
        }
        suspendEvents = false;
    };

    /** Remove a Handler with a certain Function from the List of Handlers for
     * an Event of a certain Type.
     * @memberof Human.events
     * @param channel to turn off -- default if undefined
     * @param type of the channel
     * @param fn -- function to call
     */
    HumanEvents.unEvent = HumanEvents.off = function (type, fn, channel) {  // TODO: unbind for optional channel
        // If channel unspecified -- it is default channel
        // If channel does not exist, nothing to turn off
        if (channel === undefined || channel === null) {
            channel = DEFAULT_EVENT_CHANNEL;
        } else if (channel >= eventChannels.length || channel < 0) {
            throw "Channel does not exist: " + channel;
        }

        var subscriberLists = eventChannels[ channel ];
        if (!subscriberLists) {
            subscriberLists = eventChannels[ channel ] = {};
        }
        var list = subscriberLists[ type ];
        if (!list) {
            list = [];
            subscriberLists[ type ] = list;
        }
        for (var i = list.length; i--;) {
            if (list[ i ].fn === fn) {
                list.splice(i, 1);
            }
        }
    };
})();
;/**
 @namespace Engine configs definition, update, subscription and query.

 <p>Properties are various engine configurations, such as background color in the 3D view, or mouse sensitivity.</p>

 <h3>Setting multiple properties:</h3>
 <pre>
 Human.properties.set({
        "annotation.teacher" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
            pinShaftColor: { r: 1.0,b: 0.0, g: 1.0 }
        }
        "annotation.student" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 }
            pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
        }
    });
 </pre>
 <h3>Querying properties</h3>
 <p>Querying all engine properties:</p>
 <pre>
 Human.properties.query();
 </pre>
 <p>Result:</p>
 <pre>
 {
     "annotation.default" : {
          pinHeadColor: { r: 1.0, g: 0.5, b: 0.5 },
          pinShaftColor: { r: 1.0, b: 1.0, g: 0.0 }
      },
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      },
      "annotation.student" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <p>Querying engine properties with keys matching a regular expression:</p>
 <pre>
 Human.properties.query("teacher");
 </pre>
 <p>Result:</p>
 <pre>
 {
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <h3>Subscribing to a property</h3>
 <p>A property may be subscribed to by a consumer who wants to be notified of any change to its value.</p>
 <ul>
 <li>The property will be created first if it does not yet exist, and a subscriber can provide an initial value to assign to the property if
 it is being created.</li>
 <li>The subscription will return an ID which is a handle to the subscription which can be used to unsubscribe. By default,
 the subscription ID is automatically generated, but the subscriber may optionally provide their own subscription ID instead.</li>
 </ul>
 <pre>
 var subId = Human.properties.subscribe({

          // Optional subscriber-managed ID.
          // Auto-generated if not supplied.
          subId: "mySub",

          // Mandatory property ID
          propId: "annotation.student",

          // Default config properties - these are overridden by
          // any properties that are previously or subsequently set
          // by a Config.Set command:
          value: {
              pinHeadColor:  { r: 1, g: 0, b: 0 },
              pinShaftColor: { r: 1, g: 1, b: 0 }
          },

          // Callback fired each time the config properties are set,
          // and immediately when the config is bound in this call:
          callback: function(props) {

              if (props.pinHeadColor) {
                 theAnnotation.setPinHeadColor(props.pinHeadColor);
              }

              if (props.pinShaftColor) {
                theAnnotation.setPinShaftColor(props.pinShaftColor);
             }

          }
  });
 </pre>

 <h3>Unsubscribing from a property:</h3>
 <pre>
 Human.properties.unsubscribe(subId);
 </pre>
 */
(function () {
    "use strict";

    var HumanProperties = Human.properties = {};

    // Subscription handle map, can internally generate new handles,
    // as well as insert user-generated handles
    var idPool = new Human.utils.IDPool();

    /**
     * Currently defined properties
     * @type {{*}}
     * @memberof Human.properties
     */
    HumanProperties.properties = {};

    // Maps subscription handles to callbacks
    var subCallbacks = {};

    // For each style, a map of callbacks mapped to subscription IDs
    var propSubCallbacks = {};

    // Maps subscription handles to property IDs
    var subProps = {};

    /**
     * Subscribes to a property, defining it first if not defined, and optionally setting its value
     *
     * <pre>
     *
     * // This format is extensible, eg. in case we want to add metadata etc
     *
     * var subId = Human.properties.subscribe({
     *          subId: "foo", // Call can opt to manage subscription IDs themselves
     *          propId: "myProperty",
     *          value: {
     *              color: { r: 0.2, g: 0.7, b: 1.0 },
     *              width: 1.2
     *          },
     *          callback: function(config) {
     *              someElement.setColor(config.color);
     *              someElement.setWidth(config.width);
     *          }
     *     });
     * </pre>
     *
     * @memberof Human.properties
     * @return {String} Handle to the subscription, which can be given to {@link Human.properties.unsubscribe} to unsubscribe
     */
    HumanProperties.subscribe = function (params) {

        params = params || {};

        // Every property has an ID
        var propId = params.propId;
        if (!propId) {
            Human.log.error("Human.properties.subscribe", "Param expected: propId");
            return null;
        }

        // Subscriber gets updates via callback
        var callback = params.callback;
        if (!callback) {
            Human.log.error("Human.properties.subscribe", "Param expected: callback");
            return null;
        }

        // If caller supplies own subscription handle, ensure no clash with existing handles
        if (params.subId) {
            if (idPool.containsId(params.subId)) {
                Human.log.error("Human.properties.subscribe", "Subscription already exists with this ID: " + params.subId);
                return null;
            }
        }

        var value = params.value;
        var subId = idPool.getId(params.subId); // Generate or insert subscription handle in map
        var prop = HumanProperties.properties[propId];
        var callbacks;

        if (prop) {

            // TODO (AC): check if callbacks assignment can be consolidated.
            // Register callback for the new property
            callbacks = (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}));
            callbacks[subId] = callback;

            // Property already exists
            if (value) {

                // New value supplied; set the property
                HumanProperties.properties[propId] = value;
            }

            // Map callback to subscription handle
            subCallbacks[subId] = callback;

            // Map property to subscription handle
            subProps[subId] = propId;

            // Notify callback of new property value
            callback(value);

            // Return subscription handle
            return subId;
        }

        // Register callback for the new property
        callbacks = (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}));
        callbacks[subId] = callback;

        // Initial value not given, initialize to default
        if (value === undefined || value === null) {
            value = {}; // Might as well be a literal object
        }

        // Set property to new value
        HumanProperties.properties[propId] = value;

        // Map callback to subscription handle
        subCallbacks[subId] = callback;

        // Map property to subscription handle
        subProps[subId] = propId;

        // Notify callback of new property
        callback(value);

        // Return subscription handle
        return subId;
    };

    /**
     * Switches a subscription to a different property
     *
     * @param {String} subId Subscription handle that was obtained with {@link Human.properties.subscribe}
     * @param {String} propId ID of property to switch the subscription to
     * @memberof Human.properties
     */
    HumanProperties.resubscribe = function (subId, propId) {
        var callback = subCallbacks[subId];
        if (!callback) {
            Human.log.warn("Human.properties.resubscribe", "Subscription not found: '" + subId + "'");
            return;
        }
        var oldPropId = subProps[subId];
        var newProp = HumanProperties.properties[propId];
        if (oldPropId && newProp) {
            if (propSubCallbacks[oldPropId]) {
                delete propSubCallbacks[oldPropId][subId];
            }
            (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}))[subId] = callback;
            subProps[subId] = propId;
            callback(newProp);
        }
    };

    /**
     * Creates or edits one or more properties
     * @memberof Human.properties
     * @param {String} propId ID of config
     * @param {*} props Properties to write to the config
     */
    HumanProperties.set = function (props) {
        var value;
        var callbacks;
        for (var propId in props) {
            if (props.hasOwnProperty(propId)) {
                value = props[propId];
                HumanProperties.properties[propId] = value;
                callbacks = propSubCallbacks[propId];
                if (callbacks) {
                    for (var subId in callbacks) {
                        if (callbacks.hasOwnProperty(subId)) {
                            callbacks[subId](value);
                        }
                    }
                }
            }
        }
    };

    /**
     * Unsubscribes from a property
     * @memberof Human.properties
     * @param {String} subId Subscription ID
     */
    HumanProperties.unsubscribe = function (subId) {
        var propId = subProps[subId];
        if (!propId) {
            return;
        }
        delete subProps[subId];
        delete propSubCallbacks[propId][subId];
    };

    /**
     * Query existing props
     * @param {String} [regex] Regular expression to select properties by name
     * @returns {*} JSON map of queried props
     */
    HumanProperties.query = function (regex) {
        if (!regex) {
            return HumanProperties.properties;
        }
        var props;
        if (regex) {
            var pattern = new RegExp(regex);
            props = {};
            for (var propId in HumanProperties.properties) {
                if (HumanProperties.properties.hasOwnProperty(propId)) {
                    if (pattern.test(propId)) {
                        props[propId] = HumanProperties.properties[propId];
                    }
                }
            }
        }
        return props;
    };


    var defaults = {
      "annotations.margins":{
         "top":80,
         "left":50,
         "right":50,
         "bottom":50
      },
      "annotations.labelWidth":120,
      "annotations.horizontalLines":false,
      "annotations.fadeoutAngle":100,
      "annotation.layout.labelWidth":100,
      "annotations.layout.type":"draggable",
      'camera.optics.far': 5000,
      'camera.optics.fov': 55,
      'camera.optics.near': 0.1,
      'camera.zoomLimits':{
        max: 300,
        min: 0.01
      },
      'fog.color': [1,1,1],
      'fog.density': 0.01,
      'fog.enabled': false,
      'fog.end': 1000,
      'fog.max': 1,
      'fog.min': 0,
      'fog.mode':1,
      'fog.start':0,
      'timeline.autoPlay.enabled': false,
      'timeline.autoPlay.type': 'play',
      'timeline.chapterCamerasEnabled': true,
      'timeline.prevNextMode': 'scrub',
      'ui.mouseWheel.capture': true,
      'ui.zoom.mouseWheel.enabled': true
    };

    HumanProperties.getDefaults = function(prop){
      if (prop) {
            return defaults[prop];
      } else {
            return Human.utils.shallowClone(defaults);
      }
    };

    HumanProperties.setDefaults = function (props) {
        Human.utils.apply(props, defaults);
    };

    HumanProperties.applyDefaults = function () {
        this.set(defaults);
    };

})();
;/**
 * @namespace Provides methods for logging debug info, warnings and errors.
 */
(function () {
    "use strict";

    var log = Human.log = {};

    /**
     * Logging level at which nothing is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_NONE = 0;

    /**
     * Logging level at which everything is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_DEBUG = 1;

    /**
     * Logging level at which only info, warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_INFO = 2;

    /**
     * Logging level at which only warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_WARN = 3;

    /**
     * Logging level at only errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_ERROR = 4;

    // Store messages for reporting
    log.messages = [];
    log.maxMessages = 100;

    // Used in event that notifies on each logged message
    var levelNames = ["none", "debug", "info", "warn", "error"];

    // Buffers messages until engine ready, at which point
    // they are each fired off in a Log.Message event
    var messageBuf = log.messageBuf = [];
    var maxMessageBuf = 200;

    var minLogLevel = log.LOG_WARN;

    // Reporters which may be registered to report logging messages as they happen
    var reporters = log.reporters = {};

    /**
     * Sets minimum log level. Messages logged to levels below that will then not be reported.
     * @memberof Human.log
     * @private
     */
    log.setLevel = function (newLevel) {
        minLogLevel = newLevel;
    };

    /**
     * Returns the current minimum log level
     * @memberof Human.log
     * @private
     */
    log.getLevel = function () {
        return minLogLevel;
    };

    /**
     * Logs a message at the given logging level.
     * @memberof Human.log
     * @private
     */
    log.log = function (message, level) {
        level = (level === undefined || level === null) ? log.INFO : level;
        switch (level) {
            case log.LOG_DEBUG:
                if (minLogLevel <= log.LOG_DEBUG && window.console && window.console.debug) {
                    window.console.debug(message);
                    recordMessage(message, level);

                    Human.events.fire('_log.debug', message); // Private debug event
                }
                break;
            case log.LOG_ERROR:
                if (minLogLevel <= log.LOG_ERROR && window.console && window.console.error) {
                    window.console.error(message);
                    recordMessage(message, level);

                    Human.events.fire('_log.error', message);  // Private error event
                }
                break;
            case log.LOG_INFO:
                if (minLogLevel <= log.LOG_INFO && window.console && window.console.info) {
                    window.console.info(message);
                    recordMessage(message, level);

                    Human.events.fire('_log.info', message);  // Private info event
                }
                break;
            case log.LOG_WARN:
                if (minLogLevel <= log.LOG_WARN && window.console && window.console.warn) {
                    window.console.warn(message);
                    recordMessage(message, level);

                    Human.events.fire('_log.warn', message);  // Private warn event
                }
                break;
        }
        var event = {
            message: message,
            level: levelNames[level]
        };
        // Fire off to existing reporters
        for (var reporterId in reporters) {
            if (reporters.hasOwnProperty(reporterId)) {
                Human.events.fire(reporterId, event);
            }
        }
        // If message buffer now too long, flush and start it again with warning
        if (messageBuf.length > maxMessageBuf) {
            messageBuf.length = 0;
            messageBuf.push({
                message: "Logging buffer exceeded max length of " + maxMessageBuf +
                    " - messages to this point were flushed",
                level: levelNames[log.LOG_WARN]
            });
        }
        // Buffer message for reporters which may be created later
        messageBuf.push(event);
    };

    /** Logs a debugging message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.debug = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_DEBUG);
    };

    function pad(str) {
        return (str.length < 45) ? str + "                                                           ".substr(0, 45 - str.length) : str;
    }

    /** Logs an error message
     * @name error
     * @function
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.error = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_ERROR);
    };

    /** Logs an info message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.info = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_INFO);
    };

    /** Logs a warning message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.warn = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_WARN);
    };

    // Relay engine errors through logging methods
    Human.events.on("error",
        function (event) {
            log.error(event.message);
        });

    function recordMessage(message, level) {
        var levelName = levelNames[level].toUpperCase();

        if (log.messages.length > log.maxMessages) {
            log.messages.shift();
        }

        message = "[" + levelName + "]\t" + message;

        log.messages.push(message);
    }

})();



;/**
 * @namespace Supports query of params on URL in browser location bar.
 */
(function () {
    "use strict";

    var request = Human.request = {};

    var prevHash;
    var hashParams;
    var searchParams;

    request.getHashStr = function () {
        return window.location.hash;
    };

    /**
     * Gets all hash params.
     * @memberof Human.request
     * @return {*}
     */
    request.getHashParams = function () {
        if (!hashParams || prevHash !== window.location.hash) {
            hashParams = {};
            var stringAfterHash = window.location.hash.slice(1);
            var paramsAfterHash = stringAfterHash.split(',');
            var tokens;
            for (var i = 0, len = paramsAfterHash.length; i < len; i++) {
                tokens = paramsAfterHash[i].split("=");
                hashParams[tokens[0]] = tokens[1];
            }
            prevHash = window.location.hash;
        }
        return hashParams;
    };

    /** Gets a selected hash param - those params after the hash in the URL.
     * @memberof Human.request
     *
     * @param {String} key Hash parameter key
     * @return {String} Value of the hash parameter
     */
    request.getHashParam = function (key) {
        if (!hashParams || prevHash !== window.location.hash) {
            request.getHashParams();
        }
        return hashParams[key];
    };

    /**
     * Gets the search string - those params after the "?" in the URL.
     * @memberof Human.request
     * @return {String} The search string
     */
    request.getSearchStr = function () {
        return window.location.search;
    };

    /**
     * Get all search parameters.
     * @memberof Human.request
     * @return {*}
     */
    request.getSearchParams = function () {
        if (!searchParams) {
            searchParams = {};
            var search = window.location.search.slice(1);
            var params = search.split('&');
            var tokens;
            for (var i = 0, len = params.length; i < len; i++) {
                tokens = params[i].split("=");
                searchParams[tokens[0]] = tokens[1];
            }
        }
        return searchParams;
    };

    /** Gets a selected search parameter
     * @memberof Human.request
     *
     * @param {String} key Search parameter key
     * @return {String} Value of the search parameter
     */
    request.getSearchParam = function (key) {
        if (!searchParams) {
            request.getSearchParams();
        }
        return searchParams[key];
    };

})();;
// This section is actually documenting rpc.js from human-rpc
/**
 * Human API constructor
 * @param {string} iframeId - ID of the iFrame that the Human is loaded into
 * @returns A HumanAPI instance
 *
 * @class HumanAPI
 * @classdesc The HumanAPI class is the core of the BioDIgital Human API.  A
 * HumanAPI instance will be attached to an iframe containing BioDIgital Human
 * content and can be used to send messages to or receive messages from it.
 */

/**
 * Send an API message to the Human.
 *
 * @param {string} message - Name of the API message
 * @param {object} [params] - Message parameters
 * @method
 * @name HumanAPI#send
 */

/**
 * Subscribe to a Human event
 *
 * @function
 * @name HumanAPI#on
 * @param {string} eventName - Name of the API event
 * @param {function} callback - Event handler function
 */

 /**
 * Subscribe to the next Human event of the given type
 *
 * @function
 * @name HumanAPI#once
 * @param {string} eventName - Name of the API event
 * @param {function} callback - Event handler function
 */


(function () {
    "use strict";

    var rpc = Human.rpc = {
        windowClientEnabled: true
    };

    var MAX_LOG_SIZE = 10000;

    /** Map of procedures that have been created with {@link Human.rpc.define}.
     * @memberof Human.rpc
     * @type {{}}
     */
    rpc._procedures = {};

    // Map of RPC event names to engine event names.
    rpc._eventMap = {};

    // Callbacks registered with #onResult
    var resultCallbacks = [];

    // Allow definition of several deprecated functions at a time.
    var globalHideDefinitions = false;

    var hiddenProcedures = {};

    var log = [];


    /**
     * Execution scope for a procedure execution.
     * <p>A fresh one of these is instantiated for every procedure call, providing the procedure with
     * methods for returning the procedure result and logging.</p>
     * @param {string} procName Procedure name, for logging
     * @param {string} callId ID of procedure call, against which procedure result, if any, will be published
     * @constructor
     */
    function Scope(procName, callId) {
        this.procName = procName;
        this.callId = callId;
    }

    /**
     * Publishes the result of the procedure call.
     * <p>The result value is published against the ID of the caller,
     * who may subscribe to that ID using methods like {#link Human.rpc.on} in order to get the result.</p>
     * @param {{}} value The result value
     */
    Scope.prototype.setResult = function (value) {
        for (var i = 0, len = resultCallbacks.length; i < len; i++) {
            resultCallbacks[i](this.callId, value);
        }
    };

    /**
     * Logs debug info in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.info = function (msg) {
        Human.log.info(this.procName, msg);
    };

    /**
     * Logs a warning in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.warn = function (msg) {
        Human.log.warn(this.procName, msg);
    };

    /**
     * Logs an error in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.error = function (msg) {
        Human.log.error(this.procName, msg);
    };

    /**
     * Registers a procedure, which may then be called with {@link #call}.
     *
     * @param {string} procName Procedure name
     * @param {function} proc The procedure
     */
    rpc.define = function (procName, proc, params) {
        if (rpc._procedures[procName]) {
            Human.log.warn("Human.rpc.define", "Redefining procedure: " + procName);
        }

        params = params || {};

        if (params.hidden || globalHideDefinitions) {
            hiddenProcedures[procName] = true;
        }

        rpc._procedures[procName] = function (callId, params) {
            proc.call(new Scope(procName, callId), params || {});
        };
    };

    rpc.defineEvent = function(rpcEventName, params) {

        if (rpc._eventMap[rpcEventName]) {
            Human.log.warn("Human.rpc.defineEvent", "Redefining event: " + rpcEventName);
        }

        rpc._eventMap[rpcEventName] = params || rpcEventName;
    };

    rpc.enableEvent = function(scope, rpcEventName, once) {

        if (!rpc._eventMap[rpcEventName]) {
            Human.log.warn("Human.rpc.enableEvent", "Event: " + rpcEventName + " not defined.");
            return;
        }

        var params = rpc._eventMap[rpcEventName];

        if (typeof params === "string") {
            var eventFn = once ? "once" : "on";

            Human.events[eventFn](params, function(event) {
                scope.setResult(event);
            });
        } else {
            mapEvents(scope, params, once);
        }

    };

    function mapEvents(scope, params, once) {

        var triggered = false;

        var eventFn = once ? "once" : "on";

        var eventNames = params.events;
        var mapFn = params.map;

        if (params.init) {
            params.init();
        }

        function callback(event) {
            if (once && triggered) {
                return;
            }

            triggered = true;

            var result = mapFn ? mapFn(event) : event;

            if (result !== null) {
                scope.setResult(result || {});
            }

        }

        for (var i = 0, len = eventNames.length; i < len; i++) {

            Human.events[eventFn](eventNames[i], callback);

        }
    }

    // Get names of all available, public procedures
    rpc.getProcedures = function() {
        var procNames = Object.keys(rpc._procedures);

        Human.utils.filterInPlace(procNames, function(name) {
            return !hiddenProcedures[name];
        });

        return procNames;
    };

    // Get names of all available events
    rpc.getEvents = function() {
        return ["human.ready"].concat(Object.keys(rpc._eventMap));
    };

    // RPC procedures created in the callback function
    // will be considered hidden.
    rpc.hideDefinitions = function(fn) {
        globalHideDefinitions = true;

        try {
            fn();
        } finally {
            globalHideDefinitions = false;
        }
    };

    /**
     * Subscribes to results of subsequent RPC calls.
     *
     * <p>Each time a procedure returns a result, the given callback will be fired
     * with the the ID of the procedure call and the value that was returned.</p>
     *
     * <pre>
     *     #onResult(function(callId, value) {
     *         //..
     *     });
     *
     * @param {function(callId, value)} callback The callback
     * @function
     * @name onResult
     * @memberof Human.rpc
     */
    rpc.onResult = function (callback) {
        resultCallbacks.push(callback);
    };


    rpc.call = function (callId, procName, params) {
        var proc = rpc._procedures[procName];
        if (!proc) {
            Human.log.warn("Human.rpc.call", "Target procedure not found: " + procName);
            return;
        }

        proc(callId, params);
    };

    rpc.log = function(procName) {
        if (log.length > MAX_LOG_SIZE) {
            log.shift();
        }

        log.push({
            "engine_version": Human.VERSION,
            "api_version": Human.API_VERSION,
            "identifier": procName,
            "category": procName.split(".")[0]
        });
    };

    rpc.getLog = function() {
        return log;
    };

    rpc.logPending = function() {
        return log.length > 0;
    };

    rpc.resetLog = function() {
        log.length = 0;
    };

    rpc.filterUnsafeProperties = function(obj) {
        if (!Human.utils.isObject(obj)) {
            return obj;
        }

        var clean = {};

        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (isSafe(obj[key])) {
                    clean[key] = obj[key];
                }
            }
        }

        return clean;
    };

    function isSafe(obj) {
        if (!obj || typeof obj !== "object") {
            return true;
        }

        // Window
        if (obj === window) {
            return false;
        }

        // Dom Element
        if (typeof obj.nodeName === "string" && typeof obj.querySelectorAll === "function" && typeof obj.getElementsByTagName === "function") {
            return false;
        }

        // Event
        if (typeof obj.preventDefault === "function" && typeof obj.stopPropagation === "function") {
            return false;
        }

        return true;
    }

})();
;/*
 * RPC procedures for subscription to engine events.
 *
 */

Human.rpc.hideDefinitions(function () {
    "use strict";

    Human.rpc.define("apiEvents.on", function (eventName) {
        Human.rpc.enableEvent(this, eventName, false);
    });

    Human.rpc.define("apiEvents.once", function (eventName) {
        Human.rpc.enableEvent(this, eventName, true);
    });

});
;// legacy RPC methods and events

/* NOTE: CURRENTLY UNDOCUMENTED
    * Camera path animation
    *
    * @apimethod human.send
    * @function path
    * @memberof camera
    *
    * @param {object} params
    * @param {object[]} params.points
    *
    * @param {object} params.points[].position - Camera position (eye)
    * @param {number} params.points[].position.x
    * @param {number} params.points[].position.y
    * @param {number} params.points[].position.z
    * @param {object} params.points[].target - Camera Target position (look at)
    * @param {number} params.points[].target.x
    * @param {number} params.points[].target.y
    * @param {number} params.points[].target.z
    * @param {object} [params.points[].up] - Camera Up Vector
    * @param {number} params.points[].up.x
    * @param {number} params.points[].up.y
    * @param {number} params.points[].up.z
    * @param {number} [params.velocity=1] - Camera velocity
    * @param {boolean} [params.constrainUp=false] - Fix camera up vector
    * @param {boolean} [params.easeIn=false] - Whether to ease in the animation
    * @param {boolean} [params.easeOut=true] - Whether to ease out the animation
    *
    * @param {function} [callback]
    *
    * @example <caption>Define a camera path</caption> <codepen>http://codepen.io/biodigital/pen/88c88c62d9b9f4fd0a08209220cc8b7c</codepen>
    * // Get initial camera position
    * human.send("camera.info", function(info) {
    *
    * // Define camera path.
    * // Initial camera position is inserted into path
    * // to avoid an initial jump.
    * human.send("camera.path", {
    *     points: [
    *     {
    *         position: info.position,
    *         target: info.target,
    *         up: info.up
    *     },
    *     {
    *         position: {
    *             x: 7.2915048649119685,
    *             y: 26.166339470455814,
    *             z: -11.74759554602381
    *         },
    *         target: {
    *             x: -0.06749999523162842,
    *             y: 19.702000617980957,
    *             z: 0.15849995613098145
    *         },
    *         up: {
    *             y:1
    *         }
    *     },
    *     ...
    *     ],
    *     velocity: 0.1,
    *     easeIn: false,
    *     easeOut: false,
    *     constrainUp: true
    * },
    * function() {
    *     console.log("Camera path animation complete!");
    * });
    */
Human.rpc.define("camera.path", function (params) {
    "use strict";
    var self = this;

    Human.renderer.camera.fly.flyAlongCurvePath(params,
        function () {
            self.setResult(true);
        });
});

/**
 * Set action to be triggered when an object is picked
 *
 * @apimethod human.send
 * @function pickingMode
 * @memberof scene
 *
 * @param {string} mode - Picking mode: "dissect" removes picked objects,
 * "highlight" highlights picked objects, "annotate" annotates picked objects
 *
 * @example <caption>Picking mode</caption> <codepen>http://codepen.io/biodigital/pen/17ae01cc6c14533f48c18a7e26fa4e15</codepen>
 * // Initialize API
 * var human = new HumanAPI("embeddedHuman");
 *
 * console.log("Alternating between highlight and dissect picking modes");
 *
 * var mode = "highlight";
 *
 * (function switchMode() {
 *     human.send("scene.pickingMode", mode);
 *
 *     mode = mode === "highlight" ? "dissect" : "highlight";
 *
 *     setTimeout(switchMode, 4000);
 * })();
 *
 * human.on("scene.pickingModeUpdated", function(event) {
 *     console.log("Enabling " + event.pickingMode + " mode. Click to " + event.pickingMode + " an object");
 * });
 */
Human.rpc.define("scene.pickingMode",
    function (mode) {
        "use strict";
        if (mode === "dissect") {
            Human.events.blockEvents(function() {
                Human.view.annotations.setEnabled(false);
            });
            Human.view.dissect.setEnabled(true);
        } else if (mode === "annotate") {
            Human.events.blockEvents(function() {
                Human.view.dissect.setEnabled(false);
            });
            Human.view.annotations.setEnabled(true);
        } else if (mode === "highlight") {
            Human.events.blockEvents(function() {
                Human.view.dissect.setEnabled(false);
                Human.view.annotations.setEnabled(false);
            });
            Human.view.highlight.setEnabled(true);
        } else if (mode === "none") {
            Human.events.blockEvents(function() {
                Human.view.dissect.setEnabled(false);
                Human.view.annotations.setEnabled(false);
                Human.view.highlight.setEnabled(false);
                Human.view.xray.setEnabled(false);
            });
        }

        this.setResult(true);
    });

/**
 * Set behavior of selected objects
 *
 * @apimethod human.send
 * @function selectionMode
 * @memberof scene
 *
 * @fires scene.selectionModeUpdated
 *
 * @param {string} mode - Selection mode: "isolate" hides all unselected object,
 * "highlight" highlights selected objects, "none" does nothing
 *
 * @example <caption>Selection mode</caption> <codepen>http://codepen.io/biodigital/pen/6db6bbd189097f63aeec640a165e45ff</codepen>
 * // Initialize API
 * var human = new HumanAPI("embeddedHuman");
 *
 * console.log("Switch between highlight and isolate selection modes");
 *
 * // These commands will be buffered before Human is loaded
 * human.send("scene.selectObjects", {
 *     "maleAdult_standard-Left_Craniofacial_Bones_ID": true
 * });
 *
 * var mode = "highlight";
 * var select = true;
 *
 * (function switchMode() {
 *     human.send("scene.selectionMode", mode);
 *
 *     mode = mode === "highlight" ? "isolate" : "highlight";
 *
 *     setTimeout(switchMode, 6000);
 * })();
 *
 * (function toggleSelect() {
 *     console.log("Change selected object")
 *     human.send("scene.selectObjects", {
 *         "maleAdult_standard-Left_Craniofacial_Bones_ID": select,
 *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !select
 *     });
 *
 *     select = !select;
 *
 *     setTimeout(toggleSelect, 2000);
 * })();
 *
 * human.on("scene.selectionModeUpdated", function(event) {
 *     console.log("Enabling " + event.selectionMode + " mode. Will " + event.selectionMode + " selected objects");
 * });
 */
Human.rpc.define("scene.selectionMode",
    function (mode) {
        "use strict";
        if (mode === "isolate") {
            Human.events.blockEvents(function() {
                Human.view.highlight.setEnabled(false);
            });
            Human.view.isolate.setEnabled(true);
        } else if (mode === "highlight") {
            Human.events.blockEvents(function() {
                Human.view.isolate.setEnabled(false);
            });
            Human.view.highlight.setEnabled(true);
        } else if (mode === "none") {
            Human.events.blockEvents(function() {
                Human.view.isolate.setEnabled(false);
            });
            Human.view.highlight.setEnabled(false);
        }

        this.setResult(true);
    });

// legacy RPC methods and events, hidden
    
Human.rpc.hideDefinitions(function() {
    "use strict";

    Human.rpc.defineEvent("human.error", {
        events: ["error"]
    });

    /** Captures a bookmark of current Human state, returns it as JSON
     *
     */
    Human.rpc.define("bookmarks.capture",
        function () {
            this.setResult(Human.bookmarks.capture());
        });

    /** Restores Human state from given bookmark JSON
     */
    Human.rpc.define("bookmarks.restore",
        function (params) {
            var self = this;
            Human.bookmarks.restore(params, function () {
                self.setResult(true);
            });
        });

    /**
     * Unsubscribes from an engine event
     */
    Human.rpc.define("events.off",
        function (params) {
            if (params.id) {
                // Undo specific subscription
                unbindEvent(params.id);
            } else if (params.ids) {
                // Undo list of subscriptions
                var ids = params.ids;
                for (var i = 0, len = ids.length; i < len; i++) {
                    unbindEvent(ids[i]);
                }
            } else {
                // Undo all subscriptions
                for (var id in callbacks) {
                    if (callbacks.hasOwnProperty(id)) {
                        unbindEvent(id);
                    }
                }
            }
        });

    Human.rpc.define("camera.query", function () {
        var camera = Human.renderer.camera.getLookAt();
        camera.zoom = Human.renderer.camera.getZoom();

        this.setResult(camera);
    });

    Human.rpc.define("properties.query",
        function (params) {
            this.setResult(Human.properties.query(params.regex));
        });

    Human.rpc.define("actions.doAction",
        function (params) {
            Human.actions._doAction([params.action, params.arguments]);
        });

    Human.rpc.define("alert",
        function (params) {
            window.alert(params.message || "");
        });

    Human.rpc.define("videos.getClips",
        function () {
            this.setResult(Human.media.videos.clipsList);
        });

    Human.rpc.define("videos.open",
        function (params) {
            var self = this;
            Human.media.videos.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("videos.play",
        function (params) {
            Human.media.videos.play(params.clipId);
        });

    Human.rpc.define("videos.scrub",
        function (params) {
            Human.media.videos.scrub(params.clipId, params.time);
        });

    Human.rpc.define("videos.pause",
        function (params) {
            Human.media.videos.pause(params.clipId);
        });

    Human.rpc.define("videos.stop",
        function (params) {
            Human.media.videos.stop(params.clipId);
        });

    Human.rpc.define("videos.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });

    Human.rpc.define("audio.getClips",
        function () {
            this.setResult(Human.media.audio.clipsList);
        });

    Human.rpc.define("audio.open",
        function (params) {
            var self = this;
            Human.media.audio.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("audio.play",
        function (params) {
            Human.media.audio.play(params.clipId);
        });

    Human.rpc.define("audio.scrub",
        function (params) {
            Human.media.audio.scrub(params.clipId, params.time);
        });

    Human.rpc.define("audio.pause",
        function (params) {
            Human.media.audio.pause(params.clipId);
        });

    Human.rpc.define("audio.stop",
        function (params) {
            Human.media.audio.stop(params.clipId);
        });

    Human.rpc.define("audio.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });

    Human.rpc.define("modules.getModules",
        function (params) {
            this.setResult(Human.modules.query(params));
        });

    Human.rpc.define("modules.activate",
        function (params) {
            var self = this;
            Human.modules.activateModules(params,
                function () {
                    self.setResult(true); // Activated
                });
        });

    Human.rpc.define("modules.deactivate",
        function (params) {
            Human.modules.deactivateModules(params);
        });

    Human.rpc.define("properties.subscribe",
        function (params) {
            var self = this;
            Human.properties.subscribe({
                subId: params.subId,
                propId: "myProperty",
                callback: function (value) {
                    self.setResult(value);
                }
            });
        });

    Human.rpc.define("properties.resubscribe",
        function (params) {
            Human.properties.resubscribe(params.subId, params.propId);
        });

    Human.rpc.define("properties.unsubscribe",
        function (params) {
            Human.properties.unsubscribe(params.subId);
        });

    Human.rpc.define("renderer.getBGColor", function () {
        this.setResult(Human.renderer.bg.getBGColor());
    });

    Human.rpc.define("renderer.setBGColor", function (params) {
        Human.renderer.bg.setBGColor(params.color);
    });

    Human.rpc.define("request.getParams",
        function () {
            this.setResult({
                hashParams: Human.request.getHashParams(),
                hashStr: Human.request.getHashStr(),
                searchParams: Human.request.getSearchParams(),
                searchStr: Human.request.getSearchStr()
            });
        });

    /**
     * @event scene.pickingModeUpdated
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.pickingMode
     */
    var pickingMode;

    Human.rpc.defineEvent("scene.pickingModeUpdated", {
        events: ["highlight.toggled", "dissect.toggled", "annotations.toggled"],
        map: function () {
            var newPickingMode;

            if (Human.view.dissect.enabled) {
                newPickingMode = "dissect";
            } else if (Human.view.annotations.enabled) {
                newPickingMode = "annotate";
            } else if (Human.view.highlight.enabled) {
                newPickingMode = "highlight";
            }

            if (newPickingMode === pickingMode) {
                return null;
            }

            pickingMode = newPickingMode;

            return {
                pickingMode: pickingMode
            };
        }
    });

    /**
     * @event scene.selectionModeUpdated
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.selectionMode
     */
    var selectionMode;

    Human.rpc.defineEvent("scene.selectionModeUpdated", {
        events: ["highlight.toggled", "isolate.toggled"],
        map: function () {
            var newSelectionMode;

            if (Human.view.isolate.enabled) {
                newSelectionMode = "isolate";
            } else if (Human.view.highlight.enabled) {
                newSelectionMode = "highlight";
            } else {
                newSelectionMode = "none";
            }

            if (newSelectionMode === selectionMode) {
                return null;
            }

            selectionMode = newSelectionMode;

            return {
                selectionMode: selectionMode
            };
        }
    });

    Human.rpc.define("scene.queryBoundary",
        function (params) {
            var boundary, object, fmaId;
            if (params.objectId && Human.scene.objects[params.objectId]) {

                // Get boundary of object by ID
                boundary = Human.scene.objects[params.objectId].getBoundary();

            } else if (params.fmaId) {

                // get boundary of object by FMA ID
                fmaId = params.fmaId;
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
                boundary = object.getBoundary();

            } else if (params.objectIds) {

                // Get collective boundary of multiple objects by IDs
                boundary = Human.scene.getBoundary({ objectIds: params.objectIds });

            } else if (params.fmaIds) {

                // Get collective boundary of multiple objects by FMA IDs
                var fmaIds = params.fmaIds;
                var objectIds = [];
                for (var i = 0, len = fmaIds.length; i < len; i++) {
                    fmaId = fmaIds[i];
                    object = Human.scene.objectsByFMAID[fmaId];
                    if (!object) {
                        this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                        return;
                    }
                    objectIds.push(object.objectId);
                }
                boundary = Human.scene.getBoundary({ objectIds: objectIds });

            } else if (params.selectedObjects) {

                // Get collective boundary of all currently selected objects
                boundary = Human.scene.getBoundary({ objects: Human.scene.selectedObjects });
            } else if (params.enabledObjects) {

                // Get collective boundary of all currently visible objects
                boundary = Human.scene.getBoundary({ objects: Human.scene.enabledObjects });
            } else {

                // Default: get boundary of all objects
                boundary = Human.scene.getBoundary();
            }
            this.setResult(boundary);
        });


    function fmaIdsToObjectIds(map) {
        var result = {};
        var objectsByFMA = Human.rpc.fmaIds;
        var objectIds;
        var maleStateId = Human.modules.MALE_STATE_ID;
        var femaleStateId = Human.modules.FEMALE_STATE_ID;
        for (var fmaId in map) {
            if (map.hasOwnProperty(fmaId)) {
                objectIds = objectsByFMA[fmaId];
                for (var i = 0; i < objectIds.length; i++) {
                    var object = Human.scene.objects[maleStateId + "-" + objectIds[i]] ||
                        Human.scene.objects[femaleStateId + "-" + objectIds[i]];
                    if (object) {
                        result[object.objectId] = map[fmaId];
                    }
                }
            }
        }
        return result;
    }

    (function () {
        var canvas = document.getElementById('theCanvas');

        var getCanvasPos = function (worldPos, offset) {
            if(offset) {
                vec3.add(worldPos, offset, worldPos);
            }

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var projPos = vec4.create();

            vec3.transformMat4(projPos, worldPos, viewMat);
            projPos[3]  = 1; // Need homogeneous 'w' for perspective division
            vec4.transformMat4(projPos, projPos, projMat);

            var x = projPos[0];
            var y = projPos[1];
            var w = projPos[3];

            return [
                Math.round((1 + x / w) * canvas.width  / 2),
                Math.round((1 - y / w) * canvas.height / 2)
            ];
        };

        Human.rpc.define("scene.getObjectCanvasPos",
            function (params) {
               var object = Human.scene.objects[params.objectId];

               if(object) {
                   var worldPos = object.getCenter();
                   this.setResult(getCanvasPos(worldPos, params.offset));
               }
            });
    })();

        // Captures bookmark of timeline playing state
    Human.rpc.define("timeline.getBookmark",
        function () {
            this.setResult(Human.timeline.getBookmark());
        });

    // Restores playing state of timeline to given bookmark
    Human.rpc.define("timeline.setBookmark",
        function (params) {
            Human.timeline.setBookmark(params);
        });

     Human.rpc.define("clip.set",
        function (params) {
            if (params.clips) {
                var clips = params.clips;
                var clip;
                for (var clipId in clips) {
                    if (clips.hasOwnProperty(clipId)) {
                        clip = clips[clipId];
                        clip.clipId = clipId;
                        Human.renderer.clip.setClip(clip);
                    }
                }
            } else if (params.clip) {
                Human.renderer.clip.setClip(params.clip);
            }
        });

    Human.rpc.define("clip.reset",
        function () {
            Human.renderer.clip.reset();
        });

        /**
     * Queries what effects exist
     */
    Human.rpc.define("effects.getEffects",
        function () {
            var result = [];
            var effect;
            var effects = Human.view.effects.effects;
            for (var effectId in effects) {
                if (effects.hasOwnProperty(effectId)) {
                    effect = effects[effectId];
                    result.push({
                        effectId: effectId,
                        displayName: effect.displayName,
                        description: effect.description,
                        enabled: effect.enabled,
                        params: effect.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables effects
     */
    Human.rpc.define("effects.setEnabled",
        function (params) {
            Human.view.effects.setEnabled(params);
        });

    /**
     * Sets parameters for effects
     */
    Human.rpc.define("effects.setParams",
        function (params) {
            Human.view.effects.setParams(params);
        });


    // Human.rpc.define("labels.create",
    //     function (params) {
    //         if (!params.objectId) {
    //             this.error("parameter expected: 'objectId'");
    //             return;
    //         }
    //         if (params.replace) {
    //             Human.view.labels.clearLabels();
    //         }
    //         Human.view.labels.createLabel(params);
    //     });

    // Human.rpc.define("labels.clear",
    //     function () {
    //         Human.view.labels.clearLabels();
    //     });

    /**
     * Queries what lights exist
     */
    Human.rpc.define("lights.getLights",
        function () {
            var result = [];
            var light;
            var lights = Human.renderer.lights.lights;
            for (var lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = lights[lightId];
                    result.push({
                        lightId: lightId,
                        displayName: light.displayName,
                        description: light.description,
                        enabled: light.enabled,
                        params: light.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables lights
     */
    Human.rpc.define("lights.setEnabled",
        function (params) {
            Human.renderer.lights.setEnabled(params);
        });

    /**
     * Sets parameters for lights
     */
    Human.rpc.define("lights.setParams",
        function (params) {
            Human.renderer.lights.setParams(params);
        });

    Human.rpc.define("highlight.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.highlight.enabled;
            }
            Human.view.highlight.setEnabled(enable);
            if (enable) {
                Human.view.isolate.setEnabled(false);
                Human.view.xray.setEnabled(false);
            }
        });

    Human.rpc.define("isolate.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.isolate.enabled;
            }
            Human.view.isolate.setEnabled(enable);
            if (enable) {
                var selection = Human.scene.anySelected();
                if (!selection) {
                    return;
                }
            }
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.xray.setEnabled(false);
                Human.renderer.pick.setSinglePickEnabled(true); // Multi-pick doesn't make sense in Isolate mode
                Human.renderer.pick.setMultiPickEnabled(false);
            }
        });

    Human.rpc.define("pick.doublePick",
        function (params) {
            Human.renderer.pick.doublePick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("pick.hoverPick",
        function (params) {
            Human.renderer.pick.hoverPick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("xray.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.xray.enabled;
            }
            Human.view.xray.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.isolate.setEnabled(false);
            }
        });

    Human.rpc.define("queryModes",
        function () {
            var data = {
                xray: Human.view.xray.enabled,
                highlight: Human.view.highlight.enabled,
                annotation: Human.view.annotations.enabled,
                singlePick: Human.renderer.pick.singleEnabled,
                multipick: Human.renderer.pick.multiEnabled,
                dissect: Human.view.dissect.enabled
            };
            this.setResult(data);
        });

    Human.rpc.define("navigation.setEnabled",
        function (params) {
            _setUIEnabled('navigator_container', params.enable);
        });

    Human.rpc.define("fullscreen.setEnabled",
        function (params) {
            _setUIEnabled('embed-full-screen', params.enable);
        });

    var reporters = Human.log.reporters;
    var messageBuf = Human.log.messageBuf;

    // Creates a log reporter
    // For network efficiency, this allows networked clients to only get
    // logging if they are interested in it. Potentially this is also
    // good for compression of that logging.
    Human.rpc.define("log.createReporter",
        function (params) {
            if (!params.id) {
                Human.log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            if (reporters[id]) {
                // TODO: complain
                return;
            }
            reporters[id] = {};
            // Update reporter with events so far
            for (var i = 0, len = messageBuf.length; i < len; i++) {
                Human.events.fire(id, messageBuf[i]);
            }
        });

    // Destroys a log reporter
    Human.rpc.define("log.destroyReporter",
        function (params) {
            if (!params.id) {
                Human.log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            delete reporters[id];
        });

    // Annotation object -> plain result object, only primitives, no private props
    function makeAnnotationResult(annotation) {
        var result = {};
        var value;

        for (var key in annotation) {
            if (annotation.hasOwnProperty(key)) {
                value = annotation[key];

                if(Human.utils.isPrimitive(value) && key[0] !== '_') {
                    result[key] = value;
                }
            }
        }

        // special prop adapting
        result.objectId = annotation.object ? annotation.object.objectId : "";

        result.title = annotation.label.title;
        result.description = annotation.label.description;

        result.pos = annotation.pin.pos;
        result.pinVec = annotation.pin.dir;
        result.visible = annotation.pin.visible;

        return result;
    }

    Human.rpc.define("annotations.getAnnotations",
        function () {
            var annotations = Human.view.annotations.annotations;
            var result = {};
            var annotation;

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    result[annotationId] = makeAnnotationResult(annotation);
                }
            }

            this.setResult(result);
        });

    Human.rpc.define("camera.flyTo", function (params) {
        var self = this;
        Human.renderer.camera.fly.flyTo(params,
            function () {
                self.setResult(true);
            });
    });


    Human.rpc.define("camera.jumpTo", function (params) {
        var self = this;
        Human.renderer.camera.fly.jumpTo(params,
            function () {
                self.setResult(true);
            });
    });

    Human.rpc.define("camera.getZoom", function () {
        this.setResult(Human.renderer.camera.getZoom());
    });

    var callbacks = {};

    /**
     * Subscribes to an engine event
     */
    Human.rpc.define("events.on",
        function (params) {
            var self = this;
            var id = this.id;
            if (id) {
                if (callbacks[id]) {
                    // Support "events.off" for this subscription
                    this.error("an event is already bound to this ID: '" + id + "'");
                    return;
                }
            }
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            var fn = function (event) {
                self.setResult(event);
            };
            if (params.mask) {
                params.fn = fn;
                Human.events.on(params);
            } else {
                Human.events.on(params.type, fn);
            }
            if (id) { // So we can unbind with "events.off"
                callbacks[id] = [type, fn];
            }
        });

    /**
     * Subscribes to the next engine event of the given type
     */
    Human.rpc.define("events.once",
        function (params) {
            var self = this;
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            Human.events.once(type, function (event) {
                self.setResult(event);
            });
        });

    function unbindEvent(id) {
        var callback = callbacks[id];
        if (callback) {
            var type = callback[0];
            var fn = callback[1];
            Human.unEvent(type, fn);
            delete callbacks[id];
        }
    }

    /**
     * Triggers an engine event
     */
    Human.rpc.define("events.fire",
        function (params) {
            Human.events.fire(params.eventName, params.params);
        });

    Human.rpc.define("reset",
        function () {
            var self = this;
            Human.init.reset(function () {
                    self.setResult(true);
                });
        });

    Human.rpc.define("reload",
        function () {
            Human.init.reload();
        });

    Human.rpc.define("pick.pick",
        function (params) {
            Human.renderer.pick.pick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });


    Human.rpc.define("pick.queryPick",
        function (params) {
            this.setResult(Human.renderer.pick.queryPick({ canvasX: params.canvasX, canvasY: params.canvasY, rayPick: params.rayPick }) || {});
        });

    Human.rpc.define("scene.setEnabledObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            Human.scene.setEnabledObjects({ objects: objectIds, replace: params.replace });
        });

    Human.rpc.define("scene.setSelectedObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            params.objectIds = objectIds;
            Human.scene.setSelectedObjects(params);
        });

    (function () {
        Human.rpc.define("scene.getObjects",
            function (params) {
                var result = [];
                var object;
                if (params.objectId) {
                    var objectId = params.objectId;
                    object = Human.scene.objects[objectId];
                    if (object) {
                        result.push(getObjectDescription(object));
                    }
                } else {
                    // Get parent objects before their children so that on the API side we
                    // will always create HumanAPI.Objects for the parents BEFORE those for
                    // their children, so that each child's HumanAPI.Object can be instantiated
                    // with a reference to its parent's HumanAPI.Object.
                    for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
                        traverseObjects(Human.scene.rootObjects[i], result);
                    }
                }
                this.setResult(result);
            });

        function traverseObjects(object, result) {
            if (!object) {
                return;
            }
            result.push(getObjectDescription(object));
            for (var i = 0, len = object.objects.length; i < len; i++) {
                traverseObjects(object.objects[i], result);
            }
        }

        function getObjectDescription(object) {
            var desc = {};

            for (var prop in object) {
                if (object.hasOwnProperty(prop) && prop[0] !== "_") {
                    var value = object[prop];

                    if (Human.utils.isPrimitive(value)) {
                        desc[prop] = value;
                    }
                }
            }

            desc.parentObjectId = object.parent ? object.parent.objectId : null;

            return desc;
        }
    })();



    Human.rpc.define("scene.setObjectTransform",
        function (params) {
            var objectId = params.objectId;
            var fmaId = params.fmaId;
            var object;
            if (objectId) { // Find object by ID
                object = Human.scene.objects[objectId];
                if (!object) {
                    this.error("Scene object not found: '" + objectId + "'");
                    return;
                }
            } else if (fmaId) { // Find object by FMA ID
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("scene object not found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
            }
            object.setTransform(params);
        });

    /**
     * Scrub timeline to time or chapter
     *
     * Scrub to given time in seconds:
     *
     * {
     *    time: 15
     * }
     *
     * Scrub to start of given chapter:
     *
     * {
     *    chapterId: "makeIncision"
     * }
     *
     */
    Human.rpc.define("timeline.scrub",
        function (params) {
            Human.timeline.scrub(params);
        });

    // Stops timeline if currently playing
    Human.rpc.define("timeline.stop",
        function () {
            Human.timeline.stop();
        });

    // Winds timeline to start of previous chapter
    Human.rpc.define("timeline.prev",
        function () {
            Human.timeline.prev();
        });

    // Winds timeline to start of next chapter
    Human.rpc.define("timeline.next",
        function () {
            Human.timeline.next();
        });

    // Unpauses timeline if currently paused
    Human.rpc.define("timeline.unpause",
        function () {
            Human.timeline.unpause();
        });

    Human.rpc.define("properties.set",
        function (params) {
            //backwards compatibility for older API libraries
            var props = params.props || params;
            Human.properties.set(props || {});
        });

    //Private methods

    var _setUIEnabled = function (id, enable) {
      var _enable = (typeof enable === 'undefined') ? true : enable;
      var el = document.getElementById(id);
      el.style.display = (_enable) ? 'block' : 'none';
    };
});
;Human.rpc.fmaIds = {
    "3734": [
        "Base_of_aorta_3734_ID"
    ],
    "3768": [
        "Aortic_arch_3768_ID"
    ],
    "3784": [
        "Descending_Aorta_3784_ID"
    ],
    "3818": [
        "Marginal_branch_of_right_coronary_artery_3818_ID"
    ],
    "3829": [
        "Anterior_atrial_branch_of_right_coronary_artery_3829_ID"
    ],
    "3837": [
        "Posterior_left_ventricular_branch_of_left_coronary_artery_3837_ID"
    ],
    "3932": [
        "left_lower_subclavian_artery_3932_ID",
        "Right_Brachiocephalic_trunk_3932_ID"
    ],
    "3941": [
        "Right_common_carotid_artery_3941_ID"
    ],
    "3945": [
        "Right_external_carotid_artery_3945_ID"
    ],
    "3949": [
        "Right_Internal_Carotid_Artery_3949_ID"
    ],
    "3950": [
        "Right_Internal_Carotid_Artery_3950_ID"
    ],
    "3958": [
        "Right_Vertebral_Artery_3958_ID"
    ],
    "3969": [
        "Right_internal_thoracic_artery_3969_ID"
    ],
    "3988": [
        "Superior_right_epigastric_artery_3988_ID",
        "Right_Superior_epigastric_artery_3988_ID"
    ],
    "4058": [
        "Left_common_carotid_artery_4058_ID",
        "Base_of_left_common_carotid_artery_4058_ID",
        "Base_of_Left_common_carotid_artery_4058_ID"
    ],
    "4060": [
        "Left_external_carotid_artery_4060_ID"
    ],
    "4062": [
        "Left_Internal_Carotid_Artery_4062_ID"
    ],
    "4066": [
        "Left_Vertebral_Artery_4066_ID"
    ],
    "4068": [
        "Left_internal_thoracic_artery_4068_ID"
    ],
    "4083": [
        "Left_Superior_epigastric_artery_4083_ID"
    ],
    "4085": [
        "Right_costocervical_trunk_4085_ID"
    ],
    "4086": [
        "Right_costocervical_trunk_4086_ID",
        "Left_costocervical_trunk_4086_ID"
    ],
    "4134": [
        "Left_deep_cervical_artery_4134_ID",
        "left_deep_cervical_artery_4134_ID"
    ],
    "4634": [
        "Right_Subcostal_artery_4634_ID",
        "Right_subcostal_artery_4634_ID"
    ],
    "4654": [
        "Left_Subcostal_artery_4654_ID",
        "Left_subcostal_artery_4654_ID"
    ],
    "4693": [
        "Right_subclavian_artery_4693_ID"
    ],
    "4694": [
        "left_subclavian_artery_4694_ID",
        "Left_Lower_Subclavian_artery_4694_ID",
        "right_subclavian_artery_4694_ID"
    ],
    "4706": [
        "Coronary_sinus_4706_ID"
    ],
    "4707": [
        "Great_cardiac_vein_4707_ID"
    ],
    "4712": [
        "Posterior_vein_of_left_ventricle_4712_ID"
    ],
    "4713": [
        "Middle_cardiac_vein_4713_ID"
    ],
    "4714": [
        "Small_cardiac_vein_4714_ID"
    ],
    "4715": [
        "Oblique_vein_of_left_atrium_4715_ID"
    ],
    "4720": [
        "Superior_Vena_Cava_4720_ID"
    ],
    "4728": [
        "Inferior_Thyroid_vein_4728_ID"
    ],
    "4751": [
        "Right_Brachiocephalic_vein_4751_ID",
        "Right_brachiocephalic_vein_4751_ID"
    ],
    "4755": [
        "Right_internal_jugular_vein_4755_ID"
    ],
    "4756": [
        "Right_Vertebral_vein_4756_ID"
    ],
    "4758": [
        "Right_internal_thoracic_vein_4758_ID"
    ],
    "4761": [
        "Left_Brachiocephalic_vein_4761_ID",
        "Left_brachiocephalic_vein_4761_ID"
    ],
    "4763": [
        "Left_internal_jugular_vein_4763_ID"
    ],
    "4764": [
        "Left_Vertebral_vein_4764_ID"
    ],
    "4766": [
        "Left_internal_thoracic_vein_4766_ID"
    ],
    "4771": [
        "Right_Superior_epigastric_vein_4771_ID",
        "Right_superior_epigastric_vein_4771_ID"
    ],
    "4785": [
        "Left_superior_epigastric_vein_4785_ID"
    ],
    "4838": [
        "Azygos_Vein_4838_ID",
        "Azygos_vein_4838_ID"
    ],
    "4843": [
        "Right_ascending_lumbar_vein_4843_ID"
    ],
    "4944": [
        "Hemiazgos_vein_4944_ID",
        "Hemiazygos_vein_4944_ID"
    ],
    "4950": [
        "Left_ascending_lumbar_vein_4950_ID"
    ],
    "5011": [
        "Left_Accessory_Hemiazgos_vein_5011_ID",
        "Left_Accessory_Hemiazygos_vein_5011_ID"
    ],
    "5883": [
        "Right_Splanchnic_Nerve_5883_ID",
        "Left_Splanchnic_Nerve_5883_ID"
    ],
    "6192": [
        "Right_Phrenic_Nerve_6192_ID"
    ],
    "6193": [
        "Left_Phrenic_Nerve_6193_ID"
    ],
    "6246": [
        "Left_Recurrent_Laryngeal_Nerve_6246_ID",
        "Right_Recurrent_Laryngeal_Nerve_6246_ID"
    ],
    "6258": [
        "Left_Sympathetic_Chain_6258_ID",
        "Right_Sympathetic_Chain_6258_ID"
    ],
    "6259": [
        "Right_Sympathetic_Chain_6259_ID"
    ],
    "6442": [
        "Left_C1_Spinal_Nerve_6442_ID",
        "Right_C1_Spinal_Nerve_6442_ID"
    ],
    "6451": [
        "Left_C2_Spinal_Nerve_6451_ID",
        "Right_C2_Spinal_Nerve_6451_ID"
    ],
    "6453": [
        "Left_C3_Spinal_Nerve_6453_ID",
        "Right_C3_Spinal_Nerve_6453_ID"
    ],
    "6456": [
        "Left_C4_Spinal_Nerve_6456_ID",
        "Right_C4_Spinal_Nerve_6456_ID"
    ],
    "6457": [
        "Right_C5_Spinal_Nerve_6457_ID",
        "Left_C5_Spinal_Nerve_6457_ID"
    ],
    "6459": [
        "Left_C6_Spinal_Nerve_6459_ID",
        "Right_C6_Spinal_Nerve_6459_ID"
    ],
    "6461": [
        "Right_C7_Spinal_Nerve_Group_6461_ID",
        "Left_C7_Spinal_Nerve_6461_ID",
        "Right_C7_Spinal_Nerve_6461_ID",
        "Left_C7_Spinal_Nerve_Group_6461_ID"
    ],
    "6465": [
        "Left_C8_Spinal_Nerve_6465_ID",
        "Right_C8_Spinal_Nerve_6465_ID"
    ],
    "6582": [
        "Ansa_Subclavia_6582_ID"
    ],
    "6642": [
        "Superior_hypogastric_nerve_plexus_6642_ID"
    ],
    "6643": [
        "Inferior_hypogastric_nerve_plexus_6643_ID"
    ],
    "6647": [
        "Prostatic_nerve_plexus_6647_ID"
    ],
    "7088": [
        "Heart_7088_ID"
    ],
    "7096": [
        "Right_atrium_7096_ID"
    ],
    "7097": [
        "Left_atrium_7097_ID"
    ],
    "7098": [
        "Right_Ventricle_7098_ID"
    ],
    "7101": [
        "Left_Ventricle_7101_ID"
    ],
    "7131": [
        "Esophagus_7131_ID"
    ],
    "7133": [
        "Interventricular_Septum_7133_ID"
    ],
    "7148": [
        "Stomach_7148_ID"
    ],
    "7196": [
        "Spleen_7196_ID"
    ],
    "7197": [
        "Liver_7197_ID"
    ],
    "7198": [
        "Pancreas_7198_ID"
    ],
    "7200": [
        "Small_intestine_7200_ID"
    ],
    "7202": [
        "Gallbladder_7202_ID"
    ],
    "7204": [
        "Left_Kidney_7204_ID",
        "Right_Kidney_7204_ID"
    ],
    "7205": [
        "Right_Kidney_7205_ID",
        "Left_Kidney_7205_ID"
    ],
    "7206": [
        "Duodenum_7206_ID"
    ],
    "7207": [
        "Jejunum_7207_ID"
    ],
    "7208": [
        "Ileum_7208_ID"
    ],
    "7209": [
        "Ovaries_7209_ID"
    ],
    "7211": [
        "Right_testis_7211_ID"
    ],
    "7212": [
        "Left_testis_7212_ID"
    ],
    "7213": [
        "Right_Ovary_7213_ID"
    ],
    "7214": [
        "Left_Ovary_7214_ID"
    ],
    "7218": [
        "Right_auricle_7218_ID"
    ],
    "7219": [
        "Left_auricle_7219_ID"
    ],
    "7234": [
        "Tricuspid_Valve_7234_ID"
    ],
    "7235": [
        "Mitral_valve_7235_ID"
    ],
    "7236": [
        "Aortic_Valve_7236_ID"
    ],
    "7246": [
        "Pulmonary_Valve_7246_ID"
    ],
    "7309": [
        "Right_Lung_7309_ID"
    ],
    "7310": [
        "Left_Lung_7310_ID"
    ],
    "7333": [
        "Right_Superior_Lobe_7333_ID"
    ],
    "7337": [
        "Right_Inferior_Lobe_7337_ID"
    ],
    "7370": [
        "Left_Superior_Lobe_7370_ID"
    ],
    "7371": [
        "Left_Inferior_Lobe_7371_ID"
    ],
    "7383": [
        "Right_Middle_Lobe_7383_ID"
    ],
    "7394": [
        "Trachea_7394_ID"
    ],
    "7486": [
        "manubrium_of_sternum_7486_ID",
        "body_of_sternum_7486_ID"
    ],
    "7591": [
        "Right_Costal_Cartilage_7591_ID",
        "Left_Costal_Cartilage_7591_ID"
    ],
    "7592": [
        "Left_Costal_Cartilage_7592_ID",
        "Right_Costal_Cartilage_7592_ID"
    ],
    "7647": [
        "spinal_cord_7647_ID"
    ],
    "7857": [
        "Left_first_rib_7857_ID",
        "Right_first_rib_7857_ID"
    ],
    "7882": [
        "Right_second_rib_7882_ID"
    ],
    "7883": [
        "Left_second_rib_7883_ID"
    ],
    "7909": [
        "Right_third_rib_7909_ID"
    ],
    "7910": [
        "Left_third_rib_7910_ID"
    ],
    "7957": [
        "Right_fourth_rib_7957_ID"
    ],
    "7958": [
        "Left_fourth_rib_7958_ID"
    ],
    "8066": [
        "Right_fifth_rib_8066_ID",
        "Left_fifth_rib_8066_ID"
    ],
    "8175": [
        "Left_sixth_rib_8175_ID",
        "Right_sixth_rib_8175_ID"
    ],
    "8229": [
        "Left_seventh_rib_8229_ID",
        "Right_seventh_rib_8229_ID"
    ],
    "8283": [
        "Left_eighth_rib_8283_ID",
        "Right_eighth_rib_8283_ID"
    ],
    "8364": [
        "Left_ninth_rib_8364_ID",
        "Right_ninth_rib_8364_ID"
    ],
    "8445": [
        "Right_tenth_rib_8445_ID",
        "Left_tenth_rib_8445_ID"
    ],
    "8531": [
        "Left_eleventh_rib_8531_ID",
        "Right_eleventh_rib_8531_ID"
    ],
    "8533": [
        "Right_twelfth_rib_8533_ID",
        "Left_twelfth_rib_8533_ID"
    ],
    "8612": [
        "Pulmonary_trunk_8612_ID"
    ],
    "9165": [
        "First_thoracic_vertebra_9165_ID"
    ],
    "9187": [
        "Second_thoracic_vertebra_9187_ID"
    ],
    "9209": [
        "Third_thoracic_vertebra_9209_ID"
    ],
    "9248": [
        "Fourth_thoracic_vertebra_9248_ID"
    ],
    "9600": [
        "Prostate_9600_ID"
    ],
    "9603": [
        "Thyroid_Gland_9603_ID"
    ],
    "9615": [
        "Cricoid_cartilage_9615_ID"
    ],
    "9706": [
        "Bile_Ducts_9706_ID"
    ],
    "9707": [
        "Penis_9707_ID"
    ],
    "9710": [
        "Vomer_9710_ID"
    ],
    "9711": [
        "Maxilla_9711_ID"
    ],
    "9761": [
        "Right_Transversus_thoracis_9761_ID"
    ],
    "9762": [
        "Right_Transversus_thoracis_9762_ID",
        "Left_Transversus_thoracis_9762_ID"
    ],
    "9922": [
        "Fifth_thoracic_vertebra_9922_ID"
    ],
    "9945": [
        "Sixth_thoracic_vertebra_9945_ID"
    ],
    "9968": [
        "Seventh_thoracic_vertebra_9968_ID"
    ],
    "9991": [
        "Eighth_thoracic_vertebra_9991_ID"
    ],
    "10014": [
        "Ninth_thoracic_vertebra_10014_ID"
    ],
    "10037": [
        "Tenth_thoracic_vertebra_10037_ID"
    ],
    "10059": [
        "Eleventh_thoracic_vertebra_10059_ID"
    ],
    "10081": [
        "Twelfth_thoracic_vertebra_10081_ID"
    ],
    "10551": [
        "Right_dorsal_scapular_artery_10551_ID"
    ],
    "10552": [
        "right_dorsal_scapular_artery_10552_ID",
        "left_dorsal_scapular_artery_10552_ID"
    ],
    "10660": [
        "Right_deep_cervical_artery_10660_ID"
    ],
    "10679": [
        "Right_inferior_thyroid_artery_10679_ID"
    ],
    "10680": [
        "left_inferior_thyroid_artery_10680_ID",
        "Right_suprascapular_artery_10680_ID"
    ],
    "10681": [
        "left_suprascapular_artery_10681_ID",
        "Right_transverse_cervical_artery_10681_ID",
        "right_suprascapular_artery_10681_ID"
    ],
    "10682": [
        "left_transverse_cervical_artery_10682_ID",
        "Right_superficial_cervical_artery_10682_ID"
    ],
    "10683": [
        "left_superficial_cervical_artery_10683_ID"
    ],
    "10951": [
        "Inferior_vena_cava_10951_ID",
        "base_of_inferior_vena_cava_10951_ID"
    ],
    "12519": [
        "Atlas_C1_12519_ID"
    ],
    "12520": [
        "Axis_C2_12520_ID"
    ],
    "12521": [
        "Third_cervical_vertebra_12521_ID"
    ],
    "12522": [
        "Fourth_cervical_vertebra_12522_ID"
    ],
    "12523": [
        "Fifth_cervical_vertebra_12523_ID"
    ],
    "12524": [
        "Sixth_cervical_vertebra_12524_ID"
    ],
    "12525": [
        "Seventh_cervical_vertebra_12525_ID"
    ],
    "12770": [
        "Deep_lateral_cervical_lymph_nodes_12770_ID"
    ],
    "12858": [
        "Union_between_ascending_lumbar_veins_12858_ID"
    ],
    "13072": [
        "First_lumbar_vertebra_13072_ID"
    ],
    "13073": [
        "Second_lumbar_vertebra_13073_ID"
    ],
    "13074": [
        "Third_lumbar_vertebra_13074_ID"
    ],
    "13075": [
        "Fourth_lumbar_vertebra_13075_ID"
    ],
    "13076": [
        "Fifth_lumbar_vertebra_13076_ID"
    ],
    "13111": [
        "Right_external_jugular_vein_13111_ID"
    ],
    "13112": [
        "Left_external_jugular_vein_13112_ID",
        "Right_external_jugular_vein_13112_ID"
    ],
    "13113": [
        "Left_external_jugular_vein_13113_ID"
    ],
    "13295": [
        "Diaphragm_13295_ID"
    ],
    "13322": [
        "Right_Clavicle_13322_ID"
    ],
    "13323": [
        "Left_Clavicle_13323_ID"
    ],
    "13325": [
        "Right_cephalic_vein_13325_ID"
    ],
    "13326": [
        "right_cephalic_vein_13326_ID",
        "left_cephalic_vein_13326_ID"
    ],
    "13328": [
        "Left_Clavicle_13328_ID"
    ],
    "13336": [
        "Right_external_oblique_13336_ID"
    ],
    "13337": [
        "Left_external_oblique_13337_ID"
    ],
    "13346": [
        "Right_Sternohyoid_13346_ID"
    ],
    "13347": [
        "Left_Sternohyoid_13347_ID"
    ],
    "13350": [
        "Right_Sternothyroid_13350_ID"
    ],
    "13351": [
        "Left_Sternothyroid_13351_ID"
    ],
    "13352": [
        "Right_Thyrohyoid_13352_ID"
    ],
    "13353": [
        "Left_Thyrohyoid_13353_ID"
    ],
    "13354": [
        "Intercostal_Muscles_of_Left_Thorax_13354_ID",
        "Intercostal_Muscles_of_Right_Thorax_13354_ID"
    ],
    "13358": [
        "Right_latissimus_dorsi_13358_ID"
    ],
    "13359": [
        "Left_latissimus_dorsi_13359_ID"
    ],
    "13373": [
        "Right_pectoralis_major_13373_ID"
    ],
    "13374": [
        "Left_pectoralis_major_13374_ID",
        "Right_pectoralis_major_13374_ID"
    ],
    "13375": [
        "Right_Pectoralis_minor_13375_ID"
    ],
    "13376": [
        "Left_Pectoralis_minor_13376_ID",
        "Right_Pectoralis_minor_13376_ID"
    ],
    "13377": [
        "Right_Rectus_Abdominis_13377_ID"
    ],
    "13378": [
        "Left_Rectus_Abdominis_13378_ID"
    ],
    "13379": [
        "Right_Rectus_Abdominis_13379_ID"
    ],
    "13381": [
        "Right_Rhomboid_Major_13381_ID"
    ],
    "13382": [
        "Left_Rhomboid_Major_13382_ID"
    ],
    "13383": [
        "Right_Rhomboid_Minor_13383_ID"
    ],
    "13384": [
        "Left_Rhomboid_Minor_13384_ID"
    ],
    "13395": [
        "Right_Scapula_13395_ID"
    ],
    "13396": [
        "Left_Scapula_13396_ID",
        "Right_Scapula_13396_ID"
    ],
    "13398": [
        "Right_serratus_anterior_13398_ID"
    ],
    "13399": [
        "Left_serratus_anterior_13399_ID"
    ],
    "13403": [
        "Right_Serratus_Posterior_Superior_13403_ID"
    ],
    "13404": [
        "Left_Serratus_Posterior_Superior_13404_ID"
    ],
    "13405": [
        "Right_Serratus_Posterior_Inferior_13405_ID"
    ],
    "13406": [
        "Left_Serratus_Posterior_Inferior_13406_ID"
    ],
    "13408": [
        "Right_Sternocleidomastoid_13408_ID"
    ],
    "13409": [
        "Left_Sternocleidomastoid_13409_ID"
    ],
    "13410": [
        "Right_Subclavius_13410_ID"
    ],
    "13411": [
        "Left_Subclavius_13411_ID",
        "Right_Subclavius_13411_ID"
    ],
    "13414": [
        "Right_subscapularis_13414_ID"
    ],
    "13415": [
        "Left_subscapularis_13415_ID",
        "Right_subscapularis_13415_ID"
    ],
    "13417": [
        "Right_Thoracoepigastric_vein_13417_ID"
    ],
    "13418": [
        "Left_Thoracoepigastric_vein_13418_ID"
    ],
    "13419": [
        "Right_Trapezius_13419_ID"
    ],
    "13420": [
        "Left_Trapezius_13420_ID"
    ],
    "13421": [
        "Ligamentum_arteriosum_13421_ID"
    ],
    "13478": [
        "Vertebral_Column_13478_ID"
    ],
    "13889": [
        "Pituitary_Gland_13889_ID"
    ],
    "13890": [
        "Parathyroid_Glands_13890_ID"
    ],
    "13892": [
        "Right_Internal_oblique_13892_ID"
    ],
    "13893": [
        "Left_Internal_oblique_13893_ID"
    ],
    "13912": [
        "Anterior_interventricular_artery_13912_ID"
    ],
    "14331": [
        "splenic_vein_14331_ID"
    ],
    "14332": [
        "superior_mesenteric_vein_14332_ID"
    ],
    "14335": [
        "Right_renal_vein_14335_ID"
    ],
    "14336": [
        "Left_renal_vein_14336_ID"
    ],
    "14338": [
        "Right_Hepatic_Vein_14338_ID"
    ],
    "14339": [
        "Left_Hepatic_Vein_14339_ID"
    ],
    "14341": [
        "Right_testicular_vein_14341_ID"
    ],
    "14345": [
        "Left_testicular_vein_14345_ID"
    ],
    "14384": [
        "Right_median_nerve_14384_ID"
    ],
    "14385": [
        "Left_median_nerve_14385_ID"
    ],
    "14468": [
        "Right_Recurrent_Laryngeal_Nerve_14468_ID"
    ],
    "14469": [
        "Left_Recurrent_Laryngeal_Nerve_14469_ID"
    ],
    "14542": [
        "Appendix_14542_ID"
    ],
    "14543": [
        "Colon_14543_ID"
    ],
    "14544": [
        "Rectum_14544_ID"
    ],
    "14545": [
        "Ascending_colon_14545_ID"
    ],
    "14546": [
        "Transverse_colon_14546_ID"
    ],
    "14547": [
        "Descending_Colon_14547_ID"
    ],
    "14548": [
        "Sigmoid_Colon_14548_ID"
    ],
    "14735": [
        "Right_Lumbar_artery_14735_ID",
        "Left_Lumbar_Artery_14735_ID",
        "Right_Lumbar_Artery_14735_ID"
    ],
    "14746": [
        "Right_Inferior_Phrenic_Artery_14746_ID"
    ],
    "14747": [
        "Left_Inferior_Phrenic_Artery_14747_ID"
    ],
    "14749": [
        "superior_mesenteric_artery_14749_ID"
    ],
    "14750": [
        "Inferior_Mesenteric_artery_14750_ID"
    ],
    "14752": [
        "Right_renal_artery_14752_ID"
    ],
    "14753": [
        "Left_Renal_artery_14753_ID"
    ],
    "14759": [
        "Right_testicular_artery_14759_ID"
    ],
    "14760": [
        "Left_testicular_artery_14760_ID"
    ],
    "14768": [
        "Left_Gastric_Artery_14768_ID"
    ],
    "14771": [
        "Common_hepatic_artery_14771_ID"
    ],
    "14772": [
        "Hepatic_artery_proper_14772_ID"
    ],
    "14773": [
        "Splenic_artery_14773_ID"
    ],
    "14775": [
        "Gastroduodenal_artery_14775_ID"
    ],
    "14776": [
        "Right_Gastric_artery_14776_ID"
    ],
    "14778": [
        "Right_hepatic_artery_14778_ID"
    ],
    "14779": [
        "Left_hepatic_artery_14779_ID"
    ],
    "14781": [
        "Right_Gastroepiploic_artery_14781_ID"
    ],
    "14787": [
        "Dorsal_pancreatic_artery_14787_ID"
    ],
    "14790": [
        "Inferior_pancreatic_artery_14790_ID"
    ],
    "14791": [
        "Prepancreatic_Artery_14791_ID"
    ],
    "14792": [
        "Great_pancreatic_artery_14792_ID"
    ],
    "14793": [
        "Caudal_pancreatic_artery_14793_ID"
    ],
    "14796": [
        "Left_Gastroepiploic_artery_14796_ID"
    ],
    "14810": [
        "middle_colic_artery_14810_ID"
    ],
    "14811": [
        "Right_colic_artery_14811_ID"
    ],
    "14812": [
        "Celiac_Trunk_14812_ID"
    ],
    "14815": [
        "Ileocolic_artery_14815_ID"
    ],
    "14819": [
        "ileal_branch_of_ileocolic_artery_14819_ID"
    ],
    "14820": [
        "Ileal_branch_of_ileocolic_vein_14820_ID",
        "Colic_branch_of_ileocolic_vein_14820_ID"
    ],
    "14822": [
        "Superior_branch_of_ileocolic_artery_14822_ID"
    ],
    "14826": [
        "Left_colic_artery_14826_ID"
    ],
    "14830": [
        "Sigmoid_artery_14830_ID"
    ],
    "14831": [
        "Marginal_artery_of_colon_14831_ID"
    ],
    "14832": [
        "Superior_Rectal_artery_14832_ID"
    ],
    "14835": [
        "Cystic_artery_14835_ID"
    ],
    "15388": [
        "Pancreatic_tributary_of_splenic_vein_15388_ID"
    ],
    "15390": [
        "left_gastroepiploic_vein_15390_ID"
    ],
    "15391": [
        "Inferior_Mesenteric_vein_15391_ID"
    ],
    "15394": [
        "Left_colic_vein_15394_ID"
    ],
    "15395": [
        "Sigmoid_vein_15395_ID"
    ],
    "15397": [
        "Right_gastroepiploic_vein_15397_ID"
    ],
    "15398": [
        "Anterior_Superior_pancreaticoduodenal_vein_15398_ID",
        "Anterior_Inferior_pancreaticoduodenal_vein_15398_ID",
        "Pancreaticoduodenal_vein_15398_ID",
        "Posterior_Superior_pancreaticoduodenal_vein_15398_ID",
        "Posterior_Inferior_pancreaticoduodenal_vein_15398_ID"
    ],
    "15399": [
        "Left_Gastric_vein_15399_ID"
    ],
    "15400": [
        "Right_Gastric_vein_15400_ID"
    ],
    "15407": [
        "right_colic_vein_15407_ID"
    ],
    "15408": [
        "Ileocolic_vein_15408_ID"
    ],
    "15414": [
        "Right_Hepatic_Portal_Vein_15414_ID"
    ],
    "15415": [
        "Left_Hepatic_Portal_Vein_15415_ID"
    ],
    "15571": [
        "Right_Ureter_15571_ID"
    ],
    "15572": [
        "Left_Ureter_15572_ID"
    ],
    "15629": [
        "Right_Adrenal_Gland_15629_ID"
    ],
    "15630": [
        "Left_Adrenal_Gland_15630_ID"
    ],
    "15710": [
        "Internal_anal_sphincter_15710_ID"
    ],
    "15900": [
        "Bladder_15900_ID"
    ],
    "16202": [
        "Sacrum_16202_ID"
    ],
    "16491": [
        "Right_iliohypogastric_nerve_16491_ID"
    ],
    "16492": [
        "Left_iliohypogastric_nerve_16492_ID"
    ],
    "16493": [
        "Right_ilioinguinal_nerve_16493_ID"
    ],
    "16494": [
        "Left_ilioinguinal_nerve_16494_ID"
    ],
    "16497": [
        "Right_lateral_femoral_cutaneous_nerve_16497_ID"
    ],
    "16498": [
        "Left_lateral_femoral_cutaneous_nerve_16498_ID"
    ],
    "16499": [
        "Right_femoral_nerve_16499_ID"
    ],
    "16500": [
        "Left_femoral_nerve_16500_ID"
    ],
    "16501": [
        "Right_obturator_nerve_16501_ID"
    ],
    "16502": [
        "Left_obturator_nerve_16502_ID"
    ],
    "17559": [
        "Uterus_17559_ID"
    ],
    "17740": [
        "Cervix_of_uterus_17740_ID"
    ],
    "18245": [
        "Right_Fallopian_Tube_18245_ID",
        "Left_Fallopian_Tube_18245_ID"
    ],
    "18256": [
        "Right_epididymis_18256_ID"
    ],
    "18257": [
        "Left_epididymis_18257_ID"
    ],
    "18806": [
        "Right_external_iliac_artery_18806_ID"
    ],
    "18807": [
        "Left_external_iliac_artery_18807_ID"
    ],
    "18809": [
        "Right_internal_iliac_artery_18809_ID"
    ],
    "18810": [
        "Left_internal_iliac_artery_18810_ID"
    ],
    "18824": [
        "Right_inferior_vesical_artery_18824_ID"
    ],
    "18825": [
        "Left_inferior_vesical_artery_18825_ID"
    ],
    "18829": [
        "Left_Uterine_Artery_18829_ID",
        "Right_Uterine_Artery_18829_ID"
    ],
    "18836": [
        "Right_internal_pudendal_artery_18836_ID"
    ],
    "18837": [
        "Left_internal_pudendal_artery_18837_ID"
    ],
    "18846": [
        "Right_iliolumbar_artery_18846_ID"
    ],
    "18847": [
        "Left_iliolumbar_artery_18847_ID"
    ],
    "18856": [
        "Right_lateral_sacral_artery_18856_ID"
    ],
    "18857": [
        "Left_lateral_sacral_artery_18857_ID"
    ],
    "18866": [
        "Right_obturator_artery_18866_ID"
    ],
    "18867": [
        "Left_obturator_artery_18867_ID"
    ],
    "18869": [
        "Right_superior_gluteal_artery_18869_ID"
    ],
    "18870": [
        "Right_superior_gluteal_artery_18870_ID",
        "Left_superior_gluteal_artery_18870_ID"
    ],
    "18872": [
        "Right_inferior_gluteal_artery_18872_ID"
    ],
    "18873": [
        "Left_inferior_gluteal_artery_18873_ID"
    ],
    "18885": [
        "Right_external_iliac_vein_18885_ID"
    ],
    "18886": [
        "Left_external_iliac_vein_18886_ID"
    ],
    "18887": [
        "Right_internal_iliac_vein_18887_ID"
    ],
    "18888": [
        "Left_internal_iliac_vein_18888_ID"
    ],
    "18891": [
        "Right_inferior_vesical_vein_18891_ID"
    ],
    "18892": [
        "Left_inferior_vesical_vein_18892_ID"
    ],
    "18897": [
        "Right_Uterine_Vein_18897_ID"
    ],
    "18898": [
        "Left_Uterine_Vein_18898_ID"
    ],
    "18903": [
        "Right_iliolumbar_vein_18903_ID"
    ],
    "18904": [
        "Left_iliolumbar_vein_18904_ID"
    ],
    "18906": [
        "Right_lateral_sacral_vein_18906_ID"
    ],
    "18907": [
        "Left_lateral_sacral_vein_18907_ID"
    ],
    "18909": [
        "Right_superior_gluteal_vein_18909_ID"
    ],
    "18910": [
        "Left_superior_gluteal_vein_18910_ID"
    ],
    "18912": [
        "Right_inferior_gluteal_vein_18912_ID"
    ],
    "18913": [
        "Left_inferior_gluteal_vein_18913_ID"
    ],
    "18915": [
        "Right_obturator_vein_18915_ID"
    ],
    "18916": [
        "Left_obturator_vein_18916_ID"
    ],
    "18918": [
        "Right_internal_pudendal_vein_18918_ID"
    ],
    "18919": [
        "Left_internal_pudendal_vein_18919_ID"
    ],
    "19086": [
        "Muscles_of_the_Pelvis_19086_ID"
    ],
    "19087": [
        "Levator_Ani_19087_ID"
    ],
    "19090": [
        "Pubococcygeus_19090_ID"
    ],
    "19091": [
        "Puborectalis_19091_ID"
    ],
    "19119": [
        "Right_Uterosacral_Ligament_19119_ID"
    ],
    "19120": [
        "Left_Uterosacral_Ligament_19120_ID"
    ],
    "19235": [
        "Right_vas_deferens_19235_ID"
    ],
    "19236": [
        "Left_vas_deferens_19236_ID"
    ],
    "19387": [
        "Right_Seminal_Vesicle_19387_ID"
    ],
    "19388": [
        "Left_Seminal_Vesicle_19388_ID"
    ],
    "19617": [
        "Corpus_spongiosum_of_penis_19617_ID"
    ],
    "19618": [
        "Right_corporus_cavernosum_of_penis_19618_ID",
        "Left_corporus_cavernosum_of_penis_19618_ID"
    ],
    "19667": [
        "Urethra_19667_ID"
    ],
    "19668": [
        "Male_urethra_19668_ID"
    ],
    "19730": [
        "Left_Ischiocavernosus_19730_ID",
        "Right_Ischiocavernosus_19730_ID"
    ],
    "19731": [
        "Right_Superficial_Transverse_Perineal_Muscle_19731_ID",
        "Left_Superficial_Transverse_Perineal_Muscle_19731_ID"
    ],
    "19732": [
        "Deep_transverse_perineal_muscle_19732_ID"
    ],
    "19949": [
        "Vagina_19949_ID"
    ],
    "20224": [
        "Right_Ribs_20224_ID"
    ],
    "20225": [
        "Right_Ribs_20225_ID",
        "Left_Ribs_20225_ID"
    ],
    "20226": [
        "Right_Bony_Pelvis_20226_ID",
        "Left_Ribs_20226_ID",
        "Right_side_of_bony_pelvis_20226_ID"
    ],
    "20227": [
        "Left_Bony_Pelvis_20227_ID",
        "Left_side_of_bony_pelvis_20227_ID"
    ],
    "20274": [
        "Perineal_Body_20274_ID"
    ],
    "20630": [
        "Right_genitofemoral_nerve_20630_ID"
    ],
    "20631": [
        "Left_genitofemoral_nerve_20631_ID"
    ],
    "20632": [
        "Genital_branch_of_right_genitofemoral_nerve_20632_ID"
    ],
    "20633": [
        "Genital_branch_of_left_genitofemoral_nerve_20633_ID"
    ],
    "20634": [
        "Femoral_branch_of_right_genitofemoral_nerve_20634_ID"
    ],
    "20635": [
        "Femoral_branch_of_left_genitofemoral_nerve_20635_ID"
    ],
    "20688": [
        "Right_Inferior_Epigastric_Artery_20688_ID"
    ],
    "20689": [
        "Left_Inferior_Epigastric_Artery_20689_ID"
    ],
    "20735": [
        "Right_Superficial_Epigastric_Artery_20735_ID"
    ],
    "20736": [
        "Left_Superficial_Epigastric_Artery_20736_ID"
    ],
    "20796": [
        "Right_deep_femoral_artery_20796_ID"
    ],
    "20797": [
        "Left_deep_femoral_artery_20797_ID"
    ],
    "20801": [
        "Right_lateral_circumflex_femoral_artery_20801_ID"
    ],
    "20802": [
        "Left_lateral_circumflex_femoral_artery_20802_ID"
    ],
    "20807": [
        "Right_Medial_circumflex_femoral_artery_20807_ID"
    ],
    "20808": [
        "Left_Medial_circumflex_femoral_artery_20808_ID"
    ],
    "20818": [
        "Right_dorsal_artery_of_penis_20818_ID"
    ],
    "20819": [
        "Left_dorsal_artery_of_penis_20819_ID"
    ],
    "20967": [
        "Prostatic_part_of_right_inferior_vesical_artery_20967_ID"
    ],
    "20968": [
        "Prostatic_part_of_left_inferior_vesical_artery_20968_ID"
    ],
    "21163": [
        "Right_Inferior_Epigastric_Vein_21163_ID"
    ],
    "21164": [
        "Left_Inferior_Epigastric_Vein_21164_ID"
    ],
    "21188": [
        "Right_Femoral_Vein_21188_ID"
    ],
    "21189": [
        "Left_Femoral_Vein_21189_ID"
    ],
    "21378": [
        "Superficial_Veins_of_the_Left_Leg_21378_ID",
        "Superficial_Veins_of_the_Right_Leg_21378_ID"
    ],
    "21379": [
        "Right_Great_Saphenous_Vein_21379_ID"
    ],
    "21380": [
        "Left_Great_Saphenous_Vein_21380_ID"
    ],
    "21422": [
        "Descending_branch_of_right_lateral_circumflex_femoral_artery_21422_ID"
    ],
    "21423": [
        "Descending_branch_of_left_lateral_circumflex_femoral_artery_21423_ID"
    ],
    "21863": [
        "Right_Pudendal_nerve_21863_ID"
    ],
    "21864": [
        "Left_Pudendal_nerve_21864_ID"
    ],
    "21919": [
        "Right_superficial_transverse_perineal_muscle_21919_ID"
    ],
    "21920": [
        "Left_superficial_transverse_perineal_muscle_21920_ID"
    ],
    "21921": [
        "Right_bulbospongiosus_21921_ID"
    ],
    "21922": [
        "Left_bulbospongiosus_21922_ID"
    ],
    "21923": [
        "Right_ischiocavernosus_21923_ID"
    ],
    "21924": [
        "Left_ischiocavernosus_21924_ID"
    ],
    "21930": [
        "External_Anal_Sphincter_21930_ID"
    ],
    "22109": [
        "Right_Tibial_nerve_22109_ID"
    ],
    "22110": [
        "Left_Tibial_nerve_22110_ID"
    ],
    "22111": [
        "Right_sciatic_nerve_22111_ID"
    ],
    "22112": [
        "Left_sciatic_nerve_22112_ID"
    ],
    "22171": [
        "Right_inferior_ulnar_collateral_artery_22171_ID"
    ],
    "22172": [
        "right_inferior_ulnar_collateral_artery_22172_ID",
        "left_inferior_ulnar_collateral_artery_22172_ID"
    ],
    "22322": [
        "Right_Iliacus_22322_ID"
    ],
    "22323": [
        "Left_Iliacus_22323_ID"
    ],
    "22324": [
        "Right_Obturator_Internus_22324_ID"
    ],
    "22325": [
        "Left_Obturator_Internus_22325_ID"
    ],
    "22326": [
        "Right_Obturator_externus_22326_ID"
    ],
    "22327": [
        "Left_Obturator_externus_22327_ID"
    ],
    "22328": [
        "Right_gluteus_maximus_22328_ID"
    ],
    "22329": [
        "Left_gluteus_maximus_22329_ID"
    ],
    "22330": [
        "Right_gluteus_medius_22330_ID"
    ],
    "22331": [
        "Left_gluteus_medius_22331_ID"
    ],
    "22332": [
        "Right_Gluteus_minimus_22332_ID"
    ],
    "22333": [
        "Left_Gluteus_minimus_22333_ID"
    ],
    "22334": [
        "Right_superior_gemellus_22334_ID"
    ],
    "22335": [
        "Left_superior_gemellus_22335_ID"
    ],
    "22336": [
        "Right_inferior_gemellus_22336_ID"
    ],
    "22337": [
        "Left_inferior_gemellus_22337_ID"
    ],
    "22338": [
        "Right_Quadratus_femoris_22338_ID"
    ],
    "22339": [
        "Left_Quadratus_femoris_22339_ID"
    ],
    "22340": [
        "Right_Piriformis_22340_ID"
    ],
    "22341": [
        "Left_Piriformis_22341_ID"
    ],
    "22342": [
        "Right_Psoas_Major_22342_ID"
    ],
    "22343": [
        "Left_Psoas_Major_22343_ID"
    ],
    "22344": [
        "Right_Transversus_abdominis_22344_ID"
    ],
    "22345": [
        "Left_Transversus_abdominis_22345_ID"
    ],
    "22348": [
        "Right_Quadratus_lumborum_22348_ID"
    ],
    "22349": [
        "Left_Quadratus_lumborum_22349_ID"
    ],
    "22351": [
        "Right_Psoas_Minor_22351_ID"
    ],
    "22352": [
        "Left_Psoas_Minor_22352_ID"
    ],
    "22354": [
        "Right_Sartorius_22354_ID"
    ],
    "22355": [
        "Left_Sartorius_22355_ID"
    ],
    "22358": [
        "Right_Semitendinosus_22358_ID"
    ],
    "22359": [
        "Left_Semitendinosus_22359_ID"
    ],
    "22360": [
        "Right_Biceps_Femoris_22360_ID"
    ],
    "22361": [
        "Left_Biceps_Femoris_22361_ID"
    ],
    "22425": [
        "Right_Tensor_Fasciae_Latae_22425_ID"
    ],
    "22426": [
        "Left_Tensor_Fasciae_Latae_22426_ID"
    ],
    "22444": [
        "Right_quadriceps_femoris_22444_ID"
    ],
    "22445": [
        "Left_quadriceps_femoris_22445_ID"
    ],
    "22446": [
        "Right_Articularis_Genus_22446_ID"
    ],
    "22447": [
        "Left_Articularis_Genus_22447_ID"
    ],
    "22448": [
        "Right_Semimembranosus_22448_ID"
    ],
    "22449": [
        "Left_Semimembranosus_22449_ID"
    ],
    "22450": [
        "Right_Pectineus_22450_ID"
    ],
    "22451": [
        "Left_Pectineus_22451_ID"
    ],
    "22456": [
        "Right_Adductor_Longus_22456_ID"
    ],
    "22457": [
        "Right_Adductor_Longus_22457_ID",
        "Left_Adductor_Longus_22457_ID"
    ],
    "22458": [
        "Left_Adductor_Longus_22458_ID"
    ],
    "22459": [
        "Right_Adductor_Magnus_22459_ID"
    ],
    "22460": [
        "Left_Adductor_Magnus_22460_ID"
    ],
    "22507": [
        "Right_descending_genicular_artery_22507_ID"
    ],
    "22508": [
        "Left_descending_genicular_artery_22508_ID"
    ],
    "22539": [
        "Right_Fibularis_tertius_22539_ID",
        "Left_Fibularis_tertius_22539_ID"
    ],
    "22545": [
        "Right_Tibialis_anterior_22545_ID",
        "Left_Tibialis_anterior_22545_ID"
    ],
    "22547": [
        "Left_Extensor_hallucis_longus_22547_ID",
        "Right_Extensor_hallucis_longus_22547_ID"
    ],
    "22548": [
        "Right_Extensor_hallucis_longus_22548_ID",
        "Left_Extensor_hallucis_longus_22548_ID"
    ],
    "22549": [
        "Right_extensor_digitorum_longus_22549_ID",
        "Left_extensor_digitorum_longus_22549_ID"
    ],
    "22551": [
        "Right_Fibularis_tertius_22551_ID",
        "Left_Fibularis_tertius_22551_ID"
    ],
    "22553": [
        "Right_Fibularis_longus_22553_ID",
        "Left_Fibularis_longus_22553_ID"
    ],
    "22555": [
        "Left_Fibularis_brevis_22555_ID",
        "Right_Fibularis_brevis_22555_ID"
    ],
    "22556": [
        "Right_Gastrocnemius_22556_ID"
    ],
    "22557": [
        "Left_Gastrocnemius_22557_ID"
    ],
    "22559": [
        "Right_Soleus_22559_ID",
        "Left_Soleus_22559_ID"
    ],
    "22561": [
        "Left_Plantaris_22561_ID",
        "Right_Plantaris_22561_ID"
    ],
    "22586": [
        "Right_superior_medial_genicular_artery_22586_ID"
    ],
    "22587": [
        "Left_superior_medial_genicular_artery_22587_ID"
    ],
    "22588": [
        "Right_superior_lateral_genicular_artery_22588_ID"
    ],
    "22589": [
        "Left_superior_lateral_genicular_artery_22589_ID"
    ],
    "22592": [
        "Right_Popliteus_22592_ID",
        "Left_Popliteus_22592_ID"
    ],
    "22655": [
        "Right_Axillary_artery_22655_ID"
    ],
    "22656": [
        "Left_Axillary_artery_22656_ID",
        "Right_Axillary_artery_22656_ID"
    ],
    "22669": [
        "right_superior_thoracic_artery_22669_ID"
    ],
    "22670": [
        "left_superior_thoracic_artery_22670_ID"
    ],
    "22675": [
        "Right_lateral_thoracic_artery_22675_ID"
    ],
    "22676": [
        "right_lateral_thoracic_artery_22676_ID",
        "left_lateral_thoracic_artery_22676_ID"
    ],
    "22679": [
        "Right_subscapular_artery_22679_ID"
    ],
    "22680": [
        "left_subscapular_artery_22680_ID",
        "right_subscapular_artery_22680_ID"
    ],
    "22682": [
        "Right_anterior_humeral_circumflex_artery_22682_ID"
    ],
    "22683": [
        "right_anterior_humeral_circumflex_artery_22683_ID",
        "left_anterior_humeral_circumflex_artery_22683_ID"
    ],
    "22686": [
        "Right_posterior_humeral_circumflex_artery_22686_ID"
    ],
    "22687": [
        "left_posterior_humeral_circumflex_artery_22687_ID",
        "right_posterior_humeral_circumflex_artery_22687_ID"
    ],
    "22691": [
        "Right_brachial_artery_22691_ID"
    ],
    "22692": [
        "right_brachial_artery_22692_ID",
        "left_brachial_artery_22692_ID"
    ],
    "22696": [
        "Right_deep_brachial_artery_22696_ID"
    ],
    "22697": [
        "right_deep_brachial_artery_22697_ID",
        "left_deep_brachial_artery_22697_ID"
    ],
    "22707": [
        "Right_superior_ulnar_collateral_artery_22707_ID"
    ],
    "22708": [
        "right_superior_ulnar_collateral_artery_22708_ID",
        "left_superior_ulnar_collateral_artery_22708_ID"
    ],
    "22726": [
        "Right_Splenius_cervicis_22726_ID"
    ],
    "22727": [
        "Left_Splenius_cervicis_22727_ID"
    ],
    "22728": [
        "Right_Splenius_capitis_22728_ID"
    ],
    "22729": [
        "Left_Splenius_capitis_22729_ID"
    ],
    "22733": [
        "Right_radial_artery_22733_ID"
    ],
    "22734": [
        "Right_radial_artery_22734_ID",
        "Left_radial_artery_22734_ID"
    ],
    "22740": [
        "Right_Iliocostalis_Lumborum_22740_ID"
    ],
    "22741": [
        "Left_Iliocostalis_Lumborum_22741_ID"
    ],
    "22742": [
        "Right_Iliocostalis_Thoracis_22742_ID"
    ],
    "22743": [
        "Left_Iliocostalis_Thoracis_22743_ID"
    ],
    "22744": [
        "Right_Iliocostalis_Cervicis_22744_ID"
    ],
    "22745": [
        "Left_Iliocostalis_Cervicis_22745_ID"
    ],
    "22751": [
        "Right_Longissimus_Thoracis_22751_ID"
    ],
    "22753": [
        "Left_Longissimus_Thoracis_22753_ID"
    ],
    "22754": [
        "Right_Longissimus_Capitis_22754_ID"
    ],
    "22756": [
        "Left_Longissimus_Capitis_22756_ID"
    ],
    "22757": [
        "Right_Longissimus_Cervicis_22757_ID"
    ],
    "22758": [
        "Left_Longissimus_Cervicis_22758_ID"
    ],
    "22765": [
        "Right_radial_recurrent_artery_22765_ID"
    ],
    "22766": [
        "left_radial_recurrent_artery_22766_ID",
        "right_radial_recurrent_artery_22766_ID"
    ],
    "22772": [
        "dorsal_carpal_branch_of_Right_radial_artery_22772_ID"
    ],
    "22773": [
        "dorsal_carpal_branch_of_left_radial_artery_22773_ID",
        "dorsal_carpal_branch_of_right_radial_artery_22773_ID"
    ],
    "22779": [
        "Right_Spinalis_Thoracis_22779_ID"
    ],
    "22780": [
        "Left_Spinalis_Thoracis_22780_ID"
    ],
    "22781": [
        "Right_Spinalis_Cervicis_22781_ID"
    ],
    "22782": [
        "Left_Spinalis_Cervicis_22782_ID"
    ],
    "22783": [
        "Right_Spinalis_Capitis_22783_ID"
    ],
    "22784": [
        "Left_Spinalis_Capitis_22784_ID"
    ],
    "22798": [
        "Right_ulnar_artery_22798_ID",
        "Left_ulnar_artery_22798_ID"
    ],
    "22801": [
        "Right_anterior_ulnar_recurrent_artery_22801_ID"
    ],
    "22802": [
        "right_anterior_ulnar_recurrent_artery_22802_ID",
        "left_anterior_ulnar_recurrent_artery_22802_ID"
    ],
    "22804": [
        "Right_posterior_ulnar_recurrent_artery_22804_ID"
    ],
    "22805": [
        "right_posterior_ulnar_recurrent_artery_22805_ID",
        "left_posterior_ulnar_recurrent_artery_22805_ID"
    ],
    "22807": [
        "Right_common_interosseous_artery_22807_ID"
    ],
    "22808": [
        "left_common_interosseous_artery_22808_ID",
        "right_common_interosseous_artery_22808_ID"
    ],
    "22812": [
        "Right_anterior_interosseous_artery_22812_ID"
    ],
    "22813": [
        "left_anterior_interosseous_artery_22813_ID",
        "right_anterior_interosseous_artery_22813_ID"
    ],
    "22821": [
        "dorsal_carpal_branch_of_Right_ulnar_artery_22821_ID"
    ],
    "22822": [
        "dorsal_carpal_branch_of_left_ulnar_artery_22822_ID",
        "dorsal_carpal_branch_of_right_ulnar_artery_22822_ID"
    ],
    "22836": [
        "Right_superficial_palmar_arch_22836_ID"
    ],
    "22837": [
        "left_superficial_palmar_arch_22837_ID",
        "right_superficial_palmar_arch_22837_ID"
    ],
    "22839": [
        "Right_deep_palmar_arterial_arch_22839_ID"
    ],
    "22840": [
        "left_deep_palmar_venous_arch_22840_ID",
        "right_deep_palmar_venous_arch_22840_ID",
        "right_deep_palmar_arterial_arch_22840_ID",
        "left_deep_palmar_arterial_arch_22840_ID",
        "right_deep_palmar_arch_22840_ID",
        "left_deep_palmar_arch_22840_ID"
    ],
    "22872": [
        "Right_Semispinalis_thoracis_22872_ID"
    ],
    "22873": [
        "Left_Semispinalis_thoracis_22873_ID"
    ],
    "22874": [
        "Right_Semispinalis_cervicis_22874_ID"
    ],
    "22875": [
        "Left_Semispinalis_cervicis_22875_ID"
    ],
    "22876": [
        "Right_Semispinalis_capitis_22876_ID"
    ],
    "22877": [
        "Left_Semispinalis_capitis_22877_ID"
    ],
    "22878": [
        "Right_Multifidus_22878_ID"
    ],
    "22879": [
        "Left_Multifidus_22879_ID"
    ],
    "22909": [
        "Right_basilic_vein_22909_ID"
    ],
    "22910": [
        "right_basilic_vein_22910_ID",
        "left_basilic_vein_22910_ID",
        "Left_basilic_vein_22910_ID"
    ],
    "22920": [
        "Right_palmar_metacarpal_veins_22920_ID"
    ],
    "22921": [
        "right_palmar_metacarpal_veins_22921_ID",
        "left_palmar_metacarpal_veins_22921_ID"
    ],
    "22935": [
        "Right_medial_brachial_vein_22935_ID"
    ],
    "22936": [
        "right_medial_brachial_vein_22936_ID",
        "left_medial_brachial_vein_22936_ID"
    ],
    "22948": [
        "Right_radial_vein_22948_ID"
    ],
    "22949": [
        "left_radial_vein_22949_ID",
        "right_radial_vein_22949_ID"
    ],
    "22951": [
        "right_ulnar_vein_22951_ID"
    ],
    "22952": [
        "right_ulnar_vein_22952_ID",
        "left_ulnar_vein_22952_ID"
    ],
    "22964": [
        "Right_median_cubital_vein_22964_ID"
    ],
    "22965": [
        "right_median_cubital_vein_22965_ID",
        "left_median_cubital_vein_22965_ID"
    ],
    "22968": [
        "Right_median_antebrachial_vein_22968_ID"
    ],
    "22969": [
        "left_median_antebrachial_vein_22969_ID",
        "right_median_antebrachial_vein_22969_ID"
    ],
    "23111": [
        "Right_deep_dorsal_vein_23111_ID"
    ],
    "23112": [
        "right_deep_dorsal_vein_23112_ID",
        "left_deep_dorsal_vein_23112_ID"
    ],
    "23123": [
        "Right_medial_collateral_artery_23123_ID"
    ],
    "23124": [
        "right_medial_collateral_artery_23124_ID",
        "left_medial_collateral_artery_23124_ID"
    ],
    "23126": [
        "Right_radial_collateral_artery_23126_ID"
    ],
    "23127": [
        "right_radial_collateral_artery_23127_ID",
        "left_radial_collateral_artery_23127_ID"
    ],
    "23130": [
        "Right_Humerus_23130_ID",
        "Left_Humerus_23130_ID"
    ],
    "23180": [
        "Right_circumflex_scapular_artery_23180_ID"
    ],
    "23181": [
        "right_circumflex_scapular_artery_23181_ID",
        "left_circumflex_scapular_artery_23181_ID"
    ],
    "23464": [
        "Left_radius_23464_ID",
        "Right_radius_23464_ID"
    ],
    "23467": [
        "Left_Ulna_23467_ID",
        "Right_Ulna_23467_ID"
    ],
    "23707": [
        "Right_Interosseous_membrane_23707_ID"
    ],
    "23708": [
        "Left_Interosseous_membrane_23708_ID"
    ],
    "24160": [
        "Bones_of_the_Right_Arm_24160_ID"
    ],
    "24162": [
        "Bones_of_the_Left_Arm_24162_ID"
    ],
    "24435": [
        "Right_scaphoid_bone_24435_ID",
        "Left_scaphoid_bone_24435_ID"
    ],
    "24437": [
        "Left_lunate_bone_24437_ID",
        "Right_lunate_bone_24437_ID"
    ],
    "24439": [
        "Left_triquetral_bone_24439_ID",
        "Right_triquetral_bone_24439_ID"
    ],
    "24441": [
        "Right_pisiform_24441_ID",
        "Left_pisiform_24441_ID"
    ],
    "24443": [
        "Right_trapezium_24443_ID",
        "Left_trapezium_24443_ID"
    ],
    "24444": [
        "Right_trapezoid_bone_24444_ID",
        "Left_trapezoid_bone_24444_ID"
    ],
    "24446": [
        "Right_capitate_bone_24446_ID",
        "Left_capitate_bone_24446_ID"
    ],
    "24448": [
        "Left_hamate_bone_24448_ID",
        "Right_hamate_bone_24448_ID"
    ],
    "24474": [
        "Right_femur_24474_ID"
    ],
    "24475": [
        "Left_femur_24475_ID"
    ],
    "24477": [
        "Right_tibia_24477_ID"
    ],
    "24478": [
        "Right_tibia_24478_ID",
        "Left_tibia_24478_ID"
    ],
    "24480": [
        "Right_fibula_24480_ID"
    ],
    "24481": [
        "Right_fibula_24481_ID",
        "Left_fibula_24481_ID"
    ],
    "24482": [
        "Right_talus_24482_ID"
    ],
    "24483": [
        "Right_talus_24483_ID",
        "Left_talus_24483_ID"
    ],
    "24486": [
        "Right_patella_24486_ID"
    ],
    "24487": [
        "Right_patella_24487_ID",
        "Left_patella_24487_ID"
    ],
    "24497": [
        "Right_calcaneus_24497_ID"
    ],
    "24498": [
        "Right_calcaneus_24498_ID",
        "Left_calcaneus_24498_ID"
    ],
    "24500": [
        "Navicular_bone_of_right_foot_24500_ID"
    ],
    "24501": [
        "Navicular_of_right_foot_24501_ID",
        "Navicular_of_left_foot_24501_ID",
        "Navicular_bone_of_left_foot_24501_ID"
    ],
    "24521": [
        "Right_medial_Cuneiform_bone_24521_ID"
    ],
    "24522": [
        "Left_medial_Cuneiform_bone_24522_ID",
        "Right_medial_Cuneiform_bone_24522_ID"
    ],
    "24523": [
        "Right_intermediate_Cuneiform_bone_24523_ID"
    ],
    "24524": [
        "Right_intermediate_Cuneiform_bone_24524_ID",
        "Left_intermediate_Cuneiform_bone_24524_ID"
    ],
    "24525": [
        "Right_lateral_Cuneiform_bone_24525_ID"
    ],
    "24526": [
        "Right_lateral_Cuneiform_bone_24526_ID",
        "Left_lateral_Cuneiform_bone_24526_ID"
    ],
    "24528": [
        "Right_cuboid_bone_24528_ID"
    ],
    "24529": [
        "Left_cuboid_bone_24529_ID",
        "Right_cuboid_bone_24529_ID"
    ],
    "25005": [
        "Anterior_atlanto_occipital_membrane_25005_ID",
        "Anterior_atlantooccipital_membrane_25005_ID"
    ],
    "29711": [
        "Prostatic_venous_plexus_29711_ID"
    ],
    "31893": [
        "Anterior_longitudinal_ligament_31893_ID"
    ],
    "32530": [
        "Right_Rectus_capitis_posterior_major_32530_ID"
    ],
    "32531": [
        "Left_Rectus_Capitis_posterior_major_32531_ID"
    ],
    "32532": [
        "Right_Rectus_capitis_posterior_minor_32532_ID"
    ],
    "32533": [
        "Left_Rectus_capitis_posterior_minor_32533_ID",
        "Right_Rectus_Capitis_posterior_major_32533_ID"
    ],
    "32535": [
        "Right_Rectus_capitis_posterior_minor_32535_ID"
    ],
    "32540": [
        "Right_Levator_Scapulae_32540_ID",
        "Right_Levator_scapulae_32540_ID"
    ],
    "32541": [
        "Left_Levator_scapulae_32541_ID"
    ],
    "32542": [
        "Right_Deltoid_32542_ID"
    ],
    "32543": [
        "Left_Deltoid_32543_ID",
        "Right_Deltoid_32543_ID"
    ],
    "32544": [
        "Right_supraspinatus_32544_ID",
        "Right_Supraspinatus_32544_ID"
    ],
    "32545": [
        "Left_Supraspinatus_32545_ID"
    ],
    "32547": [
        "Right_infraspinatus_32547_ID"
    ],
    "32548": [
        "Left_infraspinatus_32548_ID"
    ],
    "32551": [
        "Right_Teres_Major_32551_ID"
    ],
    "32552": [
        "Left_Teres_Major_32552_ID"
    ],
    "32553": [
        "Right_teres_minor_32553_ID"
    ],
    "32554": [
        "Left_teres_minor_32554_ID"
    ],
    "33098": [
        "Right_Rotatores_short_fibers_33098_ID",
        "Right_Rotatores_long_fibers_33098_ID"
    ],
    "33099": [
        "Left_Rotatores_long_fibers_33099_ID",
        "Left_Rotatores_short_fibers_33099_ID"
    ],
    "33520": [
        "Right_pectoral_girdle_muscles_33520_ID"
    ],
    "33521": [
        "Left_pectoral_girdle_muscles_33521_ID",
        "Right_pectoral_girdle_muscles_33521_ID"
    ],
    "37318": [
        "Right_ulnar_nerve_37318_ID"
    ],
    "37319": [
        "Left_ulnar_nerve_37319_ID"
    ],
    "37386": [
        "Right_Abductor_pollicis_brevis_37386_ID"
    ],
    "37387": [
        "Left_Abductor_pollicis_brevis_37387_ID"
    ],
    "37388": [
        "Right_Flexor_pollicis_brevis_37388_ID"
    ],
    "37389": [
        "Left_Flexor_pollicis_brevis_37389_ID"
    ],
    "37390": [
        "Right_Opponens_pollicis_37390_ID"
    ],
    "37391": [
        "Left_Opponens_pollicis_37391_ID"
    ],
    "37392": [
        "Right_Adductor_pollicis_37392_ID"
    ],
    "37393": [
        "Left_Adductor_pollicis_37393_ID",
        "Right_Palmaris_brevis_37393_ID"
    ],
    "37395": [
        "Left_Palmaris_brevis_37395_ID"
    ],
    "37396": [
        "Right_Abductor_digiti_minimi_37396_ID"
    ],
    "37397": [
        "Left_Abductor_digiti_minimi_37397_ID"
    ],
    "37398": [
        "Right_Flexor_digiti_minimi_brevis_37398_ID"
    ],
    "37399": [
        "Left_Flexor_digiti_minimi_brevis_37399_ID"
    ],
    "37400": [
        "Right_Opponens_digiti_minimi_37400_ID"
    ],
    "37401": [
        "Left_Opponens_digiti_minimi_37401_ID"
    ],
    "37460": [
        "Right_Abductor_hallucis_37460_ID",
        "Left_Abductor_hallucis_37460_ID"
    ],
    "37462": [
        "Right_Flexor_digiti_minimi_brevis_37462_ID",
        "Left_Flexor_digiti_minimi_brevis_37462_ID"
    ],
    "37464": [
        "Abductor_digiti_minimi_of_right_foot_37464_ID",
        "Abductor_digiti_minimi_of_left_foot_37464_ID"
    ],
    "37468": [
        "Left_Flexor_hallucis_brevis_37468_ID",
        "Right_Flexor_hallucis_brevis_37468_ID"
    ],
    "37470": [
        "Left_Adductor_hallucis_37470_ID",
        "Left_Adductor_hallucis_oblique_head_37470_ID",
        "Left_Adductor_hallucis_transverse_head_37470_ID",
        "Right_Adductor_hallucis_37470_ID",
        "Right_Adductor_hallucis_oblique_head_37470_ID",
        "Right_Adductor_hallucis_transverse_head_37470_ID"
    ],
    "37665": [
        "Right_Coracobrachialis_37665_ID"
    ],
    "37666": [
        "Left_Coracobrachialis_37666_ID",
        "Right_Coracobrachialis_37666_ID"
    ],
    "37668": [
        "Right_Brachialis_37668_ID"
    ],
    "37669": [
        "Left_Brachialis_37669_ID"
    ],
    "37671": [
        "Right_Biceps_Brachii_37671_ID"
    ],
    "37672": [
        "Right_Biceps_Brachii_37672_ID",
        "Left_Biceps_Brachii_37672_ID"
    ],
    "37689": [
        "Right_Triceps_Brachii_37689_ID"
    ],
    "37690": [
        "Right_Triceps_Brachii_37690_ID",
        "Left_Triceps_Brachii_37690_ID"
    ],
    "37705": [
        "Right_anconeus_37705_ID"
    ],
    "37706": [
        "Left_anconeus_37706_ID",
        "Right_anconeus_37706_ID"
    ],
    "38451": [
        "Right_Pronator_teres_38451_ID"
    ],
    "38452": [
        "Left_Pronator_teres_38452_ID"
    ],
    "38454": [
        "Right_Pronator_quadratus_38454_ID"
    ],
    "38455": [
        "Left_Pronator_quadratus_38455_ID"
    ],
    "38460": [
        "Right_Flexor_carpi_radialis_longus_38460_ID"
    ],
    "38461": [
        "Left_Flexor_carpi_radialis_longus_38461_ID"
    ],
    "38463": [
        "Right_Palmaris_longus_38463_ID"
    ],
    "38464": [
        "Left_Palmaris_longus_38464_ID"
    ],
    "38466": [
        "Right_Flexor_carpi_ulnaris_38466_ID"
    ],
    "38467": [
        "Left_Flexor_carpi_ulnaris_38467_ID"
    ],
    "38483": [
        "Right_flexor_pollicis_longus_38483_ID"
    ],
    "38484": [
        "Left_flexor_pollicis_longus_38484_ID"
    ],
    "38486": [
        "Right_Brachioradialis_38486_ID"
    ],
    "38487": [
        "Left_Brachioradialis_38487_ID"
    ],
    "38495": [
        "Right_Extensor_carpi_radialis_longus_38495_ID"
    ],
    "38496": [
        "Left_Extensor_carpi_radialis_longus_38496_ID"
    ],
    "38498": [
        "Right_Extensor_carpi_radialis_brevis_38498_ID"
    ],
    "38499": [
        "Left_Extensor_carpi_radialis_brevis_38499_ID"
    ],
    "38504": [
        "Right_Extensor_digiti_minimi_38504_ID"
    ],
    "38505": [
        "Left_Extensor_digiti_minimi_38505_ID"
    ],
    "38507": [
        "Right_Extensor_carpi_ulnaris_38507_ID"
    ],
    "38508": [
        "Left_Extensor_carpi_ulnaris_38508_ID"
    ],
    "38513": [
        "Right_Supinator_38513_ID"
    ],
    "38514": [
        "Left_Supinator_38514_ID"
    ],
    "38516": [
        "Right_Abductor_pollicis_longus_38516_ID"
    ],
    "38517": [
        "Left_Abductor_pollicis_longus_38517_ID"
    ],
    "38519": [
        "Right_Extensor_pollicis_brevis_38519_ID"
    ],
    "38520": [
        "Left_Extensor_pollicis_brevis_38520_ID"
    ],
    "38522": [
        "Right_Extensor_pollicis_longus_38522_ID"
    ],
    "38523": [
        "Left_Extensor_pollicis_longus_38523_ID"
    ],
    "38525": [
        "Right_Extensor_indicis_38525_ID"
    ],
    "38526": [
        "Left_Extensor_indicis_38526_ID"
    ],
    "38928": [
        "Right_Rectus_Femoris_38928_ID"
    ],
    "38929": [
        "Left_Rectus_Femoris_38929_ID"
    ],
    "38930": [
        "Right_Vastus_Lateralis_38930_ID"
    ],
    "38931": [
        "Left_Vastus_Lateralis_38931_ID"
    ],
    "38932": [
        "Right_Vastus_Medialis_38932_ID"
    ],
    "38933": [
        "Left_Vastus_Medialis_38933_ID"
    ],
    "38934": [
        "Right_Vastus_Intermedius_38934_ID"
    ],
    "38935": [
        "Left_Vastus_Intermedius_38935_ID"
    ],
    "39091": [
        "Left_forearm_muscles_39091_ID"
    ],
    "39092": [
        "Right_forearm_muscles_39092_ID"
    ],
    "39987": [
        "Right_Extensor_retinaculum_of_hand_39987_ID",
        "Left_Extensor_retinaculum_of_hand_39987_ID"
    ],
    "39988": [
        "Right_Flexor_retinaculum_of_hand_39988_ID",
        "Left_Flexor_retinaculum_of_hand_39988_ID"
    ],
    "42313": [
        "Right_Pisohamate_Ligament_42313_ID",
        "Left_Pisohamate_Ligament_42313_ID"
    ],
    "42369": [
        "Right_hand_muscles_42369_ID"
    ],
    "42370": [
        "Left_hand_muscles_42370_ID"
    ],
    "43883": [
        "Right_Gracilis_43883_ID"
    ],
    "43884": [
        "Left_Gracilis_43884_ID"
    ],
    "43890": [
        "Right_inferior_medial_genicular_artery_43890_ID"
    ],
    "43891": [
        "Left_inferior_medial_genicular_artery_43891_ID",
        "Right_inferior_medial_genicular_artery_43891_ID"
    ],
    "43892": [
        "Right_inferior_lateral_genicular_artery_43892_ID"
    ],
    "43893": [
        "Left_inferior_lateral_genicular_artery_43893_ID"
    ],
    "43896": [
        "Right_anterior_tibial_artery_43896_ID"
    ],
    "43897": [
        "Right_anterior_tibial_artery_43897_ID",
        "Left_anterior_tibial_artery_43897_ID"
    ],
    "43898": [
        "Left_anterior_tibial_artery_43898_ID",
        "Right_posterior_tibial_artery_43898_ID"
    ],
    "43899": [
        "Left_posterior_tibial_artery_43899_ID"
    ],
    "43907": [
        "Right_anterior_tibial_recurrent_artery_43907_ID"
    ],
    "43908": [
        "Left_anterior_tibial_recurrent_artery_43908_ID"
    ],
    "43916": [
        "Right_dorsalis_pedis_artery_43916_ID"
    ],
    "43917": [
        "Left_dorsalis_pedis_artery_43917_ID"
    ],
    "43922": [
        "Right_fibular_artery_43922_ID"
    ],
    "43923": [
        "Left_fibular_artery_43923_ID"
    ],
    "43929": [
        "Right_medial_plantar_artery_43929_ID"
    ],
    "43930": [
        "Left_medial_plantar_artery_43930_ID"
    ],
    "43931": [
        "Right_lateral_plantar_artery_43931_ID"
    ],
    "43932": [
        "Left_lateral_plantar_artery_43932_ID"
    ],
    "43935": [
        "Right_deep_medial_plantar_artery_43935_ID"
    ],
    "43936": [
        "Left_deep_medial_plantar_artery_43936_ID"
    ],
    "43943": [
        "Right_plantar_arch_43943_ID"
    ],
    "43944": [
        "Left_plantar_arch_43944_ID"
    ],
    "43950": [
        "Calcaneal_branch_of_right_fibular_artery_43950_ID"
    ],
    "43951": [
        "Calcaneal_branch_of_left_fibular_artery_43951_ID"
    ],
    "44227": [
        "Left_Popliteal_Lymph_Nodes_44227_ID",
        "Right_Popliteal_Lymph_Nodes_44227_ID"
    ],
    "44249": [
        "Right_Long_plantar_ligament_44249_ID",
        "Left_Long_plantar_ligament_44249_ID"
    ],
    "44310": [
        "Lymphatics_of_the_Lower_Limb_44310_ID"
    ],
    "44326": [
        "Descending_branch_of_right_lateral_circumflex_femoral_Vein_44326_ID"
    ],
    "44327": [
        "Descending_branch_of_left_lateral_circumflex_femoral_Vein_44327_ID"
    ],
    "44328": [
        "Right_Popliteal_vein_44328_ID"
    ],
    "44329": [
        "Left_Popliteal_vein_44329_ID"
    ],
    "44334": [
        "Right_small_saphenous_vein_44334_ID"
    ],
    "44335": [
        "Left_small_saphenous_vein_44335_ID"
    ],
    "44336": [
        "Right_Anterior_Tibial_Vein_44336_ID"
    ],
    "44337": [
        "Left_Anterior_Tibial_Vein_44337_ID"
    ],
    "44338": [
        "Right_Posterior_Tibial_Vein_44338_ID"
    ],
    "44339": [
        "Left_Posterior_Tibial_Vein_44339_ID"
    ],
    "44340": [
        "Right_superficial_epigastric_vein_44340_ID"
    ],
    "44341": [
        "Left_superficial_epigastric_vein_44341_ID"
    ],
    "44583": [
        "Right_Oblique_Popliteal_Ligament_44583_ID"
    ],
    "44584": [
        "Left_Oblique_Popliteal_Ligament_44584_ID"
    ],
    "44585": [
        "Right_Patellar_Ligament_44585_ID"
    ],
    "44586": [
        "Left_Patellar_Ligament_44586_ID"
    ],
    "44597": [
        "Right_Arcuate_Popliteal_Ligament_44597_ID"
    ],
    "44599": [
        "Left_Arcuate_Popliteal_Ligament_44599_ID"
    ],
    "44601": [
        "Right_Tibial_Collateral_Ligament_44601_ID"
    ],
    "44602": [
        "Left_Tibial_Collateral_Ligament_44602_ID"
    ],
    "44609": [
        "Right_Fibular_Collateral_Ligament_44609_ID"
    ],
    "44610": [
        "Left_Fibular_Collateral_Ligament_44610_ID"
    ],
    "44615": [
        "Right_Anterior_Cruciate_Ligament_44615_ID"
    ],
    "44616": [
        "Left_Anterior_Cruciate_Ligament_44616_ID"
    ],
    "44618": [
        "Right_Posterior_Cruciate_Ligament_44618_ID"
    ],
    "44619": [
        "Left_Posterior_Cruciate_Ligament_44619_ID"
    ],
    "44741": [
        "Right_proper_plantar_digital_nerves_44741_ID"
    ],
    "44742": [
        "Left_proper_plantar_digital_nerves_44742_ID"
    ],
    "44874": [
        "Right_dorsal_branch_of_ulnar_nerve_44874_ID"
    ],
    "44875": [
        "Left_dorsal_branch_of_ulnar_nerve_44875_ID"
    ],
    "44881": [
        "Branch_of_Dorsal_venous_arch_of_Right_foot_44881_ID",
        "Right_Dorsalis_pedis_vein_44881_ID",
        "Dorsal_venous_arch_of_Right_foot_44881_ID"
    ],
    "44882": [
        "Branch_of_Dorsal_venous_arch_of_Left_foot_44882_ID",
        "Dorsal_venous_arch_of_Left_foot_44882_ID",
        "Left_Dorsalis_pedis_vein_44882_ID"
    ],
    "44883": [
        "Medial_branch_of_Plantar_venous_arch_of_right_foot_44883_ID",
        "Plantar_venous_arch_of_Right_foot_44883_ID",
        "Lateral_branch_of_Plantar_venous_arch_of_right_foot_44883_ID"
    ],
    "44884": [
        "Medial_branch_of_Plantar_venous_arch_of_left_foot_44884_ID",
        "Lateral_branch_of_Plantar_venous_arch_of_left_foot_44884_ID",
        "Plantar_venous_arch_of_Left_foot_44884_ID"
    ],
    "44885": [
        "Right_Fibular_vein_44885_ID"
    ],
    "44886": [
        "Left_Fibular_vein_44886_ID"
    ],
    "44887": [
        "Right_Superior_Medial_Genicular_vein_44887_ID",
        "Right_Genicular_Veins_44887_ID",
        "Right_Inferior_Medial_Genicular_Vein_44887_ID",
        "Right_Superior_Lateral_Genicular_vein_44887_ID",
        "Right_Inferior_Lateral_Genicular_Vein_44887_ID"
    ],
    "44888": [
        "Left_Inferior_Lateral_Genicular_Vein_44888_ID",
        "Left_Genicular_Veins_44888_ID",
        "Left_Inferior_Medial_Genicular_Vein_44888_ID",
        "Left_Superior_Medial_Genicular_vein_44888_ID",
        "Left_Superior_Lateral_Genicular_vein_44888_ID"
    ],
    "44918": [
        "Right_medial_circumflex_femoral_vein_44918_ID"
    ],
    "44919": [
        "Left_medial_circumflex_femoral_vein_44919_ID"
    ],
    "44920": [
        "Right_lateral_circumflex_femoral_vein_44920_ID"
    ],
    "44922": [
        "Left_lateral_circumflex_femoral_vein_44922_ID"
    ],
    "45257": [
        "Right_Intermediate_Femoral_Cutaneous_Nerve_45257_ID"
    ],
    "45258": [
        "Left_Intermediate_Femoral_Cutaneous_Nerve_45258_ID"
    ],
    "45263": [
        "Right_saphenous_nerve_45263_ID"
    ],
    "45264": [
        "Left_saphenous_nerve_45264_ID"
    ],
    "45338": [
        "Right_Posterior_femoral_cutaneous_nerve_45338_ID"
    ],
    "45339": [
        "Left_Posterior_femoral_cutaneous_nerve_45339_ID"
    ],
    "45357": [
        "Right_common_fibular_nerve_45357_ID"
    ],
    "45358": [
        "Left_common_fibular_nerve_45358_ID"
    ],
    "45363": [
        "Right_superficial_fibular_nerve_45363_ID"
    ],
    "45364": [
        "Left_superficial_fibular_nerve_45364_ID"
    ],
    "45387": [
        "Right_deep_fibular_nerve_45387_ID"
    ],
    "45388": [
        "Left_deep_fibular_nerve_45388_ID"
    ],
    "45389": [
        "Right_Lateral_terminal_branch_of_deep_fibular_nerve_45389_ID"
    ],
    "45390": [
        "Left_Lateral_terminal_branch_of_deep_fibular_nerve_45390_ID"
    ],
    "45426": [
        "Right_sural_nerve_45426_ID"
    ],
    "45427": [
        "Left_sural_nerve_45427_ID"
    ],
    "45434": [
        "Right_medial_proper_plantar_nerve_45434_ID"
    ],
    "45435": [
        "Left_medial_proper_plantar_nerve_45435_ID"
    ],
    "45450": [
        "Right_lateral_plantar_nerve_45450_ID"
    ],
    "45451": [
        "Left_lateral_plantar_nerve_45451_ID"
    ],
    "45654": [
        "Female_Internal_Genitalia_45654_ID"
    ],
    "45739": [
        "Right_platysma_45739_ID"
    ],
    "45740": [
        "Left_platysma_45740_ID"
    ],
    "45769": [
        "Internal_Urethral_Sphincter_45769_ID"
    ],
    "45826": [
        "Right_Stylohyoid_45826_ID"
    ],
    "45827": [
        "Left_Stylohyoid_45827_ID"
    ],
    "45858": [
        "Right_Iliococcygeus_45858_ID"
    ],
    "45859": [
        "Left_Iliococcygeus_45859_ID"
    ],
    "45890": [
        "Right_Biceps_Femoris_Short_Head_45890_ID"
    ],
    "45891": [
        "Left_Biceps_Femoris_Short_Head_45891_ID"
    ],
    "46283": [
        "Superior_oblique_part_of_right_longus_colli_46283_ID"
    ],
    "46284": [
        "Superior_oblique_part_of_left_longus_colli_46284_ID"
    ],
    "46285": [
        "Vertical_Intermediate_part_of_right_longus_colli_46285_ID"
    ],
    "46286": [
        "Vertical_Intermediate_part_of_left_longus_colli_46286_ID"
    ],
    "46287": [
        "Inferior_oblique_part_of_right_longus_colli_46287_ID"
    ],
    "46288": [
        "Inferior_oblique_part_of_left_longus_colli_46288_ID"
    ],
    "46292": [
        "Right_Digastric_46292_ID",
        "Right_Digastric_muscle_46292_ID"
    ],
    "46293": [
        "Left_Digastric_46293_ID",
        "Left_Digastric_muscle_46293_ID"
    ],
    "46309": [
        "Right_Longus_capitis_46309_ID"
    ],
    "46310": [
        "Left_Longus_capitis_46310_ID"
    ],
    "46313": [
        "Right_Rectus_capitis_anterior_46313_ID"
    ],
    "46314": [
        "Left_Rectus_capitis_anterior_46314_ID"
    ],
    "46317": [
        "Right_Rectus_capitis_lateralis_46317_ID"
    ],
    "46318": [
        "Right_Rectus_capitis_lateralis_46318_ID",
        "Left_Rectus_capitis_lateralis_46318_ID"
    ],
    "46319": [
        "Left_Rectus_capitis_lateralis_46319_ID"
    ],
    "46321": [
        "Right_Mylohyoid_muscle_46321_ID",
        "Right_Mylohyoid_Muscle_46321_ID"
    ],
    "46322": [
        "Left_Mylohyoid_46322_ID",
        "Left_Mylohyoid_Muscle_46322_ID"
    ],
    "46326": [
        "Right_Geniohyoid_46326_ID"
    ],
    "46327": [
        "Left_Geniohyoid_46327_ID"
    ],
    "46443": [
        "Right_Coccygeus_46443_ID"
    ],
    "46444": [
        "Left_Coccygeus_46444_ID"
    ],
    "46563": [
        "Vertical_part_of_left_cricothyroid_muscle_46563_ID",
        "Right_Cricothyroid_muscle_46563_ID",
        "Oblique_part_of_left_cricothyroid_muscle_46563_ID"
    ],
    "46564": [
        "Vertical_part_of_left_cricothyroid_muscle_46564_ID",
        "Left_Cricothyroid_muscle_46564_ID",
        "Oblique_part_of_left_cricothyroid_muscle_46564_ID"
    ],
    "46621": [
        "Superior_Pharyngeal_Constrictor_46621_ID"
    ],
    "46622": [
        "Middle_Pharyngeal_Constrictor_46622_ID"
    ],
    "46623": [
        "Inferior_Pharyngeal_Constrictor_46623_ID"
    ],
    "46690": [
        "Genioglossus_46690_ID"
    ],
    "46703": [
        "Right_Hyoglossus_46703_ID"
    ],
    "46704": [
        "Left_Hyoglossus_46704_ID"
    ],
    "46705": [
        "Right_Styloglossus_46705_ID"
    ],
    "46706": [
        "Right_Styloglossus_46706_ID",
        "Left_Styloglossus_46706_ID"
    ],
    "46759": [
        "Right_frontalis_46759_ID"
    ],
    "46760": [
        "Left_frontalis_46760_ID"
    ],
    "46761": [
        "Right_occipitalis_46761_ID"
    ],
    "46762": [
        "Left_occipitalis_46762_ID"
    ],
    "46768": [
        "Epicranial_aponeurosis_46768_ID"
    ],
    "46777": [
        "Depressor_septi_nasi_46777_ID"
    ],
    "46792": [
        "Right_orbicularis_oculi_46792_ID"
    ],
    "46793": [
        "Left_orbicularis_oculi_46793_ID"
    ],
    "46796": [
        "Right_corrugator_supercilii_46796_ID"
    ],
    "46797": [
        "Left_corrugator_supercilii_46797_ID"
    ],
    "46803": [
        "Right_levator_labii_superioris_alaeque_nasi_46803_ID"
    ],
    "46804": [
        "Left_levator_labii_superioris_alaeque_nasi_46804_ID"
    ],
    "46806": [
        "Right_levator_labii_superioris_46806_ID"
    ],
    "46807": [
        "Left_levator_labii_superioris_46807_ID"
    ],
    "46812": [
        "Right_zygomaticus_major_46812_ID"
    ],
    "46813": [
        "Left_zygomaticus_major_46813_ID"
    ],
    "46814": [
        "Right_zygomaticus_minor_46814_ID"
    ],
    "46815": [
        "Left_zygomaticus_minor_46815_ID"
    ],
    "46817": [
        "Right_depressor_labii_inferioris_46817_ID"
    ],
    "46818": [
        "Left_depressor_labii_inferioris_46818_ID"
    ],
    "46823": [
        "Right_levator_anguli_oris_46823_ID"
    ],
    "46824": [
        "Left_levator_anguli_oris_46824_ID"
    ],
    "46826": [
        "Right_mentalis_46826_ID"
    ],
    "46827": [
        "Left_mentalis_46827_ID"
    ],
    "46829": [
        "Right_depressor_anguli_oris_46829_ID"
    ],
    "46830": [
        "Left_depressor_anguli_oris_46830_ID"
    ],
    "46835": [
        "Right_buccinator_46835_ID"
    ],
    "46836": [
        "Left_buccinator_46836_ID"
    ],
    "46839": [
        "Right_risorius_46839_ID"
    ],
    "46840": [
        "Left_risorius_46840_ID"
    ],
    "46841": [
        "Orbicularis_oris_46841_ID"
    ],
    "48025": [
        "Left_Tendon_of_Digastric_48025_ID",
        "Right_Tendon_of_Digastric_48025_ID",
        "Right_Tendon_of_Digastric_Muscle_48025_ID",
        "Left_Tendon_of_Digastric_Muscle_48025_ID"
    ],
    "48957": [
        "Right_auricularis_superior_48957_ID"
    ],
    "48958": [
        "Left_auricularis_superior_48958_ID"
    ],
    "48959": [
        "Right_auricularis_anterior_48959_ID"
    ],
    "48960": [
        "Left_auricularis_anterior_48960_ID"
    ],
    "48961": [
        "Right_auricularis_posterior_48961_ID"
    ],
    "48962": [
        "Left_auricularis_posterior_48962_ID"
    ],
    "48997": [
        "Right_masseter_48997_ID"
    ],
    "48998": [
        "Left_masseter_48998_ID"
    ],
    "49007": [
        "Right_temporalis_49007_ID"
    ],
    "49008": [
        "Left_temporalis_49008_ID"
    ],
    "49012": [
        "Right_Medial_Pterygoid_49012_ID"
    ],
    "49013": [
        "Left_Medial_Pterygoid_49013_ID"
    ],
    "49016": [
        "Right_inferior_lateral_pterygoid_49016_ID",
        "Right_superior_lateral_pterygoid_49016_ID"
    ],
    "49017": [
        "Left_superior_lateral_pterygoid_49017_ID",
        "Left_inferior_lateral_pterygoid_49017_ID"
    ],
    "49036": [
        "Left_inferior_rectus_49036_ID"
    ],
    "49044": [
        "Right_superior_rectus_49044_ID"
    ],
    "49045": [
        "Left_superior_rectus_49045_ID"
    ],
    "49046": [
        "Right_inferior_rectus_49046_ID"
    ],
    "49047": [
        "Left_inferior_rectus_49047_ID"
    ],
    "49048": [
        "Right_levator_palpebrae_superioris_49048_ID"
    ],
    "49049": [
        "Left_levator_palpebrae_superioris_49049_ID"
    ],
    "49050": [
        "Right_inferior_oblique_49050_ID"
    ],
    "49051": [
        "Left_inferior_oblique_49051_ID"
    ],
    "49052": [
        "Right_superior_oblique_49052_ID"
    ],
    "49053": [
        "Left_superior_oblique_49053_ID"
    ],
    "49054": [
        "Right_lateral_rectus_49054_ID"
    ],
    "49055": [
        "Left_lateral_rectus_49055_ID"
    ],
    "49056": [
        "Right_medial_rectus_49056_ID"
    ],
    "49057": [
        "Left_medial_rectus_49057_ID"
    ],
    "49152": [
        "Right_Ciliary_Muscle_49152_ID"
    ],
    "49153": [
        "Left_Ciliary_Muscle_49153_ID"
    ],
    "49177": [
        "Upper_Gastrointestinal_Tract_49177_ID"
    ],
    "49386": [
        "Right_Inferior_extensor_retinaculum_49386_ID",
        "Left_Inferior_extensor_retinaculum_49386_ID"
    ],
    "49388": [
        "Right_Superior_extensor_retinaculum_49388_ID",
        "Left_Superior_extensor_retinaculum_49388_ID"
    ],
    "49481": [
        "Right_superior_laryngeal_artery_49481_ID"
    ],
    "49482": [
        "Left_superior_laryngeal_artery_49482_ID"
    ],
    "49486": [
        "Right_superior_thyroid_artery_49486_ID"
    ],
    "49487": [
        "Left_superior_thyroid_artery_49487_ID"
    ],
    "49498": [
        "Right_ascending_pharyngeal_artery_49498_ID"
    ],
    "49499": [
        "Left_ascending_pharyngeal_artery_49499_ID"
    ],
    "49550": [
        "Right_facial_artery_49550_ID"
    ],
    "49551": [
        "Left_facial_artery_49551_ID",
        "Right_facial_artery_49551_ID"
    ],
    "49552": [
        "Left_facial_artery_49552_ID"
    ],
    "49556": [
        "Right_ascending_palatine_artery_49556_ID"
    ],
    "49557": [
        "Left_ascending_palatine_artery_49557_ID"
    ],
    "49559": [
        "Right_tonsillar_artery_49559_ID"
    ],
    "49560": [
        "Left_tonsillar_artery_49560_ID"
    ],
    "49561": [
        "Right_tonsillar_artery_49561_ID"
    ],
    "49567": [
        "Inferior_labial_artery_49567_ID"
    ],
    "49570": [
        "Superior_labial_artery_49570_ID"
    ],
    "49584": [
        "Right_angular_artery_49584_ID"
    ],
    "49585": [
        "Left_angular_artery_49585_ID"
    ],
    "49625": [
        "Right_posterior_auricular_artery_49625_ID"
    ],
    "49626": [
        "Left_posterior_auricular_artery_49626_ID"
    ],
    "49651": [
        "Right_superficial_temporal_artery_49651_ID"
    ],
    "49652": [
        "Left_superficial_temporal_artery_49652_ID"
    ],
    "49658": [
        "Right_transverse_facial_artery_49658_ID"
    ],
    "49659": [
        "Left_transverse_facial_artery_49659_ID"
    ],
    "49660": [
        "Right_transverse_facial_artery_49660_ID"
    ],
    "49676": [
        "Right_maxillary_artery_49676_ID"
    ],
    "49677": [
        "Left_maxillary_artery_49677_ID"
    ],
    "49678": [
        "Right_maxillary_artery_49678_ID"
    ],
    "49705": [
        "Right_mental_artery_49705_ID",
        "branch_of_right_mental_artery_49705_ID"
    ],
    "49706": [
        "Left_mental_artery_49706_ID",
        "branch_of_left_mental_artery_49706_ID"
    ],
    "49712": [
        "Right_middle_meningeal_artery_49712_ID"
    ],
    "49713": [
        "Left_middle_meningeal_artery_49713_ID"
    ],
    "49743": [
        "Right_deep_temporal_artery_49743_ID"
    ],
    "49744": [
        "Left_deep_temporal_artery_49744_ID"
    ],
    "49755": [
        "Right_buccal_artery_49755_ID"
    ],
    "49756": [
        "Left_buccal_artery_49756_ID"
    ],
    "49768": [
        "Right_infraorbital_artery_49768_ID"
    ],
    "49769": [
        "Left_infraorbital_artery_49769_ID"
    ],
    "49792": [
        "Right_descending_palatine_artery_49792_ID"
    ],
    "49793": [
        "Left_descending_palatine_artery_49793_ID"
    ],
    "49799": [
        "Left_greater_palatine_artery_49799_ID"
    ],
    "49800": [
        "Right_greater_palatine_artery_49800_ID"
    ],
    "49802": [
        "Right_lesser_palatine_artery_49802_ID"
    ],
    "49803": [
        "Left_lesser_palatine_artery_49803_ID"
    ],
    "49805": [
        "Right_sphenopalatine_artery_49805_ID"
    ],
    "49806": [
        "Left_sphenopalatine_artery_49806_ID"
    ],
    "49810": [
        "Right_posterior_lateral_nasal_artery_49810_ID"
    ],
    "49811": [
        "Left_posterior_lateral_nasal_artery_49811_ID"
    ],
    "49812": [
        "Posterior_septal_branch_of_right_sphenopalatine_artery_49812_ID"
    ],
    "49813": [
        "Posterior_septal_branch_of_left_sphenopalatine_artery_49813_ID"
    ],
    "49869": [
        "Right_opthalmic_artery_49869_ID",
        "Right_ophthalmic_artery_49869_ID"
    ],
    "49870": [
        "Left_opthalmic_artery_49870_ID",
        "Left_ophthalmic_artery_49870_ID"
    ],
    "49881": [
        "Right_central_retinal_artery_49881_ID",
        "Left_central_retinal_artery_49881_ID"
    ],
    "49911": [
        "Right_Inferior_Pulmonary_vein_49911_ID"
    ],
    "49913": [
        "Left_Inferior_Pulmonary_vein_49913_ID"
    ],
    "49914": [
        "Right_Superior_Pulmonary_vein_49914_ID"
    ],
    "49916": [
        "Left_Superior_Pulmonary_vein_49916_ID"
    ],
    "49928": [
        "Right_lacrimal_artery_49928_ID"
    ],
    "49929": [
        "Left_lacrimal_artery_49929_ID"
    ],
    "49974": [
        "Right_supraorbital_artery_49974_ID"
    ],
    "49975": [
        "Left_supraorbital_artery_49975_ID"
    ],
    "49987": [
        "Right_anterior_ethmoidal_artery_49987_ID"
    ],
    "49988": [
        "Left_anterior_ethmoidal_artery_49988_ID"
    ],
    "49990": [
        "Right_posterior_ethmoidal_artery_49990_ID"
    ],
    "49991": [
        "Left_posterior_ethmoidal_artery_49991_ID"
    ],
    "50001": [
        "Right_dorsal_nasal_artery_50001_ID"
    ],
    "50002": [
        "Left_dorsal_nasal_artery_50002_ID"
    ],
    "50026": [
        "Right_supratrochlear_artery_50026_ID"
    ],
    "50027": [
        "Left_supratrochlear_artery_50027_ID",
        "Right_supratrochlear_artery_50027_ID"
    ],
    "50028": [
        "Left_supratrochlear_artery_50028_ID"
    ],
    "50029": [
        "Right_anterior_cerebral_artery_50029_ID"
    ],
    "50030": [
        "Left_anterior_cerebral_artery_50030_ID"
    ],
    "50031": [
        "Left_anterior_cerebral_artery_50031_ID"
    ],
    "50038": [
        "Left_coronary_artery_50038_ID"
    ],
    "50039": [
        "Right_Coronary_Artery_50039_ID"
    ],
    "50082": [
        "Right_Middle_Cerebral_Artery_50082_ID"
    ],
    "50083": [
        "Left_Middle_Cerebral_Artery_50083_ID"
    ],
    "50085": [
        "Right_Posterior_Communicating_Artery_50085_ID"
    ],
    "50086": [
        "Left_Posterior_Communicating_Artery_50086_ID"
    ],
    "50169": [
        "Anterior_Communicating_Artery_50169_ID"
    ],
    "50197": [
        "Muscles_of_the_Right_Arm_50197_ID"
    ],
    "50198": [
        "Muscles_of_the_Right_Arm_50198_ID",
        "Muscles_of_the_Left_Arm_50198_ID"
    ],
    "50203": [
        "Right_upper_arm_muscles_50203_ID"
    ],
    "50204": [
        "Right_upper_arm_muscles_50204_ID",
        "Left_upper_arm_muscles_50204_ID"
    ],
    "50221": [
        "Right_shoulder_muscles_50221_ID",
        "Left_shoulder_muscles_50221_ID"
    ],
    "50222": [
        "Left_shoulder_muscles_50222_ID",
        "Right_shoulder_muscles_50222_ID"
    ],
    "50542": [
        "Basilar_Artery_50542_ID"
    ],
    "50545": [
        "Right_Anterior_Inferior_cerebellar_artery_50545_ID",
        "Right_anterior_Inferior_cerebellar_artery_50545_ID"
    ],
    "50546": [
        "Left_Anterior_Inferior_cerebellar_artery_50546_ID",
        "Left_anterior_Inferior_cerebellar_artery_50546_ID"
    ],
    "50574": [
        "Right_Superior_Cerebellar_artery_50574_ID"
    ],
    "50575": [
        "Left_Superior_Cerebellar_Artery_50575_ID",
        "Left_Superior_Cerebellar_artery_50575_ID"
    ],
    "50584": [
        "Right_Posterior_cerebral_artery_50584_ID",
        "Right_posterior_cerebral_artery_50584_ID"
    ],
    "50585": [
        "Left_Posterior_cerebral_artery_50585_ID",
        "Left_posterior_cerebral_artery_50585_ID"
    ],
    "50718": [
        "Superior_Terminal_Branch_of_Right_Middle_Cerebral_Artery_50718_ID"
    ],
    "50719": [
        "Superior_Terminal_Branch_of_Left_Middle_Cerebral_Artery_50719_ID"
    ],
    "50735": [
        "Hepatic_Portal_and_Associated_Branches_50735_ID"
    ],
    "50764": [
        "Right_transverse_sinus_50764_ID"
    ],
    "50765": [
        "Left_transverse_sinus_50765_ID"
    ],
    "50767": [
        "Superior_sagittal_sinus_50767_ID"
    ],
    "50768": [
        "Inferior_Sagittal_Sinus_50768_ID"
    ],
    "50769": [
        "Straight_Sinus_50769_ID"
    ],
    "50773": [
        "Intercavernous_sinus_50773_ID"
    ],
    "50781": [
        "Occipital_Sinus_50781_ID"
    ],
    "50784": [
        "Sinus_Confluence_50784_ID"
    ],
    "50808": [
        "Right_superior_thyroid_vein_50808_ID"
    ],
    "50809": [
        "Left_superior_thyroid_vein_50809_ID"
    ],
    "50852": [
        "Right_posterior_auricular_vein_50852_ID"
    ],
    "50853": [
        "Left_posterior_auricular_vein_50853_ID"
    ],
    "50859": [
        "Right_suprascapular_vein_50859_ID"
    ],
    "50860": [
        "Left_suprascapular_vein_50860_ID",
        "Right_suprascapular_vein_50860_ID"
    ],
    "50872": [
        "Right_Pulmonary_artery_50872_ID"
    ],
    "50873": [
        "Left_Pulmonary_artery_50873_ID"
    ],
    "50875": [
        "Right_optic_nerve_50875_ID"
    ],
    "50876": [
        "Left_Facial_Vein_50876_ID",
        "Right_Facial_Vein_50876_ID"
    ],
    "50877": [
        "Right_Facial_Vein_50877_ID",
        "Left_Facial_Vein_50877_ID"
    ],
    "50878": [
        "Left_optic_nerve_50878_ID"
    ],
    "50879": [
        "Right_oculomotor_nerve_50879_ID"
    ],
    "50880": [
        "Left_oculomotor_nerve_50880_ID"
    ],
    "50881": [
        "Right_trochlear_nerve_50881_ID"
    ],
    "50882": [
        "Left_trochlear_nerve_50882_ID"
    ],
    "50886": [
        "Right_abducens_nerve_50886_ID"
    ],
    "50887": [
        "Left_abducens_nerve_50887_ID"
    ],
    "50888": [
        "Right_facial_nerve_50888_ID"
    ],
    "50889": [
        "Left_facial_nerve_50889_ID"
    ],
    "50890": [
        "Right_vestibulocochlear_nerve_50890_ID"
    ],
    "50891": [
        "Left_vestibulocochlear_nerve_50891_ID"
    ],
    "50892": [
        "Right_glossopharyngeal_nerve_50892_ID"
    ],
    "50894": [
        "Left_glossopharyngeal_nerve_50894_ID"
    ],
    "50897": [
        "Right_spinal_accessory_nerve_50897_ID",
        "Left_spinal_accessory_nerve_50897_ID"
    ],
    "50899": [
        "Left_spinal_accessory_nerve_50899_ID"
    ],
    "50902": [
        "Right_hypoglossal_nerve_50902_ID"
    ],
    "50903": [
        "Left_hypoglossal_Nerve_50903_ID"
    ],
    "50929": [
        "Right_retromandibular_vein_50929_ID"
    ],
    "50930": [
        "Left_retromandibular_vein_50930_ID"
    ],
    "50933": [
        "Right_Superficial_Temporal_Vein_50933_ID"
    ],
    "50934": [
        "Left_Superficial_Temporal_Vein_50934_ID"
    ],
    "51042": [
        "Right_Deep_Femoral_vein_51042_ID"
    ],
    "51043": [
        "Left_Deep_Femoral_vein_51043_ID"
    ],
    "51085": [
        "Tendon_of_left_flexor_digitorum_brevis_51085_ID",
        "Tendon_of_right_flexor_digitorum_brevis_51085_ID",
        "Right_flexor_digitorum_longus_51085_ID",
        "Left_flexor_digitorum_longus_51085_ID"
    ],
    "51289": [
        "Right_superior_petrosal_sinus_51289_ID"
    ],
    "51290": [
        "Left_superior_petrosal_sinus_51290_ID"
    ],
    "51402": [
        "Right_Cavernous_sinus_51402_ID"
    ],
    "51403": [
        "Left_Cavernous_Sinus_51403_ID"
    ],
    "51489": [
        "Right_occipital_vein_51489_ID"
    ],
    "51490": [
        "Left_occipital_vein_51490_ID"
    ],
    "51885": [
        "Left_central_retinal_vein_51885_ID",
        "Right_central_retinal_vein_51885_ID"
    ],
    "51942": [
        "Right_superior_central_retinal_artery_51942_ID",
        "Left_superior_central_retinal_artery_51942_ID"
    ],
    "51944": [
        "Right_inferior_central_retinal_artery_51944_ID",
        "Left_inferior_central_retinal_artery_51944_ID"
    ],
    "52619": [
        "Right_trigeminal_ganglion_52619_ID"
    ],
    "52620": [
        "Left_trigeminal_ganglion_52620_ID"
    ],
    "52629": [
        "Right_lacrimal_nerve_52629_ID"
    ],
    "52630": [
        "Left_lacrimal_nerve_52630_ID"
    ],
    "52639": [
        "Right_opthalmic_nerve_52639_ID"
    ],
    "52640": [
        "Left_opthalmic_nerve_52640_ID"
    ],
    "52643": [
        "Right_supratrochlear_nerve_52643_ID"
    ],
    "52644": [
        "Left_supratrochlear_nerve_52644_ID"
    ],
    "52661": [
        "Medial_branch_of_right_supraorbital_nerve_52661_ID"
    ],
    "52662": [
        "Medial_branch_of_left_supraorbital_nerve_52662_ID"
    ],
    "52663": [
        "Lateral_branch_of_right_supraorbital_nerve_52663_ID"
    ],
    "52664": [
        "Lateral_branch_of_left_supraorbital_nerve_52664_ID"
    ],
    "52669": [
        "Right_nasociliary_nerve_52669_ID"
    ],
    "52670": [
        "Left_nasociliary_nerve_52670_ID"
    ],
    "52725": [
        "Right_maxillary_nerve_52725_ID"
    ],
    "52726": [
        "Left_maxillary_nerve_52726_ID"
    ],
    "52734": [
        "Frontal_bone_52734_ID"
    ],
    "52735": [
        "Occipital_bone_52735_ID"
    ],
    "52736": [
        "Sphenoid_bone_52736_ID"
    ],
    "52738": [
        "Right_temporal_bone_52738_ID"
    ],
    "52739": [
        "Left_temporal_bone_52739_ID"
    ],
    "52740": [
        "Ethmoid_bone_52740_ID"
    ],
    "52745": [
        "Nasal_bone_52745_ID"
    ],
    "52746": [
        "Palatine_bone_52746_ID"
    ],
    "52748": [
        "Mandible_52748_ID"
    ],
    "52749": [
        "Hyoid_bone_52749_ID"
    ],
    "52784": [
        "Left_lateral_posterior_superior_nasal_nerve_52784_ID"
    ],
    "52785": [
        "Right_lateral_posterior_superior_nasal_nerve_52785_ID"
    ],
    "52788": [
        "Right_parietal_bone_52788_ID"
    ],
    "52789": [
        "Left_parietal_bone_52789_ID"
    ],
    "52803": [
        "Right_greater_palatine_nerve_52803_ID"
    ],
    "52804": [
        "Left_greater_palatine_nerve_52804_ID"
    ],
    "52806": [
        "Right_lesser_palatine_nerve_52806_ID"
    ],
    "52807": [
        "Left_lesser_palatine_nerve_52807_ID"
    ],
    "52824": [
        "Left_posterior_inferior_nasal_nerve_52824_ID"
    ],
    "52825": [
        "Right_posterior_inferior_nasal_nerve_52825_ID"
    ],
    "52892": [
        "Right_zygomatic_bone_52892_ID"
    ],
    "52893": [
        "Left_zygomatic_bone_52893_ID"
    ],
    "52974": [
        "Zygomaticotemporal_branch_of_right_zygomatic_nerve_52974_ID"
    ],
    "52975": [
        "Zygomaticotemporal_branch_of_left_zygomatic_nerve_52975_ID"
    ],
    "52976": [
        "Zygomaticofacial_branch_of_right_zygomatic_nerve_52976_ID"
    ],
    "52977": [
        "Zygomaticotemporal_branch_of_right_zygomatic_nerve_52977_ID",
        "Zygomaticofacial_branch_of_left_zygomatic_nerve_52977_ID"
    ],
    "52978": [
        "Zygomaticotemporal_branch_of_left_zygomatic_nerve_52978_ID"
    ],
    "52979": [
        "Right_infraorbital_nerve_52979_ID"
    ],
    "52980": [
        "Left_infra_orbital_nerve_52980_ID",
        "Left_infraorbital_nerve_52980_ID"
    ],
    "52997": [
        "Right_Mandibular_Nerve_52997_ID"
    ],
    "52998": [
        "Left_Mandibular_Nerve_52998_ID"
    ],
    "53001": [
        "Right_auriculotemporal_nerve_53001_ID"
    ],
    "53002": [
        "Left_auriculotemporal_nerve_53002_ID"
    ],
    "53069": [
        "Right_pterygopalatine_ganglion_53069_ID"
    ],
    "53070": [
        "Left_pterygopalatine_ganglion_53070_ID"
    ],
    "53121": [
        "Right_zygomatic_bone_53121_ID"
    ],
    "53122": [
        "Left_zygomatic_bone_53122_ID"
    ],
    "53185": [
        "Buccal_branch_of_right_facial_nerve_53185_ID",
        "Buccal_branch_of_Right_Facial_Nerve_53185_ID"
    ],
    "53186": [
        "Buccal_branch_of_Left_Facial_Nerve_53186_ID"
    ],
    "53219": [
        "Right_lingual_nerve_53219_ID"
    ],
    "53220": [
        "Left_lingual_nerve_53220_ID"
    ],
    "53244": [
        "Right_Inferior_Alveolar_Nerve_53244_ID"
    ],
    "53245": [
        "Left_Inferior_Alveolar_Nerve_53245_ID"
    ],
    "53251": [
        "Right_mental_nerve_53251_ID",
        "Left_mental_nerve_53251_ID"
    ],
    "53252": [
        "Left_mental_nerve_53252_ID"
    ],
    "53279": [
        "Right_posterior_auricular_nerve_53279_ID"
    ],
    "53280": [
        "Left_posterior_auricular_nerve_53280_ID"
    ],
    "53290": [
        "Temporal_branch_of_the_right_facial_nerve_53290_ID"
    ],
    "53291": [
        "Temporal_branch_of_the_left_facial_nerve_53291_ID",
        "Temporal_branch_of_the_right_facial_nerve_53291_ID"
    ],
    "53366": [
        "Marginal_mandibular_branch_of_right_facial_nerve_53366_ID"
    ],
    "53367": [
        "Marginal_mandibular_branch_of_left_facial_nerve_53367_ID"
    ],
    "53398": [
        "Cervical_branch_of_right_facial_nerve_53398_ID"
    ],
    "53399": [
        "Cervical_branch_of_left_facial_nerve_53399_ID"
    ],
    "53549": [
        "Right_ciliary_ganglion_53549_ID"
    ],
    "53550": [
        "Left_ciliary_ganglion_53550_ID"
    ],
    "53641": [
        "Right_ear_53641_ID"
    ],
    "53642": [
        "Left_ear_53642_ID"
    ],
    "53643": [
        "Left_ear_53643_ID"
    ],
    "53645": [
        "Right_Lacrimal_Bone_53645_ID"
    ],
    "53646": [
        "Left_lacrimal_bone_53646_ID"
    ],
    "53654": [
        "Palatine_bone_53654_ID"
    ],
    "54375": [
        "Nasal_septum_54375_ID"
    ],
    "54449": [
        "Right_eye_54449_ID"
    ],
    "54450": [
        "Left_eye_54450_ID"
    ],
    "54640": [
        "Tongue_54640_ID"
    ],
    "55099": [
        "Thyroid_Cartilage_55099_ID"
    ],
    "55123": [
        "Lower_part_of_cricopharyngeus_55123_ID"
    ],
    "55132": [
        "Thyrohyoid_Membrane_55132_ID"
    ],
    "55143": [
        "Right_ansa_cervicalis_nerve_55143_ID"
    ],
    "55144": [
        "left_ansa_cervicalis_nerve_55144_ID"
    ],
    "55145": [
        "Right_ansa_cervicalis_nerve_55145_ID"
    ],
    "55233": [
        "Cricothyroid_ligament_55233_ID"
    ],
    "55560": [
        "Right_Superior_Parathyroid_55560_ID"
    ],
    "55561": [
        "Left_Superior_Parathyroid_55561_ID"
    ],
    "55562": [
        "Right_Inferior_Parathyroid_55562_ID"
    ],
    "55563": [
        "Left_Inferior_Parathyroid_55563_ID"
    ],
    "55610": [
        "Right_procerus_55610_ID"
    ],
    "55611": [
        "Left_procerus_55611_ID"
    ],
    "55612": [
        "Transverse_part_of_right_nasalis_55612_ID"
    ],
    "55613": [
        "Transverse_part_of_left_nasalis_55613_ID"
    ],
    "55614": [
        "Alar_part_of_right_nasalis_55614_ID"
    ],
    "55615": [
        "Alar_part_of_left_nasalis_55615_ID"
    ],
    "56103": [
        "Right_Internal_acoustic_meatus_56103_ID"
    ],
    "56104": [
        "Left_Internal_acoustic_meatus_56104_ID"
    ],
    "56427": [
        "Right_tympanic_membrane_56427_ID"
    ],
    "56428": [
        "Left_tympanic_membrane_56428_ID"
    ],
    "58236": [
        "Right_Iris_58236_ID"
    ],
    "58237": [
        "Left_Iris_58237_ID"
    ],
    "58242": [
        "Right_Lens_58242_ID"
    ],
    "58243": [
        "Left_Lens_58243_ID"
    ],
    "58271": [
        "Right_Sclera_58271_ID"
    ],
    "58272": [
        "Left_Sclera_58272_ID"
    ],
    "58299": [
        "Right_Choroid_58299_ID"
    ],
    "58300": [
        "Left_Choroid_58300_ID"
    ],
    "58302": [
        "Right_Retina_58302_ID"
    ],
    "58303": [
        "Left_Retina_58303_ID"
    ],
    "58841": [
        "Right_Hyaloid_Canal_58841_ID"
    ],
    "58842": [
        "Left_Hyaloid_Canal_58842_ID"
    ],
    "59102": [
        "Right_lacrimal_gland_59102_ID"
    ],
    "59103": [
        "Left_lacrimal_gland_59103_ID"
    ],
    "59505": [
        "Right_major_alar_cartilage_59505_ID"
    ],
    "59506": [
        "Left_major_alar_cartilage_59506_ID"
    ],
    "59512": [
        "Right_lateral_nasal_cartilage_59512_ID"
    ],
    "59513": [
        "Left_lateral_nasal_cartilage_59513_ID"
    ],
    "59545": [
        "Right_lacrimal_sac_59545_ID"
    ],
    "59546": [
        "Left_lacrimal_sac_59546_ID"
    ],
    "59797": [
        "Left_Parotid_Gland_59797_ID",
        "Right_Parotid_Gland_59797_ID"
    ],
    "59798": [
        "Right_Parotid_Gland_59798_ID",
        "Left_Parotid_Gland_59798_ID"
    ],
    "59802": [
        "Right_Submandibular_Gland_59802_ID"
    ],
    "59803": [
        "Left_Submandibular_Gland_59803_ID"
    ],
    "59804": [
        "Right_Sublingual_Gland_59804_ID"
    ],
    "59805": [
        "Left_Sublingual_Gland_59805_ID"
    ],
    "59866": [
        "Right_Parotid_Duct_59866_ID"
    ],
    "59867": [
        "Left_Parotid_Duct_59867_ID"
    ],
    "59964": [
        "Right_Submandibular_Duct_59964_ID"
    ],
    "59965": [
        "Left_Submandibular_Duct_59965_ID"
    ],
    "60180": [
        "Right_osseous_labyrinth_60180_ID"
    ],
    "60181": [
        "Left_osseous_labyrinth_60181_ID"
    ],
    "60188": [
        "Right_Anterior_semicircular_canal_60188_ID"
    ],
    "60189": [
        "Left_Anterior_semicircular_canal_60189_ID"
    ],
    "60191": [
        "Right_Posterior_semicircular_canal_60191_ID"
    ],
    "60192": [
        "Left_Posterior_semicircular_canal_60192_ID"
    ],
    "60194": [
        "Right_Lateral_semicircular_canal_60194_ID"
    ],
    "60195": [
        "Left_Lateral_semicircular_canal_60195_ID"
    ],
    "60202": [
        "Right_Cochlea_60202_ID"
    ],
    "60203": [
        "Left_Cochlea_60203_ID"
    ],
    "61020": [
        "Right_Internal_Ear_61020_ID"
    ],
    "61021": [
        "Left_Internal_Ear_61021_ID"
    ],
    "61735": [
        "Right_external_acoustic_tube_61735_ID"
    ],
    "61736": [
        "Left_external_acoustic_tube_61736_ID"
    ],
    "61965": [
        "fornix_61965_ID"
    ],
    "62008": [
        "hypothalamus_62008_ID"
    ],
    "62033": [
        "Pineal_Gland_62033_ID"
    ],
    "62045": [
        "optic_chiasm_62045_ID"
    ],
    "64919": [
        "Right_Iliopsoas_64919_ID"
    ],
    "64920": [
        "Left_Iliopsoas_64920_ID"
    ],
    "65015": [
        "Left_Flexor_hallucis_longus_65015_ID",
        "Right_Flexor_hallucis_longus_65015_ID"
    ],
    "65019": [
        "Left_Tibialis_posterior_65019_ID",
        "Right_Tibialis_posterior_65019_ID"
    ],
    "65281": [
        "Right_long_thoracic_nerve_65281_ID"
    ],
    "65282": [
        "Left_long_thoracic_nerve_65282_ID"
    ],
    "65536": [
        "Right_lumbosacral_trunk_nerve_65536_ID"
    ],
    "65537": [
        "Left_lumbosacral_trunk_nerve_65537_ID",
        "Left_lumbosacral_trunk_65537_ID"
    ],
    "66321": [
        "Right_thoracodorsal_artery_66321_ID"
    ],
    "66322": [
        "right_thoracodorsal_artery_66322_ID",
        "left_thoracodorsal_artery_66322_ID"
    ],
    "67584": [
        "Left_nerve_of_pterygoid_canal_67584_ID",
        "Right_nerve_of_pterygoid_canal_67584_ID"
    ],
    "67944": [
        "cerebellum_67944_ID"
    ],
    "69316": [
        "Right_Brachiocephalic_trunk_69316_ID"
    ],
    "69490": [
        "Right_lateral_tarsal_artery_69490_ID"
    ],
    "69491": [
        "Left_lateral_tarsal_artery_69491_ID"
    ],
    "69494": [
        "Right_arcuate_artery_69494_ID"
    ],
    "69495": [
        "Left_arcuate_artery_69495_ID"
    ],
    "69514": [
        "Right_deep_plantar_artery_69514_ID"
    ],
    "69515": [
        "Right_deep_plantar_artery_69515_ID"
    ],
    "69516": [
        "Left_deep_plantar_artery_69516_ID"
    ],
    "69726": [
        "Calcaneal_branch_of_right_posterior_tibial_artery_69726_ID"
    ],
    "69727": [
        "Calcaneal_branch_of_left_posterior_tibial_artery_69727_ID"
    ],
    "70249": [
        "Right_femoral_artery_70249_ID"
    ],
    "70250": [
        "Left_femoral_artery_70250_ID"
    ],
    "70799": [
        "Right_dorsal_metacarpal_arteries_70799_ID"
    ],
    "70800": [
        "left_dorsal_metacarpal_arteries_70800_ID",
        "right_dorsal_metacarpal_arteries_70800_ID"
    ],
    "70801": [
        "left_dorsal_digital_arteries_70801_ID",
        "right_dorsal_digital_arteries_70801_ID",
        "Right_dorsal_digital_arteries_70801_ID",
        "Right_palmar_metacarpal_arteries_70801_ID"
    ],
    "70802": [
        "left_palmar_metacarpal_arteries_70802_ID",
        "right_palmar_metacarpal_arteries_70802_ID",
        "Right_common_palmar_digital_arteries_70802_ID"
    ],
    "70803": [
        "right_common_palmar_digital_arteries_70803_ID",
        "Right_proper_palmar_digital_arteries_70803_ID",
        "left_common_palmar_digital_arteries_70803_ID"
    ],
    "70804": [
        "left_proper_palmar_digital_arteries_70804_ID",
        "right_proper_palmar_digital_arteries_70804_ID",
        "left_common_palmar_digital_arteries_70804_ID"
    ],
    "70809": [
        "Set_of_Jejunal_arteries_70809_ID"
    ],
    "70810": [
        "Set_of_ileal_arteries_70810_ID"
    ],
    "70815": [
        "Perforating_arteries_of_left_deep_fibular_artery_70815_ID",
        "Perforating_arteries_of_right_deep_fibular_artery_70815_ID"
    ],
    "70889": [
        "Left_lumbar_vein_70889_ID",
        "Right_lumbar_vein_70889_ID"
    ],
    "70917": [
        "Right_palmar_digital_veins_70917_ID"
    ],
    "70918": [
        "right_palmar_digital_veins_70918_ID",
        "left_palmar_digital_veins_70918_ID"
    ],
    "70922": [
        "Right_distal_perforating_veins_70922_ID",
        "Perforating_veins_of_right_deep_femoral_artery_70922_ID",
        "Perforating_veins_of_left_deep_femoral_artery_70922_ID",
        "Left_distal_perforating_veins_70922_ID"
    ],
    "70927": [
        "Set_of_jejunal_veins_70927_ID"
    ],
    "70928": [
        "Set_of_ileal_veins_70928_ID"
    ],
    "71132": [
        "Gastrointestinal_Tract_71132_ID"
    ],
    "71211": [
        "Right_lateral_thoracic_vein_71211_ID"
    ],
    "71212": [
        "Left_lateral_thoracic_vein_71212_ID",
        "Right_lateral_thoracic_vein_71212_ID"
    ],
    "71214": [
        "Right_thoracodorsal_vein_71214_ID",
        "Left_thoracodorsal_vein_71214_ID"
    ],
    "71215": [
        "Right_thoracodorsal_vein_71215_ID"
    ],
    "71287": [
        "Muscles_of_the_Head_and_Neck_71287_ID"
    ],
    "71291": [
        "Muscles_of_the_Back_71291_ID"
    ],
    "71293": [
        "Muscles_of_the_Thorax_71293_ID"
    ],
    "71310": [
        "Left_Intertransversarii_71310_ID",
        "Right_Intertransversarii_71310_ID"
    ],
    "71398": [
        "Left_Radiate_Sternocostal_Ligaments_71398_ID",
        "Right_Radiate_Sternocostal_Ligaments_71398_ID"
    ],
    "71894": [
        "Right_carpal_bones_71894_ID",
        "Left_carpal_bones_71894_ID"
    ],
    "71898": [
        "Right_metacarpal_bones_of_hand_71898_ID",
        "Left_metacarpal_bones_of_hand_71898_ID"
    ],
    "71900": [
        "Phalanges_of_right_hand_71900_ID",
        "Phalanges_of_left_hand_71900_ID"
    ],
    "72063": [
        "Set_of_cervical_vertebrae_72063_ID"
    ],
    "72064": [
        "Set_of_thoracic_vertebrae_72064_ID"
    ],
    "72065": [
        "Set_of_lumbar_vertebrae_72065_ID"
    ],
    "72309": [
        "Right_Stylohyoid_Ligament_72309_ID"
    ],
    "72311": [
        "Left_Stylohyoid_Ligament_72311_ID"
    ],
    "72316": [
        "Set_of_intervertebral_discs_72316_ID"
    ],
    "72826": [
        "right_caudate_nucleus_72826_ID"
    ],
    "72827": [
        "left_caudate_nucleus_72827_ID"
    ],
    "72828": [
        "right_putamen_72828_ID"
    ],
    "72829": [
        "left_putamen_72829_ID"
    ],
    "72832": [
        "right_amygdaloid_body_72832_ID"
    ],
    "72833": [
        "left_amygdaloid_body_72833_ID"
    ],
    "72856": [
        "right_lateral_globus_pallidus_72856_ID"
    ],
    "72857": [
        "left_lateral_globus_pallidus_72857_ID"
    ],
    "72858": [
        "right_medial_globus_pallidus_72858_ID"
    ],
    "72859": [
        "left_medial_globus_pallidus_72859_ID"
    ],
    "74048": [
        "Right_stapes_74048_ID"
    ],
    "74049": [
        "Left_stapes_74049_ID"
    ],
    "74050": [
        "Right_Incus_74050_ID"
    ],
    "74051": [
        "Left_Incus_74051_ID"
    ],
    "74052": [
        "Right_malleus_74052_ID"
    ],
    "74053": [
        "Left_malleus_74053_ID"
    ],
    "74073": [
        "Right_Levatores_costarum_74073_ID"
    ],
    "74074": [
        "Left_Levatores_costarum_74074_ID"
    ],
    "74075": [
        "Right_Levatores_costarum_longi_74075_ID"
    ],
    "74076": [
        "Left_Levatores_costarum_longi_74076_ID"
    ],
    "74079": [
        "Right_Subcostales_74079_ID"
    ],
    "74080": [
        "Left_Subcostales_74080_ID"
    ],
    "74525": [
        "Occipital_74525_ID"
    ],
    "75150": [
        "Teeth_75150_ID"
    ],
    "75398": [
        "Superficial_dorsal_vein_of_penis_75398_ID"
    ],
    "75492": [
        "Right_common_plantar_digital_nerves_75492_ID"
    ],
    "75493": [
        "Left_common_plantar_digital_nerves_75493_ID"
    ],
    "76767": [
        "Anterior_cardiac_vein_76767_ID"
    ],
    "76829": [
        "Right_Zonula_Fibers_76829_ID",
        "Left_Zonula_Fibers_76829_ID"
    ],
    "77161": [
        "Intermediate_Hepatic_Vein_77161_ID"
    ],
    "77380": [
        "Right_popliteal_artery_77380_ID"
    ],
    "77381": [
        "Left_popliteal_artery_77381_ID"
    ],
    "77596": [
        "Hypogastric_nerve_77596_ID"
    ],
    "77949": [
        "Right_circumflex_scapular_vein_77949_ID"
    ],
    "77950": [
        "Right_circumflex_scapular_vein_77950_ID",
        "Left_circumflex_scapular_vein_77950_ID"
    ],
    "78023": [
        "Right_lateral_brachial_vein_78023_ID"
    ],
    "78024": [
        "right_lateral_brachial_vein_78024_ID",
        "left_lateral_brachial_vein_78024_ID"
    ],
    "78209": [
        "trunk_of_Hepatic_portal_vein_78209_ID"
    ],
    "78508": [
        "Right_tarsal_bones_78508_ID"
    ],
    "78509": [
        "Left_tarsal_bones_78509_ID"
    ],
    "78510": [
        "Right_metatarsal_bones_78510_ID"
    ],
    "79468": [
        "Right_accessory_meningeal_artery_79468_ID"
    ],
    "79469": [
        "Left_accessory_meningeal_artery_79469_ID"
    ],
    "82695": [
        "trunk_of_Hepatic_portal_vein_82695_ID"
    ],
    "82933": [
        "Right_Nerve_to_levator_ani_82933_ID"
    ],
    "82934": [
        "Left_Nerve_to_levator_ani_82934_ID"
    ],
    "85274": [
        "External_Urethral_Sphincter_85274_ID"
    ],
    "86233": [
        "Lymphatics_of_the_Upper_Limb_86233_ID"
    ],
    "86917": [
        "Muscles_of_the_Abdomen_86917_ID"
    ],
    "87217": [
        "Descending_aorta_thoracic_87217_ID",
        "Descending_thoracic_aorta_87217_ID"
    ],
    "228738": [
        "Muscles_of_the_Throat_228738_ID"
    ],
    "231317": [
        "Phalanges_of_the_right_foot_231317_ID"
    ],
    "231319": [
        "Phalanges_of_the_left_foot_231319_ID"
    ],
    "258714": [
        "right_thalamus_258714_ID"
    ],
    "258716": [
        "left_thalamus_258716_ID"
    ],
    "258847": [
        "Right_Calcaneal_Tendon__aka_Achilles_Tendon_258847_ID"
    ],
    "258848": [
        "Left_Calcaneal_Tendon__aka_Achilles_Tendon_258848_ID"
    ],
    "268668": [
        "Right_interosseous_recurrent_artery_268668_ID"
    ],
    "268669": [
        "right_interosseous_recurrent_artery_268669_ID",
        "left_interosseous_recurrent_artery_268669_ID"
    ]
};
;/**
 *  @namespace Manages network sockets to which remote clients can attach.
 */
(function () {
    "use strict";

    var HumanClients = Human.clients = {};

    /**
     * Number of remote clients connected to this engine
     * @type {number}
     */
    HumanClients.numConnections = 0;

    /**
     * Registers a client type
     * @param clazz
     */
    HumanClients.addClient = function (clientFn) {
        clientFn({
            connected: function () {
                HumanClients.numConnections++;
                Human.events.fire("clients.connected", {});
            },
            disconnected: function () {
                HumanClients.numConnections--;
                Human.events.fire("clients.disconnected", {});
            }
        });
    };

})();
;/**
 Window messaging

 */
Human.clients.addClient(
    function (cfg) {
        "use strict";

        var client;
        var clientOrigin;
        var responseQueue = [];
        var rpcQueue = [];
        // TODO (Tarek): Human.processes no longer exists, so the queuing logic should be removed.
        var countProcesses = 0; // Stalls rpcQueue when > 0
        var pQueueInterval;

        Human.events.on("started",
            function () {
                sendResponse({ message: "status", status: "ready" });
            });

        if (window.addEventListener) {

            // Relay errors back to client
            Human.events.on("error",
                function (error) {
                    sendResponse({ error: error });
                });

            // Relay any RPC procedure call results back to client
            Human.rpc.onResult(
                function (key, value) {
                    var results = {};
                    results[key] = Human.rpc.filterUnsafeProperties(value);
                    sendResponse({ results: results });
                });

            // Handle messages from client
            addEventListener("message",
                function (event) {
                    var msg;
                    try {
                        msg = JSON.parse(event.data);
                    } catch (e) {
                        return;
                    }
                    if (msg.action === "connect") {
                        // Connection request
                        if (!client) {
                            Human.log.info("Human.clients.windowClient", "Client connected");
                            cfg.connected();
                            client = event.source;
                            clientOrigin = event.origin;
                            sendResponse({ message: "connected" });
                            flushResponseQueue();
                        }
                    } else {
                        // RPC call
                        if (msg.call) {
                            handleCall(msg);
                        }
                    }
                }, false);
        } else {
            Human.log.error("Human.clients.windowClient", "Browser does not support cross-window messaging");
        }

        function sendResponse(json) {
            var message = JSON.stringify(json);
            if (!client) {
                responseQueue.push(message);
                return;
            }
            client.postMessage(message, clientOrigin);
        }

        function flushResponseQueue() {
            while (responseQueue.length > 0) {
                client.postMessage(responseQueue.pop(), clientOrigin);
            }
        }

        function handleCall(msg) {
            var procName = msg.call;
            // Execute camera commands immediately to avoid queue lag
            if (procName === "camera.pan" ||
                procName === "camera.orbit" ||
                procName === "camera.flyTo" ||
                procName === "camera.jumpTo" ||
                procName === "camera.zoom" ||
                //allow procedures marked with connected param to execute immediately (they are not related to the Human)
                (msg.params && msg.params.connected)) {
                executeCall(msg);
                return;
            }
            if (countProcesses === 0) {      // Execute immediately if Human not busy
                executeCall(msg);
            } else {
                rpcQueue.push(msg);        // Else enqueue
                if (!pQueueInterval) {
                    pQueueInterval = setInterval(
                        function () {
                            if (rpcQueue.length > 0 && countProcesses === 0) {
                                executeCall(rpcQueue.shift());
                            }
                            if (rpcQueue.length === 0) {
                                clearInterval(pQueueInterval);
                            }
                        }, 20);
                }
            }
        }

        function executeCall(msg) {
            if (!Human.rpc.windowClientEnabled) {
                return;
            }
            try {
                Human.rpc.call(msg.id, msg.call, msg.params);
                Human.rpc.log(msg.call);
            } catch (e) {
                Human.log.error("Human.clients.windowClient", "Error executing RPC call [callId: " + msg.id + ", procedure: " + msg.call + "]: " + e);
            }
        }

    });


;(function () {
    "use strict";

    var HumanCookies = Human.cookies = {};

//    /**
//     * Values of all available cookies
//     * @type {String:String}
//     */
//    HumanCookies.cookies = {};
//
//    // Get the document's cookies
//    var c = document.cookie.split(';');
//    var tokens;
//    for (var i = 0, len = c.length; i < len; i++) {
//        tokens = c[i].split('=');
//        if (tokens.length == 2) {
//            HumanCookies.cookies[tokens[0]] = tokens[1];
//        }
//    }
//
//    /**
//     * Sets or removes a cookie
//     *
//     * @memberof Human.cookies
//     * @param {String} name Cookie name
//     * @param {String} [value] Cookie value - clears the cookie when null or omitted
//     */
//    HumanCookies.setCookie = function (name, value) {
//        if (value == undefined || value == null) {
//            // Clear cookie
//            delete HumanCookies.cookies[name];
//        } else {
//            // Set cookie
//            HumanCookies.cookies[name] = value;
//        }
//        save.call(this);
//    };
//
//    // Saves cookies on the document
//    function save() {     // TODO: Deferred call on tick if called frequently?
//        var list = [];
//        var numCookies = 0;
//        for (var name in HumanCookies.cookies) {
//            if (HumanCookies.cookies.hasOwnProperty(name)) {
//                if (numCookies++ > 0) {
//                    list.push(";");
//                }
//                list.push(name);
//                list.push("=");
//                list.push(HumanCookies.cookies[name]);
//            }
//        }
//        document.cookie = list.join("");
//    }

    HumanCookies.setCookie = function (name, value, days) {
        var expires;

        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        else {
            expires = "";
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    };

    HumanCookies.getCookie = function (name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    };

    HumanCookies.eraseCookie = function (name) {
        HumanCookies.setCookie(name, "", -1);
    };
})();;/**
 * @namespace Provides methods for installing initialization scripts and resetting the engine.
 */
(function () {
    "use strict";

    var HumanInit = Human.init = {};

    var started = false;

    /**
     * Bookmark of Human's initial state. An full engine reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.bookmark = {};

    /**
     * Bookmark of Human's initial camera state. A camera reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.cameraBookmark = {};

    /**
     * Saves engine state to restore to when {@link #reset} is called.
     * If the engine has multiple modules currently active, then the bookmark will capture only
     * the activation of the first module that was activated. For example, is we have two modules active,
     * say, male anatomy and healthy heart beat, then restoring the bookmark will put the engine back
     * into the state it was in right after loading, before the user selected a condition or
     * bookmark, or whatever additional content.
     */
    HumanInit.saveReset = function () {
        var bookmark = Human.bookmarks.capture();
        var modules = bookmark.modules;
        if (modules) {
            var active = modules.active;
            if (active && active.length > 1) {
                // Ensure only first active module will be reactivated when bookmark restored
                modules.active = [modules.active[0]];
            }
        }
        HumanInit.bookmark = bookmark;
        if (!!Human.timeline.activeRoot){
            // If engine loaded with a module.
            HumanInit.bookmark.camera = Human.timeline.activeRoot._chapters[0].camera.location;
        }

    };

    /**
     * Resets Human state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name reset
     * @function
     * @param {Function} [ok] Callback which signals when reset complete
     * @memberof Human.init
     */
    HumanInit.reset = function (ok) {
        // Resets app by restoring its state to the
        // bookmark that was captured after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.reset", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.renderer.lights.restoreDefaults();
        Human.bookmarks.restore(HumanInit.bookmark,
            function () {
                Human.events.fire("init.reset");
                if(ok) {
                    ok();
                }
            },
            function (err) {
                Human.log.error("Human.init.reset", "Reset failed: " + err);
                if (ok) {
                    ok();
                }
            });
    };

    /**
     * Resets Human camera state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name resetCamera
     * @function
     * @param {Function} [ok] Callback which signals when camera reset complete
     * @memberof Human.init
     */
    HumanInit.resetCamera = function (ok) {

        // try to reset to camera of current chapter
        var currentChapterLookat = Human.timeline.getCurrentChapterCamera();
        if (currentChapterLookat) {
            Human.renderer.camera.fly.flyTo(currentChapterLookat, ok);
            return;
        }

        // Try to reset to the initial camera position off the most recently activated module,
        // otherwise reset to the camera that was captured after the engine started up.

        var mostRecentModule;
        var module;
        var time = 0;
        var activeModules = Human.modules.activeModules;
        for (var moduleId in activeModules) {
            if (activeModules.hasOwnProperty(moduleId)) {
                module = activeModules[moduleId];
                if (module.camera && module.timeActivated > time) {
                    mostRecentModule = module;
                }
            }
        }
        if (mostRecentModule) {
            Human.renderer.camera.fly.flyTo(mostRecentModule.camera, ok);
            return;
        }

        // Reset to camera bookmarked after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.resetCamera", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.renderer.camera.fly.flyTo(HumanInit.bookmark.camera, ok);
    };

    /** Init the engine
     *
     */
    HumanInit.init = function (ok) {
        // Initialize websocket for assets
        Human.renderer.init();
        Human.assets.init();

        // Renderer ready and all engine JS scripts loaded
        Human.events.fire("loaded");

        if (ok) {
            ok();
        }
    };

    /** Start the engine
     *
     */
    HumanInit.start = function () {
        started = true;
        HumanInit.saveReset();
        Human.events.fire("started");
    };

})();
;/**
 * Human.renderer
 *
 * @namespace Provides access to the SceneJS WebGL engine
 */
(function () {

    "use strict";

    var TIME_MAX = 14;
    var FRAME_SAMPLES = 100;

    var HumanRenderer = Human.renderer = {
        highlightColor: new Float32Array([1.5, 1.5, 0.5]),
        xrayBGColor: new Float32Array([0.2, 0.2, 0.3]),
        frameRateThrottled: false,
        testContextLoss: false,
        viewportDirty: true,
        lastFrameStats: {
            gpuTime: 0,
            cpuTime: 0
        }
    };

    var transparencyModeMap = {
        alpha: SceneJS.TRANSPARENCY_FLAGS.ALPHA,
        improvedAlpha: SceneJS.TRANSPARENCY_FLAGS.IMPROVED_ALPHA,
        addAlpha: SceneJS.TRANSPARENCY_FLAGS.ADD_ALPHA,
        alphaToCoverage: SceneJS.TRANSPARENCY_FLAGS.ALPHA_TO_COVERAGE,
        weightedOIT: SceneJS.TRANSPARENCY_FLAGS.WEIGHTED_OIT
    };

    var scene;
    var sceneGlobalsDirty = false;
    var paused = false;

    var enableFog = false;
    var fogMode = SceneJS.DISPLAY_FLAGS.FOG_LINEAR;
    var fogDensity = 0.01;
    var fogStart = 0;
    var fogEnd = 1000;
    var fogMin = 0.0;
    var fogMax = 1.0;
    var fogColor = new Float32Array([1, 1, 1]);

    var testTickCount = 0;
    var gpuTimeTotal = 0;
    var cpuTimeTotal = 0;

    var setTicksPerRender = 1;
    var ticksPerRenderCount = 0;

    var gpuTimerQueryInProgress = false;

    var tickEvent = {
        timeStarted: 0,
        timeLast: 0,
        timeNow: 0,
        tick: 0
    };

    var frameStartEvent = {
        frameStart: 0,
        lastFrameStart: 0
    };

    var frameEndEvent = {
        frameStart: 0,
        frameEnd: 0,
        lastFrameEnd: 0,
    };

    // reusable
    var tempMat4a = mat4.create();
    var tempMat4b = mat4.create();
    var tempVec3 = vec3.create();
    var tempVec4 = vec4.create();

    Human.properties.subscribe({
        propId: "highlight.color",
        value: HumanRenderer.highlightColor,
        callback: function (value) {
            HumanRenderer.highlightColor = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.enabled",
        value: enableFog,
        callback: function (value) {
            enableFog = value;
            sceneGlobalsDirty = true;

        }
    });

    Human.properties.subscribe({
        propId: "fog.mode",
        value: fogMode,
        callback: function (value) {
            fogMode = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.start",
        value: fogStart,
        callback: function (value) {
            fogStart = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.end",
        value: fogEnd,
        callback: function (value) {
            fogEnd = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.min",
        value: fogMin,
        callback: function (value) {
            fogMin = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.max",
        value: fogMax,
        callback: function (value) {
            fogMax = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.density",
        value: fogDensity,
        callback: function (value) {
            fogDensity = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.color",
        value: fogColor,
        callback: function (value) {
            fogColor = value;
            sceneGlobalsDirty = true;
        }
    });

    HumanRenderer.init = function () {

        if (SceneJS.WEBGL_INFO.SOFTWARE_RENDERER) {
            Human.log.error("This browser is using a software renderer for WebGL. Expect substantially reduced rendering performance.");
        }

        var timeStarted = Date.now();
        var timeLast = timeStarted;
        var tick = 0;

        SceneJS.setMaxPointSize(255);

        scene = this.graph.init();

        this.postprocess.init(scene);

        this.canvas.init();
        this.lights.init();

        this.setXrayBGColor(this.xrayBGColor);

        requestAnimationFrame(function frame() {
            requestAnimationFrame(frame);

            var gpuTimer = scene.getGPUTimer();
            var gpuTimerQuery = scene.getGPUTimerQuery();
            var gl = scene.getGL();

            if (gpuTimer && gpuTimerQueryInProgress) {
                var gpuTimerAvailable = gpuTimer.getQueryObjectEXT(gpuTimerQuery, gpuTimer.QUERY_RESULT_AVAILABLE_EXT);
                var gpuTimerDisjoint = gl.getParameter(gpuTimer.GPU_DISJOINT_EXT);

                if (gpuTimerAvailable) {
                    gpuTimerQueryInProgress = false;
                }

                if (gpuTimerAvailable && !gpuTimerDisjoint) {
                    HumanRenderer.lastFrameStats.gpuTime = gpuTimer.getQueryObjectEXT(gpuTimerQuery, gpuTimer.QUERY_RESULT_EXT) / 1000000;
                }
            }

            if (paused) {
                return;
            }

            ++ticksPerRenderCount;
            if (ticksPerRenderCount < setTicksPerRender) {
                return;
            }

            ticksPerRenderCount = 0;

            var startTime = Human.timer.now();

            if (gpuTimer && !gpuTimerQueryInProgress) {
                gpuTimer.beginQueryEXT(gpuTimer.TIME_ELAPSED_EXT, gpuTimerQuery);
            }


            frameStartEvent.frameStart = Human.timer.now();
            Human.events.fire("frameStart", frameStartEvent);
            frameStartEvent.lastFrameStart = frameStartEvent.frameStart;

            if (sceneGlobalsDirty) {
                updateSceneGlobals();
            }

            if (HumanRenderer.viewportDirty) {
                scene.setViewport(0, 0, HumanRenderer.canvas.width, HumanRenderer.canvas.height);
                HumanRenderer.viewportDirty = false;
            }

            var timeNow = Human.timer.now();
            tickEvent.timeStarted = timeStarted;
            tickEvent.timeLast = timeLast;
            tickEvent.timeNow = timeNow;
            tickEvent.tick = tick;

            Human.events.fire("tick", tickEvent);

            timeLast = timeNow;
            tick++;

            if (!HumanRenderer.frameRateThrottled) {
                var stats = scene.stats.frame;

                gpuTimeTotal += stats.gpuTime;
                cpuTimeTotal += stats.cpuTime;

                if (++testTickCount === FRAME_SAMPLES) {
                    var gpuTimeAve = gpuTimeTotal / testTickCount;
                    var cpuTimeAve = cpuTimeTotal / testTickCount;

                    if (cpuTimeAve > TIME_MAX || gpuTimeAve > TIME_MAX) {
                        HumanRenderer.setTicksPerRender(2);
                        HumanRenderer.frameRateThrottled = true;
                    }

                    gpuTimeTotal = 0;
                    cpuTimeTotal = 0;
                    testTickCount = 0;
                }
            }

            HumanRenderer.prepareFrame(tickEvent);

            scene.render();

            frameEndEvent.frameStart = frameStartEvent.frameStart;
            frameEndEvent.frameEnd = Human.timer.now();
            Human.events.fire("frameEnd", frameEndEvent);
            frameEndEvent.lastFrameEnd = frameEndEvent.frameEnd;


            if (gpuTimer && !gpuTimerQueryInProgress) {
                gpuTimer.endQueryEXT(gpuTimer.TIME_ELAPSED_EXT);
                gpuTimerQueryInProgress = true;
            }

            HumanRenderer.lastFrameStats.cpuTime = Human.timer.now() - startTime;
        });
    };

    HumanRenderer.prepareFrame = function () {

        // Execute animations
        //      Must be first because of affect
        //      on camera, objects
        Human.timeline.onFrame();

        // Push updates to SceneJS
        //      Must come before annotations,
        //      which use view/proj matrices from
        //      SceneJS
        Human.renderer.lights.onFrame();
        Human.renderer.clip.onFrame();
        Human.renderer.camera.onFrame();

        // Apply pending updates to scenegraph
        //      Must come before annonations and
        //      labels to ensure that xforms are
        //      correct.
        Human.scene.onFrame();

        // Position annotations
        Human.scene.markers.onFrame();

        Human.events.fire("cull", tickEvent);

        // Frustum and clip culling.
        //      Must come last.
        Human.scene.cull();
    };

    HumanRenderer.updateDisplayForBG = function () {
        sceneGlobalsDirty = true;
    };

    /**
     * Pauses the renderer.
     *
     * <p>This actually pushes a 'pause' directive onto a stack. Only once the same number of pops are done
     * with {@link #popPause} will the renderer unpause again.</p>
     *
     * <p>You would normally do this when you want to do batches of content creation, to prevent the
     * renderer from slowing things down as it works to keeps the 3D view in synch. Then when you've
     * done all your creation, you'd unpause the renderer again.</p>
     */
    HumanRenderer.pushPause = function () {
        HumanRenderer._pauses = (!HumanRenderer._pauses) ? 1 : HumanRenderer._pauses + 1;
        if (HumanRenderer._pauses === 1) {
            paused = true;
        }
    };

    /**
     * Un-pauses the renderer.
     *
     * <p>As described in {@link #pushPause}, this pops a pause directive that was made with that method. Only once the same
     * number of pops are done with this method will the renderer unpause again.</p>
     */
    HumanRenderer.popPause = function () {
        if (!HumanRenderer._pauses) {
            return;
        }
        if (--HumanRenderer._pauses === 0) {
            paused = false;
            scene.render();   // Forces garbage collection
        }
    };


    HumanRenderer.pauseCompilation = function () {
        scene.pauseCompilation();
    };

    HumanRenderer.resumeCompilation = function () {
        scene.resumeCompilation();
    };

    HumanRenderer.setTicksPerRender = function (n) {
        setTicksPerRender = n;
        ticksPerRenderCount = 0;
    };

    HumanRenderer.resetFrameThrottling = function () {
        if (HumanRenderer.frameRateThrottled) {
            HumanRenderer.setTicksPerRender(1);
            HumanRenderer.frameRateThrottled = false;
        }

    };

    HumanRenderer.setTransparencyMode = function (mode) {
        var transparencyEnum = transparencyModeMap[mode];
        if (transparencyEnum === undefined) {
            Human.log.error("Unrecognized transparency mode: " + mode);
            return;
        }

        scene.setTransparencyMode(transparencyEnum);

        if (mode === "alphaToCoverage") {
            Human.renderer.postprocess.disable();
        } else {
            Human.renderer.postprocess.enable();
        }
    };

    HumanRenderer.setDepthSort = function (sort) {
        scene.setDepthSort(sort);
    };

    /**
     * Fires callback as soon as current task count is zero
     */
    HumanRenderer.onTasksComplete = function (ok) {
        if (HumanRenderer._pauses !== undefined && HumanRenderer._pauses !== null && HumanRenderer._pauses > 0) {
            Human.log.error("Human.renderer.onTaskComplete", "Renderer deadlock: Human.renderer.pushPause has " +
                "paused renderer. Renderer needs to be unpaused in order to complete pending tasks.");
        }
        var numTasks = Human.renderer.getScene().getStatus().numTasks;
        if (!numTasks || numTasks === 0) {
            ok();
            return;
        }
        if (HumanRenderer.__checkLoaded) {
            throw "Human.renderer.onTasksComplete: already blocking";
        }
        HumanRenderer.__checkLoaded = window.setInterval(
            function () {
                var numTasks = Human.renderer.getScene().getStatus().numTasks;
                if (!numTasks || numTasks === 0) {
                    window.clearInterval(HumanRenderer.__checkLoaded);
                    HumanRenderer.__checkLoaded = null;
                    ok();
                }
            }, 200);
    };

    // Force compilation of the SceneJS scenegraph
    HumanRenderer.compile = function () {
        scene.compile();
    };

    /** Forces renderer to render a frame
     */
    HumanRenderer.forceRenderFrame = function (params) {
        params = params || {};
        params.force = true;
        scene.render(params);
    };

    HumanRenderer.getScene = function () {
        return scene;
    };

    HumanRenderer.getLibraryRoot = function () {
        return scene;
    };

    HumanRenderer.getNode = function (nodeId) {
        return scene.findNode(nodeId);
    };

    HumanRenderer.nodeExists = function (nodeId) {
        var node = scene.findNode(nodeId);
        return (node !== null && node !== undefined);
    };

    HumanRenderer.loseContext = function() {
        scene.loseWebGLContext();
    };

    /**
     * Returns the 4x4 View transform matrix.
     * <p>Transform World-space coordinates by this matrix to obtain View-space coordinates.</p>
     */
    HumanRenderer.getViewMat = function () {
        return scene.getViewMatrix();
    };

    /**
     * Returns the 4x4 Projection transform matrix.
     * <p>Transform View-space coordinates by this matrix to obtain Canvas-space coordinates.</p>
     */
    HumanRenderer.getProjMat = function () {
        return scene.getProjectionMatrix();
    };

    /**
    *    Check if a WebGL extension is supported on the client
    */
    HumanRenderer.checkWebGLExtension = function(extension) {
        return SceneJS.checkExtension(extension);
    };

    HumanRenderer.setXrayBGColor = function(color) {
        this.xrayBGColor.set(color);
        scene.setXrayColor(color[0], color[1], color[2]);
    };

    HumanRenderer.viewPositionToCanvas = function(viewPosition, canvasPosition) {
        var pMat = HumanRenderer.getProjMat();

        // position in view space
        tempVec4.set(viewPosition);
        tempVec4[3] = 1;

        vec4.transformMat4(tempVec4, tempVec4, pMat);
        var w = tempVec4[3];
        canvasPosition[0] = 0.5 * this.canvas.width * (1 + tempVec4[0] / w);
        canvasPosition[1] = 0.5 * this.canvas.height * (1 - tempVec4[1] / w);
        return canvasPosition;
    };

    /**
     * Given a vec3 or vec4 point in world space, returns the corresponding
     * canvas coordinate.
     */
    HumanRenderer.worldPositionToCanvas = function(worldPosition, canvasPosition) {
        vec3.transformMat4(tempVec3, worldPosition, HumanRenderer.getViewMat());

        return HumanRenderer.viewPositionToCanvas(tempVec3, canvasPosition);
    };

    HumanRenderer.getResolutionScalingSupported = (function () {

        /* Resolution scaling is only supported if the canvas element has
         * explicit, non-inline, stylesheet CSS rules for "width" and "height", eg. #myCanvas { width: 100%; height: 100%; }
        */

        var testDone = false;
        var resolutionScalingSupported = false;

        function doTest() {

            var proto = Element.prototype;
            var slice = Function.call.bind(Array.prototype.slice);
            var matches = Function.call.bind(proto.matchesSelector ||
                proto.mozMatchesSelector || proto.webkitMatchesSelector ||
                proto.msMatchesSelector || proto.oMatchesSelector);

            var elementMatchCSSRule = function (element, cssRule) { // Returns true if a DOM Element matches a cssRule
                return matches(element, cssRule.selectorText);
            };

            var propertyInCSSRule = function (prop, cssRule) { // Returns true if a property is defined in a cssRule
                return prop in cssRule.style && cssRule.style[prop] !== "";
            };

            var cssRules = slice(document.styleSheets).reduce(function (rules, styleSheet) { // Get the cssRules across all the stylesheets in one array
                return rules.concat(slice(styleSheet.cssRules));
            }, []);

            var elementRules = cssRules.filter(elementMatchCSSRule.bind(null, HumanRenderer.canvas.canvas)); // get only the css rules that matches that element
            var hasWidth = propertyInCSSRule.bind(null, "width");
            var hasHeight = propertyInCSSRule.bind(null, "height");

            resolutionScalingSupported = (elementRules.some(hasWidth) && elementRules.some(hasHeight));

            testDone = true;
        }

        return function () { // SSAA needs CSS width & height on the canvas
            if (!testDone) {
                doTest();
            }
            return resolutionScalingSupported;
        };

    })();

    HumanRenderer.setResolutionScaling = function(scale) {
        if (scale < 1) {
            scale = 1;
        }
        scene.setResolutionScaling(scale);
    };

    HumanRenderer.canvasPositionToWorldRay = function(x, y, origin, direction){
        var px = 2 * x / Human.renderer.canvas.width - 1;
        var py = 1 - 2 * y / Human.renderer.canvas.height;
        var eye = Human.renderer.camera.eye;
        origin[0] = eye.x;
        origin[1] = eye.y;
        origin[2] = eye.z;
        direction[0] = px;
        direction[1] = py;
        direction[2] = 0.5;
        var inverseProjMat =  mat4.invert(tempMat4a, this.getProjMat());
        var inverseViewMat =  mat4.invert(tempMat4b, this.getViewMat());
        vec3.transformMat4(direction, direction, inverseProjMat);
        vec3.transformMat4(direction, direction, inverseViewMat);
        vec3.subtract(direction, direction, origin);
        vec3.normalize(direction, direction);
    };

    var centerVec = vec3.create(); // Eye -> sphere center
    var edgePos = vec3.create(); // Sphere edge position
    var edgeVec = vec3.create(); // Eye -> sphere edge
    var rVec = vec3.create();    // Sphere center -> sphere edge
    var origin = vec3.create();
    var direction = vec3.create();
    HumanRenderer.canvasCircleToWorldSphereRadius = function(canvasX, canvasY, canvasRadius, worldCenter) {
        this.canvasPositionToWorldRay(canvasX, canvasY + canvasRadius, origin, direction);
        var forward = Human.renderer.camera.getLookDir(tempVec3);
        var denom = vec3.dot(forward, direction);
        if(denom > 0.001) {
            vec3.subtract(centerVec, worldCenter, origin);
            var t = vec3.dot(centerVec, forward) / denom;
            vec3.scale(edgeVec, direction, t);
            vec3.add(edgePos, origin, edgeVec);
            vec3.subtract(rVec, edgePos, worldCenter);

            return vec3.length(rVec);
        }
        return 0;
    };

    function updateSceneGlobals() {
        scene.setFogEnabled(enableFog);
        scene.setFogMode(fogMode);
        scene.setFogStart(fogStart);
        scene.setFogEnd(fogEnd);
        scene.setFogMin(fogMin);
        scene.setFogMax(fogMax);
        scene.setFogDensity(fogDensity);
        scene.setFogColor(fogColor[0], fogColor[1], fogColor[2]);

        sceneGlobalsDirty = false;
    }

})();
;(function() {
    "use strict";

    var sceneRootNode;

    var NODE_ORDER_RANK = {
        xform:          1,
        properties:     2,
        texture:        3,
        material:       3,
        cubemap:        3,
        fresnel:        3,
        billboard:      3,
        morphGeometry:  4,
        geometry:       5
    };

    var graph = Human.renderer.graph = {
        libraryRootNode: null
    };

    // Create scene graph
    var SCENE_DEFINITION = {
        type: "scene",
        canvasId: Human.canvasId,
        // transparent canvas
        transparent: true,

        contextAttr: {

            // Default: false. If false, once the drawing buffer is presented as described in theDrawing Buffer
            // section, the contents of the drawing buffer are cleared to their default values. All elements of the
            // drawing buffer (color, depth and stencil) are cleared. If the value is true the buffers will not be
            // cleared and will preserve their values until cleared or overwritten by the author.
            // On some hardware setting the preserveDrawingBuffer flag to true can have significant performance implications.
            // http://code.google.com/p/chromium/issues/detail?id=82086
            preserveDrawingBuffer: false,
            antialias: true
        }
    };

    graph.init = function() { // TODO: Why not build whole scene graph here?

        SCENE_DEFINITION.canvasId = Human.canvasId;

        sceneRootNode = SceneJS.createScene(SCENE_DEFINITION, {
            simulateWebGLContextLost: Human.renderer.testContextLoss
        });

        this.libraryRootNode = sceneRootNode.addNode({
            type: "library"
        });

        sceneRootNode.setCamera({
            eye: [0 , 0, 55],
            look: [0, 0, 0],
            up: [0, 1, 0]
        });

        sceneRootNode.setProjection({
            type: "perspective",
            fov: 60,
            near: 0.01,
            far: 400.0,
            fovAxis: "y",
            pan: {
                x: 0,
                y: 0,
                z: 0
            }
        });

        return sceneRootNode;
    };

    /**
     * Creates a subtree within this render graph. You can then call #insertNode to create nodes
     * within the subtree, or #destroySubtree to destroy the subtree.
     *
     * @param {SceneJS.Node} [parent] Optional leaf node belonging to a parent Human.sceneObject.
     * @returns {SceneJS.Node} Root of new subtree.
     */
    graph.createSubtree = function(node) {
        return sceneRootNode.addNode(node);
    };

    /**
     * Inserts a SceneJS node into the given subtree, which must have been created earlier with #createSubtree.
     *
     * @param {SceneJS.Node} rootNode Root of subtree.
     * @param {SceneJS.Node | *} insertNode Node to insert, given as either instance or JSON config.
     * @returns {SceneJS.Node} Node that was newly inserted.
     */
    graph.insertNode = function(rootNode, insertNode) {

        if (insertNode instanceof SceneJS.Node) {
            if (insertNode.parent && insertNode.parent.type === "library") {
                insertNode.disconnect();
            } else {
                insertNode = {
                    type: insertNode.type,
                    coreId: insertNode.getCoreId()
                };
            }
        } else {
            if (insertNode.type === "reflect") {
                insertNode.type = "cubemap";
            }
        }

        var type = insertNode.type;
        var insertNodeScore = NODE_ORDER_RANK[type];

        var currentNode = rootNode;

        while(currentNode) {
            var currentNodeScore = NODE_ORDER_RANK[currentNode.type] ? NODE_ORDER_RANK[currentNode.type] : 0;

            if(insertNodeScore < currentNodeScore) {
                var parent = currentNode.parent;

                currentNode.disconnect();
                insertNode = parent.addNode(insertNode);

                insertNode.addNode(currentNode);

                return insertNode;
            } else if(currentNode.nodes.length === 0) {
                return currentNode.addNode(insertNode);
            }

            currentNode = currentNode.nodes[0];
        }
    };

    // Disconnect a node from an object chain
    graph.disconnectNode = function(node) {
        var parent = node.parent;
        var children = node.disconnectNodes();
        node.disconnect();
        parent.addNodes(children);
    };

    /**
     * Destroys the given subtree, which must have been created earlier with #createSubtree.
     * Also destroys all nodes that were inserted into the subtree with #insertNode.
     *
     * @param {SceneJS.Node} rootNode Root of subtree to destroy.
     */
    graph.destroySubtree = function(rootNode) {
        rootNode.destroy();
    };

})();
;/**
 * Human.renderer.bg
 *
 * @namespace Get and set the background color
 */
(function () {
    "use strict";

    var HumanRendererBG = Human.renderer.bg = {};
    var bgColor = null;

    HumanRendererBG.getBGColor = function () {
        var _bgColor = null;

        if (bgColor) {
            _bgColor = [];

            for (var i = 0; i < bgColor.length; i++) {
                _bgColor.push(bgColor[i]);
            }
        }

        return _bgColor;
    };

    HumanRendererBG.setBGColor = function (_bgColor) {
      if(Array.isArray(_bgColor)) {
        bgColor = _bgColor;
      }
    };

})();
;/**
 * Human.renderer.canvas
 *
 * @namespace Manages the WebGL canvas
 */
(function () {
    "use strict";
    
    Human.renderer.canvas = {
        canvas: null,
        annotationCanvas: null,
        context2D: null,
        width: 0,
        height: 0
    };

    Human.renderer.canvas.init = function() {
        this.canvas = document.getElementById(Human.canvasId);
        this.annotationCanvas = document.getElementById(Human.annotationCanvasId);
        this.context2D = this.annotationCanvas.getContext("2d");
        this.width = this.canvas.clientWidth;
        this.height = this.canvas.clientHeight;

        resize();
    };

    // HACK for UI compatibility
    Human.renderer.resize = resize;
    window.addEventListener("resize", resize);

    function resize() {
        var canvas = Human.renderer.canvas.canvas;
        var annotationCanvas = Human.renderer.canvas.annotationCanvas;

        var canvasBody = canvas.parentNode;

        var canvasWidth = canvasBody.clientWidth;
        var canvasHeight = canvasBody.clientHeight;

        Human.renderer.canvas.width = canvasWidth;
        Human.renderer.canvas.height = canvasHeight;

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        annotationCanvas.width = canvasWidth;
        annotationCanvas.height = canvasHeight;

        Human.renderer.viewportDirty = true;
        Human.renderer.camera.updateCanvas();
        Human.renderer.postprocess.updateCanvas();
        Human.renderer.draw.updateCanvas();

        Human.events.fire("canvas.resized", {
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight
        });
    }

})();
;/**
 * @namespace Manages the camera
 */
(function () {
    "use strict";

    var HumanRendererCamera = Human.renderer.camera = {
        FRUSTUM_TOP:    0,
        FRUSTUM_BOTTOM: 1,
        FRUSTUM_LEFT:   2,
        FRUSTUM_RIGHT:  3,
        FRUSTUM_NEAR:   4,
        FRUSTUM_FAR:    5,
        autoSetNearFar: true,    // Automaticallly set near and far plane to scene boundaries.
        nearFarDirty: false
    };

    // Used in some methods for distance calculations
    var eyeVec = vec3.create();
    var lookVec = vec3.create();
    var upVec = vec3.create();
    var leftVec = vec3.create();
    var rightVec = vec3.create();
    var nearCenter = vec3.create();
    var farCenter = vec3.create();
    var panVec = vec3.create();
    var eyeVecNorm = vec3.create();
    var upVecNorm = vec3.create();
    var viewDirVec = vec3.create();
    var tempVec = vec3.create();
    var tempMat4 = mat4.create();
    // [top, bottom, left, right, near, far]
    var frustum = [
        { n: vec3.create(), d: 0},
        { n: vec3.create(), d: 0},
        { n: vec3.create(), d: 0},
        { n: vec3.create(), d: 0},
        { n: vec3.create(), d: 0},
        { n: vec3.create(), d: 0}
    ];
    var frustumDirty = true;

    /**
     Current eye position
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanRendererCamera.eye = { x: 0, y: 0, z: -80 };

    /**
     Current point-of-interest
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanRendererCamera.look = { x: 0, y: 0, z: 0 };

    /**
     Current "up" vector
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanRendererCamera.up = { x: 0, y: 1, z: 0 };

    HumanRendererCamera.rotationCenter = vec3.create();

    HumanRendererCamera.lookDistance = 80;

    /**
     * Offset added to the "look" point in View-space, allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     * @type {{x: number, y: number, z: number}}
     */
    HumanRendererCamera._screenPan = {x: 0, y: 0, z: 0 };

    HumanRendererCamera._startcamera = {
      eye: HumanRendererCamera.eye,
      look: HumanRendererCamera.look,
      up: HumanRendererCamera.up
    };

    // Schedules scene graph updates when true

    var lookatNodeDirty = true;
    var cameraNodeDirty = true;

    // True when no scene graph updates pending
    var rested = false;

    /**
     * When true, causes camera to ignore calls to pan or rotate.
     * This is set and unset by Human.camera.fly to stop the user from panning or rotating
     * the camera while flight is in progress, which screws things up.
     */
    HumanRendererCamera.lock = false;

    /**
     Camera aspect ration
     @type {number}
     @readonly
     */
    HumanRendererCamera.aspect = 1;

    /**
     Field-ov-view angle on Y-axis
     @type {number}
     @readonly
     */
    HumanRendererCamera.fovy = 55;

    // Field-of-View angle in degrees
    Human.properties.subscribe({
        propId: "camera.optics.fov",
        value: HumanRendererCamera.fovy,
        callback: function (value) {
            HumanRendererCamera.fovy = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanRendererCamera.near = 0.1;

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanRendererCamera.far = 5000;


    /**
     Minimum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanRendererCamera.minZoom = 0.01;

    /**
     Maximum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanRendererCamera.maxZoom = 150;

    // Zoom limits - distance between eye and look
    Human.properties.subscribe({
        propId: "camera.zoomLimits",
        value: {
            min: 0.01,
            max: 150
        },
        callback: function (value) {
            if (value.min < 0.01) {
                Human.log.error("Human.renderer.camera", "Property 'camera.zoomLimits.min' too small - should be >= 0.01");
                return;
            }
            if (value.min >= value.max) {
                Human.log.error("Human.renderer.camera", "Property 'camera.zoomLimits.min' should be less than camera.zoomLimits.max");
                return;
            }
            HumanRendererCamera.minZoom = value.min;
            HumanRendererCamera.maxZoom = value.max;
            lookatNodeDirty = true;
        }
    });

    // Adjust camera aspect on canvas resize
    HumanRendererCamera.updateCanvas = function () {
        HumanRendererCamera.setAspect(Human.renderer.canvas.width / Human.renderer.canvas.height);
    };

    

    /**
     Sets the position of the camera.

     @param params
     @param [params.eye]
     @param [params.look]
     @param [params.up]
     */
    HumanRendererCamera.setLookAt = function (params) {
        var eye = params.eye || HumanRendererCamera.eye;
        var look = params.look || HumanRendererCamera.look;
        var up = params.up || HumanRendererCamera.up;

        // Not constrained, set state and schedule scene update

        HumanRendererCamera.eye = eye;
        HumanRendererCamera.look = look;
        HumanRendererCamera.up = up;

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);

        HumanRendererCamera.lookDistance = vec3.distance(eyeVec, lookVec);

        if (params.look && !params.preserveCenter) {
            this.setRotationCenter(params.look.x, params.look.y, params.look.z);
        }

        lookatNodeDirty = true;
    };

    HumanRendererCamera.setRotationCenter = function (x, y, z) {
        HumanRendererCamera.rotationCenter[0] = x;
        HumanRendererCamera.rotationCenter[1] = y;
        HumanRendererCamera.rotationCenter[2] = z;
    };

    /**
     Returns the position of this camera.
     @returns {{eye: *, look: *, up: *}}
     */
    HumanRendererCamera.getLookAt = function () {
        return {
            eye: HumanRendererCamera.eye,
            look: HumanRendererCamera.look,
            up: HumanRendererCamera.up
        };
    };

    // Camera direction in world space
    HumanRendererCamera.getLookDir = function (dir) {
        var eye = this.eye;
        var look = this.look;

        dir[0] = look.x - eye.x;
        dir[1] = look.y - eye.y;
        dir[2] = look.z - eye.z;

        vec3.normalize(dir, dir);

        return dir;
    };

    /**
     * Sets offset added to the "look" position in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @param {{x: number, y: number, z: number}} screenPan The View-space pan vector
     */
    HumanRendererCamera.setScreenPan = function (screenPan) {
        HumanRendererCamera._screenPan.x = screenPan.x || 0;
        HumanRendererCamera._screenPan.y = screenPan.y || 0;
        HumanRendererCamera._screenPan.z = screenPan.z || 0;
        cameraNodeDirty = true;
    };

    /**
     * Gets offset that's added to the "look" point in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @return {{x: number, y: number, z: number}} The View-space pan vector
     */
    HumanRendererCamera.getScreenPan = function () {
        return HumanRendererCamera._screenPan;
    };

    HumanRendererCamera._reset = {
        eye: { x: HumanRendererCamera.eye.x, y: HumanRendererCamera.eye.y, z: HumanRendererCamera.eye.z },
        look: { x: HumanRendererCamera.look.x, y: HumanRendererCamera.look.y, z: HumanRendererCamera.look.z },
        up: { x: HumanRendererCamera.up.x, y: HumanRendererCamera.up.y, z: HumanRendererCamera.up.z }
    };

    /**
     * Resets this camera to initial position
     */
    HumanRendererCamera.reset = function () {
        HumanRendererCamera.yaw = 0;
        HumanRendererCamera.pitch = 90;
        HumanRendererCamera._eye = { x: HumanRendererCamera._reset.eye.x, y: HumanRendererCamera._reset.eye.y, z: HumanRendererCamera._reset.eye.z };
        HumanRendererCamera._look = { x: HumanRendererCamera._reset.look.x, y: HumanRendererCamera._reset.look.y, z: HumanRendererCamera._reset.look.z };
        HumanRendererCamera._up = { x: HumanRendererCamera._reset.up.x, y: HumanRendererCamera._reset.up.y, z: HumanRendererCamera._reset.up.z };
        HumanRendererCamera.rotationCenter.set([HumanRendererCamera._reset.look.x, HumanRendererCamera._reset.look.y, HumanRendererCamera._reset.look.z]);
        lookatNodeDirty = true;
    };


    /**
     * Rotate 'eye' about 'look', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanRendererCamera.rotateY = function (angle) {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.up, upVec);

        vec3.subtract(eyeVec, eyeVec, HumanRendererCamera.rotationCenter);
        vec3.subtract(lookVec, lookVec, HumanRendererCamera.rotationCenter);

        var sign = Human.math.sign(upVec[1]) || 1;

        // Rotate 'eye' vector about 'up' vector
        mat4.fromRotation(tempMat4, sign * angle * 0.0174532925, Human.math.Y_AXIS);
        vec3.transformMat4(eyeVec, eyeVec, tempMat4);
        vec3.transformMat4(lookVec, lookVec, tempMat4);
        vec3.transformMat4(upVec, upVec, tempMat4); // NOTE(Tarek): Works because there's no translation in tempMat4

        vec3.add(eyeVec, eyeVec, HumanRendererCamera.rotationCenter);
        vec3.add(lookVec, lookVec, HumanRendererCamera.rotationCenter);

        // Update scene graph camera
        HumanRendererCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            },
            preserveCenter: true
        });
    };



    /**
     * Rotate 'eye' about 'look' around the Orthogonal Vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanRendererCamera.rotateX = function (angle) {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.up, upVec);

        vec3.subtract(eyeVec, eyeVec, HumanRendererCamera.rotationCenter);
        vec3.subtract(lookVec, lookVec, HumanRendererCamera.rotationCenter);

        // Get 'eye' -> 'look' vector
        vec3.subtract(eyeVecNorm, lookVec, eyeVec);

        vec3.normalize(eyeVecNorm, eyeVecNorm);
        vec3.normalize(upVecNorm, upVec);

        // Get orthogonal vector from 'eye' and 'up'
        vec3.cross(leftVec, upVecNorm, eyeVecNorm);

        // Rotate 'eye' vector about orthogonal vector
        mat4.fromRotation(tempMat4, angle * 0.0174532925, leftVec);
        vec3.transformMat4(eyeVec, eyeVec, tempMat4);
        vec3.transformMat4(lookVec, lookVec, tempMat4);
        vec3.transformMat4(upVec, upVec, tempMat4);    // NOTE(Tarek): Works because there's not translation in tempMat4

        vec3.add(eyeVec, eyeVec, HumanRendererCamera.rotationCenter);
        vec3.add(lookVec, lookVec, HumanRendererCamera.rotationCenter);

        // Update scene graph camera
        HumanRendererCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            },
            preserveCenter: true
        });
    };

    /**
     * Pans the camera along X and Y axis.
     * Applies constraints added with {@link #addConstraint}.
     * @param pan The pan vector
     */

    var eyeVec2 = vec3.create();

    HumanRendererCamera.pan = function (pan) {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        // Get eye, look and up as arrays
        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        vec3.subtract(eyeVec2, eyeVec, lookVec);

        // Building this pan vector
        panVec[0] = panVec[1] = panVec[2] = 0;

        if (pan.x !== undefined) {

            // Pan along orthogonal vector to 'look' and 'up'

            vec3.normalize(eyeVecNorm, eyeVec2);
            vec3.normalize(upVecNorm, upVec);

            var left = vec3.cross(leftVec, eyeVec2, upVec);
            vec3.normalize(left, vec3.cross(leftVec, eyeVec2, upVec));

            vec3.scale(tempVec, left, pan.x);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.y !== undefined) {

            // Pan along 'up' vector
            vec3.normalize(upVecNorm, upVec);

            vec3.scale(tempVec, upVecNorm, pan.y);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.z !== undefined) {

            // Pan along 'eye'- -> 'look' vector

            vec3.normalize(eyeVecNorm, eyeVec);

            vec3.scale(tempVec, eyeVecNorm, pan.z);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        vec3.add(eyeVec, eyeVec, panVec);
        vec3.add(lookVec, lookVec, panVec);

        HumanRendererCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            preserveCenter: true
        });
    };

    /** Sets the projection aspect ratio
     */
    HumanRendererCamera.setAspect = function (aspect) {
        HumanRendererCamera.aspect = aspect;
        cameraNodeDirty = true;
    };

    /**
     Positions camera to look at the scene from along the -X axis.
     */
    HumanRendererCamera.viewRight = function () {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanRendererCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: -dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +X axis.
     */
    HumanRendererCamera.viewLeft = function () {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanRendererCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Z axis.
     */
    HumanRendererCamera.viewPosterior = function () {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanRendererCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: -dist },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the -Z axis.
     */
    HumanRendererCamera.viewAnterior = function () {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanRendererCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: dist },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanRendererCamera.viewSuperior = function () {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanRendererCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: -dist + elev, z: 0 },
            up: {x: 0, y: 0, z: 1 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanRendererCamera.viewInferior = function () {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanRendererCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: dist + elev, z: 0 },
            up: {x: 0, y: 0, z: -1 }
        });

    };

    /**
     * Increments/decrements zoom factor, ie. distance between eye and look.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param delta
     */
    HumanRendererCamera.zoom = function (delta) {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);
        vec3.subtract(eyeVec, eyeVec, lookVec);            // Get vector from eye to look
        var lenLook = Math.abs(vec3.length(eyeVec));    // Get len of that vector
        var newLenLook = Math.abs(lenLook + delta);         // Get new len after zoom

        if (HumanRendererCamera.minZoom && HumanRendererCamera.maxZoom) {

            var f = (lenLook / HumanRendererCamera.maxZoom) * 0.6;

            delta = (40 * delta) * f;

            newLenLook = Math.abs(lenLook + delta);

            if (newLenLook < HumanRendererCamera.minZoom) {
                newLenLook = HumanRendererCamera.minZoom;

            } else if (newLenLook > HumanRendererCamera.maxZoom) {
                newLenLook = HumanRendererCamera.maxZoom;
            }
        }

        vec3.normalize(eyeVecNorm, eyeVec);  // Get normalised vector
        vec3.scale(eyeVec, eyeVecNorm, newLenLook);
        vec3.add(eyeVec, lookVec, eyeVec);

        HumanRendererCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            preserveCenter: true
        });
    };

    /**
     * Sets the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param {Number} zoomFactor The factor
     */
    HumanRendererCamera.setZoom = function (zoomFactor) {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);  // Get vector from eye to look
        vec3.normalize(eyeVecNorm, eyeVec);  // Get normalised vector
        vec3.scale(eyeVec, eyeVecNorm, HumanRendererCamera.minZoom + (1.0 - zoomFactor) * (HumanRendererCamera.maxZoom - HumanRendererCamera.minZoom));

        vec3.add(eyeVec, lookVec, eyeVec);

        HumanRendererCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            preserveCenter: true
        });
    };

    /**
     * Returns the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * @return {Number} The zoom factor
     */
    HumanRendererCamera.getZoom = function () {

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);            // Get vector from eye to look
        var lenLook = Math.abs(vec3.length(eyeVec));    // Get len of that vector

        return 1 - (((lenLook - HumanRendererCamera.minZoom) / HumanRendererCamera.maxZoom));
    };


    /**
     * Sets the zoom via a percentage factor which indicates a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @deprecated
     * @param {Number} zoomPercent The percentage factor
     */
    HumanRendererCamera.setZoomPercent = function (zoomPercent) {

        if (HumanRendererCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);  // Get vector from eye to look
        vec3.normalize(eyeVecNorm, eyeVec);  // Get normalised vector

        vec3.scale(eyeVec, eyeVecNorm, HumanRendererCamera.minZoom + (100.0 - zoomPercent) * 0.01 * (HumanRendererCamera.maxZoom - HumanRendererCamera.minZoom));

        HumanRendererCamera.setLookAt({
            eye: {
                x: lookVec[0] + eyeVec[0],
                y: lookVec[1] + eyeVec[1],
                z: lookVec[2] + eyeVec[2]
            },
            preserveCenter: true
        });
    };

    /**
     * @deprecated
     */
    HumanRendererCamera.getZoomPercent = function () {

        Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);            // Get vector from eye to look
        var lenLook = Math.abs(vec3.length(eyeVec));    // Get len of that vector

        return 100 - (((lenLook - HumanRendererCamera.minZoom) / HumanRendererCamera.maxZoom) * 100);
    };

    HumanRendererCamera.getFrustum = function () {
        if (frustumDirty) {
            buildFrustum();
            frustumDirty = false;
        }

        return frustum;
    };

    function buildFrustum() {
        var camera = HumanRendererCamera;
        var near = camera.near;
        var far = camera.far;
        var aspect = camera.aspect;
        var fov = camera.fovy * Math.PI / 180;

        eyeVec[0] = camera.eye.x;
        eyeVec[1] = camera.eye.y;
        eyeVec[2] = camera.eye.z;
        lookVec[0] = camera.look.x;
        lookVec[1] = camera.look.y;
        lookVec[2] = camera.look.z;
        upVec[0] = camera.up.x;
        upVec[1] = camera.up.y;
        upVec[2] = camera.up.z;

        var nearHalfHeight = Math.tan(fov * 0.5) * near;
        var nearHalfWidth = nearHalfHeight * aspect;

        vec3.subtract(viewDirVec, lookVec, eyeVec);
        vec3.normalize(viewDirVec, viewDirVec);

        vec3.cross(rightVec, viewDirVec, upVec);
        vec3.normalize(rightVec, rightVec);

        // Orthogonalize upVec
        vec3.cross(upVec, rightVec, viewDirVec);

        vec3.scale(tempVec, viewDirVec, near);
        vec3.add(nearCenter, eyeVec, tempVec);

        vec3.scale(tempVec, viewDirVec, far);
        vec3.add(farCenter, eyeVec, tempVec);

        vec3.scale(frustum[camera.FRUSTUM_NEAR].n, viewDirVec, -1);
        frustum[camera.FRUSTUM_NEAR].d = -vec3.dot(nearCenter, frustum[camera.FRUSTUM_NEAR].n);

        frustum[camera.FRUSTUM_FAR].n.set(viewDirVec);
        frustum[camera.FRUSTUM_FAR].d = -vec3.dot(farCenter, frustum[camera.FRUSTUM_FAR].n);

        vec3.scale(tempVec, rightVec, nearHalfWidth);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(frustum[camera.FRUSTUM_RIGHT].n, tempVec, upVec);
        frustum[camera.FRUSTUM_RIGHT].d = -vec3.dot(eyeVec, frustum[camera.FRUSTUM_RIGHT].n);

        vec3.scale(tempVec, rightVec, -nearHalfWidth);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(frustum[camera.FRUSTUM_LEFT].n, upVec, tempVec);
        frustum[camera.FRUSTUM_LEFT].d = -vec3.dot(eyeVec, frustum[camera.FRUSTUM_LEFT].n);

        vec3.scale(tempVec, upVec, nearHalfHeight);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(frustum[camera.FRUSTUM_TOP].n, rightVec, tempVec);
        frustum[camera.FRUSTUM_TOP].d = -vec3.dot(eyeVec, frustum[camera.FRUSTUM_TOP].n);

        vec3.scale(tempVec, upVec, -nearHalfHeight);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(frustum[camera.FRUSTUM_BOTTOM].n, tempVec, rightVec);
        frustum[camera.FRUSTUM_BOTTOM].d = -vec3.dot(eyeVec, frustum[camera.FRUSTUM_BOTTOM].n);
    }

    /* Calculate and return data for all 6 planes in the frustum
        NOTE: conver input to pixel units
        INPUT:
            X: offset (in pixels) of sub-region left edge from canvas left edge
            Y: offset (in pixels) of sub-region top edge from canvas top edge
            width: width of sub-region in pixels
            height: height of sub-region in pixels
        NOTE: Assumes that the inner near plane is defined to be a subregion of the true near plane
    **/
    HumanRendererCamera.getSubRegionFrustum = function(x, y, width, height){
        // Camera and Perspective Info
        var camera = HumanRendererCamera;
        var near = camera.near;
        var far = camera.far;
        var aspect = camera.aspect;
        var fov = camera.fovy * Math.PI / 180;

        eyeVec[0] = camera.eye.x;
        eyeVec[1] = camera.eye.y;
        eyeVec[2] = camera.eye.z;
        lookVec[0] = camera.look.x;
        lookVec[1] = camera.look.y;
        lookVec[2] = camera.look.z;
        upVec[0] = camera.up.x;
        upVec[1] = camera.up.y;
        upVec[2] = camera.up.z;

        // Camera Orthonormal Axes
        vec3.subtract(viewDirVec, lookVec, eyeVec);
        vec3.normalize(viewDirVec, viewDirVec);
        vec3.cross(rightVec, viewDirVec, upVec);
        vec3.normalize(rightVec, rightVec);
        vec3.cross(upVec, rightVec, viewDirVec); // Orthogo-normalize upVec
        vec3.normalize(upVec, upVec);

        // NearCenter: World coordinate of near plane's center point
        vec3.scale(tempVec, viewDirVec, near);
        vec3.add(nearCenter, eyeVec, tempVec);

        // Frustum Planes Data
        var _frustum = [
            {n:vec3.create(), d:0},
            {n:vec3.create(), d:0},
            {n:vec3.create(), d:0},
            {n:vec3.create(), d:0},
            {n:vec3.create(), d:0},
            {n:vec3.create(), d:0}
        ];

        // Whole Near Plane Information
        var nearHalfHeight = Math.tan(fov * 0.5) * near;
        var nearHalfWidth = nearHalfHeight * aspect;

        // Convert canvas points to magnitudes along canvas axis
        var cHalfWidth = Human.renderer.canvas.width/2.0;
        var cHalfHeight = Human.renderer.canvas.height/2.0;
        var left =  (x - cHalfWidth)/cHalfWidth;
        var right = left + width/(cHalfWidth);
        var top = (cHalfHeight - y)/cHalfHeight;
        var bottom = top - height/(cHalfHeight);

        // Near Plane
        _frustum[HumanRendererCamera.FRUSTUM_NEAR].n.set(viewDirVec);
        _frustum[HumanRendererCamera.FRUSTUM_NEAR].d = -vec3.dot(_frustum[HumanRendererCamera.FRUSTUM_NEAR].n, nearCenter);

        // Far Plane
        vec3.scale(tempVec, viewDirVec, far);
        vec3.add(farCenter, eyeVec, tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_FAR].n.set([-viewDirVec[0], -viewDirVec[1], -viewDirVec[2]]);
        _frustum[HumanRendererCamera.FRUSTUM_FAR].d = -vec3.dot(_frustum[HumanRendererCamera.FRUSTUM_FAR].n, farCenter);

        // Left Plane: point along right-vec some distance from center
        vec3.scale(tempVec, rightVec, left*nearHalfWidth);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(tempVec, tempVec, upVec);
        vec3.normalize(tempVec, tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_LEFT].n.set(tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_LEFT].d = -vec3.dot(tempVec, eyeVec);

        // Right Plane:  point along right-vec some distance from center
        vec3.scale(tempVec, rightVec, right*nearHalfWidth);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(tempVec, upVec, tempVec);
        vec3.normalize(tempVec, tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_RIGHT].n.set(tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_RIGHT].d = -vec3.dot(tempVec, eyeVec);

        // Bottom Plane: point along up-vec some distance from center
        vec3.scale(tempVec, upVec, bottom*nearHalfHeight);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(tempVec, rightVec, tempVec);
        vec3.normalize(tempVec, tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_BOTTOM].n.set(tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_BOTTOM].d = -vec3.dot(tempVec, eyeVec);

        // Top Plane: point along up-vec some additional distance from center
        vec3.scale(tempVec, upVec, top*nearHalfHeight);
        vec3.add(tempVec, nearCenter, tempVec);
        vec3.subtract(tempVec, tempVec, eyeVec);
        vec3.normalize(tempVec, tempVec);
        vec3.cross(tempVec, tempVec, rightVec);
        vec3.normalize(tempVec, tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_TOP].n.set(tempVec);
        _frustum[HumanRendererCamera.FRUSTUM_TOP].d = -vec3.dot(tempVec, eyeVec);

        return _frustum;
    };

    HumanRendererCamera.onFrame = function () {

        if (lookatNodeDirty) {
            Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
            Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);
            Human.math.vec3ObjToArray(HumanRendererCamera.up, upVec);

            // View transform update scheduled for scene graph
            var scene = Human.renderer.getScene();
            scene.setCamera({eye:eyeVec, look:lookVec, up:upVec});

            vec3.subtract(tempVec, eyeVec, lookVec);

            Human.events.fire("camera.updated", {

                // Camera position
                eye: HumanRendererCamera.eye,
                look: HumanRendererCamera.look,
                up: HumanRendererCamera.up,

                // Distance from viewpoint to point-of-interest
                dist: Math.abs(vec3.length(tempVec))
            });

            // Camera not at rest now
            rested = false;

            // Scene camera position now up to date
            lookatNodeDirty = false;
            frustumDirty = true;
            HumanRendererCamera.nearFarDirty = true;

        } else {

            // Else camera position now at rest

            if (!rested) {

                rested = true;

                Human.math.vec3ObjToArray(HumanRendererCamera.eye, eyeVec);
                Human.math.vec3ObjToArray(HumanRendererCamera.look, lookVec);
                vec3.subtract(tempVec, eyeVec, lookVec);

                Human.events.fire("camera.rested", {

                    // Camera position
                    eye: HumanRendererCamera.eye,
                    look: HumanRendererCamera.look,
                    up: HumanRendererCamera.up,

                    // Distance from viewpoint to point-of-interest
                    dist: Math.abs(vec3.length(tempVec))
                });
            }
        }

        if (HumanRendererCamera.autoSetNearFar && HumanRendererCamera.nearFarDirty) {
            var sceneBb = Human.scene.getBoundary();
            var particleBb = Human.particles.getBoundary();

            var xmin = Math.min(sceneBb.xmin, particleBb.xmin);
            var ymin = Math.min(sceneBb.ymin, particleBb.ymin);
            var zmin = Math.min(sceneBb.zmin, particleBb.zmin);
            var xmax = Math.max(sceneBb.xmax, particleBb.xmax);
            var ymax = Math.max(sceneBb.ymax, particleBb.ymax);
            var zmax = Math.max(sceneBb.zmax, particleBb.zmax);

            var viewMat = Human.renderer.getViewMat();
            var vx = viewMat[2]; 
            var vy = viewMat[6]; 
            var vz = viewMat[10]; 
            var vw = viewMat[14];

            var dx = xmax - xmin;
            var dy = ymax - ymin;
            var dz = zmax - zmin;

            var range = Math.sqrt(dx * dx + dy * dy + dz * dz);  // Bounding box diagonal

            var maxZ = xmin * vx + ymin * vy + zmin * vz + vw;

            if (isFinite(maxZ)) {
                maxZ = Math.max(maxZ, xmax * vx + ymin * vy + zmin * vz + vw);
                maxZ = Math.max(maxZ, xmin * vx + ymax * vy + zmin * vz + vw);
                maxZ = Math.max(maxZ, xmin * vx + ymin * vy + zmax * vz + vw);
                maxZ = Math.max(maxZ, xmax * vx + ymax * vy + zmin * vz + vw);
                maxZ = Math.max(maxZ, xmax * vx + ymin * vy + zmax * vz + vw);
                maxZ = Math.max(maxZ, xmin * vx + ymax * vy + zmax * vz + vw);
                maxZ = Math.max(maxZ, xmax * vx + ymax * vy + zmax * vz + vw);

                HumanRendererCamera.near = Math.max(-maxZ, 0.1);
                HumanRendererCamera.far  = HumanRendererCamera.near + range;

                HumanRendererCamera.nearFarDirty = false;
                cameraNodeDirty = true;
            }
        }

        if (cameraNodeDirty) {
            // Update the scene graph
            Human.renderer.getScene().setProjection({
                    type: "perspective",
                    fov: HumanRendererCamera.fovy,
                    near: HumanRendererCamera.near,
                    far: HumanRendererCamera.far,
                    aspect: HumanRendererCamera.aspect,
                    pan: HumanRendererCamera._screenPan
                });

            // Scene projection now up to date
            cameraNodeDirty = false;
            frustumDirty = true;

            Human.renderer.postprocess.updateProjection();
        }

    };

})();
;/** @namespace Manages picking of {@link Human.scene.Object}s in the {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanRendererPick = Human.renderer.pick = {};

    /**
     * Performs a pick at the given X,Y canvas coordinates
     * @memberof Human.renderer.pick
     * @param params
     * @param {Number} params.canvasX Canvas X-coordinate
     * @param {Number} params.canvasY Canvas Y-coordinate
     * @param {Boolean} params.mouseDownLeft True when left mouse key is down
     * @param {Boolean} params.mouseDownRight True when right mouse key is down
     * @param {Boolean} params.ctrlDown True when ALT key is down
     * @param {Boolean} hover Set true to do a hover-pick
     * @param {Boolean} doubleClick Set true to do a "double click" pick
     * @return
     */
    HumanRendererPick.pick = function (x, y, params) {

        var scene = Human.renderer.getScene();

        if (!scene) {
            return null;
        }

        var result = { objectId: null };
        var object = null;

        var hit = scene.pick(x, y, params) || null;


        if (hit) {
            object = Human.scene.objects[hit.name];
            var renderObjectId = hit.objectId;
            result = Human.utils.apply(hit, result);
            if (object) {
                result.objectId = object.objectId;
                if (renderObjectId) {
                    for (var i = 0, len = object.renderables.length; i < len; ++i) {
                        var renderObject = object.renderables[i].getRenderObject();
                        if (renderObject && renderObject.id === renderObjectId) {
                            result.renderableIndex = i;
                            break;
                        }
                    }
                }
            }
        }

        if (object) {
            Human.events.fire("pick.picked", result);
        } else {
            Human.events.fire("pick.missed", result);
        }

        return result;
    };

})();
;/**
 * @namespace Manages clip planes for cross-section views
 */
/*
NOTE: Clipping Planes do not play nicely with progressive loading.
The plane is set relative to the bounding box of the current view.
However, the bounding box is unknown before the geometry assets are progressively
loaded into the scene. Perhaps the engine should consider only the world coordinates
of the plane center and direction, and let the 0-to-100% progress bar be managed by applications.
The absolute planes can be created and enforced with or without pre-loaded geometry assets (boundaries);
*/
(function () {
    "use strict";

    var HumanRendererClip = Human.renderer.clip = {};

    HumanRendererClip.LEFT = 0;
    HumanRendererClip.RIGHT = 1;
    HumanRendererClip.BOTTOM = 2;
    HumanRendererClip.TOP = 3;
    HumanRendererClip.FRONT = 4;
    HumanRendererClip.BACK = 5;

    var clipConfigs = [
        {n: new Float32Array([-1.0, 0.0, 0.0]), d: 0, fade: false, fadeDistance: 0 }, // left
        {n: new Float32Array([1.0, 0.0, 0.0]), d: 0, fade: false, fadeDistance: 0 }, // right
        {n: new Float32Array([0.0, -1.0, 0.0]), d: 0, fade: false, fadeDistance: 0 }, // bottom
        {n: new Float32Array([0.0, 1.0, 0.0]), d: 0, fade: false, fadeDistance: 0 }, // top
        {n: new Float32Array([0.0, 0.0, -1.0]), d: 0, fade: false, fadeDistance: 0 }, // front
        {n: new Float32Array([0.0, 0.0, 1.0]), d: 0, fade: false, fadeDistance: 0 } // back
    ];

    var boundary = {
        xmin: Infinity,
        xmax: -Infinity,
        ymin: Infinity,
        ymax: -Infinity,
        zmin: Infinity,
        zmax: -Infinity,
    };

    var enabledClips = new Array(clipConfigs.length);
    var clipProgress = new Float32Array(clipConfigs.length);
    var clipBoundaries = new Array(clipConfigs.length);

    var activeClips = [];

    var clipsDirty = true;

    // Allows strings to be used for clipId, e.g. "front", "back"
    var ID_MAP = {
        left: HumanRendererClip.LEFT,
        right: HumanRendererClip.RIGHT,
        bottom: HumanRendererClip.BOTTOM,
        top: HumanRendererClip.TOP,
        front: HumanRendererClip.FRONT,
        back: HumanRendererClip.BACK
    };

    var propertiesNode = null;
    var xformNode = null;
    var translationMat = mat4.create();
    var rotationMat = mat4.create();
    var scalingMat = mat4.create();
    var xformMat = mat4.create();
    var translation = vec3.create();
    var scale = vec3.fromValues(1, 1, 1);

    /**
     * Update state of a clipping plane.
     */
    HumanRendererClip.setClip = function (params) {
        var id = ID_MAP[params.clipId] !== undefined ? ID_MAP[params.clipId] : params.clipId;

        var clip = clipConfigs[id];
        var sceneBoundary = clipBoundaries[id] = params.boundary || Human.scene.getBoundary();

        if (params.enabled !== undefined) {
            enabledClips[id] = params.enabled;
        }

        if (params.fade !== undefined) {
            clip.fade = params.fade;
        }

        if (params.fadeDistance !== undefined) {
            clip.fadeDistance = params.fadeDistance;
        }

        if (params.progress !== undefined) {
            var progress = clipProgress[id] = params.progress;
            var range = 0;
            var mid = 0;

            if (id === HumanRendererClip.LEFT || id === HumanRendererClip.RIGHT) {
                range = sceneBoundary.xmax - sceneBoundary.xmin;
                mid = sceneBoundary.xmin + 0.5 * range;
            }

            if (id === HumanRendererClip.TOP || id === HumanRendererClip.BOTTOM) {
                range = sceneBoundary.ymax - sceneBoundary.ymin;
                mid = sceneBoundary.ymin + 0.5 * range;
            }

            if (id === HumanRendererClip.FRONT || id === HumanRendererClip.BACK) {
                range = sceneBoundary.zmax - sceneBoundary.zmin;
                mid = sceneBoundary.zmin + 0.5 * range;
            }

            if (id === HumanRendererClip.LEFT || id === HumanRendererClip.BOTTOM || id === HumanRendererClip.FRONT) {
                mid *= -1;
            }

            progress = 1 - progress;

            progress -= 0.5;

            clip.d = -(progress * range + mid);
        }



        clipsDirty = true;

        // Notify of new clip plane state
        Human.events.fire("clip.updated", {
            clipId: id,
            progress: params.progress || this.getProgress(id),
            enabled: !!enabledClips[id],
            fade: clip.fade,
            fadeDistance: clip.fadeDistance
        });

    };

    HumanRendererClip.getActiveClips = function() {
        return activeClips;
    };

    HumanRendererClip.isEnabled = function(id) {
        return !!enabledClips[ID_MAP[id] || id];
    };

    HumanRendererClip.getProgress = function(id) {
        return clipProgress[ID_MAP[id] || id];
    };

    HumanRendererClip.serialize = function() {
        var serializedClips = {};

        for (var i = 0, len = clipConfigs.length; i < len; ++i) {
            serializedClips[i] = {
                clipId: i,
                enabled: !!enabledClips[i],
                progress: clipProgress[i],
                fade: clipConfigs[i].fade,
                fadeDistance: clipConfigs[i].fadeDistance,
                boundary: clipBoundaries[i]
            };
        }

        return serializedClips;
    };

    HumanRendererClip.show = function (id) {
        if (!propertiesNode) {
            initGeo();
        }

        var clip = clipConfigs[id];
        var sceneBoundary = Human.scene.getBoundary();
        var rangeX = sceneBoundary.xmax - sceneBoundary.xmin;
        var rangeY = sceneBoundary.ymax - sceneBoundary.ymin;
        var rangeZ = sceneBoundary.zmax - sceneBoundary.zmin;
        var midX = (sceneBoundary.xmin + sceneBoundary.xmax) * 0.5;
        var midY = (sceneBoundary.ymin + sceneBoundary.ymax) * 0.5;
        var midZ = (sceneBoundary.zmin + sceneBoundary.zmax) * 0.5;

        propertiesNode.setEnabled(true);

        if (id === HumanRendererClip.LEFT || id === HumanRendererClip.RIGHT) {
            mat4.fromYRotation(rotationMat, Math.PI * 0.5);
            translation[0] = -clip.d * clip.n[0];
            translation[1] = midY;
            translation[2] = midZ;
            scale[0] = rangeZ;
            scale[1] = rangeY;
        }

        if (id === HumanRendererClip.TOP || id === HumanRendererClip.BOTTOM) {
            mat4.fromXRotation(rotationMat, Math.PI * 0.5);
            translation[0] = midX;
            translation[1] = -clip.d * clip.n[1];
            translation[2] = midZ;
            scale[0] = rangeX;
            scale[1] = rangeZ;
        }

        if (id === HumanRendererClip.FRONT || id === HumanRendererClip.BACK) {
            mat4.identity(rotationMat);
            translation[0] = midX;
            translation[1] = midY;
            translation[2] = -clip.d * clip.n[2];
            scale[0] = rangeX;
            scale[1] = rangeY;
        }

        mat4.fromScaling(scalingMat, scale);
        mat4.fromTranslation(translationMat, translation);

        mat4.multiply(xformMat, rotationMat, scalingMat);
        mat4.multiply(xformMat, translationMat, xformMat);

        xformNode.setElements(xformMat);
    };

    HumanRendererClip.hide = function() {
        if (!propertiesNode) {
            return;
        }

        propertiesNode.setEnabled(false);
    };

    /**
     * Reset cross-sections to dormant state
     */
    HumanRendererClip.reset = function () {
        for (var i = 0, len = clipConfigs.length; i < len; ++i) {
            enabledClips[i] = false;
        }

        clipsDirty = true;

        Human.events.fire("CrossSections.Reset");
    };

    HumanRendererClip.onFrame = function () {
        if (clipsDirty) {
            activeClips.length = 0;

            for (var i = 0, len = clipConfigs.length; i < len; ++i) {
                if (enabledClips[i]) {
                    activeClips.push(clipConfigs[i]);
                }
            }

            Human.renderer.getScene().setClips(activeClips);
            clipsDirty = false;
        }
    };

    // Get boundary created by canonical axis clipping planes
    HumanRendererClip.getBoundary = function(){
        boundary.xmin = enabledClips[HumanRendererClip.LEFT] ? clipConfigs[HumanRendererClip.LEFT].d       : -Infinity;
        boundary.xmax = enabledClips[HumanRendererClip.RIGHT] ? -clipConfigs[HumanRendererClip.RIGHT].d    : Infinity;
        boundary.ymin = enabledClips[HumanRendererClip.BOTTOM] ? clipConfigs[HumanRendererClip.BOTTOM].d   : -Infinity;
        boundary.ymax = enabledClips[HumanRendererClip.TOP] ? -clipConfigs[HumanRendererClip.TOP].d        : Infinity;
        boundary.zmin = enabledClips[HumanRendererClip.BACK] ? clipConfigs[HumanRendererClip.BACK].d       : -Infinity;
        boundary.zmax = enabledClips[HumanRendererClip.FRONT] ? -clipConfigs[HumanRendererClip.FRONT].d    : Infinity;

        return boundary;
    };

    function initGeo() {
        propertiesNode = Human.renderer.getScene().addNode({
            type: "properties",
            properties: {
                enabled: false,
                backfaces: true,
                clipping: false,
                picking: false,
                noDepthMask: true
            }
        });

        xformNode = propertiesNode.addNode({ type: "xform" });

        xformNode.addNode({
            type: "material",
            emit: 0.9,
            baseColor: {r: 0.3, g: 0.3, b: 0.4},
            specularColor: {r: 0.3, g: 0.3, b: 0.4},
            specular: 0.0,
            shine: 100.0,
            alpha: 0.2,

            nodes: [
                {
                    type: "geometry/plane"
                }
            ]
        });
    }

})();
;/**

 @namespace Dynamic lighting support

 <p>Usage:</p>

 <pre>

 // Add some lights

 Human.renderer.lights.addLight({
                lightId: "light0",
                displayName: "Default ambient",
                description: "Default ambient light source",
                params: {
                    mode: "ambient",
                    color: { r: 0.15, g: 0.15, b: 0.15 },
                    diffuse: true
                }
            });

 Human.renderer.lights.addLight({
                lightId: "light1",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 0.15, g: 0.15, b: 0.2 },
                    dir: { x: -0.3, y: 0.4, z: 0.5 },
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 Human.renderer.lights.addLight({
                lightId: "light2",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "point",
                    color: { r: 1.3, g: 1.3, b: 1.2 },
                    pos: { x: -1.0, y: 0.0, z: 1.0},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 // Enable and disable lights in a batch

 Human.renderer.lights.setEnabled({
        lights: {
            "light0": true,
            "light1": true,
            "light2": false
        },
        replace: true // Disable all previously active lights
 });

 // Set light parameters in a batch

 </pre>
 */
(function () {
    "use strict";

    var HumanRendererLights = Human.renderer.lights = {};

    /**
     * Lights mapped to their IDs
     *
     * @type {{String:Human.renderer.lights.Light}}
     */
    HumanRendererLights.lights = {};

    /**
     * Default lights should be stored for re-enabling after custom
     * lights are disabled.
    */
    HumanRendererLights.defaultLightIds = [];
    var lightConfigs = [];
    var configDirty = true;
    var sceneDirty = true;

    // Create default lights once engine code has loaded, all enabled
    HumanRendererLights.init = function () {
        // Need exactly one ambient light
        HumanRendererLights.addLight({
            lightId: 'light0',
            enabled: true,
            params: {
                mode: 'ambient',
                color: {
                    r: 0.2,
                    g: 0.2,
                    b: 0.2,
                    diffuse: true
                }
            }
        });

        HumanRendererLights.addLight({
            lightId: 'light1',
            enabled: true,
            params: {
                mode: 'dir',
                dir: {
                    x: 1.0,
                    y: 0.0,
                    z: -0.5
                },
                color: {
                    r: 0.1,
                    g: 0.1,
                    b: 0.2
                },
                diffuse: true,
                specular: true,
                space: 'view'
            }
        });

        HumanRendererLights.addLight({
            lightId: 'light2',
            enabled: true,
            params: {
                mode: 'dir',
                dir: {
                    x: -1,
                    y: 0.0,
                    z: 1.0
                },
                color: {
                    r: 0.55,
                    g: 0.5,
                    b: 0.5
                },
                diffuse: true,
                specular: true,
                space: 'view'
            }
        });

        HumanRendererLights.addLight({
            lightId: 'light3',
            enabled: true,
            params: {
                mode: 'dir',
                dir: {
                    x: 0.25,
                    y: 0.0,
                    z: -1.0
                },
                color: {
                    r: 0.9,
                    g: 0.9,
                    b: 0.9
                },
                diffuse: true,
                specular: false,
                space: 'view'
            }
        });

        HumanRendererLights.defaultLightIds.push('light0');
        HumanRendererLights.defaultLightIds.push('light1');
        HumanRendererLights.defaultLightIds.push('light2');
        HumanRendererLights.defaultLightIds.push('light3');

    };

    /**
     * Adds a light
     * @param params
     */
    HumanRendererLights.addLight = function (params) {

        if (HumanRendererLights.lights.hasOwnProperty(params.lightId)) {
            Human.log.warn("Human.renderer.lights.addLights", "The lightId already exists: " + params.lightId);
            return;
        }

        HumanRendererLights.lights[params.lightId] = {
            lightId: params.lightId,
            enabled: !!params.enabled,
            params: params.params,
            index: lightConfigs.length
        };

        configDirty = true;
        sceneDirty = true;
    };

    /**
     * Add Lights from a map of lights
     */
    HumanRendererLights.addLights = function(lights){
        for (var lightId in lights){
            if (lights.hasOwnProperty(lightId)){
                HumanRendererLights.addLight(lights[lightId]);
            }
        }
    };

    /**
     * Removes a light
     * @param lightId ID of light to remove
     */
    HumanRendererLights.removeLight = function (lightId) {
        if (HumanRendererLights.lights[lightId]) {
            delete HumanRendererLights.lights[lightId];
            configDirty = true;
            sceneDirty = true;
        }
    };

    /**
     * Removes all lights
     */
    HumanRendererLights.removeAllLights = function () {
        HumanRendererLights.lights = {};
        lightConfigs.length = 0;
        sceneDirty = true;
    };

    /**
     * Remove all non default lights
     */
    HumanRendererLights.removeCustomLights = function(){
        for (var lightId in HumanRendererLights.lights) {
            if (HumanRendererLights.lights.hasOwnProperty(lightId) &&
                HumanRendererLights.defaultLightIds.indexOf(lightId) < 0) {
                    delete HumanRendererLights.lights[lightId];
                    sceneDirty = true;
                }
        }
    };

    /**
     * Enables or disables one or more lights
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.renderer.lights.setEnabled({
     *      lightId: "myLight",
     *      enable: true
     *  });
     *
     *  Human.renderer.lights.setEnabled({
     *      lights: {
     *          "myLight": true,
     *          "myOtherlight": false
     *      },
     *      replace: true // Disable any lights that are previously enabled
     *  });
     * </pre>
     * @param params
     */
    HumanRendererLights.setEnabled = function (lights) {
        var dirty = false;
        for (var lightId in lights) {
            var light = HumanRendererLights.lights[lightId];
            if (!light) {
                Human.log.error("Human.renderer.lights.setEnabled", "Light not found: " + lightId);
                continue;
            }
            var val = !!lights[lightId];
            if (light.enabled !== val) {
                light.enabled = val;
                dirty = true;
            }
        }

        if (dirty) {
            configDirty = true;
            sceneDirty = true;
        }
    };

    /**
     * Disables all lights
     */
    HumanRendererLights.clearEnabled = function () {
        var dirty = false;
        for (var lightId in HumanRendererLights.lights) {
            HumanRendererLights.lights[lightId].enabled = false;
            dirty = true;
        }
        if (dirty) {
            configDirty = true;
            sceneDirty = true;
        }
    };

    /**
     * Sets parameters for lights
     * @param params
     */
    HumanRendererLights.setLight = function (params) {
        var lightId = params.lightId;
        var light = HumanRendererLights.lights[lightId];

        if (!light) {
            Human.log.error("Light " + lightId + " does not exist");
            return;
        }

        if (params.mode !== undefined) {
            light.params.mode = params.mode;
        }

        if (params.color !== undefined) {
            light.params.color = params.color;
        }

        if (params.dir !== undefined) {
            light.params.dir = params.dir;
        }

        if (params.pos !== undefined) {
            light.params.pos = params.pos;
        }

        if (params.diffuse !== undefined) {
            light.params.diffuse = params.diffuse;
        }

        if (params.specular !== undefined) {
            light.params.specular = params.specular;
        }

        if (params.innerCone !== undefined) {
            light.params.innerCone = params.innerCone;
        }

        if (params.outerCone !== undefined) {
            light.params.outerCone = params.outerCone;
        }

        if (params.constantAttenuation !== undefined) {
            light.params.constantAttenuation = params.constantAttenuation;
        }

        if (params.linearAttenuation !== undefined) {
            light.params.linearAttenuation = params.linearAttenuation;
        }

        if (params.quadraticAttenuation !== undefined) {
            light.params.quadraticAttenuation = params.quadraticAttenuation;
        }

        if (params.space !== undefined){
            light.params.space = params.space;
        }

        sceneDirty = true;
    };

    /* Restore Defaults (currently only one set of defaults)
    */
    HumanRendererLights.restoreDefaults = function(){
        var lights = {};

        HumanRendererLights.defaultLightIds.forEach(function(id){
            lights[id] = true;
        });

        HumanRendererLights.clearEnabled();
        HumanRendererLights.setEnabled(lights);
    };

    HumanRendererLights.onFrame = function() {
        if (configDirty) {
            var count = 0;
            lightConfigs.length = 0;
            for (var lightId in HumanRendererLights.lights) {
                var light = HumanRendererLights.lights[lightId];
                if (light.enabled) {
                    lightConfigs.push(light.params);
                    light.index = count++;
                }
            }
            configDirty = false;
            sceneDirty = true;
        }

        if (sceneDirty) {
            Human.renderer.getScene().setLights(lightConfigs);
            sceneDirty = false;
        }
    };

})();
;/**
 @namespace Reflections control

 Human.renderer.reflections.setEnabled(["environments:sky"]);

 */
(function () {
    "use strict";

    var HumanRendererReflections = Human.renderer.reflections = {};

    HumanRendererReflections.setEnabled = function (reflectionId) {
        var cubemapAsset = Human.assets.reflections.reflections[reflectionId];
        if (!cubemapAsset) {
            Human.log.error("Human.renderer.reflections.setEnabled", "reflection not found: " + reflectionId);
            return;
        }
        activateReflection(cubemapAsset);
    };

    function activateReflection(cubemapAsset) {
        var scene = Human.renderer.getScene();
        if (!scene) { // Scene not ready yet
            return;
        }
        swapReflectionsRecursive(scene, cubemapAsset);
    }

    function swapReflectionsRecursive(node, cubemapAsset) {
        if (node.type === "cubemap" || node.applyTo === "reflection") {
            swapReflections(node, cubemapAsset);
        }
        while (node.nodes && node.nodes.length > 0) {
            var child = node.nodes[0];
            swapReflectionsRecursive(child, cubemapAsset);
        }
    }

    function swapReflections(cubemap, cubemapAsset) {
        if (cubemap.getCoreId() === cubemapAsset.node.getCoreId()) {
            return;
        }
        var parent = cubemap.getParent();
        var nodes = cubemap.disconnectNodes();
        cubemap.destroy();
        // HACK: Because node destroys are deferred to next animation loop, in this case we need to make
        // our destroy() happen immediately.
        cubemap._engine._doDestroyNodes();
        var newCubemap = parent.addNode({
            type: "cubemap",
            coreId: cubemapAsset.node.getCoreId()
        });
        newCubemap.addNodes(nodes);
    }

    HumanRendererReflections.clearEnabled = function () {

    };
})();
;/**
 @namespace Lightmaps control

 Human.renderer.lightmaps.setEnabled(["environments:sky"]);

 */
(function () {
    "use strict";

    var HumanRendererLightmaps = Human.renderer.lightmaps = {};

    HumanRendererLightmaps.setEnabled = function (reflectionId) {
        var cubemapAsset = Human.assets.reflections.reflections[reflectionId];
        if (!cubemapAsset) {
            Human.log.error("Human.renderer.lightmaps.setEnabled", "reflection not found: " + reflectionId);
            return;
        }
        activateReflection(cubemapAsset);
    };

    function activateReflection(cubemapAsset) {
        var scene = Human.renderer.getScene();
        if (!scene) { // Scene not ready yet
            return;
        }
        swapLightmapsRecursive(scene, cubemapAsset);
    }

    function swapLightmapsRecursive(node, cubemapAsset) {
        if (node.type === "cubemap" || node.applyTo === "lightmap") {
            swapLightmaps(node, cubemapAsset);
        }
        while (node.nodes && node.nodes.length > 0) {
            var child = node.nodes[0];
            swapLightmapsRecursive(child, cubemapAsset);
        }
    }

    function swapLightmaps(cubemap, cubemapAsset) {
        if (cubemap.getCoreId() === cubemapAsset.node.getCoreId()) {
            return;
        }
        var parent = cubemap.getParent();
        var nodes = cubemap.disconnectNodes();
        cubemap.destroy();
        // HACK: Because node destroys are deferred to next animation loop, in this case we need to make
        // our destroy() happen immediately.
        cubemap._engine._doDestroyNodes();
        var newCubemap = parent.addNode({
            type: "cubemap",
            coreId: cubemapAsset.node.getCoreId()
        });
        newCubemap.addNodes(nodes);
    }

    HumanRendererLightmaps.clearEnabled = function () {

    };
})();
;(function() {
    "use strict";

    var postprocess = Human.renderer.postprocess = {
        scene: null,
        framebuffersInitialized: false,
        enabled: true,
        effects: {},
        currentConfig: []
    };

    postprocess.init = function(scene) {
        this.scene = scene;

        scene.createPostProcessType("blit", [
            "precision highp float;",
            "varying vec2 vUV;",
            "uniform sampler2D uColorBuffer;",
            "void main() {",
                "gl_FragColor = texture2D(uColorBuffer, vUV);",
            "}",
        ].join("\n"));

        for (var effect in this.effects) {
            this.effects[effect].init(scene);
        }

    };

    postprocess.enable = function() {
        if (!this.enabled) {
            this.enabled = true;
            postprocess.parse(this.currentConfig);
        }  
    }; 
    
    postprocess.disable = function() {
        if (this.enabled) {
            this.destroyPipeline();
            this.enabled = false;
        }
    };

    postprocess.parse = function(cfg) {
        this.destroyPipeline();

        this.currentConfig = cfg;

        if (!this.enabled) {
            return;
        }

        var pipeline = [];

        for (var i = 0, len = cfg.length; i < len; ++i) {
            var stage = cfg[i];

            var effect = Human.renderer.postprocess.effects[stage.effect];
            if (effect) {
                pipeline.push(stage.effect);
                Human.renderer.postprocess.effects[stage.effect].configure(stage);
            } else {
                Human.log.error("Unknown postprocess effect: ", stage.effect);
            }
        }

        createPipeline(pipeline);
    };

    postprocess.destroyPipeline = function() {
        this.scene.postProcessOpaque(null);
        this.scene.postProcessFinal(null);
    };

    postprocess.updateProjection = function() {
        for (var effect in this.effects) {
            if (this.effects[effect].updateProjection) {
                this.effects[effect].updateProjection();
            }
        }
    };

    postprocess.updateCanvas = function() {
        for (var effect in this.effects) {
            if (this.effects[effect].updateCanvas) {
                this.effects[effect].updateCanvas();
            }
        }
    };

    function createPipeline(effects) {
        if (!postprocess.enabled) {
            return;
        }

        var ctx = {
            opaquePipeline: [],
            transparentPipeline: [],
            finalPipeline: [],
            pipelineFramebuffers: {
                opaque: {
                    read: "__MAIN",
                    write: "__BDS_COLOR1"
                },
                transparent: {
                    read: "__MAIN",
                    write: "__BDS_COLOR1"
                },
                final: {
                    read: "__MAIN",
                    write: "__BDS_COLOR1"
                }
            },

            getIOFramebuffers: function(pipeline) {
                var fbs = this.pipelineFramebuffers[pipeline];
                var current = {
                    read: fbs.read,
                    write: fbs.write
                };

                if (fbs.write === "__BDS_COLOR1") {
                    fbs.read = "__BDS_COLOR1";
                    fbs.write = "__BDS_COLOR2";
                } else {
                    fbs.read = "__BDS_COLOR2";
                    fbs.write = "__BDS_COLOR1";
                }

                return current;
            }
        };

        var finalStage, textures, readFromMain;
        var i, len;

        for (i = 0, len = effects.length; i < len; ++i) {
            var effect = postprocess.effects[effects[i]];
            if (effect) {
                effect.addStage(ctx);
            } else {
                Human.log.error("Unknown effect: " + effects[i]);
            }
        }

        if (ctx.opaquePipeline.length === 0 && ctx.transparentPipeline.length === 0 && ctx.finalPipeline.length === 0) {
            return;
        }

        if (!postprocess.framebuffersInitialized) {
            postprocess.scene.createFramebuffer("__BDS_COLOR1", {
                depthAttachment: false
            });

            postprocess.scene.createFramebuffer("__BDS_COLOR2", {
                depthAttachment: false
            });

            postprocess.framebuffersInitialized = true;
        }
        
        if (ctx.opaquePipeline.length > 0) {
            finalStage = ctx.opaquePipeline[ctx.opaquePipeline.length - 1];
            textures = finalStage.textures;
            readFromMain = false;
            for (var sampler in textures) {
                if (textures[sampler].framebuffer === "__MAIN") {
                    readFromMain = true;
                    break;
                }
            }

            if (readFromMain) {
                ctx.opaquePipeline.push({
                    type: "blit",
                    id: "blitOpaqueToMain",
                    textures: {
                        uColorBuffer: {
                            framebuffer: finalStage.framebuffer,
                            target: "color",
                        }
                    },
                    framebuffer: "__MAIN"
                });
            } else {
                finalStage.framebuffer = "__MAIN";
            }
            postprocess.scene.postProcessOpaque(ctx.opaquePipeline);
        }

        if (ctx.finalPipeline.length > 0) {
            finalStage = ctx.finalPipeline[ctx.finalPipeline.length - 1];
            finalStage.framebuffer = false;
        } else {
            ctx.finalPipeline.push({
                type: "blit",
                id: "blitToScreen",
                textures: {
                    uColorBuffer: {
                        framebuffer: "__MAIN",
                        target: "color",
                    }
                },
                framebuffer: false
            });
        }
        postprocess.scene.postProcessFinal(ctx.finalPipeline);
    }
})();
;(function() {
    "use strict";

    var MESH_MAP_DELIMETER = "---";

    var draw = Human.renderer.draw = {
        initalized: false,
        erase: false,
        brushRadius: 20,
        brushColor: vec3.fromValues(1, 0, 0),
        brushColorCSS: null
    };

    var packer = null;
    var scene = null;
    var offscreenCanvas = null;
    var offscreenContext2D = null;
    var submeshes = {};
    var painted = false;

    var tempVec3a = vec3.create();

    var currentPatchId = 0;
    var pickedObjects = {};

    var canvasWidth = 0;
    var canvasHeight = 0;

    var lastX = -1;
    var lastY = -1;

    draw.init = function() {
        if (this.initalized) {
            return;
        }

        scene = Human.renderer.getScene();
        offscreenCanvas = document.createElement("canvas");
        offscreenContext2D = offscreenCanvas.getContext("2d");
        packer = new GrowingPacker();

        this.initalized = true;

        this.setBrushColor(this.brushColor[0], this.brushColor[1], this.brushColor[2]);
        this.updateCanvas();
    };

    draw.setBrushColor = function(r, g, b) {
        this.brushColor[0] = r;
        this.brushColor[1] = g;
        this.brushColor[2] = b;

        this.brushColorCSS = Human.utils.floatRGBToHexString(r, g, b);
    };

    draw.beginStroke = function(x, y) {
        setBrush();

        Human.renderer.canvas.context2D.beginPath();
        Human.renderer.canvas.context2D.arc(x, y, this.brushRadius, 0, 2 * Math.PI, false);
        Human.renderer.canvas.context2D.fill(); 
        Human.renderer.canvas.context2D.beginPath();
        Human.renderer.canvas.context2D.moveTo(x, y);
        captureMeshData(x, y);
        lastX = x;
        lastY = y;
    };

    draw.strokeTo = function(x, y) {
        Human.renderer.canvas.context2D.lineTo(x, y);
        Human.renderer.canvas.context2D.stroke();

        var step = this.brushRadius * 2;
        var dx = x - lastX;
        var dy = y - lastY;
        var d = Math.sqrt(dx * dx + dy * dy);
        if (d > step) {
            var numSteps = Math.floor(d / step);
            var stepx = step * (dx / d);
            var stepy = step * (dy / d);
            for (var i = 1; i <= numSteps; ++i) {
                var curx = lastX + (i * stepx);
                var cury = lastY + (i * stepy);
                captureMeshData(curx, cury);
            }
        }

        captureMeshData(x, y);
        lastX = x;
        lastY = y;
    };

    draw.record = function() {
        if(painted) {
            updateDrawTextures();
            ++currentPatchId;
        }
        for(var submeshId in submeshes) {
            var meshData = submeshes[submeshId];
            // We've added a new patch, increment counter
            meshData.bb.min[0] = meshData.bb.min[1] = Infinity; 
            meshData.bb.max[0] = meshData.bb.max[1] = -Infinity; 
        }
        pickedObjects = {};
        Human.renderer.canvas.context2D.clearRect(0, 0, canvasWidth, canvasHeight);
        offscreenContext2D.clearRect(0, 0, canvasWidth, canvasHeight);
        painted = false;
    };

    draw.updateCanvas = function() {
        if (!this.initalized) {
            return;
        }

        var canvas = Human.renderer.canvas;
        offscreenCanvas.width = canvasWidth = canvas.width;
        offscreenCanvas.height = canvasHeight = canvas.height;
    };

    function setBrush() {
        var drawCtx = Human.renderer.canvas.context2D;
        drawCtx.lineWidth = draw.brushRadius * 2;
        drawCtx.lineJoin = "round";
        drawCtx.lineCap = "round";
        if(draw.erase) {
            drawCtx.strokeStyle = "#FFFFFF";
            drawCtx.fillStyle = "#FFFFFF";
        } else {
            drawCtx.strokeStyle = draw.brushColorCSS;
            drawCtx.fillStyle = draw.brushColorCSS;
        }
    }

    var worldNormal = vec4.create();
    var v1 = vec3.create();
    var v2 = vec3.create();
    var v3 = vec3.create();
    var inverseWorldMat = mat4.create();
    var modelPos = vec3.create();
    function captureMeshData(x, y) {
        var hit = Human.renderer.pick.corePick(x, y, {rayPick: true});
        if(!hit || !hit.worldPos) {
            return;
        }

        var submeshId = hit.objectId + MESH_MAP_DELIMETER + hit.renderableIndex;
        var object = Human.scene.objects[hit.objectId];
        var renderable = object.renderables[hit.renderableIndex];
        if(!submeshes[submeshId]) {
            deindexMesh(renderable, submeshId);
        }

        var radius = Human.renderer.canvasCircleToWorldSphereRadius(x, y, draw.brushRadius, hit.worldPos);
        var worldPos = hit.worldPos;
        var geometry = renderable.geometryNode;
        var drawable = renderable.getRenderObject();
        
        //get triangle which intersect with the sphere
        mat4.invert(inverseWorldMat, object.worldMatrix);
        vec3.transformMat4(modelPos, worldPos, inverseWorldMat);
        
        var meshData = submeshes[submeshId];
        var triangleUVs = meshData.triangleUVs;
        var i, len;

        var triangleList = Human.math.intersections.spherePolyhedron(geometry, modelPos, radius);
        if (triangleList.length === 0) {
            return;
        }

        var eraseTriangles = {};
        if(draw.erase) {
            var eraseTris = Human.math.intersections.sphereInPolyhedron(geometry, modelPos, radius);
            for (i = 0, len = eraseTris.length; i < len; ++i) {
                eraseTriangles[eraseTris[i]] = true;
            }
        }

        var forward = Human.renderer.camera.getLookDir(tempVec3a);
        var triangleIndex, uvs;
        for(i = 0, len = triangleList.length; i < len; ++i) {
            triangleIndex = triangleList[i];

            if (eraseTriangles[triangleIndex] && triangleUVs[triangleIndex]) {
                delete triangleUVs[triangleIndex];
                continue;
            }

            drawable.getTrianglePositionOnSurface(triangleIndex * 3, v1, v2, v3);
            Human.math.triangleNormal(v1, v2, v3, worldNormal); // Model normal here.
            vec4.transformMat4(worldNormal, worldNormal, object.worldMatrix);

            if (vec3.dot(worldNormal, forward) > 0) {
                continue;
            }
            
            drawable.getPointInWorldSpace(v1, v1);
            drawable.getPointInWorldSpace(v2, v2);
            drawable.getPointInWorldSpace(v3, v3);

            if (!triangleUVs[triangleIndex]) {
                uvs = new Array(3);
                calculateTriangleUVs(v1, v2, v3, uvs);
                triangleUVs[triangleIndex] = {
                    patchId: currentPatchId,
                    uvs: uvs
                };
            } else if (triangleUVs[triangleIndex].patchId !== currentPatchId) {
                triangleUVs[triangleIndex].patchId = currentPatchId;
                calculateTriangleUVs(v1, v2, v3, triangleUVs[triangleIndex].uvs);
            }
        }
      
        // calculate uv bounding box
        var bb = meshData.bb;
        for (triangleIndex in triangleUVs) {
            uvs = triangleUVs[triangleIndex].uvs;
            var uv1 = uvs[0];
            var uv2 = uvs[1];
            var uv3 = uvs[2];
            bb.min[0] = Math.min(bb.min[0], uv1[0]);
            bb.min[0] = Math.min(bb.min[0], uv2[0]);
            bb.min[0] = Math.min(bb.min[0], uv3[0]);

            bb.max[0] = Math.max(bb.max[0], uv1[0]);
            bb.max[0] = Math.max(bb.max[0], uv2[0]);
            bb.max[0] = Math.max(bb.max[0], uv3[0]);

            bb.min[1] = Math.min(bb.min[1], uv1[1]);
            bb.min[1] = Math.min(bb.min[1], uv2[1]);
            bb.min[1] = Math.min(bb.min[1], uv3[1]);

            bb.max[1] = Math.max(bb.max[1], uv1[1]);
            bb.max[1] = Math.max(bb.max[1], uv2[1]);
            bb.max[1] = Math.max(bb.max[1], uv3[1]);
        }

        pickedObjects[submeshId] = renderable;
        painted = true;
    }

    var drawList = [];
    var patchList = [];
    function updateDrawTextures() {
        drawList.length = 0;

        var submeshId;
        var meshData;
        for (submeshId in pickedObjects) {
            meshData = submeshes[submeshId];
            drawList.push(pickedObjects[submeshId].getRenderObject());
        }

        Human.renderer.forceRenderFrame({
            custom: {
                renderMode: "drawTexture",
                objects: drawList
            }
        });

        var mainCanvas = Human.renderer.canvas.canvas;
        var drawCanvas = Human.renderer.canvas.annotationCanvas;
        var drawCtx = Human.renderer.canvas.context2D;


        //draw webgl canvas to image (only draw textures)
        offscreenContext2D.globalCompositeOperation = 'source-over';
        offscreenContext2D.drawImage(mainCanvas, 0, 0);

        if (draw.erase) {
            offscreenContext2D.globalCompositeOperation = "destination-out";
        } else {
            offscreenContext2D.globalCompositeOperation = 'source-over';
        }        

        //draw strokes or erase.
        offscreenContext2D.drawImage(drawCanvas, 0, 0);

        //as we need to use canvas to resize the image, we need to save a copy of the screen
        var strokeImageData = offscreenContext2D.getImageData(0, 0, canvasWidth, canvasHeight);

        //remember to clean the scale canvas
        offscreenContext2D.clearRect(0, 0, canvasWidth, canvasHeight);

        var i, len, patchId;
        for (submeshId in pickedObjects) {
            var renderable = pickedObjects[submeshId];
            meshData = submeshes[submeshId];
            var bb = meshData.bb;
            if(bb.min[0] === Infinity) {
                Human.console.error("Draw mesh data invalid.");
                continue;
            }
             //set back the copy of the screen
            drawCtx.putImageData(strokeImageData, 0, 0);
            
            var imageData = drawCtx.getImageData(
                bb.min[0] * canvasWidth, 
                bb.min[1] * canvasHeight, 
                (bb.max[0] - bb.min[0]) * canvasWidth, 
                (bb.max[1] - bb.min[1]) * canvasHeight
            );
            drawCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            //add attributes to the current patch
            var patches = meshData.patches;
            patches[currentPatchId] = {
                w: imageData.width,
                h: imageData.height,
                imageData: imageData,
            };

            patchList.length = 0;
            for (patchId in patches) {
                patchList.push(patches[patchId]);
            }

            //rearrange patches
            patchList.sort(function (a, b) {
                return b.h - a.h;
            });
            
            packer.fit(patchList);

            //enlarge drawCanvas
            var textureWidth = Math.min(Human.math.nextPowerOf2(packer.root.w), 4096);
            var textureHeight = Math.min(Human.math.nextPowerOf2(packer.root.h), 4096);

            drawCanvas.width = Math.max(drawCanvas.width, textureWidth);
            drawCanvas.height = Math.max(drawCanvas.height, textureHeight);

            //set texture
            for(i = 0, len = patchList.length; i < len; ++i) {
                drawCtx.putImageData(patchList[i].imageData, patchList[i].fit.x, patchList[i].fit.y);
            }

            var textureData = drawCtx.getImageData(0, 0, textureWidth, textureHeight);

            renderable.drawTexture.setImage(textureData);
            
            //set uvs
            var triangleUVs = meshData.triangleUVs;
            var uvs = renderable.geometryNode.getUVs();
            var geoDrawUVs = uvs[uvs.length - 1];

            var activePatches = {};

            for (var triIndex in triangleUVs) {
                var triangleData = triangleUVs[triIndex];

                if(triangleData.patchId === currentPatchId) {
                    // Normalize UVs to 0..1 range
                    var minx = bb.min[0];
                    var miny = bb.min[1];
                    var rangex = bb.max[0] - bb.min[0];
                    var rangey = bb.max[1] - bb.min[1];
                    for (i = 0; i < 3; ++i) {
                        var uv = triangleData.uvs[i];
                        uv[0] = (uv[0] - minx) / rangex;
                        uv[1] = (uv[1] - miny) / rangey;
                    }
                }
                var patch = patches[triangleData.patchId];
                var uv1 = triangleData.uvs[0];
                var uv2 = triangleData.uvs[1];
                var uv3 = triangleData.uvs[2];
                var xNorm = patch.fit.x / textureWidth;
                var yNorm = patch.fit.y / textureHeight;
                var wNorm = patch.w / textureWidth;
                var hNorm = patch.h / textureHeight;

                geoDrawUVs[triIndex * 3 * 2] = uv1[0] * wNorm + xNorm;
                geoDrawUVs[triIndex * 3 * 2 + 1] = 1 - uv1[1] * hNorm + 1 - yNorm;

                geoDrawUVs[(triIndex * 3 + 1) * 2] = uv2[0] * wNorm + xNorm;
                geoDrawUVs[(triIndex * 3 + 1) * 2 + 1] = 1 - uv2[1] * hNorm + 1 - yNorm;

                geoDrawUVs[(triIndex * 3 + 2) * 2] = uv3[0] * wNorm + xNorm;
                geoDrawUVs[(triIndex * 3 + 2) * 2 + 1] = 1 - uv3[1] * hNorm + 1 - yNorm;

                activePatches[triangleData.patchId] = true;
            }

            for (patchId in patches) {
                if (!activePatches[patchId]) {
                    delete patches[patchId];
                }
            }

            renderable.geometryNode.setUV(uvs.length - 1, geoDrawUVs);

            //setback canvas size
            drawCanvas.width = canvasWidth;
            drawCanvas.height = canvasHeight;
        }
    }

    function calculateTriangleUVs(v1, v2, v3, uvs) {
        var uv1 = vec2.create();
        Human.renderer.worldPositionToCanvas(v1, uv1);
        uv1[0] /= canvasWidth;
        uv1[1] /= canvasHeight;
        uvs[0] = uv1;

        var uv2 = vec2.create();
        Human.renderer.worldPositionToCanvas(v2, uv2);
        uv2[0] /= canvasWidth;
        uv2[1] /= canvasHeight;
        uvs[1] = uv2;

        var uv3 = vec2.create();
        Human.renderer.worldPositionToCanvas(v3, uv3);
        uv3[0] /= canvasWidth;
        uv3[1] /= canvasHeight;
        uvs[2] = uv3; 
    }
    
    var decompressedUV1 = vec2.create();
    var decompressedUV2 = vec2.create();
    var decompressedUV3 = vec2.create();
    function deindexMesh(renderable, submeshId) {
        var geometry = renderable.geometryNode;

        //deindexMesh mesh
        var mesh = {
            type: "geometry",
            primitive: "triangles",
            id: submeshId + "_draw_geometry",
            positionDecodeMat: geometry.getPositionDecodeMat()
        };

        var positions = geometry.getPositions();
        var normals = geometry.getNormals();
        var uvs = geometry.getUVs();
        var indices = geometry.getIndices();

        var numVertices = indices.length;
        var PosType = positions.constructor;
        mesh.positions = new PosType(numVertices * 3);
        if(normals) {
            if(geometry.hasCompressedNormals()) {
                mesh.normals = new Int8Array(numVertices * 2);
            } else {
                mesh.normals = new Float32Array(numVertices * 3);
            }
        }
        if(uvs) {
            mesh.uvs = new Array(uvs.length + 1);
            var k = 0;
            for(var len0 = uvs.length; k < len0;  k++) {
                mesh.uvs[k] = new Float32Array(numVertices * 2);
            }
            mesh.uvs[k] = new Float32Array(numVertices * 2);
        } else {
            mesh.uvs = [new Float32Array(numVertices * 2)];
        }

        var outPositions = mesh.positions;
        var outNormals = mesh.normals;
        var outUVs = mesh.uvs;
        for(var i = 0, len1 = indices.length; i < len1; i += 3) {
            var idx0 = indices[i];
            var idx1 = indices[i + 1];
            var idx2 = indices[i + 2];

            outPositions[i * 3] = positions[idx0 * 3];
            outPositions[i * 3 + 1] = positions[idx0 * 3 + 1];
            outPositions[i * 3 + 2] = positions[idx0 * 3 + 2];
            outPositions[i * 3 + 3] = positions[idx1 * 3];
            outPositions[i * 3 + 4] = positions[idx1 * 3 + 1];
            outPositions[i * 3 + 5] = positions[idx1 * 3 + 2];
            outPositions[i * 3 + 6] = positions[idx2 * 3];
            outPositions[i * 3 + 7] = positions[idx2 * 3 + 1];
            outPositions[i * 3 + 8] = positions[idx2 * 3 + 2];

            if(outNormals) {
                if(geometry.hasCompressedNormals()) {
                    outNormals[i * 2] = normals[idx0 * 2];
                    outNormals[i * 2 + 1] = normals[idx0 * 2 + 1];
                    outNormals[i * 2 + 2] = normals[idx1 * 2];
                    outNormals[i * 2 + 3] = normals[idx1 * 2 + 1];
                    outNormals[i * 2 + 4] = normals[idx2 * 2];
                    outNormals[i * 2 + 5] = normals[idx2 * 2 + 1];
                } else {
                    outNormals[i * 3] = normals[idx0 * 3];
                    outNormals[i * 3 + 1] = normals[idx0 * 3 + 1];
                    outNormals[i * 3 + 2] = normals[idx0 * 3 + 2];
                    outNormals[i * 3 + 3] = normals[idx1 * 3];
                    outNormals[i * 3 + 4] = normals[idx1 * 3 + 1];
                    outNormals[i * 3 + 5] = normals[idx1 * 3 + 2];
                    outNormals[i * 3 + 6] = normals[idx2 * 3];
                    outNormals[i * 3 + 7] = normals[idx2 * 3 + 1];
                    outNormals[i * 3 + 8] = normals[idx2 * 3 + 2];
                }
            }

            if(outUVs) {
                var j = 0;
                var inUV, outUV;
                if(uvs) {
                    for(var len2 = uvs.length; j < len2; j++) {
                        inUV = uvs[j]; 
                        outUV = outUVs[j]; 
                        decompressedUV1[0] = inUV[idx0 * 2];
                        decompressedUV1[1] = inUV[idx0 * 2 + 1];
                        decompressedUV2[0] = inUV[idx1 * 2];
                        decompressedUV2[1] = inUV[idx1 * 2 + 1];
                        decompressedUV3[0] = inUV[idx2 * 2];
                        decompressedUV3[1] = inUV[idx2 * 2 + 1];
                        
                        var decodeMat = geometry.getUVDecodeMat(j);
                        if (decodeMat) {
                            Human.math.decompressUV(decompressedUV1, decompressedUV1, decodeMat);
                            Human.math.decompressUV(decompressedUV2, decompressedUV2, decodeMat);
                            Human.math.decompressUV(decompressedUV3, decompressedUV3, decodeMat);
                        }
                        outUV[i * 2] = decompressedUV1[0];
                        outUV[i * 2 + 1] = decompressedUV1[1];
                        outUV[i * 2 + 2] = decompressedUV2[0];
                        outUV[i * 2 + 3] = decompressedUV2[1];
                        outUV[i * 2 + 4] = decompressedUV3[0];
                        outUV[i * 2 + 5] = decompressedUV3[1];
                    }
                }
                outUV = outUVs[j]; 
                outUV[i * 2] = -1; 
                outUV[i * 2 + 1] = -1;
                outUV[i * 2 + 2] = -1; 
                outUV[i * 2 + 3] = -1;
                outUV[i * 2 + 4] = -1; 
                outUV[i * 2 + 5] = -1;
            }

        }

        submeshes[submeshId] = {
            triangleUVs: {}, 
            patches: {},
            bb: {
                min: vec2.fromValues(Infinity, Infinity),
                max: vec2.fromValues(-Infinity, -Infinity)
            }
        };

        var uvidx = 0;
        if(uvs) {
            uvidx = uvs.length;
        }

        renderable.attachDrawTexture({
            type: "texture",
            applyFrom: "uv" + uvidx, // Apply to last set of UVs
            applyTo: "color",
            blendMode: "conditionalAlpha",
            drawTexture: true,
        });

        var geometryId = submeshId + "-draw-mesh";
        Human.assets.geometries.createGeometry(geometryId, { geometry: mesh });
        renderable.setGeometry(geometryId);
    }

})();
;/**
 * @namespace Manages camera curve path, an array of 3d cubic bezier curves
 */
(function () {
    "use strict";

    Human.renderer.camera.CurvePath = function() {
        var curves = [];

        var numPoints, numCurves;

        var pathLength = 0;

        var tempVec3 = vec3.create();

        var Bezier = Human.math.bezier;

        /** Build the curves array.
         * param {[Human.math.vec3]} points
         */
        this.init = function(points) {
            curves = [];
            pathLength = 0;
            numPoints = points.length;
            numCurves = numPoints - 1;

            if(numPoints < 2) {
                // invalid
                Human.log.error('curvePath init no enough points');
            }

            // used to compute control points at edge
            var startPoint = vec3.create();
            var endPoint = vec3.create();

            vec3.subtract(tempVec3, points[0], points[1]);
            vec3.scale(tempVec3, tempVec3, 0.25);
            vec3.add(startPoint, points[0], tempVec3);

            vec3.subtract(tempVec3, points[numPoints - 1], points[numPoints - 2]);
            vec3.scale(tempVec3, tempVec3, 0.25);
            vec3.add(endPoint, points[numPoints - 1], tempVec3);

            var i;
            var p00, p0, p1, p11;   // 4 interpolate points
            var b0;
            var b1 = vec3.create();
            var b2 = vec3.create();
            var b3;   // 4 control points for one cubic bezier curve
            for(i = 1; i < numPoints; ++i) {
                p0 = points[i-1];
                p1 = points[i];
                b0 = p0;
                b3 = p1;

                // b1 = b0 + ((p1 - p00) * 0.25);
                if ( i <= 1) {
                    vec3.subtract(tempVec3, p0, startPoint);
                } else {
                    p00 = points[i-2];
                    vec3.subtract(tempVec3, p1, p00);
                    vec3.scale(tempVec3, tempVec3, 0.25);
                }
                vec3.add(b1, b0, tempVec3);

                // b2 = b3 - ((p2 - p0) * 0.25);
                if ( i >= numPoints - 1) {
                    vec3.subtract(tempVec3, endPoint, p1);
                } else {
                    p11 = points[i+1];
                    vec3.subtract(tempVec3, p11, p0);
                    vec3.scale(tempVec3, tempVec3, 0.25);
                }
                vec3.subtract(b2, b3, tempVec3);

                curves.push(new Bezier(
                    b0[0], b0[1], b0[2],
                    b1[0], b1[1], b1[2],
                    b2[0], b2[1], b2[2],
                    b3[0], b3[1], b3[2]
                ));
            }

            // calculate curve path total length by summing up length of each segment
            for(i = 0; i < numCurves; ++i) {
                pathLength += curves[i].length();
            }

        };

        /**
         * t: 0-1
         */

        this.getPosition = function(t) {
            var p = this.getParameter(t);

            return {position: curves[p.i].compute(p.t01), i: p.i, t01: p.t01};
        };

        /**
         * i: 0 , numPoints - 2
         */
        this.getParameter = function(t) {
            var i, t01;
            t01 = t * (numPoints-1);
            t01 = Human.math.clamp(t01, 0, numPoints - 1);

            i = Math.floor(t01);
            if (i >= numPoints - 1) {
                i -= 1;
            }

            t01 -= i;

            return {i: i, t01: t01};
        };

        /**
         *
         */
        this.getPathLength = function() {
            return pathLength;
        };
    };
})();
;/**
 * @namespace Manages camera flights
 */
(function () {
    "use strict";

    var fly = Human.renderer.camera.fly = {};

    // TODO: delete this, for tweaking only
    fly.flyTimeScale = 1;
    fly.velocity = 1.0;
    fly.cylindricalArcScale = 1;
    fly.cylindricalView = false;
    fly.cylindricalOnly = false;
    fly.cylindricalRotationLerpMin = Math.PI / 6;
    fly.cylindricalRotationLerpMax = Math.PI / 2;
    fly.cylindricalRadiusLerpMin = 0.2;
    fly.cylindricalRadiusLerpMax = 1.0;

    var stopFOV = 55;

    var callbacks = [];
    var animation = null;

    var eyeCurvePath = new Human.renderer.camera.CurvePath();
    var lookCurvePath = new Human.renderer.camera.CurvePath();

    fly.onFrame = function () {
        if (animation) {
            animation.update(Date.now());
        }
    };

    fly.cancelAnimation = function () {
        if (animation) {
            //animation._onComplete(animation);
            finishAnimation();
            animation = null;
        }
    };

    /** Initiates camera flight along a catmull rom spline
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {[Object]} [params.points]
     * @param {*} [params.points[].eye] (alias position) Eye position to fly to
     * @param {*} [params.points[].look] (alias look) Look vector to fly to
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0
     * @param {Boolean} [params.constrainUp]
     * @param {Boolean} [params.easeIn]
     * @param {Boolean} [params.easeOut]
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.renderer.camera.fly
     */
    fly.flyAlongCurvePath = function (params, ok, error) {

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.renderer.camera.fly.flyAlongCurvePath", msg);
            ok();
        };

        if(!params) {
            error("params must be defined");
            ok();
        }

        var velocity = params.velocity !== undefined ? params.velocity : 1;


        var eyePoints = [];
        var lookPoints = [];
        var upVecs = [];

        var i, len;
        for(i = 0, len = params.points.length; i < len; ++i) {
            eyePoints.push(Human.math.vec3ObjToArray(params.points[i].eye || params.points[i].position));
            lookPoints.push(Human.math.vec3ObjToArray(params.points[i].look || params.points[i].target));
            upVecs.push(Human.math.vec3ObjToArray(params.points[i].up));
        }

        eyeCurvePath.init(eyePoints);
        lookCurvePath.init(lookPoints);

        flyAlongCurvePath({
            eyeCurvePath: eyeCurvePath, lookCurvePath: lookCurvePath, upVecs: upVecs,
            velocity: velocity, constrainUp: params.constrainUp,
            easeIn: params.easeIn,
            easeOut: params.easeOut
        }, ok);

    };

    function flyAlongCurvePath(params, ok) {

        Human.renderer.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};

        // Replace old animation if one existing
        animation = new Human.renderer.camera.fly.CurvePathAnimation({
            //mode: 'curvePath',
            eyeCurvePath: params.eyeCurvePath,
            lookCurvePath: params.lookCurvePath,
            upVecs: params.upVecs,
            velocity: params.velocity,
            constrainUp: params.constrainUp,
            easeIn: params.easeIn,
            easeOut: params.easeOut,

            onComplete: finishAnimation
        });

        animation.update(Date.now());
    }

    /** Initiates camera flight to the given target
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Number} [params.animationDuration] Time in seconds that it takes the camera to arrive at its target - default is null, overrides velocity when given.
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0, overridden by animationDuration.
     * @param {Number} [params.arc] Camera flight arc factor - 0.0 for no arc, 1.0 for maximum arc - default is 0.0
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.renderer.camera.fly
     */
    fly.flyTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.renderer.camera.fly", msg);
            ok();
        };

        if (params.objectId) {

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = object.getBoundary();
            if (boundary) {
                flyTo({
                        target: { boundary: boundary },
                        arc: params.arc,
                        backOff: params.backOff,
                        cylindricalView: params.cylindricalView,
                        animationDuration: params.animationDuration,
                        velocity: params.velocity,
                        easeIn: params.easeIn,
                        easeOut: params.easeOut
                    },
                    ok);
            } else {
                ok();
            }
        } else if (params.boundary) {

            boundary = params.boundary;
            flyTo({
                target: { boundary: boundary },
                arc: params.arc,
                backOff: params.backOff,
                cylindricalView: params.cylindricalView,
                animationDuration: params.animationDuration,
                velocity: params.velocity,
                easeIn: params.easeIn,
                easeOut: params.easeOut
            }, ok);

        }  else if (params.eye || params.look) {

            flyTo({
                    target: { eye: params.eye, look: params.look, up: params.up },
                    arc: params.arc,
                    backOff: params.backOff,
                    animationDuration: params.animationDuration,
                    velocity: params.velocity,

                    // Want to animate "up" vector, which we don't animate by default
                    // in order to preserve camera's upwards orientation while flying
                    constrainUp: false,

                    cylindricalView: params.cylindricalView,
                    easeIn: params.easeIn,
                    easeOut: params.easeOut
                },
                ok);

        } else {

            // Fly to default position

            flyTo({
                    target: {
                        eye: { x: 0.0, y: 6.0, z: -70.0 },
                        look: { x: 0.0, y: 0.0, z: 0 },
                        up: {x: 0.0, y: 1.0, z: 0.0}
                    },
                    arc: params.arc,
                    backOff: params.backOff,
                    cylindricalView: params.cylindricalView,
                    animationDuration: params.animationDuration,
                    velocity: params.velocity,
                    easeIn: params.easeIn,
                    easeOut: params.easeOut
                },
                ok);
        }
    };

    function flyTo(params, ok) {

        Human.renderer.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};
        // Replace old animation if one existing
        animation = new Human.renderer.camera.fly.Animation({
            animationDuration: params.animationDuration,
            velocity: params.velocity,
            target: params.target, arc: params.arc, backOff: params.backOff,
            constrainUp: params.constrainUp,
            onComplete: finishAnimation,
            cylindricalView: params.cylindricalView,
            easeIn: params.easeIn,
            easeOut: params.easeOut
        });
        animation.update(Date.now());
    }

    function finishAnimation() {
        animation = null;
        while (callbacks.length > 0) {
            callbacks.pop()();
        }
        Human.renderer.camera.lock = false;
    }

    /** Jumps camera to the given target
     *
     * <p>Terminates any camera flight in progress and signals its completion.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Number} [params.backOff] Camera back-off factor in range of [0..1], when 0 is close (default), 1 is far
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.renderer.camera.fly
     */
    fly.jumpTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };

        error = error || function (msg) {
            Human.log.error("Human.renderer.camera.fly", msg);
            ok();
        };

        var target;

        if (params.objectId) {

            // Boundary of scene object, found by ID

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = object.getBoundary();

            if (boundary) {
                target = {
                    target: {
                        boundary: boundary
                    },
                    backOff: params.backOff
                };
            }

        } else if (params.boundary) {

            target = jumpToBoundary(params);

        } else if (params.eye || params.look) {

            // Given eye point and look vector

            if (!params.eye && !params.look) {
                error("incomplete parameter configuration: both 'eye' and 'look' expected");
                return;
            }
            target = {
                target: {
                    eye: params.eye,
                    look: params.look,
                    up: params.up
                }
            };

        }  else {

            // Default position

            target = {
                target: {
                    eye: { x: 0.0, y: 6.0, z: -70.0 },
                    look: { x: 0.0, y: 0.0, z: 0 },
                    up: {x: 0.0, y: 1.0, z: 0.0}
                },
                backOff: params.backOff
            };
        }

        if (target) {

            finishAnimation();

            if (target.target.boundary) {
                target.target.stopFOV = stopFOV || target.target.stopFOV;
                Human.renderer.camera.fly.jumpTo(target.target);
            } else {
                Human.renderer.camera.setLookAt(target.target);
            }
        }

        ok();
    };

    /*
    * Force cancellation of currently running animation.
    */
    fly.cancel = finishAnimation;

    function jumpToBoundary(params) {
        // Given boundary
        var backOff = params.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;

        var cameraLook = Human.math.vec3ObjToArray(Human.renderer.camera.look);
        var cameraEye = Human.math.vec3ObjToArray(Human.renderer.camera.eye);
        var vec = vec3.create();

        vec3.subtract(vec, cameraEye, cameraLook);
        vec3.normalize(vec, vec);

        var boundary = params.boundary;
        var boundaryCenter = Human.math.getBoundaryCenter(boundary);
        var stopFOV = params.stopFOV;
        var lenVec = vec3.length(vec);
        var diag = Human.math.getBoundaryDiag(boundary);
        var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
        var sca = len / lenVec;

        vec3.scale(vec, vec, sca);
        vec3.add(vec, boundaryCenter, vec);

        return {
            target: {
                eye: {
                    x: vec[0],
                    y: vec[1],
                    z: vec[2]
                },
                look: {
                    x: boundaryCenter[0],
                    y: boundaryCenter[1],
                    z: boundaryCenter[2]
                },
                up: {
                    x: 0,
                    y: 1,
                    z: 0
                }
            }
        };
    }

})();
;/**
 * @class Interpolates a {@link Human.renderer.camera} along a curved path from current position to look at a
 * target region of space.
 * @private
 *
 */
(function () {
    "use strict";

    var stopFOV = 55;

    var tempVec = vec3.create();
    // For cyliner coordinate
    var eye1Cylinder = vec3.create();
    var eye2Cylinder = vec3.create();

    /**
     * Returns a value t between 0 and 1, eye2 = (1-t) * translation_eye2 + t * cylindrical_eye2 (nlerp)
     * @private
     */
    function getCylindricalAndTranslationBlendFactor(rotation, radius) {
        var fly = Human.renderer.camera.fly;
        var t1 = Human.math.clamp((rotation - fly.cylindricalRotationLerpMin) / (fly.cylindricalRotationLerpMax - fly.cylindricalRotationLerpMin), 0, 1);
        var t2 = Human.math.clamp((radius - fly.cylindricalRadiusLerpMin) / (fly.cylindricalRadiusLerpMax - fly.cylindricalRadiusLerpMin), 0, 1);
        return Math.min(t1,t2);
    }

    /**
     * @private
     */
    Human.renderer.camera.fly.Animation = function (cfg) {
        var target = cfg.target;

        var cylindricalView = cfg.cylindricalView !== undefined ? cfg.cylindricalView : Human.renderer.camera.fly.cylindricalView;

        this.arc = cylindricalView ? (cfg.arc === undefined ? 1.0 : cfg.arc) : 0;
        this.scaleArc = cfg.scaleArc === undefined ? Human.renderer.camera.fly.cylindricalArcScale : cfg.scaleArc;

        this.easeIn = !!cfg.easeIn;
        this.easeOut = cfg.easeOut !== false;

        // When true, we'll not change the camera's "up" vector
        //this.constrainUp = cfg.constrainUp !== false;
        this.constrainUp = cfg.constrainUp === undefined ? false : cfg.constrainUp;

        if (!target) {
            Human.log.error("Human.renderer.camera.fly.Animation config missing: target");
            if (cfg.onComplete) {
                cfg.onComplete();
            }
            return;
        }
        // Initial camera state
        var camera = Human.renderer.camera;
        this._look1 = Human.math.vec3ObjToArray(camera.look);
        this._eye1 = Human.math.vec3ObjToArray(camera.eye);
        this._up1 = Human.math.vec3ObjToArray(camera.up);

        vec3.subtract(tempVec, this._eye1, this._look1);

        // this._vec : dir from look1 to eye1
        this._vec = vec3.create();
        vec3.normalize(this._vec, tempVec);

        // Back-off factor in range of [0..1], when 0 is close, 1 is far
        var backOff = cfg.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;
        // Final camera state
        if (target.boundary) {
            // Zooming to look and eye computed from boundary
            var boundary = target.boundary;
            var dist = target.dist || 2.5;
            // ?? : this._vec is normalized, this might be changed to lenVec = 1
            var lenVec = Math.abs(vec3.length(this._vec));
            var diag = Human.math.getBoundaryDiag(boundary);
            var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
            var sca = (len / lenVec) * dist;
            this._look2 = Human.math.getBoundaryCenter(boundary);
            if (target.offset) {
                this._look2[0] += target.offset[0];
                this._look2[1] += target.offset[1];
                this._look2[2] += target.offset[2];
            }

            // calculate this._eye2
            var cylindricalOnly = Human.renderer.camera.fly.cylindricalOnly;

            if (cylindricalView) {
                this.arc = 1;
                Human.math.cartesianToCylindrical(this._look1, eye1Cylinder);   //use eye1Cylinder as a tempVec for cylindrical coordinate of look1
                Human.math.cartesianToCylindrical(this._look2, eye2Cylinder);   //use eye2Cylinder as a tempVec for cylindrical coordinate of look2
                var rotation = Human.math.getShortRotation(eye1Cylinder[1], eye2Cylinder[1]);
                var radius = eye2Cylinder[0];
                var t = getCylindricalAndTranslationBlendFactor(Math.abs(rotation), radius);

                if(!cylindricalOnly) {
                    eye2Cylinder[0] = sca;  //look2 -> eye2
                    eye2Cylinder[2] = 0;
                    this._eye2 = Human.math.cylindricalToCartesian(eye2Cylinder);  // this._eye2 used as tempVec here

                    //blend with original look dir
                    vec3.scale(tempVec, this._vec, sca);
                    Human.math.lerpVec3(t, 0, 1, tempVec, this._eye2, tempVec);
                    vec3.normalize(tempVec, tempVec);
                    vec3.scale(tempVec, tempVec, sca);
                    vec3.add(this._eye2, this._look2, tempVec);
                } else {
                    eye2Cylinder[0] = eye2Cylinder[0] + sca;
                    this._eye2 = Human.math.cylindricalToCartesian(eye2Cylinder);
                }

            } else {
                vec3.scale(tempVec, this._vec, sca);
                this._eye2 = vec3.add(vec3.create(), this._look2, tempVec);
            }


            this._up2 = vec3.create();

            if (this.constrainUp) {
                this._up2[0] = camera.up.x;
                this._up2[1] = camera.up.y;
                this._up2[2] = camera.up.z;
            } else if (target.up) {
                this._up2[0] = target.up.x || 0;
                this._up2[1] = target.up.y || 0;
                this._up2[2] = target.up.z || 0;
            } else {
                this._up2[1] = 1;
            }

        } else {
            // Zooming to specific look and eye points
            var look = target.look;
            var eye = target.eye;
            var up = target.up;
            var cameraEye = Human.renderer.camera.eye;
            var cameraLook = Human.renderer.camera.look;
            var cameraUp = Human.renderer.camera.up;
            this._look2 = vec3.create();
            this._eye2 = vec3.create();
            this._up2 = vec3.create();

            if (look) {
                this._look2[0] = look.x || 0;
                this._look2[1] = look.y || 0;
                this._look2[2] = look.z || 0;
            } else {
                this._look2[0] = cameraLook.x;
                this._look2[1] = cameraLook.y;
                this._look2[2] = cameraLook.z;
            }

            if (eye) {
                this._eye2[0] = eye.x || 0;
                this._eye2[1] = eye.y || 0;
                this._eye2[2] = eye.z || 0;
            } else {
                this._eye2[0] = cameraEye.x;
                this._eye2[1] = cameraEye.y;
                this._eye2[2] = cameraEye.z;
            }

            if (up && !this.constrainUp) {
                this._up2[0] = up.x || 0;
                this._up2[1] = up.y || 0;
                this._up2[2] = up.z || 0;
            } else {
                this._up2[0] = cameraUp.x;
                this._up2[1] = cameraUp.y;
                this._up2[2] = cameraUp.z;
            }

        }

        // Distance to travel
        vec3.subtract(tempVec, this._look2, this._look1);
        var lookDist = Math.abs(vec3.length(tempVec));

        vec3.subtract(tempVec, this._eye2, this._eye1);

        // simple lerp straight line distance
        var eyeDist = Math.abs(vec3.length(tempVec));

        // Curve animation setup
        if (this.arc > 0.0) {
            Human.math.cartesianToCylindrical(this._eye1, eye1Cylinder);
            Human.math.cartesianToCylindrical(this._eye2, eye2Cylinder);

            // dist = (r1 + r2) * radian
            var shortRotation = Human.math.getShortRotation(eye1Cylinder[1], eye2Cylinder[1]);
            var v = (eye1Cylinder[0] + eye2Cylinder[0]) * Math.abs(shortRotation);
            var h = eye2Cylinder[2] - eye1Cylinder[1];
            var cylinderDist = Math.sqrt( v*v + h*h );
            eyeDist = (1 - this.arc) * eyeDist + this.arc * cylinderDist;
        }

        this._dist = lookDist > eyeDist ? lookDist : eyeDist;

        if (cfg.animationDuration) {
            this._animationDuration = cfg.animationDuration * 1000; // Duration in millisecs internally
        } else {
            this._animationDuration = Human.renderer.camera.fly.flyTimeScale * 1000.0 * ((this._dist / ((cfg.velocity || Human.renderer.camera.fly.velocity) * 200.0)) + 1); // extra seconds to ensure arrival
        }

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.renderer.camera}
     */

    var eyeVec = vec3.create();
    var lookVec = vec3.create();

    Human.renderer.camera.fly.Animation.prototype.update = function (time) {
        if (this._time1 === undefined) {
            this._time1 = time;
            this._time2 = this._time1 + this._animationDuration;
        }

        if (this._done || time > this._time2) {
            if (!this._done) {
                Human.renderer.camera.setLookAt({
                    look: Human.math.vec3ArrayToObj(this._look2),
                    eye: Human.math.vec3ArrayToObj(this._eye2),
                    up:  Human.math.vec3ArrayToObj(this._up2)
                });
            }
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._animationDuration;

        var easedTime;
        if (this.easeIn && this.easeOut) {
            easedTime = Human.math.easeInOut(t, 0, 1, 1);
        } else if (this.easeIn) {
            easedTime = Human.math.easeIn(t, 0, 1, 1);
        } else if (this.easeOut) {
            easedTime = Human.math.easeOut(t, 0, 1, 1);
        } else {
            easedTime = t;
        }

        Human.math.lerpVec3(easedTime, 0, 1, this._look1, this._look2, lookVec);

        if (this.arc > 0.0) {
            Human.math.lerpVec3Cylindrical(easedTime, 0, 1, eye1Cylinder, eye2Cylinder, tempVec);

            if (this.scaleArc !== 1) {
                var radius = tempVec[0];
                var scaled = this.scaleArc * radius;
                if (easedTime < 0.5) {
                    radius = Human.math.lerpScalar(easedTime, 0, 0.5, radius, scaled);
                } else {
                    radius = Human.math.lerpScalar(easedTime, 0.5, 1, scaled, radius);
                }
                // console.log(t, tempVec[0], radius)
                tempVec[0] = radius;
            }

            Human.math.cylindricalToCartesian(tempVec, eyeVec);

            if (this.arc < 1.0) {
                // simple lerp of eye
                Human.math.lerpVec3(
                    easedTime,
                    0,
                    1,
                    this._eye1,
                    this._eye2,
                    tempVec); // Destination

                // blend the curved animation with lerp animation
                Human.math.lerpVec3(this.arc, 0, 1, tempVec, eyeVec, eyeVec);
            }

        } else {
            // simple lerp of eye
            Human.math.lerpVec3(
                easedTime,
                0,
                1,
                this._eye1,
                this._eye2,
                eyeVec); // Destination
        }

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"

            Human.renderer.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec)
            });

        } else {

            // Interpolating "eye", "look" and "up"

            var up = Human.math.lerpVec3(easedTime, 0, 1, this._up1, this._up2, []);

            Human.renderer.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec),
                up:  Human.math.vec3ArrayToObj(up)
            });
        }
    };

    Human.renderer.camera.fly.Animation.prototype.stop = function () {
    };
})();
;/**
 * @class Interpolates a {@link Human.renderer.camera} along an array of bezier curves (curve path)
 * @private
 *
 */
(function () {
    "use strict";

    var velocity = 1.0;
    //var stopFOV;

    var up1 = vec3.create();

    Human.properties.subscribe({
        propId: "camera.flyCurvePath",
        value: {
            velocity: 1.0,
        },
        callback: function (value) {
            velocity = value.velocity || 1.0;
        }
    });

    /**
     * @private
     */
    Human.renderer.camera.fly.CurvePathAnimation = function (cfg) {

        this.easeIn = !!cfg.easeIn;
        this.easeOut = cfg.easeOut !== false;

        // When true, we'll not change the camera's "up" vector
        this.constrainUp = cfg.constrainUp === undefined ? false : cfg.constrainUp;

        this._eyeCurvePath = cfg.eyeCurvePath;
        this._lookCurvePath = cfg.lookCurvePath;
        this._upVecs = cfg.upVecs;

        var camera = Human.renderer.camera;

        var t = 1;
        var p = this._lookCurvePath.getParameter(t);
        var i = p.i;
        this._look2 = Human.math.vec3ObjToArray(this._lookCurvePath.getPosition(t).position);
        this._eye2 = Human.math.vec3ObjToArray(this._eyeCurvePath.getPosition(t).position);
        this._up2 = this.constrainUp ? Human.math.vec3ObjToArray(camera.up) : this._upVecs[i+1];

        // Distance to travel
        var eyeLength = this._eyeCurvePath.getPathLength();
        var lookLength = this._lookCurvePath.getPathLength();

        this._dist = Math.max(eyeLength, lookLength);

        // Duration of travel
        this._duration = Human.renderer.camera.fly.flyTimeScale * 1000.0 * ((this._dist / ((cfg.velocity || velocity) * 200.0)) + 1); // extra seconds to ensure arrival

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.renderer.camera}
     */

    Human.renderer.camera.fly.CurvePathAnimation.prototype.update = function (time) {
        if (this._time1 === undefined) {
            this._time1 = time;
            this._time2 = this._time1 + this._duration;
        }

        if (this._done || time > this._time2) {
            if (!this._done) {
                Human.renderer.camera.setLookAt({
                    look: Human.math.vec3ArrayToObj(this._look2),
                    eye: Human.math.vec3ArrayToObj(this._eye2),
                    up:  Human.math.vec3ArrayToObj(this._up2)
                });
            }
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._duration;
        var easedTime;
        if (this.easeIn && this.easeOut) {
            easedTime = Human.math.easeInOut(t, 0, 1, 1);
        } else if (this.easeIn) {
            easedTime = Human.math.easeIn(t, 0, 1, 1);
        } else if (this.easeOut) {
            easedTime = Human.math.easeOut(t, 0, 1, 1);
        } else {
            easedTime = t;
        }

        var look = this._lookCurvePath.getPosition(easedTime).position;
        var eye = this._eyeCurvePath.getPosition(easedTime).position;

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"
            Human.renderer.camera.setLookAt({
                look: look,
                eye: eye
            });

        } else {

            // Interpolating "eye", "look" and "up"
            var p = this._lookCurvePath.getParameter(easedTime);
            Human.math.lerpVec3(p.t01, 0, 1, this._upVecs[p.i], this._upVecs[p.i+1], up1);

            Human.renderer.camera.setLookAt({
                look: look,
                eye: eye,
                up:  Human.math.vec3ArrayToObj(up1)
            });


        }
    };

})();
;(function() {
    "use strict";

    var DEFAULT_FOCUS_START = 90;
    var DEFAULT_FOCUS_END = 130;
    var DEFAULT_BLUR = 0.1;

    var DOF_SOURCE = [
       "precision highp float;",
       "#define MAX_BLUR 20.0",
       "varying vec2 vUV;",
       "uniform float uFocusStart;",
       "uniform float uFocusEnd;",
       "uniform float uBlurCoefficient;",
       "uniform sampler2D uTexture;",
       "uniform sampler2D uDepth;",
       "uniform vec2 uTexelOffset;",
       "uniform vec2 uDepthRange;",
       "void main() {",
           // Convert to linear depth
           "float ndc = 2.0 * texture2D(uDepth, vUV).r - 1.0;",
           "float depth = -(2.0 * uDepthRange.y * uDepthRange.x) / (ndc * (uDepthRange.y - uDepthRange.x) - uDepthRange.y - uDepthRange.x);",
           "float deltaDepth = max(depth - uFocusEnd, 0.0) + max(uFocusStart - depth, 0.0);",
            
           "vec4 color = vec4(0.0);",
           "if (ndc < 1.0 && deltaDepth > 0.0) {",
               "float blurRadius = min(floor(uBlurCoefficient * deltaDepth), MAX_BLUR);",
               "float halfBlur = blurRadius * 0.5;",
               "float count = 0.0;",
               "for (float i = 0.0; i <= MAX_BLUR; ++i) {",
                   "if (i > blurRadius) {",
                       "break;",
                   "}",
                   "color += texture2D(uTexture, vUV + ((i - halfBlur) * uTexelOffset));",
                   "++count;",
               "}",
               "color /= count;",
           "} else {",
               "color = texture2D(uTexture, vUV);",
           "}",
           "gl_FragColor = color;",
        "}"
    ].join("\n");

    var dofHConfig = {
        type: "dof",
        id: "dofHorizontal",
        uniforms: {
            uFocusStart: DEFAULT_FOCUS_START,
            uFocusEnd: DEFAULT_FOCUS_END,
            uBlurCoefficient: DEFAULT_BLUR,
            uTexelOffset: new Float32Array([1 / window.innerWidth, 0]),
            uDepthRange: new Float32Array([0.1, 10000])
        },
        textures: {
            uTexture: {
                framebuffer: "---SET_ME---",
                target: "color"
            },
            uDepth: {  
                framebuffer: "__MAIN",
                target: "depth"
            }
        },
        framebuffer: "---SET_ME---"
    };

    var dofVConfig = {
        type: "dof",
        id: "dofVertical",
        uniforms: {
            uTexelOffset: new Float32Array([0, 1 / window.innerHeight]),
        },
        textures: {
            uTexture: {
                framebuffer: "---SET_ME---",
                target: "color"
            },
            uDepth: {  
                framebuffer: "__MAIN",
                target: "depth"
            }
        },
        framebuffer: "---SET_ME---"
    };

    var DOF = Human.renderer.postprocess.effects.dof = {
        scene: null,
        supported: SceneJS.WEBGL_INFO.depthTexturesSupported,
        focusStart: DEFAULT_FOCUS_START,
        focusEnd: DEFAULT_FOCUS_END,
        blurCoefficient: DEFAULT_BLUR
    };

    DOF.init = function(scene) {
        this.scene = scene;
        
        if (!this.supported) {
            return;
        }

        scene.createPostProcessType("dof", DOF_SOURCE);
    };

    DOF.addStage = function(ctx) {
        if (!this.supported) {
            return;
        }

        var ioFramebuffers = ctx.getIOFramebuffers("final");

        dofHConfig.uniforms.uFocusStart = this.focusStart;
        dofHConfig.uniforms.uFocusEnd = this.focusEnd;
        dofHConfig.uniforms.uBlurCoefficient = this.blurCoefficient;
        dofHConfig.uniforms.uDepthRange[0] = Human.renderer.camera.near;
        dofHConfig.uniforms.uDepthRange[1] = Human.renderer.camera.far;
        dofHConfig.uniforms.uTexelOffset[0] = 1 / Human.renderer.canvas.width;
        dofHConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        dofHConfig.framebuffer = ioFramebuffers.write;

        ioFramebuffers = ctx.getIOFramebuffers("final");

        dofVConfig.uniforms.uTexelOffset[1] = 1 / Human.renderer.canvas.height;
        dofVConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        dofVConfig.framebuffer = ioFramebuffers.write;

        ctx.finalPipeline.push(dofHConfig);
        ctx.finalPipeline.push(dofVConfig);
    };

    DOF.setFocusStart = function(start) {
        this.focusStart = dofHConfig.uniforms.uFocusStart = start;
        var dofStage = this.scene.getPostProcessStage("dofHorizontal");
        if (dofStage) {
            dofStage.setUniform("uFocusStart", this.focusStart);
        }
    };

    DOF.setFocusEnd = function(end) {
        this.focusEnd = dofHConfig.uniforms.uFocusEnd = end;
        var dofStage = this.scene.getPostProcessStage("dofHorizontal");
        if (dofStage) {
            dofStage.setUniform("uFocusEnd", this.focusEnd);
        }
    };

    DOF.setBlurCoefficient = function(blur) {
        this.blurCoefficient = dofHConfig.uniforms.uBlurCoefficient = blur;
        var dofStage = this.scene.getPostProcessStage("dofHorizontal");
        if (dofStage) {
            dofStage.setUniform("uBlurCoefficient", this.blurCoefficient);
        }
    };

    DOF.configure = function(cfg) {
        cfg = cfg || {};
        cfg.focusStart = cfg.focusStart === undefined ? DEFAULT_FOCUS_START : cfg.focusStart;
        cfg.focusEnd = cfg.focusEnd === undefined ? DEFAULT_FOCUS_END : cfg.focusEnd;
        cfg.blur = cfg.blur === undefined ? DEFAULT_BLUR : cfg.blur;

        this.setFocusStart(cfg.focusStart);
        this.setFocusEnd(cfg.focusEnd);
        this.setBlurCoefficient(cfg.blur);
    };

    DOF.updateProjection = function() {
        dofHConfig.uniforms.uDepthRange[0] = Human.renderer.camera.near;
        dofHConfig.uniforms.uDepthRange[1] = Human.renderer.camera.far;

        var dofStage = this.scene.getPostProcessStage("dofHorizontal");
        if (dofStage) {
            dofStage.setUniform("uDepthRange", dofHConfig.uniforms.uDepthRange);
        }
    };

    DOF.updateCanvas = function() {
        var canvas = Human.renderer.canvas;
        dofHConfig.uniforms.uTexelOffset[0] = 1 / canvas.width;
        dofVConfig.uniforms.uTexelOffset[1] = 1 / canvas.height;

        var dofHStage = this.scene.getPostProcessStage("dofHorizontal");
        var dofVStage = this.scene.getPostProcessStage("dofVertical");
        if (dofHStage && dofVStage) {
            dofHStage.setUniform("uTexelOffset", dofHConfig.uniforms.uTexelOffset);
            dofVStage.setUniform("uTexelOffset", dofVConfig.uniforms.uTexelOffset);
        }
    };

})();
;(function() {
    "use strict";

    var DEFAULT_BLUR = 0.1;

    var BLUR_SOURCE = [
       "precision highp float;",
       "#define MAX_BLUR 20.0",
       "varying vec2 vUV;",
       "uniform float uBlurCoefficient;",
       "uniform sampler2D uTexture;",
       "uniform vec2 uTexelOffset;",
       "void main() {",            
           "vec4 color = vec4(0.0);",
           "float blurRadius = min(floor(uBlurCoefficient * 100.0), MAX_BLUR);",
           "float halfBlur = blurRadius * 0.5;",
           "float count = 0.0;",
           "for (float i = 0.0; i <= MAX_BLUR; ++i) {",
               "if (i > blurRadius) {",
                   "break;",
               "}",
               "color += texture2D(uTexture, vUV + ((i - halfBlur) * uTexelOffset));",
               "++count;",
           "}",
           "color /= count;",
           "gl_FragColor = color;",
        "}"
    ].join("\n");

    var blurHConfig = {
        type: "blur",
        id: "blurHorizontal",
        uniforms: {
            uBlurCoefficient: DEFAULT_BLUR,
            uTexelOffset: new Float32Array([1 / window.innerWidth, 0]),
        },
        textures: {
            uTexture: {
                framebuffer: "---SET_ME---",
                target: "color"
            }
        },
        framebuffer: "---SET_ME---"
    };

    var blurVConfig = {
        type: "blur",
        id: "blurVertical",
        uniforms: {
            uTexelOffset: new Float32Array([0, 1 / window.innerHeight]),
        },
        textures: {
            uTexture: {
                framebuffer: "---SET_ME---",
                target: "color"
            }
        },
        framebuffer: "---SET_ME---"
    };

    var blur = Human.renderer.postprocess.effects.blur = {
        scene: null,
        blurCoefficient: DEFAULT_BLUR
    };

    blur.init = function(scene) {
        this.scene = scene;
        scene.createPostProcessType("blur", BLUR_SOURCE);
    };

    blur.addStage = function(ctx) {
        var ioFramebuffers = ctx.getIOFramebuffers("final");

        blurHConfig.uniforms.uBlurCoefficient = this.blurCoefficient;
        blurHConfig.uniforms.uTexelOffset[0] = 1 / Human.renderer.canvas.width;
        blurHConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        blurHConfig.framebuffer = ioFramebuffers.write;

        ioFramebuffers = ctx.getIOFramebuffers("final");

        blurVConfig.uniforms.uTexelOffset[1] = 1 / Human.renderer.canvas.height;
        blurVConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        blurVConfig.framebuffer = ioFramebuffers.write;

        ctx.finalPipeline.push(blurHConfig);
        ctx.finalPipeline.push(blurVConfig);
    };

    blur.setBlurCoefficient = function(blur) {
        this.blurCoefficient = blurHConfig.uniforms.uBlurCoefficient = blur;
        var blurStage = this.scene.getPostProcessStage("blurHorizontal");
        if (blurStage) {
            blurStage.setUniform("uBlurCoefficient", this.blurCoefficient);
        }
    };

    blur.configure = function(cfg) {
        cfg = cfg || {};
        cfg.blur = cfg.blur === undefined ? DEFAULT_BLUR : cfg.blur;

        this.setBlurCoefficient(cfg.blur);
    };

    blur.updateCanvas = function() {
        var canvas = Human.renderer.canvas;
        var blurHStage = this.scene.getPostProcessStage("blurHorizontal");
        var blurVStage = this.scene.getPostProcessStage("blurVertical");
        if (blurHStage && blurVStage) {
            blurHConfig.uniforms.uTexelOffset[0] = 1 / canvas.width;
            blurVConfig.uniforms.uTexelOffset[1] = 1 / canvas.height;
            blurHStage.setUniform("uTexelOffset", blurHConfig.uniforms.uTexelOffset);
            blurVStage.setUniform("uTexelOffset", blurVConfig.uniforms.uTexelOffset);
        }
    };

})();
;(function() {
    "use strict";

    var DEFAULT_RADIUS = 0.2;
    var DEFAULT_CENTER = new Float32Array([0, 0]);
    var DEFAULT_BLUR = 0.1;

    var blurParams = new Float32Array(4);
    var hTexelParams = new Float32Array(3);
    var vTexelParams = new Float32Array(3);

    var RADIAL_BLUR_SOURCE = [
       "precision highp float;",
       "#define MAX_BLUR 20.0",
       "varying vec2 vUV;",
       "uniform sampler2D uTexture;",
       "uniform vec4 uBlurParams;",
       "uniform vec3 uTexelParams;",
       "void main() {",
           "vec2 center = uBlurParams.xy;",
           "float radius = uBlurParams.z;",
           "float blurCoefficient = uBlurParams.w;",
           "vec2 texelOffset = uTexelParams.xy;",
           "float aspect = uTexelParams.z;",
           "vec2 pos = vUV * 2.0 - 1.0;",
           "pos.x *= aspect;",
           "float r = length(pos - center);",
           "float deltaR = max(r - radius, 0.0);",
            
           "vec4 color = vec4(0.0);",
           "if (deltaR > 0.0) {",
               "float blurRadius = min(floor(blurCoefficient * 100.0 * deltaR), MAX_BLUR);",
               "float halfBlur = blurRadius * 0.5;",
               "float count = 0.0;",
               "for (float i = 0.0; i <= MAX_BLUR; ++i) {",
                   "if (i > blurRadius) {",
                       "break;",
                   "}",
                   "color += texture2D(uTexture, vUV + ((i - halfBlur) * texelOffset));",
                   "++count;",
               "}",
               "color /= count;",
           "} else {",
               "color = texture2D(uTexture, vUV);",
           "}",
           "gl_FragColor = color;",
        "}"
    ].join("\n");

    var radialBlurHConfig = {
        type: "radialBlur",
        id: "radialBlurHorizontal",
        uniforms: {
            uBlurParams: blurParams,
            uTexelParams: hTexelParams
        },
        textures: {
            uTexture: {
                framebuffer: "---SET_ME---",
                target: "color"
            }
        },
        framebuffer: "---SET_ME---"
    };

    var radialBlurVConfig = {
        type: "radialBlur",
        id: "radialBlurVertical",
        uniforms: {
            uTexelParams: vTexelParams
        },
        textures: {
            uTexture: {
                framebuffer: "---SET_ME---",
                target: "color"
            }
        },
        framebuffer: "---SET_ME---"
    };

    var radialBlur = Human.renderer.postprocess.effects.radialBlur = {
        scene: null,
        radius: DEFAULT_RADIUS,
        center: new Float32Array(DEFAULT_CENTER),
        blurCoefficient: DEFAULT_BLUR
    };

    radialBlur.init = function(scene) {
        this.scene = scene;
        scene.createPostProcessType("radialBlur", RADIAL_BLUR_SOURCE);
    };

    radialBlur.addStage = function(ctx) {
        var ioFramebuffers = ctx.getIOFramebuffers("final");

        blurParams.set(this.center);
        blurParams[2] = this.radius;
        blurParams[3] = this.blurCoefficient;

        var aspect = Human.renderer.canvas.width / Human.renderer.canvas.height;
        hTexelParams[0] = aspect / Human.renderer.canvas.width;
        hTexelParams[2] = aspect;

        vTexelParams[1] = 1 / Human.renderer.canvas.height;
        vTexelParams[2] = aspect;

        radialBlurHConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        radialBlurHConfig.framebuffer = ioFramebuffers.write;

        ioFramebuffers = ctx.getIOFramebuffers("final");

        radialBlurVConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        radialBlurVConfig.framebuffer = ioFramebuffers.write;

        ctx.finalPipeline.push(radialBlurHConfig);
        ctx.finalPipeline.push(radialBlurVConfig);
    };

    radialBlur.setRadius = function(r) {
        this.radius = blurParams[2] = r;

        var radialBlurStage = this.scene.getPostProcessStage("radialBlurHorizontal");
        if (radialBlurStage) {
            radialBlurStage.setUniform("uBlurParams", blurParams);
        }
    };

    radialBlur.setCenter = function(x, y) {
        this.center[0] = x;
        this.center[1] = y;
        blurParams.set(this.center);

        var radialBlurStage = this.scene.getPostProcessStage("radialBlurHorizontal");
        if (radialBlurStage) {
            radialBlurStage.setUniform("uBlurParams", blurParams);
        }
    };

    radialBlur.setBlurCoefficient = function(blur) {
        this.blurCoefficient = blurParams[3] = blur;

        var radialBlurStage = this.scene.getPostProcessStage("radialBlurHorizontal");
        if (radialBlurStage) {
            radialBlurStage.setUniform("uBlurParams", blurParams);
        }
    };

    radialBlur.configure = function(cfg) {
        cfg = cfg || {};
        cfg.radius = cfg.radius === undefined ? DEFAULT_RADIUS : cfg.radius;
        cfg.center = cfg.center === undefined ? DEFAULT_CENTER : cfg.center;
        cfg.blur = cfg.blur === undefined ? DEFAULT_BLUR : cfg.blur;

        this.setRadius(cfg.radius);
        this.setCenter(cfg.center[0], cfg.center[1]);
        this.setBlurCoefficient(cfg.blur);
    };

    radialBlur.updateCanvas = function() {
        var canvas = Human.renderer.canvas;
        var aspect = canvas.width / canvas.height;

        hTexelParams[0] = aspect / canvas.width;
        hTexelParams[2] = aspect;

        vTexelParams[1] = 1 / canvas.height;
        vTexelParams[2] = aspect;

        var radialBlurHStage = this.scene.getPostProcessStage("radialBlurHorizontal");
        var radialBlurVStage = this.scene.getPostProcessStage("radialBlurVertical");
        if (radialBlurHStage && radialBlurVStage) {
            radialBlurHStage.setUniform("uTexelParams", hTexelParams);
            radialBlurVStage.setUniform("uTexelParams", vTexelParams);
        }
    };

})();
;(function() {
    "use strict";

    var DEFAULT_GAMMA = 2.2;
    var DEFAULT_TONEMAP = false;

    var GAMMA_CORRECT_SOURCE = [
        "precision highp float;",
        "varying vec2 vUV;",
        "uniform float uGamma;",
        "uniform bool uToneMap;",
        "uniform sampler2D uTexture;",
        "vec3 toneMapReinhard(vec3 color) {",
        "    return color / (color + 1.0);",
        "}",
        "void main() {",
        "   vec4 color = texture2D(uTexture, vUV);",
        "   if (uToneMap) {",
        "       color.rgb = toneMapReinhard(color.rgb);",
        "   }",
        "   color.rgb = pow(color.rgb, vec3(1.0 / uGamma));",
        "   gl_FragColor = color;",
        "}"
    ].join("\n");

    var gammaConfig = {
        type: "gammaCorrect",
        id: "gammaCorrect",
        uniforms: {
            uGamma: DEFAULT_GAMMA,
            uToneMap: DEFAULT_TONEMAP
        },
        textures: {
            uTexture: {
                framebuffer:  "---SET_ME---",
                target: "color"
            }
        },
        framebuffer:  "---SET_ME---"
    };
    
    var gammaCorrect = Human.renderer.postprocess.effects.gammaCorrect = {
        scene: null,
        gamma: DEFAULT_GAMMA,
        toneMap: DEFAULT_TONEMAP
    };

    gammaCorrect.init = function(scene) {
        this.scene = scene;
        scene.createPostProcessType("gammaCorrect", GAMMA_CORRECT_SOURCE);
    };

    gammaCorrect.addStage = function(ctx) {
        var ioFramebuffers = ctx.getIOFramebuffers("final");
        gammaConfig.uniforms.uGamma = this.gamma;
        gammaConfig.uniforms.uToneMap = this.toneMap;
        gammaConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        gammaConfig.framebuffer = ioFramebuffers.write;
        ctx.finalPipeline.push(gammaConfig);
    };

    gammaCorrect.setGamma = function(gamma) {
        this.gamma = gammaConfig.uniforms.uGamma = gamma;
        var gammaStage = this.scene.getPostProcessStage("gammaCorrect");
        if (gammaStage) {
            gammaStage.setUniform("uGamma", this.gamma);
        }
    };

    gammaCorrect.setToneMap = function(toneMap) {
        this.toneMap = gammaConfig.uniforms.uToneMap = toneMap;
        var gammaStage = this.scene.getPostProcessStage("gammaCorrect");
        if (gammaStage) {
            gammaStage.setUniform("uToneMap", this.toneMap);
        }
    };

    gammaCorrect.configure = function(cfg) {
        cfg = cfg || {};
        cfg.gamma = cfg.gamma === undefined ? DEFAULT_GAMMA : cfg.gamma;
        cfg.toneMap = cfg.toneMap === undefined ? DEFAULT_TONEMAP : cfg.toneMap;
        this.setGamma(cfg.gamma);
        this.setToneMap(cfg.toneMap);
    };

})();
;(function() {
    "use strict";

    var FXAA_SOURCE = [
        "precision highp float;",

        "uniform sampler2D uTexture;",
        "uniform vec2 uTexelOffset;",

        "varying vec2 vUV;",

        "const float fxaaQualitySubpix = 0.75;",
        "const float fxaaQualityEdgeThreshold = 0.125;",
        "const float fxaaQualityEdgeThresholdMin = 0.0;",
        

        // NVIDIA GameWorks Graphics Samples GitHub link: https://github.com/NVIDIAGameWorks/GraphicsSamples
        // Original FXAA 3.11 shader link: https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/master/samples/es3-kepler/FXAA/FXAA3_11.h

        // Steps used to integrate into Cesium:
        // * The following defines are set:
        //       #define FXAA_PC 1
        //       #define FXAA_WEBGL_1 1
        //       #define FXAA_GREEN_AS_LUMA 1
        //       #define FXAA_EARLY_EXIT 1
        //       #define FXAA_GLSL_120 1
        // * All other preprocessor directives besides the FXAA_QUALITY__P* directives were removed.
        // * Double underscores are invalid for preprocessor directives so replace them with a single underscore. Replace
        //   /FXAA_QUALITY__P(.*)/g with /FXAA_QUALITY__P$1/.
        // * There are no implicit conversions from ivec* to vec* so replace:
        //       #define FxaaInt2 ivec2
        //           with
        //       #define FxaaInt2 vec2
        // * The texture2DLod function is only available in vertex shaders so replace:
        //       #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
        //       #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
        //           with
        //       #define FxaaTexTop(t, p) texture2D(t, p)
        //       #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))
        // * FXAA_QUALITY_PRESET is prepended in the javascript code. We may want to expose that setting in the future.
        // * The following parameters to FxaaPixelShader are unused and can be removed:
        //       fxaaConsolePosPos
        //       fxaaConsoleRcpFrameOpt
        //       fxaaConsoleRcpFrameOpt2
        //       fxaaConsole360RcpFrameOpt2
        //       fxaaConsoleEdgeSharpness
        //       fxaaConsoleEdgeThreshold
        //       fxaaConsoleEdgeThresholdMi
        //       fxaaConsole360ConstDir

        //
        // Choose the quality preset.
        // This needs to be compiled into the shader as it effects code.
        // Best option to include multiple presets is to
        // in each shader define the preset, then include this file.
        //
        // OPTIONS
        // -----------------------------------------------------------------------
        // 10 to 15 - default medium dither (10=fastest, 15=highest quality)
        // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
        // 39       - no dither, very expensive
        //
        // NOTES
        // -----------------------------------------------------------------------
        // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
        // 13 = about same speed as FXAA 3.9 and better than 12
        // 23 = closest to FXAA 3.9 visually and performance wise
        //  _ = the lowest digit is directly related to performance
        // _  = the highest digit is directly related to style
        //
        "#define FXAA_QUALITY_PRESET 25",

        "#if (FXAA_QUALITY_PRESET == 10)",
            "#define FXAA_QUALITY_PS 3",
            "#define FXAA_QUALITY_P0 1.5",
            "#define FXAA_QUALITY_P1 3.0",
            "#define FXAA_QUALITY_P2 12.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 11)",
            "#define FXAA_QUALITY_PS 4",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 3.0",
            "#define FXAA_QUALITY_P3 12.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 12)",
            "#define FXAA_QUALITY_PS 5",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 4.0",
            "#define FXAA_QUALITY_P4 12.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 13)",
            "#define FXAA_QUALITY_PS 6",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 4.0",
            "#define FXAA_QUALITY_P5 12.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 14)",
            "#define FXAA_QUALITY_PS 7",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 4.0",
            "#define FXAA_QUALITY_P6 12.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 15)",
            "#define FXAA_QUALITY_PS 8",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 2.0",
            "#define FXAA_QUALITY_P6 4.0",
            "#define FXAA_QUALITY_P7 12.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 20)",
            "#define FXAA_QUALITY_PS 3",
            "#define FXAA_QUALITY_P0 1.5",
            "#define FXAA_QUALITY_P1 2.0",
            "#define FXAA_QUALITY_P2 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 21)",
            "#define FXAA_QUALITY_PS 4",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 22)",
            "#define FXAA_QUALITY_PS 5",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 23)",
            "#define FXAA_QUALITY_PS 6",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 24)",
            "#define FXAA_QUALITY_PS 7",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 3.0",
            "#define FXAA_QUALITY_P6 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 25)",
            "#define FXAA_QUALITY_PS 8",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 2.0",
            "#define FXAA_QUALITY_P6 4.0",
            "#define FXAA_QUALITY_P7 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 26)",
            "#define FXAA_QUALITY_PS 9",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 2.0",
            "#define FXAA_QUALITY_P6 2.0",
            "#define FXAA_QUALITY_P7 4.0",
            "#define FXAA_QUALITY_P8 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 27)",
            "#define FXAA_QUALITY_PS 10",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 2.0",
            "#define FXAA_QUALITY_P6 2.0",
            "#define FXAA_QUALITY_P7 2.0",
            "#define FXAA_QUALITY_P8 4.0",
            "#define FXAA_QUALITY_P9 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 28)",
            "#define FXAA_QUALITY_PS 11",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 2.0",
            "#define FXAA_QUALITY_P6 2.0",
            "#define FXAA_QUALITY_P7 2.0",
            "#define FXAA_QUALITY_P8 2.0",
            "#define FXAA_QUALITY_P9 4.0",
            "#define FXAA_QUALITY_P10 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 29)",
            "#define FXAA_QUALITY_PS 12",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.5",
            "#define FXAA_QUALITY_P2 2.0",
            "#define FXAA_QUALITY_P3 2.0",
            "#define FXAA_QUALITY_P4 2.0",
            "#define FXAA_QUALITY_P5 2.0",
            "#define FXAA_QUALITY_P6 2.0",
            "#define FXAA_QUALITY_P7 2.0",
            "#define FXAA_QUALITY_P8 2.0",
            "#define FXAA_QUALITY_P9 2.0",
            "#define FXAA_QUALITY_P10 4.0",
            "#define FXAA_QUALITY_P11 8.0",
        "#endif",
        "#if (FXAA_QUALITY_PRESET == 39)",
            "#define FXAA_QUALITY_PS 12",
            "#define FXAA_QUALITY_P0 1.0",
            "#define FXAA_QUALITY_P1 1.0",
            "#define FXAA_QUALITY_P2 1.0",
            "#define FXAA_QUALITY_P3 1.0",
            "#define FXAA_QUALITY_P4 1.0",
            "#define FXAA_QUALITY_P5 1.5",
            "#define FXAA_QUALITY_P6 2.0",
            "#define FXAA_QUALITY_P7 2.0",
            "#define FXAA_QUALITY_P8 2.0",
            "#define FXAA_QUALITY_P9 2.0",
            "#define FXAA_QUALITY_P10 4.0",
            "#define FXAA_QUALITY_P11 8.0",
        "#endif",

        "#define FxaaBool bool",
        "#define FxaaFloat float",
        "#define FxaaFloat2 vec2",
        "#define FxaaFloat3 vec3",
        "#define FxaaFloat4 vec4",
        "#define FxaaHalf float",
        "#define FxaaHalf2 vec2",
        "#define FxaaHalf3 vec3",
        "#define FxaaHalf4 vec4",
        "#define FxaaInt2 vec2",
        "#define FxaaTex sampler2D",

        "#define FxaaSat(x) clamp(x, 0.0, 1.0)",
        "#define FxaaTexTop(t, p) texture2D(t, p)",
        "#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r))",

        "FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }",

        "FxaaFloat4 FxaaPixelShader(",
            //
            // Use noperspective interpolation here (turn off perspective interpolation).
            // {xy} = center of pixel
            "FxaaFloat2 pos,",
            //
            // Input color texture.
            // {rgb_} = color in linear or perceptual color space
            // if (FXAA_GREEN_AS_LUMA == 0)
            //     {___a} = luma in perceptual color space (not linear)
            "FxaaTex tex,",
            //
            // Only used on FXAA Quality.
            // This must be from a constant/uniform.
            // {x_} = 1.0/screenWidthInPixels
            // {_y} = 1.0/screenHeightInPixels
            "FxaaFloat2 fxaaQualityRcpFrame,",
            //
            // Only used on FXAA Quality.
            // This used to be the FXAA_QUALITY_SUBPIX define.
            // It is here now to allow easier tuning.
            // Choose the amount of sub-pixel aliasing removal.
            // This can effect sharpness.
            //   1.00 - upper limit (softer)
            //   0.75 - default amount of filtering
            //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
            //   0.25 - almost off
            //   0.00 - completely off
            "FxaaFloat fxaaQualitySubpix,",
            //
            // Only used on FXAA Quality.
            // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
            // It is here now to allow easier tuning.
            // The minimum amount of local contrast required to apply algorithm.
            //   0.333 - too little (faster)
            //   0.250 - low quality
            //   0.166 - default
            //   0.125 - high quality
            //   0.063 - overkill (slower)
            "FxaaFloat fxaaQualityEdgeThreshold,",
            //
            // Only used on FXAA Quality.
            // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
            // It is here now to allow easier tuning.
            // Trims the algorithm from processing darks.
            //   0.0833 - upper limit (default, the start of visible unfiltered edges)
            //   0.0625 - high quality (faster)
            //   0.0312 - visible limit (slower)
            // Special notes when using FXAA_GREEN_AS_LUMA,
            //   Likely want to set this to zero.
            //   As colors that are mostly not-green
            //   will appear very dark in the green channel!
            //   Tune by looking at mostly non-green content,
            //   then start at zero and increase until aliasing is a problem.
            "FxaaFloat fxaaQualityEdgeThresholdMin",
        ") {",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat2 posM;",
            "posM.x = pos.x;",
            "posM.y = pos.y;",
            "FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
            "#define lumaM rgbyM.y",
            "FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));",
            "FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));",
            "FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));",
            "FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat maxSM = max(lumaS, lumaM);",
            "FxaaFloat minSM = min(lumaS, lumaM);",
            "FxaaFloat maxESM = max(lumaE, maxSM);",
            "FxaaFloat minESM = min(lumaE, minSM);",
            "FxaaFloat maxWN = max(lumaN, lumaW);",
            "FxaaFloat minWN = min(lumaN, lumaW);",
            "FxaaFloat rangeMax = max(maxWN, maxESM);",
            "FxaaFloat rangeMin = min(minWN, minESM);",
            "FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;",
            "FxaaFloat range = rangeMax - rangeMin;",
            "FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);",
            "FxaaBool earlyExit = range < rangeMaxClamped;",
        /*--------------------------------------------------------------------------*/
            "if(earlyExit)",
                "return rgbyM;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));",
            "FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));",
            "FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));",
            "FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat lumaNS = lumaN + lumaS;",
            "FxaaFloat lumaWE = lumaW + lumaE;",
            "FxaaFloat subpixRcpRange = 1.0/range;",
            "FxaaFloat subpixNSWE = lumaNS + lumaWE;",
            "FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;",
            "FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat lumaNESE = lumaNE + lumaSE;",
            "FxaaFloat lumaNWNE = lumaNW + lumaNE;",
            "FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;",
            "FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat lumaNWSW = lumaNW + lumaSW;",
            "FxaaFloat lumaSWSE = lumaSW + lumaSE;",
            "FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);",
            "FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);",
            "FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;",
            "FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;",
            "FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;",
            "FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;",
            "FxaaFloat lengthSign = fxaaQualityRcpFrame.x;",
            "FxaaBool horzSpan = edgeHorz >= edgeVert;",
            "FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;",
        /*--------------------------------------------------------------------------*/
            "if(!horzSpan) lumaN = lumaW;",
            "if(!horzSpan) lumaS = lumaE;",
            "if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;",
            "FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat gradientN = lumaN - lumaM;",
            "FxaaFloat gradientS = lumaS - lumaM;",
            "FxaaFloat lumaNN = lumaN + lumaM;",
            "FxaaFloat lumaSS = lumaS + lumaM;",
            "FxaaBool pairN = abs(gradientN) >= abs(gradientS);",
            "FxaaFloat gradient = max(abs(gradientN), abs(gradientS));",
            "if(pairN) lengthSign = -lengthSign;",
            "FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat2 posB;",
            "posB.x = posM.x;",
            "posB.y = posM.y;",
            "FxaaFloat2 offNP;",
            "offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;",
            "offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;",
            "if(!horzSpan) posB.x += lengthSign * 0.5;",
            "if( horzSpan) posB.y += lengthSign * 0.5;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat2 posN;",
            "posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;",
            "posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;",
            "FxaaFloat2 posP;",
            "posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;",
            "posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;",
            "FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;",
            "FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));",
            "FxaaFloat subpixE = subpixC * subpixC;",
            "FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));",
        /*--------------------------------------------------------------------------*/
            "if(!pairN) lumaNN = lumaSS;",
            "FxaaFloat gradientScaled = gradient * 1.0/4.0;",
            "FxaaFloat lumaMM = lumaM - lumaNN * 0.5;",
            "FxaaFloat subpixF = subpixD * subpixE;",
            "FxaaBool lumaMLTZero = lumaMM < 0.0;",
        /*--------------------------------------------------------------------------*/
            "lumaEndN -= lumaNN * 0.5;",
            "lumaEndP -= lumaNN * 0.5;",
            "FxaaBool doneN = abs(lumaEndN) >= gradientScaled;",
            "FxaaBool doneP = abs(lumaEndP) >= gradientScaled;",
            "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;",
            "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;",
            "FxaaBool doneNP = (!doneN) || (!doneP);",
            "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;",
            "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;",
        /*--------------------------------------------------------------------------*/
            "if(doneNP) {",
                "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                "doneN = abs(lumaEndN) >= gradientScaled;",
                "doneP = abs(lumaEndP) >= gradientScaled;",
                "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;",
                "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;",
                "doneNP = (!doneN) || (!doneP);",
                "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;",
                "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;",
        /*--------------------------------------------------------------------------*/
                "#if (FXAA_QUALITY_PS > 3)",
                "if(doneNP) {",
                    "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                    "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                    "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                    "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                    "doneN = abs(lumaEndN) >= gradientScaled;",
                    "doneP = abs(lumaEndP) >= gradientScaled;",
                    "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;",
                    "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;",
                    "doneNP = (!doneN) || (!doneP);",
                    "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;",
                    "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;",
        /*--------------------------------------------------------------------------*/
                    "#if (FXAA_QUALITY_PS > 4)",
                    "if(doneNP) {",
                        "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                        "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                        "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                        "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                        "doneN = abs(lumaEndN) >= gradientScaled;",
                        "doneP = abs(lumaEndP) >= gradientScaled;",
                        "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;",
                        "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;",
                        "doneNP = (!doneN) || (!doneP);",
                        "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;",
                        "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;",
        /*--------------------------------------------------------------------------*/
                        "#if (FXAA_QUALITY_PS > 5)",
                        "if(doneNP) {",
                            "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                            "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                            "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                            "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                            "doneN = abs(lumaEndN) >= gradientScaled;",
                            "doneP = abs(lumaEndP) >= gradientScaled;",
                            "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;",
                            "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;",
                            "doneNP = (!doneN) || (!doneP);",
                            "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;",
                            "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;",
        /*--------------------------------------------------------------------------*/
                            "#if (FXAA_QUALITY_PS > 6)",
                            "if(doneNP) {",
                                "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                                "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                                "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                                "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                                "doneN = abs(lumaEndN) >= gradientScaled;",
                                "doneP = abs(lumaEndP) >= gradientScaled;",
                                "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;",
                                "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;",
                                "doneNP = (!doneN) || (!doneP);",
                                "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;",
                                "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;",
        /*--------------------------------------------------------------------------*/
                                "#if (FXAA_QUALITY_PS > 7)",
                                "if(doneNP) {",
                                    "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                                    "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                                    "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                                    "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                                    "doneN = abs(lumaEndN) >= gradientScaled;",
                                    "doneP = abs(lumaEndP) >= gradientScaled;",
                                    "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;",
                                    "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;",
                                    "doneNP = (!doneN) || (!doneP);",
                                    "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;",
                                    "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;",
        /*--------------------------------------------------------------------------*/
            "#if (FXAA_QUALITY_PS > 8)",
            "if(doneNP) {",
                "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                "doneN = abs(lumaEndN) >= gradientScaled;",
                "doneP = abs(lumaEndP) >= gradientScaled;",
                "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;",
                "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;",
                "doneNP = (!doneN) || (!doneP);",
                "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;",
                "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;",
        /*--------------------------------------------------------------------------*/
                "#if (FXAA_QUALITY_PS > 9)",
                "if(doneNP) {",
                    "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                    "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                    "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                    "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                    "doneN = abs(lumaEndN) >= gradientScaled;",
                    "doneP = abs(lumaEndP) >= gradientScaled;",
                    "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;",
                    "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;",
                    "doneNP = (!doneN) || (!doneP);",
                    "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;",
                    "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;",
        /*--------------------------------------------------------------------------*/
                    "#if (FXAA_QUALITY_PS > 10)",
                    "if(doneNP) {",
                        "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                        "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                        "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                        "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                        "doneN = abs(lumaEndN) >= gradientScaled;",
                        "doneP = abs(lumaEndP) >= gradientScaled;",
                        "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;",
                        "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;",
                        "doneNP = (!doneN) || (!doneP);",
                        "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;",
                        "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;",
        /*--------------------------------------------------------------------------*/
                        "#if (FXAA_QUALITY_PS > 11)",
                        "if(doneNP) {",
                            "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                            "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                            "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                            "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                            "doneN = abs(lumaEndN) >= gradientScaled;",
                            "doneP = abs(lumaEndP) >= gradientScaled;",
                            "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;",
                            "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;",
                            "doneNP = (!doneN) || (!doneP);",
                            "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;",
                            "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;",
        /*--------------------------------------------------------------------------*/
                            "#if (FXAA_QUALITY_PS > 12)",
                            "if(doneNP) {",
                                "if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
                                "if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
                                "if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
                                "if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
                                "doneN = abs(lumaEndN) >= gradientScaled;",
                                "doneP = abs(lumaEndP) >= gradientScaled;",
                                "if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;",
                                "if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;",
                                "doneNP = (!doneN) || (!doneP);",
                                "if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;",
                                "if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;",
        /*--------------------------------------------------------------------------*/
                            "}",
                            "#endif",
        /*--------------------------------------------------------------------------*/
                        "}",
                        "#endif",
        /*--------------------------------------------------------------------------*/
                    "}",
                    "#endif",
        /*--------------------------------------------------------------------------*/
                "}",
                "#endif",
        /*--------------------------------------------------------------------------*/
            "}",
            "#endif",
        /*--------------------------------------------------------------------------*/
                                "}",
                                "#endif",
        /*--------------------------------------------------------------------------*/
                            "}",
                            "#endif",
        /*--------------------------------------------------------------------------*/
                        "}",
                        "#endif",
        /*--------------------------------------------------------------------------*/
                    "}",
                    "#endif",
        /*--------------------------------------------------------------------------*/
                "}",
                "#endif",
        /*--------------------------------------------------------------------------*/
            "}",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat dstN = posM.x - posN.x;",
            "FxaaFloat dstP = posP.x - posM.x;",
            "if(!horzSpan) dstN = posM.y - posN.y;",
            "if(!horzSpan) dstP = posP.y - posM.y;",
        /*--------------------------------------------------------------------------*/
            "FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;",
            "FxaaFloat spanLength = (dstP + dstN);",
            "FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;",
            "FxaaFloat spanLengthRcp = 1.0/spanLength;",
        /*--------------------------------------------------------------------------*/
            "FxaaBool directionN = dstN < dstP;",
            "FxaaFloat dst = min(dstN, dstP);",
            "FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;",
            "FxaaFloat subpixG = subpixF * subpixF;",
            "FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;",
            "FxaaFloat subpixH = subpixG * fxaaQualitySubpix;",
        /*--------------------------------------------------------------------------*/
            "FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;",
            "FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);",
            "if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;",
            "if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;",
            "return FxaaTexTop(tex, posM);",
        "}",

        "void main() {",
            "gl_FragColor = FxaaPixelShader(",
                    "vUV,",
                    "uTexture,",
                    "uTexelOffset,",
                    "fxaaQualitySubpix,",
                    "fxaaQualityEdgeThreshold,",
                    "fxaaQualityEdgeThresholdMin);",
        "}",
    ].join("\n");

    var fxaaConfig = {
        type: "fxaa",
        id: "fxaa",
        uniforms: {
            uTexelOffset: new Float32Array([1 / window.innerWidth, 1 / window.innerHeight]),
        },
        textures: {
            uTexture: {
                framebuffer:  "---SET_ME---",
                target: "color"
            }
        },
        framebuffer:  "---SET_ME---"
    };
    
    var fxaa = Human.renderer.postprocess.effects.fxaa = {
        scene: null
    };

    fxaa.init = function(scene) {
        this.scene = scene;
        scene.createPostProcessType("fxaa", FXAA_SOURCE);
    };

    fxaa.addStage = function(ctx) {
        var ioFramebuffers = ctx.getIOFramebuffers("final");

        fxaaConfig.uniforms.uTexelOffset[0] = 1 / Human.renderer.canvas.width;
        fxaaConfig.uniforms.uTexelOffset[1] = 1 / Human.renderer.canvas.height;
        fxaaConfig.textures.uTexture.framebuffer = ioFramebuffers.read;
        fxaaConfig.framebuffer = ioFramebuffers.write;
        
        ctx.finalPipeline.push(fxaaConfig);
    };

    fxaa.configure = function() {
    };

    fxaa.updateCanvas = function() {
        fxaaConfig.uniforms.uTexelOffset[0] = 1 / Human.renderer.canvas.width;
        fxaaConfig.uniforms.uTexelOffset[1] = 1 / Human.renderer.canvas.height;

        var fxaaStage = this.scene.getPostProcessStage("fxaa");
        if (fxaaStage) {
            fxaaStage.setUniform("uTexelOffset", fxaaConfig.uniforms.uTexelOffset);
        }
    };

})();
;(function() {
    "use strict";

    var DEFAULT_RADIUS = 0.9;
    var DEFAULT_INTENSITY = 50;
    var DEFAULT_BIAS = 0.1;
    var DEFAULT_SCALE = 0.9;
    var DEFAULT_CUTOFF = 0.3;

    var SAO_SOURCE =  [
       "#extension GL_OES_standard_derivatives : require",
       "precision highp float;",
       "#define PI2 6.283185",
       "#define TAU (PI2 * 2.0)",
       "#define NUM_SAMPLES 16.0",
       "#define SAMPLE_WEIGHT (1.0 / NUM_SAMPLES)",
       "#define EPSILON 0.0001",
       "varying vec2 vUV;",
       "uniform float uSampleRadius;",
       "uniform float uIntensity;",
       "uniform float uContrast;",
       "uniform float uBias;",
       "uniform vec2 uTexelOffset;",
       "uniform vec3 uDepthParams;",
       "uniform vec3 uXYParams;",
       "uniform sampler2D uDepthBuffer;",
       "vec3 getPosition(float fragDepth, vec2 uv) {",
           "vec2 clipCoord = uv * 2.0 - 1.0;",
           "float zView = uDepthParams.x / (fragDepth * uDepthParams.y + uDepthParams.z);",
           "return vec3(",
                "clipCoord.x * zView * uXYParams.x * uXYParams.y,",
                "clipCoord.y * zView * uXYParams.y,",
                "zView",
           ");",
       "}",
       "vec2 packDepth(float viewZ) {",
       "    float d = viewZ / -uDepthParams.z;",
           "float temp = floor(d * 256.0);",
           "return vec2(",
           "    temp / 256.0,",
           "    d * 256.0 - temp",
           ");",
       "}",
       "void main() {",
           "float fragDepth = texture2D(uDepthBuffer, vUV).x;",
           "if (fragDepth == 1.0) { discard; }",
           "vec3 position = getPosition(fragDepth, vUV);",
           "vec3 normal = normalize(cross(dFdx(position), dFdy(position)));",
           "float ssRadius = min((uXYParams.z * uSampleRadius) / (position.z + EPSILON), 32.0);",
           "if (ssRadius < 4.0) { discard; }",
           "float occlusion = 0.0;",
           "for (int i = 0; i < int(NUM_SAMPLES); ++i) {",
           "   float a = (float(i) + 0.5) * SAMPLE_WEIGHT;",
           "   float h = ssRadius * a;",
           "   float theta = a * TAU;",
           "   vec2 u = vec2(cos(theta), sin(theta));",
           "   vec2 uv = vUV + h * u * uTexelOffset;",
           "   fragDepth = texture2D(uDepthBuffer, uv).x;",
           "   vec3 samplePosition = getPosition(fragDepth, uv);",
           "   vec3 dir = samplePosition - position;",
           "   float len2 = dot(dir, dir);",
           "   float f = max(0.0, uSampleRadius * uSampleRadius - len2);",
           "   occlusion += f * f * f * max(0.0, dot(dir, normal) - uBias) / (len2 + EPSILON);",
           "}",
           "occlusion = max(0.0, occlusion * 2.0 * uIntensity * SAMPLE_WEIGHT);",
           "vec2 odd = mod(gl_FragCoord.xy, 2.0);",
           "if (abs(dFdx(position.z)) < 0.02) {",
           "    occlusion -= dFdx(occlusion) * (odd.x - 0.5);",
           "}",
           "if (abs(dFdy(position.z)) < 0.02) {",
           "    occlusion -= dFdy(occlusion) * (odd.y - 0.5);",
           "}",
           "gl_FragColor.r = occlusion;",
           "gl_FragColor.gb = packDepth(position.z);",
       "}"
    ].join("\n");

    var SAO_BLUR_SOURCE = [
        "precision highp float;",
        "varying vec2 vUV;",
        "uniform sampler2D uColorBuffer;",
        "uniform vec2 uTexelOffset;",
        "float unpackDepth(vec2 p) {",
        "    return p.x + p.y / 256.0;",
        "}",
        "void main() {",
            "float gaussian[5];",
            "gaussian[0] = 0.153170;",
            "gaussian[1] = 0.144893;",
            "gaussian[2] = 0.122649;",
            "gaussian[3] = 0.092902;",
            "gaussian[4] = 0.062970;",
            "vec3 centerValue = texture2D(uColorBuffer, vUV).rgb;",
            "float totalWeight = gaussian[0];",
            "float sum = centerValue.r * totalWeight;",
            "float centerDepth = unpackDepth(centerValue.gb);",
            "for (int r = 1; r <= 4; ++r) {",
            "    vec2 uv = vUV + uTexelOffset * float(r) * 2.0;",
            "    vec3 sampleValue = texture2D(uColorBuffer, uv).rgb;",
            "    float sampleDepth = unpackDepth(sampleValue.gb);",
            "    float weight = gaussian[r];",
            "    weight *= max(0.0, 1.0 - 10.0 * abs(sampleDepth - centerDepth));",
            "    sum += sampleValue.r * weight;",
            "    totalWeight += weight;",
            "}",
            "for (int r = 1; r <= 4; ++r) {",
            "    vec2 uv = vUV + uTexelOffset * -float(r) * 2.0;",
            "    vec3 sampleValue = texture2D(uColorBuffer, uv).rgb;",
            "    float sampleDepth = unpackDepth(sampleValue.gb);",
            "    float weight = gaussian[r];",
            "    weight *= max(0.0, 1.0 - 10.0 * abs(sampleDepth - centerDepth));",
            "    sum += sampleValue.r * weight;",
            "    totalWeight += weight;",
            "}",
            "gl_FragColor.r = sum / (totalWeight + 0.0001);",
        "}"
    ].join("\n");

    var SAO_BLEND_SOURCE = [
        "precision highp float;",
        "varying vec2 vUV;",
        "uniform sampler2D uColorBuffer;",
        "uniform sampler2D uOcclusionBuffer;",
        "uniform float uOcclusionScale;",
        "uniform float uOcclusionCutoff;",
        "void main() {",
            "vec4 color = texture2D(uColorBuffer, vUV);",
            "float ambient = 1.0 - smoothstep(uOcclusionCutoff, 1.0, texture2D(uOcclusionBuffer, vUV).r) * uOcclusionScale;",
            "gl_FragColor = vec4(color.rgb * ambient, color.a);",
        "}"
    ].join("\n");

    var saoConfig = {
        type: "sao",
        id: "sao",
        uniforms: {
            uSampleRadius: 0.4,
            uIntensity: 8,
            uBias: 0.001,
            uTexelOffset: new Float32Array([1 / window.innerWidth, 1 / window.innerHeight]),
            uXYParams: new Float32Array(3),
            uDepthParams: new Float32Array(3)
        },
        textures: {
            uDepthBuffer: {
                framebuffer: "__MAIN",
                target: "depth"
            }
        },
        framebuffer: "__BDS_SAO"
    };

    var blurHConfig = {
        type: "saoblur",
        id: "saohblur",
        uniforms: {
            uTexelOffset: new Float32Array([1 / window.innerWidth, 0]),
        },
        textures: {
            uColorBuffer: {
                framebuffer: "__BDS_SAO",
                target: "color",
            }
        },
        framebuffer: "---SET_ME---"
    };

    var blurVConfig = {
        type: "saoblur",
        id: "saovblur",
        uniforms: {
            uTexelOffset: new Float32Array([0, 1 / window.innerHeight]),
        },
        textures: {
            uColorBuffer: {
                framebuffer: "---SET_ME---",
                target: "color",
            }
        },
        framebuffer: "__BDS_SAO"
    };

    var blendConfig = {
        type: "saoblend",
        id: "saoblend",
        uniforms: {
            uOcclusionScale: DEFAULT_SCALE,
            uOcclusionCutoff: DEFAULT_CUTOFF
        },
        textures: {
            uColorBuffer: {
                framebuffer: "---SET_ME---",
                target: "color",
            },
            uOcclusionBuffer: {  
                framebuffer: "__BDS_SAO",
                target: "color"
            }
        },
        framebuffer: "--SET_ME---"
    };

    var sao = Human.renderer.postprocess.effects.sao = {
        scene: null,
        supported: SceneJS.WEBGL_INFO.depthTexturesSupported,
        fbInitialized: false,
        sampleRadius: DEFAULT_RADIUS,
        intensity: DEFAULT_INTENSITY,
        bias: DEFAULT_BIAS,
        scale: DEFAULT_SCALE
    };

    sao.init = function(scene) {
        this.scene = scene;

        if (!this.supported) {
            return;
        }

        scene.createPostProcessType("sao", SAO_SOURCE);
        scene.createPostProcessType("saoblur", SAO_BLUR_SOURCE);
        scene.createPostProcessType("saoblend", SAO_BLEND_SOURCE);
    };

    sao.addStage = function(ctx) {
        if (!this.supported) {
            return;
        }

        if (!this.fbInitialized) {
            initializeFramebuffer(this.scene);
        }

        var projection = this.scene.getProjection();
        var aspect = projection.aspect;
        var fov = projection.fov * Math.PI / 180;
        var near = projection.near;
        var far = projection.far;
        var multiplier = -Math.tan(fov * 0.5);
        var scaleFactor = -Human.renderer.canvas.height / (2.0 * Math.tan(fov * 0.5));

        var width = Human.renderer.canvas.width;
        var height = Human.renderer.canvas.height;

        var ioFramebuffers = ctx.getIOFramebuffers("opaque");

        var colorIn = ioFramebuffers.read;
        var colorOut = ioFramebuffers.write;

        // In __MAIN depth, out: __BDS_SAO
        saoConfig.uniforms.uSampleRadius = this.sampleRadius;
        saoConfig.uniforms.uIntensity = this.intensity;
        saoConfig.uniforms.uBias = this.bias;
        saoConfig.uniforms.uTexelOffset[0] = 1 / width;
        saoConfig.uniforms.uTexelOffset[1] = 1 / height;
        saoConfig.uniforms.uXYParams[0] = aspect;
        saoConfig.uniforms.uXYParams[1] = multiplier;
        saoConfig.uniforms.uXYParams[2] = scaleFactor;
        saoConfig.uniforms.uDepthParams[0] = -near * far;
        saoConfig.uniforms.uDepthParams[1] = near - far;
        saoConfig.uniforms.uDepthParams[2] = far;

        // In __BDS_SAO, out: colorOut
        blurHConfig.uniforms.uTexelOffset[0] = 1 / width;
        blurHConfig.uniforms.uTexelOffset[1] = 0;
        blurHConfig.framebuffer = colorOut;

        // In colorOut, out: __BDS_SAO
        blurVConfig.uniforms.uTexelOffset[0] = 0;
        blurVConfig.uniforms.uTexelOffset[1] = 1 / height;
        blurVConfig.textures.uColorBuffer.framebuffer = colorOut;

        // In colorIn, __BDS_SAO, out: colorOut
        blendConfig.uniforms.uOcclusionScale = this.scale;
        blendConfig.textures.uColorBuffer.framebuffer = colorIn;
        blendConfig.framebuffer = colorOut;

        ctx.opaquePipeline.push(saoConfig);
        ctx.opaquePipeline.push(blurHConfig);
        ctx.opaquePipeline.push(blurVConfig);
        ctx.opaquePipeline.push(blendConfig);
    };

    sao.setSampleRadius = function(r) {
        this.sampleRadius = saoConfig.uniforms.uSampleRadius = r;
        var saoStage = this.scene.getPostProcessStage("sao");
        if (saoStage) {
            saoStage.setUniform("uSampleRadius", this.sampleRadius);
        }
    };

    sao.setIntensity = function(i) {
        this.intensity = saoConfig.uniforms.uIntensity = i;
        var saoStage = this.scene.getPostProcessStage("sao");
        if (saoStage) {
            saoStage.setUniform("uIntensity", this.intensity);
        }
    };

    sao.setBias = function(b) {
        this.bias = saoConfig.uniforms.uBias = b;
        var saoStage = this.scene.getPostProcessStage("sao");
        if (saoStage) {
            saoStage.setUniform("uBias", this.bias);
        }
    };

    sao.setOcclusionScale = function(s) {
        this.scale = blendConfig.uniforms.uOcclusionScale = s;
        var blendStage = this.scene.getPostProcessStage("saoblend");
        if (blendStage) {
            blendStage.setUniform("uOcclusionScale", this.scale);
        }
    };

    sao.setOcclusionCutoff = function(c) {
        this.cutoff = blendConfig.uniforms.uOcclusionCutoff = c;
        var blendStage = this.scene.getPostProcessStage("saoblend");
        if (blendStage) {
            blendStage.setUniform("uOcclusionCutoff", this.cutoff);
        }
    };

    sao.configure = function(cfg) {
        cfg = cfg || {};
        cfg.sampleRadius = cfg.sampleRadius === undefined ? DEFAULT_RADIUS : cfg.sampleRadius;
        cfg.intensity = cfg.intensity === undefined ? DEFAULT_INTENSITY : cfg.intensity;
        cfg.bias = cfg.bias === undefined ? DEFAULT_BIAS : cfg.bias;
        cfg.scale = cfg.scale === undefined ? DEFAULT_SCALE : cfg.scale;
        cfg.cutoff = cfg.cutoff === undefined ? DEFAULT_CUTOFF : cfg.cutoff;

        this.setSampleRadius(cfg.sampleRadius);
        this.setIntensity(cfg.intensity);
        this.setBias(cfg.bias);
        this.setOcclusionScale(cfg.scale);
        this.setOcclusionCutoff(cfg.cutoff);
    };

    sao.updateProjection = function() {
        var projection = this.scene.getProjection();
        var aspect = projection.aspect;
        var fov = projection.fov * Math.PI / 180;
        var near = projection.near;
        var far = projection.far;
        var multiplier = -Math.tan(fov * 0.5);
        var scaleFactor = -Human.renderer.canvas.height / (2.0 * Math.tan(fov * 0.5));

        saoConfig.uniforms.uXYParams[0] = aspect;
        saoConfig.uniforms.uXYParams[1] = multiplier;
        saoConfig.uniforms.uXYParams[2] = scaleFactor;
        saoConfig.uniforms.uDepthParams[0] = -near * far;
        saoConfig.uniforms.uDepthParams[1] = near - far;
        saoConfig.uniforms.uDepthParams[2] = far;


        var saoStage = this.scene.getPostProcessStage("sao");
        
        if (saoStage) {
            saoStage.setUniform("uXYParams", saoConfig.uniforms.uXYParams);            
            saoStage.setUniform("uDepthParams", saoConfig.uniforms.uDepthParams);            
        }
    };

    sao.updateCanvas = function() {
        var width = Human.renderer.canvas.width;
        var height = Human.renderer.canvas.height;

        var projection = this.scene.getProjection();
        var aspect = projection.aspect;
        var fov = projection.fov * Math.PI / 180;
        var multiplier = -Math.tan(fov * 0.5);
        var scaleFactor = -Human.renderer.canvas.height / (2.0 * Math.tan(fov * 0.5));

        saoConfig.uniforms.uTexelOffset[0] = 1 / width;
        saoConfig.uniforms.uTexelOffset[1] = 1 / height;
        saoConfig.uniforms.uXYParams[0] = aspect;
        saoConfig.uniforms.uXYParams[1] = multiplier;
        saoConfig.uniforms.uXYParams[2] = scaleFactor;

        blurHConfig.uniforms.uTexelOffset[0] = 1 / width;

        blurVConfig.uniforms.uTexelOffset[1] = 1 / height;

        
        var saoStage = this.scene.getPostProcessStage("sao");
        var blurHStage = this.scene.getPostProcessStage("saohblur");
        var blurVStage = this.scene.getPostProcessStage("saovblur");
        if (saoStage && blurHStage && blurVStage) {
            saoStage.setUniform("uXYParams", saoConfig.uniforms.uXYParams);            
            saoStage.setUniform("uTexelOffset", saoConfig.uniforms.uTexelOffset);
            blurHStage.setUniform("uTexelOffset", blurHConfig.uniforms.uTexelOffset);
            blurVStage.setUniform("uTexelOffset",  blurVConfig.uniforms.uTexelOffset);
        }
    };

    function initializeFramebuffer(scene) {
        scene.createFramebuffer("__BDS_SAO", {
            depthAttachment: false
        });
    }

})();
;(function () {
  "use strict";

  var blurAmount;
  var opacity = 1.0;
  var translation = [0, 0, 0];
  var scale = 0;
  var shadowNode;
  var shadowTransform;
  var shadowTexture;
  var blurImages = {};


  // There are distinct images for different blur amounts
  // Blur Amount "0" corresponds to image src/assets/images/blur/blur_0.png (in Human Studio Next)
  // Blur Amount ".1" corresponds to image src/assets/images/blur/blur_1.png 
  // etc..
  var imageLookup = {
    0: "0",
    0.1: "1",
    0.2: "2",
    0.3: "3",
    0.4: "4",
    0.5: "5",
    0.6: "6",
    0.7: "7",
    0.8: "8",
    0.9: "9",
    1: "10",
  };

  function getBlurImageSrc(blurAmount) {
    var blurImageNum = imageLookup[blurAmount.toString()];
    var root = window.localBaseDirectory || "/";
    return root + "assets/images/blur/blur_" + blurImageNum + ".png";
  }

  function loadBlurImage(blurAmount) {
    var src = getBlurImageSrc(blurAmount);

    // We want to reduce the overhead of loading blur images over the network as much as possible.
    // Blur images are cached so they only need to be requested once.
    if (blurImages[src]) {
      return blurImages[src]
    }

    var image = new Image();
    image.src = src;
    blurImages[src] = image;
    return image;
  }


  function calcTransform(translation, scale) {
    // The model space coordinates for the quad primitive are along Y and X. 
    // Since the plane needs to lay flat as if it was the ground, in world space it needs to rotate 90 degrees about X.
    var angle = -90 * 0.0174532925; // radians
    var xform = mat4.create();
    var rot = mat4.create();
    mat4.fromXRotation(rot, angle);
    mat4.translate(xform, xform, translation);
    mat4.mul(xform, xform, rot);
    mat4.scale(xform, xform, [scale, scale, scale]);
    return xform;
  }

  var GroundShadow = (Human.renderer.groundShadow = {});

  GroundShadow.init = function () {
    if (shadowNode) {
      return;
    }

    var ShadowNodeDef = {
      type: "material",
      baseColor: {
        r: 0,
        g: 0,
        b: 0,
      },
      nodes: [
        {
          type: "texture",
          id: "shadowTexture",
          src: getBlurImageSrc(blurAmount || .5),
          applyTo: "alpha", // Apply to material "color" property (default)
          blendMode: "add",
          nodes: [
            {
              type: "xform",
              id: "shadowTransform",
              nodes: [
                // Box primitive implemented by plugin at
                // http://scenejs.org/api/latest/plugins/node/geometry/box.js
                {
                  id: "shadowPlane",
                  type: "geometry/plane",
                },
              ],
            },
          ],
        },
      ],
    };


    // find scene
    var scene = Human.renderer.getScene();

    // add node
    shadowNode = scene.addNode(ShadowNodeDef);

    // set transform
    shadowTransform = scene.getNode("shadowTransform");
    shadowTransform.setElements(calcTransform(translation, scale));

    // turn off backfaces
    var shadowPlane = scene.getNode("shadowPlane").nodes[0];
    shadowPlane.setBackfaces(false);

    // set texture opacity
    shadowTexture = scene.getNode("shadowTexture");
    shadowTexture.setBlendFactor(opacity);
  };

  GroundShadow.destroy = function () {
    if (shadowNode) {
      shadowNode.destroy();
      shadowNode = null;
      shadowTransform = null;
      shadowTexture = null;
    }
  };

  GroundShadow.update = function (cfg) {
    opacity = cfg.opacity;
    translation = cfg.translation;
    scale = cfg.scale;

    shadowTransform.setElements(calcTransform(translation, scale));
    shadowTexture.setBlendFactor(opacity);


    // When the blur amount changes, update the shadowTexture's blur image.
    if (blurAmount !== cfg.blurAmount) {
      var blurImage = loadBlurImage(cfg.blurAmount);

      
      // 'completed' is a property of HTMLImageElement that lets me know if the image has finished downloading.
      switch (blurImage.complete) {
        // The image may have already been loaded, and was retrieved from the cache.
        case true: {
          shadowTexture.setImage(blurImage);
          break;
        }

        // The image is still loading. Register a callback.
        case false: {
          blurImage.onload = function () {
            shadowTexture.setImage(blurImage);
          };
        }
      }
    }
    
    blurAmount = cfg.blurAmount;
  };
})();
;/**
 * @namespace The 3D scene, consisting of a hierarchy of {@link Human.scene.Object}s.
 */
(function () {
    "use strict";

    var KD_TREE_MAX_DEPTH = 10;
    var KD_TREE_MIN_OBJECTS = 1;
    var graphMatcher = new Human.utils.selection.GraphMatcher();
    var HumanScene = Human.scene = {};

    /** Array of root objects
     *
     * @type {Array}
     * @memberof Human.scene
     */
    HumanScene.rootObjects = [];

    /**
     * A map of objects by ID for each model that's currently loaded
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.modelObjects = {};

    /** All objects by ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objects = {};

    HumanScene.colorModPriorities = {
        __HIGHLIGHT: Number.POSITIVE_INFINITY
    };

    /** All objects by FMA ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objectsByFMAID = {};

    /**
     * For each distinct object meta tag, a map of object IDs to object instances.
     *
     * Eg.
     *
     * <pre>
     * {
     *     "head": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "skeleton": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "digestion": {
     *          "maleAdult_mandible": <object>
     *     }
     * }
     * </pre>
     * @type {{}}
     */
    HumanScene.objectsForTags = {};

    HumanScene._kdTree = null;
    HumanScene.kdTreeDirty = true;

    /**
     * @memberof Human.scene
     * @type {Array}
     */
    HumanScene.boundary = {
        xmin: Number.POSITIVE_INFINITY,
        ymin: Number.POSITIVE_INFINITY,
        zmin: Number.POSITIVE_INFINITY,
        xmax: Number.NEGATIVE_INFINITY,
        ymax: Number.NEGATIVE_INFINITY,
        zmax: Number.NEGATIVE_INFINITY
    };

    HumanScene.center = vec3.create();

    /**
     * Map of flags for the currently visible objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.enabledObjects = {};           // Enabled objects

    HumanScene._leavesCache = {};

    /**
     * Creates an object
     *
     * <p>Object is not yet enabled or selected</p>
     *<pre>
     * createObject({
     *
     *      // All objects, leaf and branch
     *
     *      moduleId:         "maleAdult",
     *      objectId:         "Left_posterior_auricular_artery_49626",
     *      displayName:    "Left Posterior Auricular Artery"
     *      parentObjectId: "Anatomy",
     *
     *      // Leaf objects only:
     *
     *      materialId:     "bloodsupply01_blinn43SG",
     *      geometryId:     "Left_posterior_auricular_artery_49626Shape",
     *      attachObjectId : "the-scene-root" | undefined,
     *      pickable:       true,
     *      layerName:      "Muscular_System"
     *
     *      flags: {
     *          transparency:       0.2,
     *          pickable:           false,
     *          renderPriority:     0 | null
     *      }
     * });
     * </pre>
     *
     * @memberof Human.scene
     * @private
     */

    HumanScene.createObject = function (params) {

        if (!params.objectId) {
            Human.log.error("Scene.createObject", "Param expected: objectId");
            return;
        }

        // Can't have duplicate object or fmaId's
        if (HumanScene.objects[params.objectId]) {
            Human.log.error("Scene.createObject", "Param: objectId already in use");
            return;
        }

        var parent = params.parentObjectId ? HumanScene.objects[params.parentObjectId] : null;
        var modelId = params.modelId;

        // Inherit metatags from parent object

        params.tags = params.tags || [];

        var tags = parent ? HumanScene._inheritTags(params.tags, parent) : params.tags;

        params.modelId = modelId;
        params.parent = parent;
        params.tags = tags;

        if (parent) {
            params.reflectedX = parent.reflectedX;
            params.reflectedY = parent.reflectedY;
            params.reflectedZ = parent.reflectedZ;
        }

        var object;
        if (params.group) {
            object = new Human.scene.Group(params);
        } else {
            object = new Human.scene.Object(params);
        }

        HumanScene.objects[params.objectId] = object;
        if (object.fmaId) {
            HumanScene.objectsByFMAID[object.fmaId] = object;
        }
        if (parent) {
            parent.objects.push(object);
        } else {
            HumanScene.rootObjects.push(object); // Register on roots map
        }

        (HumanScene.modelObjects[modelId] = HumanScene.modelObjects[modelId] || {})[params.objectId] = object;

        HumanScene._registerObjectForTags(object);

        // Publish object creation
        Human.events.fire("scene.objectCreated", {
            moduleId: params.moduleId,
            modelId: modelId,
            objectId: object.objectId,
            name: object.displayName,
            description: object.description,
            displayName: object.displayName,
            fmaId: object.fmaId,
            tags: object.tags,
            parentObjectId: parent ? parent.objectId : null
        });

        if (params.shown !== undefined) {
            object.show(params.shown);
            if (params.shown) {
                HumanScene.enabledObjects[params.objectId] = object;
            }
        }

        HumanScene._leavesCache = {};

        return object;
    };

    HumanScene._inheritTags = function(childTags, parentObject) {
        var tags = childTags || [];
        var parentTags = parentObject.tags;
        var tag;
        var parentTag;
        var inheritTags = [];
        if (tags) {
            for (var i = 0, leni = parentTags.length; i < leni; i++) {
                parentTag = parentTags[i];
                var inherit = true;
                for (var j = 0, lenj = tags.length; j < lenj; j++) {
                    tag = tags[j];
                    if (tag === parentTag) {
                        inherit = false;
                    }
                }
                if (inherit) {
                    inheritTags.push(parentTag);
                }
            }
            return tags.concat(inheritTags);
        } else {
            return tags;
        }
    };

    HumanScene._registerObjectForTags = function(object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (!tagObjects) {
                tagObjects = HumanScene.objectsForTags[tag] = {};
            }
            tagObjects[object.objectId] = object;
        }
    };

    HumanScene._deregisterObjectForTags = function (object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (tagObjects) {
                delete tagObjects[object.objectId];
            }
        }
    };

    /**
     * Enable or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setEnabledObjects = function (params) {

        var objects = params.objects || params.objectIds;

        var enabledObjectsUpdate = {};

        var initialValue = params.replace ? false : undefined;
        var needsAssets = params.fetchAssets ? [] : null;

        HumanScene.setEnabledSubtree(Human.scene.rootObjects, objects, initialValue, needsAssets, enabledObjectsUpdate);

        if (needsAssets) {
            Human.scene.graph.attachAssetSetsToSubtree(needsAssets);
        }

        if (!Human.utils.isEmpty(enabledObjectsUpdate)) {
            Human.events.fire("scene.objectsShown", {    // Post-notify
                enabledObjectsUpdate: enabledObjectsUpdate
            });
        }
    };

    HumanScene.setEnabledSubtree = function(objects, updates, parentValue, needsAssets, enabledUpdates) {
        for (var i = 0, len = objects.length; i < len; ++i) {
            var object = objects[i];
            var currentValue = updates[object.objectId] !== undefined ? updates[object.objectId] : parentValue;

            if (object.isLeaf()) {
                if (currentValue === true) {
                    if (!HumanScene.enabledObjects[object.objectId]) {
                        HumanScene.enabledObjects[object.objectId] = object;
                        enabledUpdates[object.objectId] = true;
                        object.show(true);

                        if (needsAssets && !object.isRenderable()) {
                            needsAssets.push(object);
                        }
                    }
                } else if (currentValue === false && HumanScene.enabledObjects[object.objectId]) {
                    delete HumanScene.enabledObjects[object.objectId];
                    enabledUpdates[object.objectId] = false;
                    object.show(false);
                }
            } else {
                HumanScene.setEnabledSubtree(object.objects, updates, currentValue, needsAssets, enabledUpdates);
            }
        }
    };

    HumanScene.setColorModPriority = function(id, priority) {
        this.colorModPriorities[id] = priority;

        var leafObjects = this.getLeaves();

        for (var i = 0, len = leafObjects.length; i < len; ++i) {
            Human.scene.objects[leafObjects[i]].colorModPrioritiesDirty();
        }
    };

    /**
     * Returns the IDs of leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getLeaves = function (objectId) {
        var objectIdList = HumanScene._leavesCache[ objectId ];
        if (!objectIdList) {
            objectIdList = [];
            if (objectId) {
               var object = HumanScene.objects[objectId];
               if (object) {
                   HumanScene._getLeaves([object], objectIdList);
               }
            } else {
                HumanScene._getLeaves(Human.scene.rootObjects, objectIdList);
            }

            HumanScene._leavesCache[ objectId ] = objectIdList;
        }
        return objectIdList;
    };

    HumanScene._getLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                objectIdList.push(object.objectId);
            } else {
                HumanScene._getLeaves(object.objects, objectIdList);
            }
        }
    };

    /**
     * Returns the IDs of visible leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getEnabledLeaves = function (objectId) {
        var objectIdList;
        if (objectId) {
            var object = HumanScene.objects[objectId];
            objectIdList = [];
            if (object) {
                HumanScene._getEnabledLeaves([object], objectIdList);
            }
        } else {
            objectIdList = Object.keys(HumanScene.enabledObjects);
        }
        return objectIdList;
    };

    HumanScene._getEnabledLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                if (HumanScene.enabledObjects.hasOwnProperty(object.objectId)) {
                    objectIdList.push(object.objectId);
                }
            } else {
                HumanScene._getEnabledLeaves(object.objects, objectIdList);
            }
        }
    };

    HumanScene._getKeys = function (map, val) {
        var keys = {};
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                key[key] = val;
            }
        }
        return keys;
    };

    /** Destroys an object and all sub-objects
     */
    HumanScene.destroyObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return;
        }
        var i, len;
        for (i = 0, len = HumanScene.rootObjects.length; i < len; i++) {
            if (HumanScene.rootObjects[i].objectId === objectId) {
                HumanScene.rootObjects.splice(i, 1);
                break;
            }
        }
        delete HumanScene.objects[objectId];                              // Delete object
        if (object.fmaId) {
            delete HumanScene.objectsByFMAID[object.fmaId];
        }

        delete HumanScene.enabledObjects[objectId];                       // Delete from enabled objects

        if (object.parent) {
            object.parent._removeObject(objectId);
        }
        var children = object.objects.slice(0); // Avoid modification during removals
        for (i = 0, len = children.length; i < len; i++) {
            HumanScene.destroyObject(children[i].objectId);
        }

        if (object.isLeaf()) {
            object.destroyNodes();
        }

        delete HumanScene.modelObjects[object.modelId][object.objectId];

        HumanScene._deregisterObjectForTags(object);

        // Will need to recompute leaf object cache
        HumanScene._leavesCache = {};

        Human.events.fire("scene.objectDestroyed", { objectId: objectId });
    };

    /**
     *
     * @param [params]
     * @param [params.objectId] ID of single object
     * @param [params.objectIds] Array of object IDs
     * @param [params.objects] Map of IDs to objects
     * @returns {*}
     */
    HumanScene.getBoundary = function (params) {

        if (!params) {
            return this.boundary;
        }

        params = params || {};

        var object;
        var objectId;
        var boundary, b;

        if (params.objectIds) {
            boundary = {
                xmin: Number.POSITIVE_INFINITY,
                ymin: Number.POSITIVE_INFINITY,
                zmin: Number.POSITIVE_INFINITY,
                xmax: Number.NEGATIVE_INFINITY,
                ymax: Number.NEGATIVE_INFINITY,
                zmax: Number.NEGATIVE_INFINITY
            };

            // Requesting boundary of multiple objects given as array of IDs

            var objectIds = params.objectIds;

            for (var i = 0, len = objectIds.length; i < len; i++) {

                object = HumanScene.objects[objectIds[i]];

                if (object && object.objects.length === 0) { // Leaf object

                    b = object.getBoundary();

                    if (b.xmin < boundary.xmin) {
                        boundary.xmin = b.xmin;
                    }
                    if (b.ymin < boundary.ymin) {
                        boundary.ymin = b.ymin;
                    }
                    if (b.zmin < boundary.zmin) {
                        boundary.zmin = b.zmin;
                    }
                    if (b.xmax > boundary.xmax) {
                        boundary.xmax = b.xmax;
                    }
                    if (b.ymax > boundary.ymax) {
                        boundary.ymax = b.ymax;
                    }
                    if (b.zmax > boundary.zmax) {
                        boundary.zmax = b.zmax;
                    }
                }
            }
        } else if (params.objects) {

            boundary = {
                xmin: Number.POSITIVE_INFINITY,
                ymin: Number.POSITIVE_INFINITY,
                zmin: Number.POSITIVE_INFINITY,
                xmax: Number.NEGATIVE_INFINITY,
                ymax: Number.NEGATIVE_INFINITY,
                zmax: Number.NEGATIVE_INFINITY
            };

            // Requesting boundary of an ID-map of objects

            var objects = params.objects;

            for (objectId in objects) {

                if (objects[objectId] && HumanScene.objects[objectId]) {

                    object = HumanScene.objects[objectId];

                    if (object.objects.length === 0) { // Leaf object

                        b = object.getBoundary();

                        if (b.xmin < boundary.xmin) {
                            boundary.xmin = b.xmin;
                        }
                        if (b.ymin < boundary.ymin) {
                            boundary.ymin = b.ymin;
                        }
                        if (b.zmin < boundary.zmin) {
                            boundary.zmin = b.zmin;
                        }
                        if (b.xmax > boundary.xmax) {
                            boundary.xmax = b.xmax;
                        }
                        if (b.ymax > boundary.ymax) {
                            boundary.ymax = b.ymax;
                        }
                        if (b.zmax > boundary.zmax) {
                            boundary.zmax = b.zmax;
                        }
                    }
                }
            }
        } else if (params.clipped) {
            boundary = Human.utils.deepClone(this.boundary);
        } else {
            boundary = this.boundary;
        }

        // take the inner boundary of scene boundary and cardinal clipping planes
        if (params.clipped){
            var clipBoundary = Human.renderer.clip.getBoundary();
            boundary.xmin = Math.max(boundary.xmin, clipBoundary.xmin);
            boundary.xmax = Math.min(boundary.xmax, clipBoundary.xmax);
            boundary.ymin = Math.max(boundary.ymin, clipBoundary.ymin);
            boundary.ymax = Math.min(boundary.ymax, clipBoundary.ymax);
            boundary.zmin = Math.max(boundary.zmin, clipBoundary.zmin);
            boundary.zmax = Math.min(boundary.zmax, clipBoundary.zmax);
        }
        return boundary;
    };

    HumanScene.getKdTree = function() {
        if (this.kdTreeDirty) {
            var rootObjects = Human.scene.rootObjects;
            var leaves = [];

            var captureLeafObject = function (o) {
                if (o.shown && o.objects.length === 0) {
                    leaves.push(o);
                }
            };

            for (var i = 0, len = rootObjects.length; i < len; ++i) {
                rootObjects[i].traverseDown(captureLeafObject);
            }

            this._kdTree = buildKdTreeNode(leaves, 0, 0);
            this.kdTreeDirty = false;
        }

        return this._kdTree;
    };

    // Make the sene-graph datastructure compliant with the grpah matcher
    HumanScene.access = function(objectId) {
        return HumanScene.getLeaves(objectId);
    };

    // Return scene graph nodes match set-logic query.
    HumanScene.select = function(query) {
        return graphMatcher.match(HumanScene, query);
    };

    // Single scene-graph traversal to set all properties, defaulting to parent properties.
    // Also has to fire event with published changes.
    HumanScene.setObjectProperties = function(instructions){
        instructions = instructions || {};

        var overrides = {};
        var shownChanges = {};      // objects that have changed shown property value
        var shownObjects = {};      // objects where shown = true

        var nonInheritable = {'transform':true};

        //NOTE[XRAY]
        // var xRayChanges = {};       // objects that have changed xray value
        // var xRayObjects = {};

        // Perform update on all objects in scene-graph through downward traversal
        var rootObjects = Human.scene.rootObjects;

        function setProperties(object){
            var override = overrides[object.objectId] = instructions[object.objectId] || {};

            // merge with inherited properties from parent
            if (object.parent){
                var parentOverride = overrides[object.parent.objectId];
                for (var key in parentOverride) {
                    if (override[key] === undefined && !nonInheritable[key]) {
                        override[key] = parentOverride[key];
                    }
                }

                // special handling of glass factor, as it is not needed to be inherited
                override.glassFactor = object.glassFactor;
                override.murkiness = object.murkiness;
            }

            // Register changes to 'shown' property
            if (override.hasOwnProperty("shown") && object.shown !== override.shown){
                if (object.isLeaf()){
                    shownChanges[object.objectId] = override.shown;
                }
            }

            if (object.isLeaf()) {
                if (override.shown){
                    shownObjects[object.objectId] = object;
                    HumanScene.enabledObjects[object.objectId] = object;
                } else {
                    delete HumanScene.enabledObjects[object.objectId];
                }
                object.clearColorModifiers();
                object.clearOpacityModifiers();
                object.setProperties(override);
            }

        }

        for (var i = 0, len = rootObjects.length; i < len; i++) {
            rootObjects[i].traverseDown(setProperties);
        }

        Human.events.fire("scene.objectsShown", {
          enabledObjectsUpdate: shownChanges,
          showSelectedObjects: HumanScene.showSelectedObjects
        });

        ///////////////////////////////////////////
        // Primarily for legacy object selection
        ///////////////////////////////////////////
        Human.events.fire("scene.objectPropertiesSet", {
          instructions: instructions
        });

    };

    // Apply pending updates to the scenegraph and
    // rebuild boundaries if necessary.
    HumanScene.onFrame = function() {
        var boundaryUpdated = false;
        var i, len;

        for (i = 0, len = this.rootObjects.length; i < len; ++i) {
            if (updateXform(this.rootObjects[i], false)) {
                boundaryUpdated = true;
            }
        }

        if (boundaryUpdated) {
            this.boundary.xmin = Number.POSITIVE_INFINITY;
            this.boundary.ymin = Number.POSITIVE_INFINITY;
            this.boundary.zmin = Number.POSITIVE_INFINITY;
            this.boundary.xmax = Number.NEGATIVE_INFINITY;
            this.boundary.ymax = Number.NEGATIVE_INFINITY;
            this.boundary.zmax = Number.NEGATIVE_INFINITY;

            for (i = 0, len = this.rootObjects.length; i < len; ++i) {
                var bb = this.rootObjects[i].getBoundary();
                this.boundary.xmin = Math.min(this.boundary.xmin, bb.xmin);
                this.boundary.ymin = Math.min(this.boundary.ymin, bb.ymin);
                this.boundary.zmin = Math.min(this.boundary.zmin, bb.zmin);
                this.boundary.xmax = Math.max(this.boundary.xmax, bb.xmax);
                this.boundary.ymax = Math.max(this.boundary.ymax, bb.ymax);
                this.boundary.zmax = Math.max(this.boundary.zmax, bb.zmax);

            }

            this.center[0] = (this.boundary.xmin + this.boundary.xmax) * 0.5;
            this.center[1] = (this.boundary.ymin + this.boundary.ymax) * 0.5;
            this.center[2] = (this.boundary.zmin + this.boundary.zmax) * 0.5;
        }
    };

    function updateXform(object, parentUpdated) {
        var updateLocal = object.matrixDirty;
        var updateWorld = updateLocal || parentUpdated;
        var boundaryUpdated = updateWorld;
        var i, len;

        if (updateLocal) {
            object.buildMatrix();
        }

        if (updateWorld) {
            if (object.parent) {
                mat4.multiply(object.worldMatrix, object.parent.worldMatrix, object.localMatrix);
            } else {
                object.worldMatrix.set(object.localMatrix);
            }
            object.matrixDirty = false;
        }

        if (object.isLeaf()) {
            if (updateWorld) {
                object.compileXform();
                return true;
            }
            if (object.geoDirty) {
                object.compileBoundary();
                object.geoDirty = false;
                return true;
            }

            return false;
        }

        for (i = 0, len = object.objects.length; i < len; ++i) {
            if (updateXform(object.objects[i], updateWorld)) {
                boundaryUpdated = true;
            }
        }

        if (boundaryUpdated) {
            object.boundary.xmin = Number.POSITIVE_INFINITY;
            object.boundary.ymin = Number.POSITIVE_INFINITY;
            object.boundary.zmin = Number.POSITIVE_INFINITY;
            object.boundary.xmax = Number.NEGATIVE_INFINITY;
            object.boundary.ymax = Number.NEGATIVE_INFINITY;
            object.boundary.zmax = Number.NEGATIVE_INFINITY;

            for (i = 0, len = object.objects.length; i < len; ++i) {
                var bb = object.objects[i].getBoundary();
                object.boundary.xmin = Math.min(object.boundary.xmin, bb.xmin);
                object.boundary.ymin = Math.min(object.boundary.ymin, bb.ymin);
                object.boundary.zmin = Math.min(object.boundary.zmin, bb.zmin);
                object.boundary.xmax = Math.max(object.boundary.xmax, bb.xmax);
                object.boundary.ymax = Math.max(object.boundary.ymax, bb.ymax);
                object.boundary.zmax = Math.max(object.boundary.zmax, bb.zmax);
            }

            object.center[0] = (object.boundary.xmin + object.boundary.xmax) * 0.5;
            object.center[1] = (object.boundary.ymin + object.boundary.ymax) * 0.5;
            object.center[2] = (object.boundary.zmin + object.boundary.zmax) * 0.5;
        }

        return boundaryUpdated;
    }

    HumanScene.cull = function() {
        cullKdTreeNode(
            this.getKdTree(),
            Human.renderer.camera.getFrustum(),
            Human.renderer.clip.getActiveClips()
        );
    };

    var boundaryProps = [
        "xmin",
        "ymin",
        "zmin"
    ];

    function buildKdTreeNode(objects, dim, depth) {
        var min = vec3.create();
        var max = vec3.create();

        var node = {
            objects: objects,
            left: null,
            right: null,
            bb: {
                min: min,
                max: max
            }
        };

        if (objects.length === 0) {
            return node;
        }

        min[0] = min[1] = min[2] = Number.POSITIVE_INFINITY;
        max[0] = max[1] = max[2] = Number.NEGATIVE_INFINITY;

        var object, b;
        var i, len;

        for (i = 0, len = objects.length; i < len; ++i) {
            object = objects[i];
            b = object.getBoundary();

            if (b.xmin < min[0]) {
                min[0] = b.xmin;
            }

            if (b.xmax > max[0]) {
                max[0] = b.xmax;
            }

            if (b.ymin < min[1]) {
                min[1] = b.ymin;
            }

            if (b.ymax > max[1]) {
                max[1] = b.ymax;
            }

            if (b.zmin < min[2]) {
                min[2] = b.zmin;
            }

            if (b.zmax > max[2]) {
                max[2] = b.zmax;
            }
        }

        if (depth > KD_TREE_MAX_DEPTH) {
            return node;
        }

        var boundaryProp = boundaryProps[dim];

        var mid = (min[dim] + max[dim]) / 2;
        var left = new Array(objects.length);
        var numLeft = 0;
        var right = new Array(objects.length);
        var numRight = 0;

        for (i = 0, len = objects.length; i < len; ++i) {
            object = objects[i];
            b = object.getBoundary();
            if (b[boundaryProp] <= mid) {
                left[numLeft++] = object;
            } else {
                right[numRight++] = object;
            }
        }

        if (numLeft < KD_TREE_MIN_OBJECTS || numRight < KD_TREE_MIN_OBJECTS) {
            return node;
        }

        left.length = numLeft;
        right.length = numRight;

        node.left = buildKdTreeNode(left, (dim + 1) % 3, depth + 1);
        node.right = buildKdTreeNode(right, (dim + 1) % 3, depth + 1);

        return node;
    }

    function cullKdTreeNode(kdTreeNode, frustum, clips) {
        var min = kdTreeNode.bb.min;
        var max = kdTreeNode.bb.max;
        var cameraResult = 1;
        var clipsResult = 1;
        var i, len;

        if (frustum) {
            cameraResult = Human.math.intersections.planesAabb(frustum, min, max);
        }

        if (clips) {
            clipsResult = Human.math.intersections.planesAabb(clips, min, max);
        }

        if (clipsResult === -1) {
            for (i = 0, len = kdTreeNode.objects.length; i < len; ++i) {
                kdTreeNode.objects[i].clipCull(true);
            }

            return;
        }

        if (cameraResult === -1) {
            for (i = 0, len = kdTreeNode.objects.length; i < len; ++i) {
                kdTreeNode.objects[i].frustumCull(true);
            }

            return;
        }

        if (cameraResult === 1) {
            frustum = null;
        }

        if (clipsResult === 1) {
            clips = null;
        }

        if (cameraResult === 0 || clipsResult === 0) {
            if (kdTreeNode.left) {
                cullKdTreeNode(kdTreeNode.left, frustum, clips);
                cullKdTreeNode(kdTreeNode.right, frustum, clips);
            } else {
                for (i = 0, len = kdTreeNode.objects.length; i < len; ++i) {
                    cullObjectToFrustum(kdTreeNode.objects[i], frustum, clips);
                }
            }
        } else {
            for (i = 0, len = kdTreeNode.objects.length; i < len; ++i) {
                kdTreeNode.objects[i].frustumCull(false);
                kdTreeNode.objects[i].clipCull(false);
            }
        }
    }

    var boundaryMin = vec3.create();
    var boundaryMax = vec3.create();
    var frustumTestDetails = new Array(6);
    var clipTestDetails = [];

    function cullObjectToFrustum(object, frustum, clips) {
        var bb = object.getBoundary();

        boundaryMin[0] = bb.xmin;
        boundaryMin[1] = bb.ymin;
        boundaryMin[2] = bb.zmin;

        boundaryMax[0] = bb.xmax;
        boundaryMax[1] = bb.ymax;
        boundaryMax[2] = bb.zmax;

        var cameraResult = 1;
        var clipsResult = 1;
        var fading = false;

        if (frustum) {
            cameraResult = Human.math.intersections.planesAabb(frustum, boundaryMin, boundaryMax, frustumTestDetails);
        }

        if (clips) {
            clipTestDetails.length = clips.length;
            clipsResult = Human.math.intersections.planesAabb(clips, boundaryMin, boundaryMax, clipTestDetails);
            for (var i = 0, len = clipTestDetails.length; i < len; ++i) {
                if (clipTestDetails[i] === undefined) {
                    break;
                }
                if (clipTestDetails[i] === 0 && clips[i].fade) {
                    fading = true;
                    break;
                }
            }
        }

        object.frustumCull(cameraResult === -1);
        object.clipCull(clipsResult === -1);

        if (cameraResult === -1 || clipsResult === -1) {
            return;
        }

        object.clipFade(fading);
        object.setVisiblyClipped(
            (cameraResult === 0 && frustumTestDetails[Human.renderer.camera.FRUSTUM_NEAR] === 0) ||
            clipsResult === 0
        );
    }

})();
;(function () {
    "use strict";

    /**
     * @class An object within {@link Human.scene}
     * @param cfg
     * @constructor
     */
    Human.scene.Group = function (cfg) {
        /** ID of model that contains this object
         *
         * @type {modelId|*}
         */
        this.modelId = cfg.modelId;

        /** Unique ID of this object
         * @type {String}
         */
        this.objectId = cfg.objectId;

        /** FMA ID
         * @type {String}
         */
        this.fmaId = cfg.fmaId;

        /** Z-sorting layer
         * @type {*}
         */
        this.layer = cfg.layer;

        /** Long display name
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /** Detailed description
         * @type {String}
         */
        this.description = cfg.description;

        /** Parent object
         * @type @link Human.scene.Group
         */
        this.parent = cfg.parent;

        /** Anatomy region metatags
         *
         * @type {Array of String}
         */
        this.tags = cfg.tags;

        // Selection defered to ancestor.
        this.anonymous = cfg.anonymous;

        /** Sub-objects
         *  @type {[Human.scene.Group]}
         */
        this.objects = [];

        

        this.reflectedX = cfg.reflectedX || false;
        this.reflectedY = cfg.reflectedY || false;
        this.reflectedZ = cfg.reflectedZ || false;
        this.localMatrix = mat4.create();
        this.worldMatrix = mat4.create();
        this._worldToObjectMatrix = mat4.create();
        this.matrixDirty = false;
        this.geoDirty = false;

        this.boundary = {
            xmin: Number.POSITIVE_INFINITY,
            ymin: Number.POSITIVE_INFINITY,
            zmin: Number.POSITIVE_INFINITY,
            xmax: Number.NEGATIVE_INFINITY,
            ymax: Number.NEGATIVE_INFINITY,
            zmax: Number.NEGATIVE_INFINITY
        };

        this.center = vec3.create();

        this.transformId = cfg.transformId;
        this.transformInitialized = !cfg.transformId;

        // Initial transform
        this.pivot = {x: 0, y: 0, z: 0};
        this.translate = {x: 0, y: 0, z: 0};
        this.scale = {x: 1, y: 1, z: 1};
        this.rotate = {x: 0, y: 0, z: 0};
        this._transformNode = null;

        // Both branch and leaf nodes can have transform assets
        if (cfg.pivot || cfg.translate || cfg.scale || cfg.rotate) {
            // Initial transform
            this.setTransform(cfg);
        }
    };


    Human.scene.Group.prototype.checkRenderable = function() {
        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].checkRenderable();
        }
    };

    Human.scene.Group.prototype.isVisible = function () {
            var numLeaves = this.getLeafObjects().length;
            return this.getShownObjects().length === numLeaves &&
                this.getRenderableObjects().length === numLeaves;

    };

    Human.scene.Group.prototype.isLeaf = function () {
        return false;
    };

    /**
     * Sets modelling transformation for this object
     *
     * @param {*} params Transform
     * @param {*} params.pivot Pivot point
     * @param {*} params.translate Translation vector
     * @param {*} params.scale Scaling vector
     * @param {*} params.rotate Rotation vectors
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Group.prototype.setTransform = function (params) {

        if (this.pivot === null) {
            this.pivot = {x: 0, y: 0, z: 0};
            this.translate = {x: 0, y: 0, z: 0};
            this.rotate = {x: 0, y: 0, z: 0};
            this.scale = {x: 1, y: 1, z: 1};
        }

        if (params.pivot) {
            if (params.pivot.x !== undefined) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined) {
                this.scale.z = params.scale.z;
            }
            if (params.scale.x < 0) {
                this.setReflectedX(true);
            }
            if (params.scale.y < 0) {
                this.setReflectedY(true);
            }
            if (params.scale.z < 0) {
                this.setReflectedZ(true);
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined) {
                this.rotate.z = params.rotate.z;
            }
        }

        if (!this.transformInitialized) {
            this.transformInitialized = true;
            this.checkRenderable();
        }
        
        this.matrixDirty = true;
    };



    var pivotMat = mat4.create();
    var scaleMat = mat4.create();
    var translateMat = mat4.create();
    var rotateZMat = mat4.create();
    var rotateYMat = mat4.create();
    var rotateXMat = mat4.create();

    Human.scene.Group.prototype.buildMatrix = function () {
        var pivot = this.pivot;
        var translate = this.translate;
        mat4.fromTranslation(pivotMat, [-pivot.x, -pivot.y, -pivot.z]);
        var scale = this.scale;
        mat4.fromScaling(scaleMat, [scale.x, scale.y, scale.z]);
        mat4.fromTranslation(translateMat, [translate.x + pivot.x, translate.y + pivot.y, translate.z + pivot.z]);
        var rotate = this.rotate;
        mat4.fromRotation(rotateZMat, rotate.z * Math.PI / 180.0, Human.math.Z_AXIS);
        mat4.fromRotation(rotateYMat, rotate.y * Math.PI / 180.0, Human.math.Y_AXIS);
        mat4.fromRotation(rotateXMat, rotate.x * Math.PI / 180.0, Human.math.X_AXIS);
        mat4.identity(this.localMatrix);
        mat4.multiply(this.localMatrix, pivotMat, this.localMatrix);
        mat4.multiply(this.localMatrix, scaleMat, this.localMatrix);
        mat4.multiply(this.localMatrix, rotateXMat, this.localMatrix);
        mat4.multiply(this.localMatrix, rotateYMat, this.localMatrix);
        mat4.multiply(this.localMatrix, rotateZMat, this.localMatrix);
        mat4.multiply(this.localMatrix, translateMat, this.localMatrix);

        this.matrixDirty = false;
    };


    // Returns true if this object is in a negatively-scaled coordinate space
    // where the scaling may be done by this object's transform, or a transform
    // on a parent.
    Human.scene.Group.prototype.reflectedTransform = function () {
        var negatedAxes = 0;
        if (this.reflectedX) {
            ++negatedAxes;
        }
        if (this.reflectedY) {
            ++negatedAxes;
        }
        if (this.reflectedZ) {
            ++negatedAxes;
        }

        return negatedAxes % 2 === 1;
    };

    /**
     * Returns this object's World-space boundary
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Group.prototype.getBoundary = function () {
        return this.boundary;
    };

    /**
     * Returns this object's World-space matrix
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Group.prototype.getWorldMatrix = function () {
        return this.worldMatrix;
    };

    /**
     * Returns inverse of all ancestor transforms
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Group.prototype.getWorldToObjectMatrix = function () {
        if (this.parent) {
            mat4.invert(this._worldToObjectMatrix, this.parent.worldMatrix);
        }

        return this._worldToObjectMatrix;
    };

    /**
     * Gets this object's World-space boundary center
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Group.prototype.getCenter = function () {
        return this.center;
    };

    Human.scene.Group.prototype.setReflectedX = function (reflected) {
        this.reflectedX = reflected;

        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].setReflectedX(reflected);
        }
    };

    Human.scene.Group.prototype.setReflectedY = function (reflected) {
        this.reflectedY = reflected;

        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].setReflectedY(reflected);
        }
    };

    Human.scene.Group.prototype.setReflectedZ = function (reflected) {
        this.reflectedZ = reflected;

        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].setReflectedZ(reflected);
        }
    };

    Human.scene.Group.prototype._removeObject = function (objectId) {
        for (var i = 0, len = this.objects.length; i < len; i++) {
            if (this.objects[i].objectId === objectId) {
                this.objects.splice(i, 1);
                return;
            }
        }
    };

    Human.scene.Group.prototype.isRenderable = function(){
            for (var i = 0, len = this.objects.length; i < len; ++i) {
                if (!this.objects[i].isRenderable()) {
                    return false;
                }
            }

            return true;
    };

    Human.scene.Group.prototype.isPinnable = function(){
            for (var i = 0, len = this.objects.length; i < len; ++i) {
                if (!this.objects[i].isPinnable()) {
                    return false;
                }
            }

            return true;
    };

    Human.scene.Group.prototype.getDefaultProperties = function(){
        return {
            shown: false,
            pickable: true,
            backfaces: false,
            glassFactor: 0.0,
            murkiness: 1.0,
            opacity:  1.0
        };
    };

    // -----------------  QUICK AND DIRTY TRAVERSAL ---------------------------

    Human.scene.Group.prototype.traverseUp = function(callback){
        callback(this);
        if (this.parent) {
            this.parent.traverseUp(callback);
        }
    };

    Human.scene.Group.prototype.traverseDown = function(callback){
        callback(this);
        for (var i = 0, len = this.objects.length; i < len; i++) {
            this.objects[i].traverseDown(callback);
        }
    };

    Human.scene.Group.prototype.getLeafObjects = function(callback){
        var leafObjects = [];

        this.traverseDown(function (child) {
            if(child.isLeaf()) {
                leafObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return leafObjects;
    };

    Human.scene.Group.prototype.getRenderableObjects = function(callback){
        var renderableObjects = [];

        this.getLeafObjects(function (child) {
            if(child.isRenderable()) {
                renderableObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return renderableObjects;
    };

    Human.scene.Group.prototype.getShownObjects = function(callback){
        var shownObjects = [];

        this.getLeafObjects(function (child) {
            if(child.shown) {
                shownObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return shownObjects;
    };

})();
;(function () {
    "use strict";

    var ColorFresnel = window.ColorFresnel; // added to global namespace
    var ScalarFresnel = window.ScalarFresnel;

    /**
     * @class An object within {@link Human.scene}
     * @param cfg
     * @constructor
     */
    Human.scene.Object = function (cfg) {
        /** ID of model that contains this object
         *
         * @type {modelId|*}
         */
        this.modelId = cfg.modelId;

        /** Unique ID of this object
         * @type {String}
         */
        this.objectId = cfg.objectId;

        // Selection defered to ancestor.
        this.anonymous = cfg.anonymous;

        /** FMA ID
         * @type {String}
         */
        this.fmaId = cfg.fmaId;

        /** Z-sorting layer
         * @type {*}
         */
        this.layer = parseInt(cfg.layer, 10) || 0; // sometimes, 'layer' exists as a string. It should be a number.

        /** Long display name
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /** Detailed description
         * @type {String}
         */
        this.description = cfg.description;

        /** Parent object
         * @type @link Human.scene.Object
         */
        this.parent = cfg.parent;

        /** True when this object is shown
         * @type {*|Boolean}
         */
        this.shown = false;

        // Culled via frustum culling
        this.culledByFrustum = false;

        // Culled via clipping plane
        this.culledByClip = false;

        // Intersecting a fade clipping plane
        this.fadeByClip = false;

        /** True when this object may be picked
         *  @type {Boolean}
         */
        this.pickable = true;

        /** True when this object may be clipped
         *  @type {Boolean}
         */
        this.clippable = true;

        /** True when this object is X-rayed
         *  @type {Boolean}
         */
        this.xray = false;

        // opacity is 1 if completely opaque
        this.opacity = cfg.opacity !== undefined ? cfg.opacity : 1.0;

        /** When transparent, this controls the degree of "facing ratio" effect, which is
         * where the object becomes more opaque towards the edges.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.glassFactor = 1.0;
        /** When transparent, this controls the degree of "murkiness" effect.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.murkiness = 1.0;

        /** True when this object is highlighted
         *  @type {Boolean}
         */
        this.highlight = false;

        this.tintColor = new Float32Array([1, 1, 1]);
        this.saturation = 0;
        this.contrast = 0;
        this.brightness = 0;

        this.colorModifiers = {};
        this.colorModifierList = [];
        this.colorModifierConfigs = [];

        this.opacityModifiers = {};
        this.opacityModifierConfigs = [];

        /** True when this object may show backfaces.
         *  @type {Boolean}
         */
        this.backfaces = false;

        // True if this object is currently clipped by the near plane.
        this.visiblyClipped = false;

        // Vertex winding order
        this.windingOrder = "ccw";

        /** Anatomy region metatags
         *
         * @type {Array of String}
         */
        this.tags = cfg.tags;

        /** Sub-objects
         *  @type {[Human.scene.Object]}
         */
         // Always empty. Just here to make
         // traversal across groups simpler.
        this.objects = [];



        this.reflectedX = cfg.reflectedX || false;
        this.reflectedY = cfg.reflectedY || false;
        this.reflectedZ = cfg.reflectedZ || false;
        this.localMatrix = mat4.create();
        this.worldMatrix = mat4.create();
        this._worldToObjectMatrix = mat4.create();
        this.matrixDirty = false;
        this.geoDirty = false;

        this.boundary = {
            xmin: Number.POSITIVE_INFINITY,
            ymin: Number.POSITIVE_INFINITY,
            zmin: Number.POSITIVE_INFINITY,
            xmax: Number.NEGATIVE_INFINITY,
            ymax: Number.NEGATIVE_INFINITY,
            zmax: Number.NEGATIVE_INFINITY
        };

        this.center = vec3.create();

        this.transformId = cfg.transformId;
        this.transformInitialized = !cfg.transformId;

        // Initial transform
        this.pivot = {x: 0, y: 0, z: 0};
        this.translate = {x: 0, y: 0, z: 0};
        this.scale = {x: 1, y: 1, z: 1};
        this.rotate = {x: 0, y: 0, z: 0};
        this._transformNode = null;


        // Eventually, we'll not create roots within roots, where the SceneJS subgraphs for Human objects will
        // be flat, ie. not nested within the SceneJS scene graph. Before we do that however, we need to manage the
        // nested coordinate spaces (ie multiplication of nested matrices) within Human, rather than rely on
        // SceneJS' inherited coordinate spaces, as we do currently.
        this._rootNode = null;
        this._renderableRoot = null;
        this.renderables = [];

        // Map for legacy anonymous object IDs
        this.anonymousIdToRenderableIndex = cfg.anonymousIdToRenderableIndex || {};

        if (cfg.renderables) {
            this.initRenderables();
            for (var i = 0, len = cfg.renderables.length; i < len; ++i) {
                this.addRenderable(cfg.renderables[i]);
            }
        }

        if (cfg.geometryId || cfg.morphId) {
            this.initRenderables();
            this.addRenderable(cfg);
        }

        // Both branch and leaf nodes can have transform assets

        if (cfg.pivot || cfg.translate || cfg.scale || cfg.rotate) {
            // Initial transform
            this.setTransform(cfg);
        }
        this._checkFlippedWinding();

        if (this._propertiesNode) {
            this._propertiesNode.setSolidColor(cfg.capColor ||  { r: 0.7, g: 0.7, b: 0.7 });
        }
    };

    Human.scene.Object.prototype.initRenderables = function () {
        if (this._rootNode) {
            return;
        }

        this._rootNode = this._transformNode = Human.renderer.graph.createSubtree({
            type: "xform",
        });

        // Flags

        var flags = this.getDefaultFlags();

        this._xrayBackfaces = false;

        flags.enabled = false;
        flags.pickable = true;
        flags.solid = Human.scene.enableSolidObjects;
        flags.layer = this.layer || 0;
        flags.name = this.objectId;
        flags.xray = false;
        flags.highlight = false;
        flags.opacity = this.opacity;
        flags.glassFactor = this.glassFactor;
        flags.murkiness = this.murkiness;
        flags.xrayEnabled = true;

        this._renderableRoot = this._propertiesNode = Human.renderer.graph.insertNode(this._rootNode, {
            type: "properties",
            properties: flags
        });
    };

    Human.scene.Object.prototype.addRenderable = function (cfg) {
        this.renderables.push(new Human.scene.Renderable(this, cfg));
    };

    /////////////////////////////////////////
    // Applying assets to this object
    /////////////////////////////////////////


    Human.scene.Object.prototype.detachAsset = function (type) {
        var i, len;
        switch (type) {
            case "geometry":
                for (i = 0, len = this.renderables.length; i < len; ++i) {
                    this.renderables[i].detachGeometry();
                }
            break;
            case "material":
                for (i = 0, len = this.renderables.length; i < len; ++i) {
                    this.renderables[i].detachMaterial();
                }
            break;
            case "morph":
                for (i = 0, len = this.renderables.length; i < len; ++i) {
                    this.renderables[i].detachMorph();
                }
            break;
        }
    };

    Human.scene.Object.prototype.checkRenderable = function() {
        if (this.isRenderable()) {
            Human.events.fire("scene.objectRenderable", {
                objectId: this.objectId
            });
        }
    };

    Human.scene.Object.prototype.isRenderable = function () {
        for (var i = 0, len = this.renderables.length; i < len; ++i) {
            if (!this.renderables[i].isRenderable()) {
                return false;
            }
        }

        var object = this;

        while (object) {
            if (object.transformId && !object.transformInitialized) {
                return false;
            }

            object = object.parent;
        }

        return true;
    };

    Human.scene.Object.prototype.isVisible = function () {
        return this.shown && this.isRenderable();
    };

    Human.scene.Object.prototype.isLeaf = function () {
        return true;
    };

    /**
     * Sets modelling transformation for this object
     *
     * @param {*} params Transform
     * @param {*} params.pivot Pivot point
     * @param {*} params.translate Translation vector
     * @param {*} params.scale Scaling vector
     * @param {*} params.rotate Rotation vectors
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransform = function (params) {

        if (this.pivot === null) {
            this.pivot = {x: 0, y: 0, z: 0};
            this.translate = {x: 0, y: 0, z: 0};
            this.rotate = {x: 0, y: 0, z: 0};
            this.scale = {x: 1, y: 1, z: 1};
        }

        if (params.pivot) {
            if (params.pivot.x !== undefined) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined) {
                this.scale.z = params.scale.z;
            }
            if (params.scale.x < 0) {
                this.setReflectedX(true);
            }
            if (params.scale.y < 0) {
                this.setReflectedY(true);
            }
            if (params.scale.z < 0) {
                this.setReflectedZ(true);
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined) {
                this.rotate.z = params.rotate.z;
            }
        }

        if (!this.transformInitialized) {
            this.transformInitialized = true;
            this.checkRenderable();
        }

        this.matrixDirty = true;
    };


    // returns true if the values are equal
    function compareProperty(value1, value2) {
        // compare type and value
        var type1 = value1.constructor.name;
        var type2 = value2.constructor.name;
        if (type1 === type2) {
            if (type1 === "Number" || type1 === "Boolean") {
                return value1 === value2;
            } else if (type1 === "Array" || type1 === "Float32Array"){
                return value1.reduce(function(r, val, idx){
                    return r && val===value2[idx];
                }, true);
            } else if (type1 === "ScalarFresnel") {
                return ScalarFresnel.prototype.isEqual(value1, value2);
            } else if (type1 === "ColorFresnel") {
                return ColorFresnel.prototype.isEqual(value1, value2);
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    // return copy of property value (to avoid pass by reference issues)
    function cleanProperty(value) {
        var type = value.constructor.name;
        if (type === "Array") {
            return value.slice(0);
        } else if (type === "ColorFresnel") {
            return new ColorFresnel(value.center, value.edge, value.centerBias, value.edgeBias, value.power);
        } else if (type === "ScalarFresnel") {
            return new ScalarFresnel(value.center, value.edge, value.centerBias, value.edgeBias, value.power);
        } else {
            // immutable (or unsupported property type)
            return value;
        }
    }

    var pivotMat = mat4.create();
    var scaleMat = mat4.create();
    var translateMat = mat4.create();
    var rotateZMat = mat4.create();
    var rotateYMat = mat4.create();
    var rotateXMat = mat4.create();

    Human.scene.Object.prototype.buildMatrix = function () {
        var pivot = this.pivot;
        var translate = this.translate;
        mat4.fromTranslation(pivotMat, [-pivot.x, -pivot.y, -pivot.z]);
        var scale = this.scale;
        mat4.fromScaling(scaleMat, [scale.x, scale.y, scale.z]);
        mat4.fromTranslation(translateMat, [translate.x + pivot.x, translate.y + pivot.y, translate.z + pivot.z]);
        var rotate = this.rotate;
        mat4.fromRotation(rotateZMat, rotate.z * Math.PI / 180.0, Human.math.Z_AXIS);
        mat4.fromRotation(rotateYMat, rotate.y * Math.PI / 180.0, Human.math.Y_AXIS);
        mat4.fromRotation(rotateXMat, rotate.x * Math.PI / 180.0, Human.math.X_AXIS);
        mat4.identity(this.localMatrix);
        mat4.multiply(this.localMatrix, pivotMat, this.localMatrix);
        mat4.multiply(this.localMatrix, scaleMat, this.localMatrix);
        mat4.multiply(this.localMatrix, rotateXMat, this.localMatrix);
        mat4.multiply(this.localMatrix, rotateYMat, this.localMatrix);
        mat4.multiply(this.localMatrix, rotateZMat, this.localMatrix);
        mat4.multiply(this.localMatrix, translateMat, this.localMatrix);

        this.matrixDirty = false;
    };

    Human.scene.Object.prototype.compileXform = function () {
        if (this._transformNode) {
            this._transformNode.setElements(this.worldMatrix);

            this.compileBoundary();
        }
    };

    Human.scene.Object.prototype.compileBoundary = function () {
        Human.scene.kdTreeDirty = true;
        Human.renderer.camera.nearFarDirty = true;
        var matrix = this.worldMatrix;
        var worldBoundary = this._getBoundary(matrix);
        this.boundary.xmin = worldBoundary.xmin;
        this.boundary.ymin = worldBoundary.ymin;
        this.boundary.zmin = worldBoundary.zmin;
        this.boundary.xmax = worldBoundary.xmax;
        this.boundary.ymax = worldBoundary.ymax;
        this.boundary.zmax = worldBoundary.zmax;

        this.center[0] = (this.boundary.xmin + this.boundary.xmax) * 0.5;
        this.center[1] = (this.boundary.ymin + this.boundary.ymax) * 0.5;
        this.center[2] = (this.boundary.zmin + this.boundary.zmax) * 0.5;
    };

    // Returns true if this object is in a negatively-scaled coordinate space
    // where the scaling may be done by this object's transform, or a transform
    // on a parent.
    Human.scene.Object.prototype.reflectedTransform = function () {
        var negatedAxes = 0;
        if (this.reflectedX) {
            ++negatedAxes;
        }
        if (this.reflectedY) {
            ++negatedAxes;
        }
        if (this.reflectedZ) {
            ++negatedAxes;
        }

        return negatedAxes % 2 === 1;
    };

    Human.scene.Object.prototype._checkFlippedWinding = function () {
        if (this._propertiesNode) {
            var flip = this.reflectedTransform();
            var defaultWinding = this.windingOrder;
            var flippedWinding = this.windingOrder === "ccw" ? "cw" : "ccw";
            this._propertiesNode.setFrontface(flip ? flippedWinding : defaultWinding);
        }

    };

    /**
     * Returns this object's World-space boundary
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getBoundary = function () {
        return this.boundary;
    };

    /**
     * Returns this object's World-space matrix
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getWorldMatrix = function () {
        return this.worldMatrix;
    };

    /**
     * Returns inverse of all ancestor transforms
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getWorldToObjectMatrix = function () {
        if (this.parent) {
            mat4.invert(this._worldToObjectMatrix, this.parent.worldMatrix);
        }

        return this._worldToObjectMatrix;
    };

    /**
     * Gets this object's World-space boundary center
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.getCenter = function () {
        return this.center;
    };

    var position = vec3.create();
    var boundaryOffset = vec3.create();

    // Get minimal boundary enclosing the given vertex array
    Human.scene.Object.prototype._getBoundary = function (matrix) {
        var xmin = Number.POSITIVE_INFINITY;
        var ymin = Number.POSITIVE_INFINITY;
        var zmin = Number.POSITIVE_INFINITY;
        var xmax = Number.NEGATIVE_INFINITY;
        var ymax = Number.NEGATIVE_INFINITY;
        var zmax = Number.NEGATIVE_INFINITY;
        var x, y, z;

        for (var i = 0, len = this.renderables.length; i < len; ++i) {
            var renderable = this.renderables[i];
            var bb = renderable.boundary;

            if (!renderable.isRenderable()) {
                continue;
            }

            if (this._propertiesNode.getSkybox()) {
                var camera = Human.renderer.camera.eye;
                boundaryOffset[0] = camera.x;
                boundaryOffset[1] = camera.y;
                boundaryOffset[2] = camera.z;
            } else {
                boundaryOffset[0] = 0;
                boundaryOffset[1] = 0;
                boundaryOffset[2] = 0;
            }

            for (var j = 0; j < 8; j++) {
                position[0] = j & 1 ? bb.xmin : bb.xmax;
                position[1] = j & 2 ? bb.ymin : bb.ymax;
                position[2] = j & 4 ? bb.zmin : bb.zmax;
                vec3.transformMat4(position, position, matrix);
                x = position[0] - boundaryOffset[0];
                y = position[1] - boundaryOffset[1];
                z = position[2] - boundaryOffset[2];

                if (x < xmin) {
                    xmin = x;
                }
                if (y < ymin) {
                    ymin = y;
                }
                if (z < zmin) {
                    zmin = z;
                }
                if (x > xmax) {
                    xmax = x;
                }
                if (y > ymax) {
                    ymax = y;
                }
                if (z > zmax) {
                    zmax = z;
                }
            }
        }

        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    };

    /**
     * Show/hide this object
     * Only has effect on leaf objects, ignored on branch objects
     * @param {Boolean} doShow Flag specifying whether or not to show
     * @private
     */
    Human.scene.Object.prototype.show = function (doShow) {
        if (this.shown !== doShow) {
            this.shown = doShow;

            if (this._propertiesNode) {
                updateVisibility(this);
                Human.scene.kdTreeDirty = true;

                var eventName = "scene.object" + (this.shown ? "Shown" : "Hidden");

                Human.events.fire(eventName, {
                    objectId: this.objectId
                });

            }
        }
    };

    Human.scene.Object.prototype.frustumCull = function (doCull) {
        if (this.culledByFrustum !== doCull && this._propertiesNode) {
            this.culledByFrustum = doCull;
            updateVisibility(this);
        }
    };

    Human.scene.Object.prototype.clipCull = function (doCull) {
        if (this.culledByClip !== doCull && this._propertiesNode) {
            this.culledByClip = doCull;
            updateVisibility(this);
        }
    };

    Human.scene.Object.prototype.clipFade = function (doFade) {
        if (this.fadeByClip !== doFade && this._propertiesNode) {
            this.fadeByClip = doFade;
            this._propertiesNode.setProperties({
                forceTransparent: doFade,
                partiallyOpaque: doFade
            });
        }
    };

    /**
     * Set degree of transparency of this object - sets property, but only does something if this object has scene content
     *
     * @param {Number} opacity Degree of transparency between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setOpacity = function (opacity) {
        if (opacity === false) {
            this.clearOpacityModProperties({'opacity': true});
            return;
        }
        opacity = cleanProperty(opacity);
        if (Array.isArray(opacity) && opacity.length === 5) {
            opacity = new ScalarFresnel(opacity);
        }
        if (!compareProperty(this.opacity, opacity)){
            this.opacity = opacity; // associable with groups for purposes of single-pass synchronization
            if (this._propertiesNode){
                this.setOpacityModifier("__OPACITY", {
                    value: this.opacity
                });
            }
        }
    };

    /**
     * Set whether or not object appears X-rayed
     * Only has effect on leaf objects, ignored on branch objects
     * @param {boolean} xray True to make object appear X-rayed
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setXRay = function (xray) {
        this.setXRayColors(xray);
        this.xray = xray;
    };

    /*
    *  Use xray colors without changing object "xray" flag
    */
    Human.scene.Object.prototype.setXRayColors = function (xray) {
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({
                xray: xray
            });
            updateBackfaces(this);
        }
    };

    /** When transparent, this sets the degree of "facing ratio" effect, which is
     * where the object becomes more opaque towards the edges.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} glassFactor Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setGlassFactor = function (glassFactor) {
        this.glassFactor = glassFactor;
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({glassFactor: glassFactor});
        }
    };

    /** When transparent, this sets the degree of "murkiness" effect.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} murkiness Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setMurkiness = function (murkiness) {
        this.murkiness = murkiness;
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({murkiness: murkiness});
        }
    };

    /**
     * Sets whether or not this object is pickable
     * Only has effect on leaf objects, ignored on branch objects
     * @param pickable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setPickable = function (pickable) {
        if (this.pickable !== pickable) {
            if (this._propertiesNode) {
                this._propertiesNode.setPicking(pickable);
            }
            this.pickable = pickable;
        }
    };

    /**
     * Sets whether or not this object is clippable
     * Only has effect on leaf objects, ignored on branch objects
     * @param clippable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setClippable = function (clippable) {
        if (this.clippable !== clippable) {
            if (this._propertiesNode) {
                this._propertiesNode.setClipping(clippable);
            }
            this.clippable = clippable;
        }
    };

    // add/replace/drop color modifier with config. cfg of null will remove the modifier
    Human.scene.Object.prototype.setColorModifier = function (id, cfg) {
        if (!this._propertiesNode) {
            return;
        }

        var listUpdated = false;

        if (cfg === null) {
            // delete existing modifier
            delete this.colorModifiers[id];
            listUpdated = true;
        } else if (!this.colorModifiers[id]) {
            // add new modifier
            this.colorModifiers[id] = {
                priority: Human.scene.colorModPriorities[id] || 0,
                params: {
                    applyTo: cfg.applyTo,
                    value: cfg.value,
                    range: cfg.range || null
                }
            };
            listUpdated = true;
        } else {
            // replace existing modifier
            var modifier = this.colorModifiers[id];

            if (cfg.applyTo !== undefined) {
                modifier.params.applyTo = cfg.applyTo;
            }

            if (cfg.value !== undefined) {
                modifier.params.value = cfg.value;
            }

            if (cfg.range !== undefined) {
                modifier.params.range = cfg.range;
            } else {
                modifier.params.range = null;
            }
        }

        if (listUpdated) {
            updateColorModifiersList(this);
        }

        this._propertiesNode.setProperties({ colorModifiers: this.colorModifierConfigs });
    };

    // clear all color modifications on the object (properties and recipes)
    Human.scene.Object.prototype.clearColorModifiers = function () {
        if (!this._propertiesNode) {
            return;
        }

        this.colorModifiers = {};
        updateColorModifiersList(this);
        this.tintColor = new Float32Array(defaultProperties.tintColor.value);
        this.brightness = defaultProperties.brightness.value;
        this.saturation = defaultProperties.saturation.value;
        this.contrast = defaultProperties.contrast.value;

        this._propertiesNode.setProperties({ colorModifiers: this.colorModifierConfigs });
    };

    // clear color mod properties from the object (properties only)
    Human.scene.Object.prototype.clearColorModProperties = function(cfg){
        if (!this._propertiesNode){
            return;
        }

        if (!cfg || !!cfg.tintColor) {
            delete this.colorModifiers['__TINT_COLOR'];
            this.tintColor = new Float32Array(defaultProperties.tintColor.value);
        }
        if (!cfg || !!cfg.brightness) {
            delete this.colorModifiers['__BRIGHTNESS'];
            this.brightness = defaultProperties.brightness.value;
        }

        if (!cfg || !!cfg.saturation){
            delete this.colorModifiers['__SATURATION'];
            this.saturation = defaultProperties.saturation.value;
        }

        if (!cfg || !!cfg.contrast) {
            delete this.colorModifiers['__CONTRAST'];
            this.contrast = defaultProperties.contrast.value;
        }

        updateColorModifiersList(this);
        this._propertiesNode.setProperties({colorModifiers: this.colorModifierConfigs});

    };

    Human.scene.Object.prototype.setOpacityModifier = function (id, cfg) {
        if (!this._propertiesNode) {
            return;
        }

        var listUpdated = false;

        if (cfg === null) {
            // delete existing modifier
            delete this.opacityModifiers[id];
            listUpdated = true;
        } else if (!this.opacityModifiers[id]) {
            this.opacityModifiers[id] = {
                value: cfg.value,
                range: cfg.range || null
            };
            listUpdated = true;
        } else {
            var modifier = this.opacityModifiers[id];

            if (cfg.value !== undefined) {
                modifier.value = cfg.value;
            }

            if (cfg.range !== undefined) {
                modifier.range = cfg.range;
            } else {
                modifier.range = null;
            }
        }

        if (listUpdated) {
            updateOpacityModifiersList(this);
        }

        this._propertiesNode.setProperties({ opacityModifiers: this.opacityModifierConfigs });
    };

    // clear all opacity modifications on the object (recipes and properties)
    Human.scene.Object.prototype.clearOpacityModifiers = function() {
        if (!this._propertiesNode) {
            return;
        }

        this.opacityModifiers = {};
        this.opacity = defaultProperties.opacity.value;
        updateOpacityModifiersList(this);
        this._propertiesNode.setProperties({ opacityModifiers: this.opacityModifierConfigs });
    };

    // clear only opacity property modifiers
    Human.scene.Object.prototype.clearOpacityModProperties = function(cfg){
        if (!this._propertiesNode){
            return;
        }

        if (!cfg || !!cfg.opacity){
            delete this.opacityModifiers['__OPACITY'];
            this.opacity = defaultProperties.opacity.value;
        }

        updateOpacityModifiersList(this);
        this._propertiesNode.setProperties({ opacityModifiers: this.opacityModifierConfigs });
    };

    Human.scene.Object.prototype.colorModPrioritiesDirty = function() {
        for (var id in this.colorModifiers) {
            this.colorModifiers[id].priority = Human.scene.colorModPriorities[id] || 0;
        }

        updateColorModifiersList(this);

        this._propertiesNode.setProperties({ colorModifiers: this.colorModifierConfigs });
    };

    Human.scene.Object.prototype.setHighlight = function (highlight) {
        if (this._propertiesNode) {
            if (highlight) {
                var color = Human.renderer.highlightColor;
                this.setColorModifier("__HIGHLIGHT", {
                    applyTo: "tintColor",
                    value: color
                });
            } else {
                this.setColorModifier("__HIGHLIGHT", {
                    applyTo: "tintColor",
                    value: Human.math.VEC3_ONES
                });
            }
            this.highlight = highlight;
        }
    };

    // Default = color = [1,1,1]
    function _setTintColor(obj, color) {
        if (obj._propertiesNode) {
            obj.tintColor = color;
            obj.setColorModifier("__TINT_COLOR", {
                applyTo: "tintColor",
                value: obj.tintColor
            });
        }
    }

    // Default = (1, 1, 1). if false , remove tint color
    Human.scene.Object.prototype.setTintColor = function (args) {

        if (args === false) {
            this.clearColorModProperties({tintColor: true});
            return;
        }

        var color;
        if (arguments.length === 3) {
            // legacy api  r,g,b tuple
            color = [arguments[0],arguments[1],arguments[2]];
        } else {
            // color array, color fresnel, boolean
            color = cleanProperty(arguments[0]);
            if (Array.isArray(color) && color.length === 5) {
                color = new ColorFresnel(color);
            }
        }

        if (!compareProperty(this.tintColor, color)) {
            _setTintColor(this, color);
        }

    };

    // Default = 0
    Human.scene.Object.prototype.setContrast = function (contrast) {
        if (contrast === false){
            this.clearColorModProperties({'contrast': true});
            return;
        }
        contrast = cleanProperty(contrast);
        if (Array.isArray(contrast) && contrast.length === 5) {
            contrast = new ScalarFresnel(contrast);
        }
        if (this._propertiesNode && !compareProperty(this.contrast, contrast)) {
            this.contrast = contrast;
            this.setColorModifier("__CONTRAST", {
                applyTo: "contrast",
                value: this.contrast
            });
        }
    };

    // Default = 0
    Human.scene.Object.prototype.setSaturation = function (saturation) {
        if (saturation === false) {
            this.clearColorModProperties({'saturation': true});
            return;
        }
        saturation = cleanProperty(saturation);
        if (Array.isArray(saturation) && saturation.length === 5) {
            saturation = new ScalarFresnel(saturation);
        }
        if (this._propertiesNode && !compareProperty(this.saturation, saturation)) {
            this.saturation = saturation;
            this.setColorModifier("__SATURATION", {
                applyTo: "saturation",
                value: this.saturation
            });
        }
    };

    Human.scene.Object.prototype.setBrightness = function (brightness) {
        if (brightness === false){
            this.clearColorModProperties({'brightness': true});
            return;
        }
        brightness = cleanProperty(brightness);
        if (Array.isArray(brightness) && brightness.length === 5) {
            brightness = new ScalarFresnel(brightness);
        }
        if (this._propertiesNode && !compareProperty(this.brightness, brightness)) {
            this.brightness = brightness;
            this.setColorModifier("__BRIGHTNESS", {
                applyTo: "brightness",
                value: this.brightness
            });
        }
    };

    // Render in two passes for weightedOIT and improvedAlpha transparency mode.
    Human.scene.Object.prototype.setPartiallyOpaque = function (po) {
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({ partiallyOpaque: po });
        }
    };

    /**
     * Sets whether or not this object shows backfaces.
     * Only has effect on leaf objects, ignored on branch objects
     * @param backfaces
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setBackfaces = function (backfaces) {
        if (this.backfaces !== backfaces) {
            this.backfaces = backfaces;
            updateBackfaces(this);
        }
    };

    Human.scene.Object.prototype.setVisiblyClipped = function (visiblyClipped) {
        if (this.visiblyClipped !== visiblyClipped && this.hasRenderObjects()) {
            this.visiblyClipped = visiblyClipped;
            updateBackfaces(this);
        }
    };

    Human.scene.Object.prototype.setReflectedX = function (reflected) {
        this.reflectedX = reflected;
        this._checkFlippedWinding();
    };

    Human.scene.Object.prototype.setReflectedY = function (reflected) {
        this.reflectedY = reflected;
        this._checkFlippedWinding();
    };

    Human.scene.Object.prototype.setReflectedZ = function (reflected) {
        this.reflectedZ = reflected;
        this._checkFlippedWinding();
    };

    Human.scene.Object.prototype.destroyNodes = function () {
        if (this._rootNode) {
            Human.renderer.graph.destroySubtree(this._rootNode);
            this.renderables.length = 0;
            this._rootNode = null;
        }
    };

    // ------------------ EXPLICIT DEFAULTS -----------------------------------
    // throw away
    var defaultProperties = {
        "shown": {setter: Human.scene.Object.prototype.show, value: false, keyable: true, type:"boolean"},
        "pickable": {setter: Human.scene.Object.prototype.setPickable, value: true, keyable: false, type:"boolean"},
        "backfaces": {setter: Human.scene.Object.prototype.setBackfaces, value: false, keyable: false, type:"boolean"},
        "glassFactor": {setter: Human.scene.Object.prototype.setGlassFactor, value: 0.0, keyable: false, type:"number"},
        "murkiness": {setter: Human.scene.Object.prototype.setMurkiness, value: 1.0, keyable: false, type:"number"},
        "opacity": {setter: Human.scene.Object.prototype.setOpacity, value: 1.0, keyable: true, type:"number"},
        "tintColor": {setter: Human.scene.Object.prototype.setTintColor, value: new Float32Array([1.0, 1.0, 1.0]), keyable: false, type:"Float32Array"},
        "saturation": {setter: Human.scene.Object.prototype.setSaturation, value: 0, keyable: false, type:"number"},
        "brightness": {setter: Human.scene.Object.prototype.setBrightness, value: 0, keyable: false, type:"number"},
        "contrast": {setter: Human.scene.Object.prototype.setContrast, value: 0.0, keyable: false, type:"number"}
    };

    //NOTE[XRAY]
    //"xray": {setter: Human.scene.Object.prototype.setXRay, value:false, keyable:false, type:"boolean"}


    var defaultPropertyKeys = Object.keys(defaultProperties);

    Human.scene.Object.prototype.getDefaultFlags = function () {
        return {
            picking: this.pickable,
            enabled: false,
            specular: true,
            backfaces: false,
            reflection: true,
            solid: Human.scene.enableSolidObjects
        };
    };

    Human.scene.Object.prototype.getDefaultProperties = function(){
        var result = {};

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            result[prop] = defaultProperties[prop].value;
        }

        return result;
    };

    Human.scene.Object.prototype.getProperties = function(){
        var self = this;
        var result = {};

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            result[prop] = self[prop];
        }

        return result;
    };

    // Set properties of an individual object ONLY. No traversal.
    Human.scene.Object.prototype.setProperties = function(overrides){
        overrides = overrides || {};
        var self = this;
        var target;
        var pvalue;

        var i, len;
        this.clearColorModifiers(); // reset color mods
        this.clearOpacityModifiers(); // reset opacity mods
        for (i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            target = defaultProperties[prop];
            pvalue = overrides[prop] !== undefined ? overrides[prop] : target.value;

            // apply if different
            if (!compareProperty(self[prop], pvalue)){
                target.setter.call(self, pvalue);
            }
        }


        // loop through default recipes and add/remove according to overrides
        var recipeName, recipes = Human.scene.colorRecipes.getRecipes();
        for (i = 0; i< recipes.length; i++) {
            recipeName = recipes[i];
            Human.scene.colorRecipes.setObjectRecipe(this.objectId, recipeName, overrides[recipeName] || false);
        }
    };

    Human.scene.Object.prototype.barycentricToModelSpace = function(renderableIndex, primitiveIndex, barycentric, out) {
        if (this.renderables.length <= renderableIndex) {
            return false;
        }

        var renderObject = this.renderables[renderableIndex].getRenderObject();

        if (renderObject) {
            // get object-space position
            renderObject.barycentricToCartesian(primitiveIndex, barycentric, out);
            return out;
        } else {
            return false;
        }
    };

    Human.scene.Object.prototype.barycentricToWorldSpace = function(renderableIndex, primitiveIndex, barycentric, out) {
        this.barycentricToModelSpace(renderableIndex, primitiveIndex, barycentric, out);
        if (out) {
            vec3.transformMat4(out, out, this.getWorldMatrix());
            return out;
        } else {
            return false;
        }
    };

    Human.scene.Object.prototype.isPinnable = function(){
        return this.hasRenderObjects();
    };

    Human.scene.Object.prototype.hasRenderObjects = function(){
        for (var i = 0, len = this.renderables.length; i < len; ++i) {
            if (!this.renderables[i].getRenderObject()) {
                return false;
            }
        }

        return true;
    };


    // create synchronization object state for serialization.
    // Does NOT include transform data
    Human.scene.Object.prototype.serialize = function(){
        var synchronization = {};
        for (var prop in defaultProperties) {
            var dprop = defaultProperties[prop];
            if (!compareProperty(dprop.value, this[prop])){
                // add to synchronization
                var v = this[prop];
                var serializedValue;
                if (v instanceof ScalarFresnel || v instanceof ColorFresnel) {
                    serializedValue = JSON.parse(JSON.stringify([v.center, v.edge, v.centerBias, v.edgeBias, v.power]));
                } else {
                    serializedValue = JSON.parse(JSON.stringify(v));
                }
                synchronization[prop] = serializedValue;
            }
        }
        return synchronization;
    };

    // -----------------  QUICK AND DIRTY TRAVERSAL ---------------------------

    Human.scene.Object.prototype.traverseUp = function(callback){
        callback(this);
        if (this.parent) {
            this.parent.traverseUp(callback);
        }
    };

    Human.scene.Object.prototype.traverseDown = function(callback){
        callback(this);
    };

    Human.scene.Object.prototype.getLeafObjects = function(callback){
        if (callback) {
            callback(this);
        }
        return [this];
    };

    function updateVisibility(object) {
        object._propertiesNode.setEnabled(object.shown && !object.culledByFrustum && !object.culledByClip);
    }

    function updateBackfaces(object) {
        var renderables = object.renderables;
        for (var i = 0, len = renderables.length; i < len; ++i) {
//            renderables[i].setBackfaces((object.backfaces || object.visiblyClipped));
            // [GH] - always disable backfaces
            renderables[i].setBackfaces(false);
        }
    }

    function sortModifiers(a, b) {
        return a.priority - b.priority;
    }

    function updateColorModifiersList(object) {
        object.colorModifierList.length = 0;

        for (var id in object.colorModifiers) {
            object.colorModifierList.push(object.colorModifiers[id]);
        }

        object.colorModifierList.sort(sortModifiers);

        object.colorModifierConfigs.length = object.colorModifierList.length;

        for (var i = 0, len = object.colorModifierList.length; i < len; ++i) {
            object.colorModifierConfigs[i] = object.colorModifierList[i].params;
        }
    }

    function updateOpacityModifiersList(object) {
        object.opacityModifierConfigs.length = 0;

        for (var id in object.opacityModifiers) {
            object.opacityModifierConfigs.push(object.opacityModifiers[id]);
        }
    }

})();
;(function() {
    "use strict";

    var idCounter = 0;

    var Renderable = Human.scene.Renderable = function(object, cfg) {
        this.id = idCounter++;
        this.object = object;
        this.rootNode = object._renderableRoot.addNode();

        this.geometryId  = cfg.geometryId || null;
        this.materialId  = cfg.materialId || null;
        this.morphId     = cfg.morphId || null;

        this.drawTexture = null;

        this.geometryAttached = false;
        this.materialAttached = false;
        this.morphAttached = false;

        this.geometryNode = null;
        this.materialNode = null;
        this.textureNodes = null;
        this.fresnelNodes = null;
        this.reflectionNode = null;
        this.lightMapNode = null;

        this.boundary = {
            xmin: Number.POSITIVE_INFINITY,
            ymin: Number.POSITIVE_INFINITY,
            zmin: Number.POSITIVE_INFINITY,
            xmax: Number.NEGATIVE_INFINITY,
            ymax: Number.NEGATIVE_INFINITY,
            zmax: Number.NEGATIVE_INFINITY
        };

        this.backfaces = false;
        this.addBlend = false;
        this.layer = cfg.layer || 0;
    };

    Renderable.prototype.attachAsset = function (type, asset) {
        var wasRenderable = this.isRenderable();

        this[type + "Attached"] = true;

        if (wasRenderable !== this.isRenderable()) {
            this.compileMaterial();
            this.compileGeometry();
            if (this.morphAttached) {
                this.compileMorph();
            }
            this.setBackfaces(this.backfaces);
            this.setAddBlend(this.addBlend);
            this.setLayer(this.layer);
            this.object.checkRenderable();
        } else if (this.isRenderable()) {
            this.compileMorph();
        }

        if (type === "morph" || (type === "geometry" && !this.morph)) {
            this.boundary = asset.boundary;
        }
    };

    Renderable.prototype.detachGeometry = function () {
        if (!this.geometryNode) {
            return;
        }
        this.geometryNode.splice();
        this.geometryNode.destroy();
        this.geometryNode = null;
        this.geometryAttached = false;
        Human.assets.putAsset(this.geometryId);
    }; 

    Renderable.prototype.detachMaterial = function () {
        if (this.materialNode) {
            this.materialNode.splice();
            this.materialNode.destroy();
            this.materialNode = null;
        }

        if (this.textureNodes) {
            for (var i = 0, len = this.textureNodes.length; i < len; ++i) {
                this.textureNodes[i].splice();
                this.textureNodes[i].destroy();
            }
            this.textureNodes = null;
        }

        if (this.fresnelNodes) {
            for (var type in this.fresnelNodes) {
                this.fresnelNodes[type].splice();
                this.fresnelNodes[type].destroy();
            }
            this.fresnelNodes = null;
        }

        if (this.reflectionNode) {
            this.reflectionNode.splice();
            this.reflectionNode.destroy();
            this.reflectionNode = null;
        }

        if (this.lightMapNode) {
            this.lightMapNode.splice();
            this.lightMapNode.destroy();
            this.lightMapNode = null;
        }

        this.materialAttached = false;
        Human.assets.putAsset(this.materialId);
    };

    Renderable.prototype.detachMorph = function () {
        if (!this.morphNode) {
            return;
        }
        this.morphNode.splice();
        this.morphNode.destroy();
        this.morphNode = null;
        this.morphAttached = false;
        Human.assets.putAsset(this.morphId);
    };    

    Renderable.prototype.disconnectGeometry = function () {
        if (!this.geometryNode) {
            return;
        }
        
        Human.renderer.graph.disconnectNode(this.geometryNode);
        this.geometryNode = null;
        this.geometryAttached = false;
    }; 

    Renderable.prototype.disconnectMaterial = function () {
        if (this.materialNode) {
            Human.renderer.graph.disconnectNode(this.materialNode);
            this.materialNode = null;
        }

        if (this.textureNodes) {
            for (var i = 0, len = this.textureNodes.length; i < len; ++i) {
                Human.renderer.graph.disconnectNode(this.textureNodes[i]);
            }
            this.textureNodes = null;
        }

        if (this.fresnelNodes) {
            for (var type in this.fresnelNodes) {
                Human.renderer.graph.disconnectNode(this.fresnelNodes[type]);
            }
            this.fresnelNodes = null;
        }

        if (this.reflectionNode) {
            Human.renderer.graph.disconnectNode(this.reflectionNode);
            this.reflectionNode = null;
        }

        if (this.lightMapNode) {
            Human.renderer.graph.disconnectNode(this.lightMapNode);
            this.lightMapNode = null;
        }
        this.materialAttached = false;
    };

    Renderable.prototype.disconnectMorph = function () {
        if (!this.morphNode) {
            return;
        }
        Human.renderer.graph.disconnectNode(this.morphNode);
        this.morphNode = null;
        this.morphAttached = false;
    };    

    Renderable.prototype.isRenderable = function () {
        return !!(this.materialAttached && this.geometryAttached);
    };

    Renderable.prototype.getRenderObject = function () {
        if (this.geometryNode) {
            return this.geometryNode.getObject();
        } else {
            return null;
        }
    };

    Renderable.prototype.isTransparent = function () {
        var renderObject = this.getRenderObject();
        if (renderObject) {
            return renderObject.isTransparent();
        } else {
            return false;
        }
    };

    Renderable.prototype.setBackfaces = function (bf) {
        bf = bf && !this.isTransparent();
        this.backfaces = bf; 
        if (this.geometryNode) {
            this.geometryNode.setBackfaces(this.backfaces);
        }
    };

    Renderable.prototype.setAddBlend = function (ab) {
        this.addBlend = ab; 
        if (this.geometryNode) {
            this.geometryNode.setAddBlend(this.addBlend);
        }
    };

    Renderable.prototype.setLayer = function (l) {
        this.layer = l; 
        if (this.geometryNode) {
            this.geometryNode.setLayer(this.layer);
        }
    };

    Renderable.prototype.setGeometry = function(geometryId) {
        this.disconnectGeometry();
        this.geometryId = geometryId;
        this.geometryAttached = true;
        this.compileGeometry();
    };

    Renderable.prototype.setMaterial = function(materialId) {
        this.disconnectMaterial();
        this.materialId = materialId;
        this.materialAttached = true;
        this.compileMaterial();
    };

    Renderable.prototype.attachDrawTexture = function(texture){
        this.drawTexture = Human.renderer.graph.insertNode(this.rootNode, texture);
    };

    Renderable.prototype.compileGeometry = function () {
        var geometryAsset = Human.assets.geometries.geometries[this.geometryId];

        if (!geometryAsset) {
            return;
        }

        this.geometryNode = Human.renderer.graph.insertNode(this.rootNode, {
            type: "geometry",
            coreId: geometryAsset.geometry.getCoreId()
        });
        var self = this;
        this.geometryNode.onObjectCreate = function(renderObject) {
            if (self.isTransparent()) {
                self.setBackfaces(self.backfaces);
            }
            renderObject.sortTieBreaker = self.id;
        };
        this.object.geoDirty = true;
    };

    Renderable.prototype.compileMaterial = function () {
        var material = Human.assets.materials.materials[this.materialId];

        if (!material) {
            return;
        }

        if (material.textures) {
            var textures = material.textures;
            this.textureNodes = [];

            var iTexture;
            var lenTextures;
            for (iTexture = 0, lenTextures = textures.length; iTexture < lenTextures; iTexture++) {
                if (textures[iTexture]) {
                    this.textureNodes.push(
                        Human.renderer.graph.insertNode(this.rootNode, {
                            type: "texture",
                            coreId: textures[iTexture].getCoreId()
                        })
                    );
                }
            }
        }

        if (material.material) {
            this.materialNode = Human.renderer.graph.insertNode(this.rootNode, {
                type: "material",
                coreId: material.material.getCoreId()
            });
        }

        if (material.flags) {
            var flags = Human.utils.apply(material.flags, this.object._propertiesNode.getProperties());

            if (flags.frontface !== undefined) {
                this.object.windingOrder = flags.frontface;
            }

            if (flags.backfaces !== undefined) {
                this.setBackfaces(flags.backfaces);
            }

            if (flags.addBlend !== undefined) {
                this.setAddBlend(flags.addBlend);
            }

            this.object._propertiesNode.setProperties(flags);
        }

        if (material.reflection) {
            this.reflectionNode = Human.renderer.graph.insertNode(this.rootNode, {
                type: "cubemap",
                coreId: material.reflection.getCoreId()
            });
        }

        if (material.lightmap) {
            this.lightMapNode = Human.renderer.graph.insertNode(this.rootNode, {
                type: "cubemap",
                coreId: material.lightmap.getCoreId()
            });
        }

        if (material.fresnels) {
            var fresnels = material.fresnels;
            this.fresnelNodes = {};
            for (var type in fresnels) {
                if (fresnels.hasOwnProperty(type)) {
                    this.fresnelNodes[type] = Human.renderer.graph.insertNode(this.rootNode, {
                        type: "fresnel",
                        coreId: fresnels[type].getCoreId()
                    });
                }
            }
        }

        if (material.glassFactor !== undefined) {
            this.object.setGlassFactor(material.glassFactor);
        }

        if (material.murkiness !== undefined) {
            this.object.setMurkiness(material.murkiness);
        }
    };

    Renderable.prototype.compileMorph = function () {
        var morphAsset = Human.assets.morphs.morphs[this.morphId];

        if (!morphAsset) {
            return;
        }

        this.morphNode = Human.renderer.graph.insertNode(this.rootNode, {
            type: "morphGeometry",
            coreId: morphAsset.morphGeometry.getCoreId()
        });

        this.object.geoDirty = true;
    };

    Renderable.prototype.isAttached = function () {
        return this.object.renderables.indexOf(this) > -1;
    };

})();;/** Set Operations and Getters on key-value maps
 * Compares membership of keys between two maps.
 * Returns a new map.
 *
 * Membership is determined by map key by defualt.
 * Optional function to return the value associated with member key in final set; if null
 * the key-value pair will be ignored entirely.
 * Function can return 'null' (and only null) to override otherwise matching keys.
 *
 * NOTES:
 *   - If using objectIds as keys, assume that the objectds have been globalized.
 *   - Assumes set arguemnts are hash-maps (objects with no non-native function properties).
 *   - Assumes maps are not hierarchical i.e. each map value is a simple key-value map with native value types.
 *   - No assumption that values have to have the same properties.
 *   - Presrve optional selector functions where appropriate.
 *   - Support values of type "boolean" and of type "objects"
 *
 * TODO: We could consider making the below functions prototypes of a custom Human Object Set class.
 *  That way we could do operation chaining.
 *
 * TODO: Expand "*" placeholders if present.
 *
 * TODO: Make sure the original sets aren't being altered.
*/
(function () {
    "use strict";
    var sets = Human.scene.sets = {};

    // -------------- DEFAULTS ----------------------------------------------
    // Prefer item2 if it exists;
    var defaultSelector = function(item1, item2){
      // Allow for item1, item2 to be of type "booleans" as well as of type "objects".
      var ignoreValues = [null, undefined];
      if (ignoreValues.indexOf(item2) < 0) {
        return item2;
      }
      else if (ignoreValues.indexOf(item1) < 0){
        return item1;
      }
      else {
        return null;
      }
    };

    // Check for item in set keys.
    var defaultSetMembership = function(item, key){
      return (key === item)? true : false;
    };

    // --------------- GETTERS -----------------------------------------------

    /** Get list of all keys.
     * Returns a list of unique keys.
     * Optional Selector to filter keys.
    */
    sets.keys = function(aset, fnSelector){
      fnSelector = fnSelector || false;
      var oKeys = Object.keys(aset);

      var result = [];
      if (!fnSelector){
        result = oKeys; // return all keys
      } else {
        oKeys.forEach(function(key){
          if (fnSelector(key)){
            result.push(key);
          }
        });
      }
      return result;
    };


    /** Get subset of keys containing a regular expression
     * Returns a list of keys satisfying a regular expression.
    */
    sets.filterKeys = function(aset, regexp){
      var pattern;
      var result = [];
      // Ensure regular expression
      if (regexp instanceof RegExp){
        pattern = regexp;
      } else {
        try {
          pattern = new RegExp(regexp);
        }
        catch (err){
          return {};
        }
      }

      var isok = function(key){
        return pattern.test(key);
      };

      result = sets.keys(aset).filter(isok);
      return result;

    };

    /** Get list of keys where value satisfied a condition
     * fnCondition(value) returns true if value satisfies some condition.
    */
    sets.keysWhere = function(aset, fnCondition){
      var result = [];
      for (var key in aset){
        if (aset.hasOwnProperty(key)){
          if (fnCondition(aset[key])){
            result.push(key);
          }
        }
      }
      return result;
    };

    /** Get membership status of key in set.
     * Returns true/false if key is a member of aset.
    */
    sets.hasKey = function(aset, key){
      var keys = sets.keys(aset);
      if (keys.indexOf(key)>=0){
        return true;
      } else {
        return false;
      }
    };

    /** Return Iterator over key,value pairs of set
    */
    sets.getSetIterator = function(set){

      var index = 0, keys = sets.keys(set), length = keys.length;

      return {
        next: function(){
            var item;
            if (!this.hasNext()){ return null;}
            var key = keys[index];
            item = {"key":key,"value":set[key]};
            index ++;
            return item;
        },
        hasNext: function(){ return index < length;},
        rewind: function(){index=0; return set[keys[0]];},
        current: function(){
          return set[keys[index]];
        }
      };
    };

    /** Get list of all values
     * Returns a list of values for each unique key in set.
     * The order of values will match the order of keys.
    */
    sets.values = function(aset){
      var keys = sets.keys(aset);
      var result = [];
      keys.forEach(function(key){
        result.push(aset[key]);
      });
      return result;
    };

    /** Get list of keys in EITHER set1 OR set2
     * NOTE: http://stackoverflow.com/questions/1723168/what-is-the-fastest-or-most-elegant-way-to-compute-a-set-difference-using-javasc
    */
    sets.jointKeys = function(set1, set2){
      var h = {}, f = function (v) { h[v] = true; };
      var keySet1 = sets.keys(set1);
      var keySet2 = sets.keys(set2);
      keySet1.forEach(f);
      keySet2.forEach(f);
      return sets.keys(h);
    };

    /** Get list of intersecting keys in BOTH set1 AND set2
    */
    sets.commonKeys = function(set1, set2){
      var h = {};
      var keySet1 = sets.keys(set1);
      var keySet2 = sets.keys(set2);
      keySet1.forEach(function(v){ h[v] = 1; });
      keySet2.forEach(function(v){ h[v] = (h[v] || 0) + 1; });
      return sets.keysWhere(h, function(v){ return v>1? true : false;});
    };

    /** Get list of keys IN set1 but NOT in set2
    */
    sets.uniqueKeys = function(set1, set2){
      var h = {};
      var f1 = function(v){h[v] = 1;};
      var f2 = function(v){h[v] = 0;};
      var keySet1 = sets.keys(set1);  // order matters
      var keySet2 = sets.keys(set2);  // set 2 comes after set 1!!
      keySet1.forEach(f1);
      keySet2.forEach(f2);
      return sets.keysWhere(h, function(v){return v>0? true: false;});
    };

    //--------------------- SET OPERATIONS -------------------------------------

    /** Get union of key-value pairs
     * Returns new key-value map with keys jointly in set1 and set2
     *
     * Optional Argument: fnSelector() function
     *  - selector = function(itemSet1,itemSet2);
     *  - returns value made from properties of itemSet1 and itemSet2
    */
    sets.union = function(set1, set2, fnSelector){
      var uKeys, union = {};
      var ph = null; // placeholder

      // Setup default selector function.
      if (!fnSelector){
        fnSelector = defaultSelector;
      }

      // Get joint keys and set the desired value to each key.
      uKeys = sets.jointKeys(set1, set2);
      uKeys.forEach(function(key){
        ph = fnSelector(set1[key], set2[key]);
        if (ph !== null){
          union[key] =  ph;
        }
      });
      return union;
    };

    /** Get intersection of key-value pairs
    */
    sets.intersection = function(set1, set2, fnSelector){
      var iKeys, intersection = {}, ph = null;
      if (!fnSelector){
        fnSelector = defaultSelector;
      }

      // Get intersecting keys and the preferred value;
      iKeys = sets.commonKeys(set1, set2);
      iKeys.forEach(function(key){
        ph = fnSelector(set1[key], set2[key]);
        if (ph !== null) {
          intersection[key] = ph;
        }
      });
      return intersection;
    };

    /** Get elements in set1 that are NOT in set 2
    * fnSelector can return null to prohibit key-value pair.
    */
    sets.difference = function(set1, set2, fnSelector){
      var unqKeys = sets.uniqueKeys(set1, set2), ph=null;
      if (!fnSelector){
        fnSelector = defaultSelector;
      }
      var uniqueToSet1 = {};
      unqKeys.forEach(function(key){
        ph = fnSelector(set1[key]);
        if (ph !== null){
          uniqueToSet1[key] = ph;
        }
      });
      return uniqueToSet1;
    };

    /** Ask if item is contained in set
     * fnSatisfy(item, key, value): returns true if item satisfied a condition.
     *   Default tests membership of key in set.
    */
    sets.isin = function(item, set1, fnSatisfy){
      if (!fnSatisfy){
        fnSatisfy = defaultSetMembership;
      }

      var found = false;
      var setIter = sets.getSetIterator(set1);
      var kvp;
      while (setIter.hasNext() && !found){
        kvp = setIter.next();
        found = fnSatisfy(item, kvp.key, kvp.value);
      }
      return found;
    };

    // -------------------- SET OPERATIONS ON Directed Acyclic Graphs ----------
    // TODO: Expand the set operations to consider hierarchical sets in a Directed Acyclic Graph.


  })();
;(function() {
    "use strict";

    var graph = Human.scene.graph = {};

    // Store attached assets by type for a given sesssion
    var attachedAssets = {};
    var numRequestedAssets = 0;
    var numAttachedAssets = 0;

    // Used to map the old anonymous object IDs to a renderable index
    var anonymousRenderableCount = 0;

    var typesToDetach = {}; // HACK to selectively detach assets from tree

    // Simple Graph Construction from fully specified scene graph
    graph.buildGraph = function(objects, parent) {
        // Exit if no objects
        if (!objects) {
            return;
        }

        if (!parent) {
            // Reset for each scene graph load
            anonymousRenderableCount = 0;
        }

        var object, humanObject;
        for (var i = 0; i < objects.length; i++) {
            object = objects[i];

            collapseAnonymousObjects(object);

            // Anonymous objects
            if (!object.objectId) {
                object.objectId = parent.objectId + anonymousRenderableCount++;
                object.anonymous = true;
            }

            object.group = object.objects && object.objects.length > 0;
            humanObject = createHumanObject(object, parent);

            if (humanObject === null) {
                continue;
            }
            
            if (object.objects){
                graph.buildGraph(object.objects, humanObject);
            }
        }

    };

    function createHumanObject(object, parent) {

        var objectId = object.objectId;

        var geometryId = object.geometryId || null;
        var morphId = object.morphId || null;
        var materialId = object.materialId || null;
        var transformId = object.transformId || null;

        // Do not overwrite existing objects
        if (Human.scene.objects[objectId]) {
            return null;
        }

        // Inherit parent layer if necessary
        if (object.layer === undefined) {
            object.layer = parent ? parent.layer : 0;
        }

        object.objectId = objectId;

        object.parent = parent;
        object.parentObjectId = parent ? parent.objectId : null;
        object.materialId = materialId;
        object.geometryId = geometryId;
        object.morphId = morphId;
        object.transformId = transformId;
        object.tags = object.tags || [];
        object.capColor = inherit("capColor", object, parent);
        object.modelId = object.objectId.split("-")[0];

        var sceneObject = Human.scene.createObject(object);

        if (object.opacity !== undefined) {
            sceneObject.setOpacity(object.opacity);
        }

        if (object.shown !== undefined) {
            sceneObject.show(object.shown);
        }

        return sceneObject;
    }


    /* Gather asset ids from a portion of the scene graph
     *
     *  return value format format:
     *      {
     *          "geometry": {
     *              "geometryId1": [target_object_id, ...],
     *              "geometryId2": [target_object_id, ...]
     *              // etc...
     *          }
     *          // etc...
     *      }
     *
     *  Result can be provided to gradually gather asset Ids over several
     *  calls.
     */

    graph.gatherAssetIdsFromObject = function(objects, types, result) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        types = types || ["geometry", "material", "transform", "morph"];

        result = result || {};

        for (var i = 0, len = objects.length; i < len; i++) {
            gatherAssetIdsFromObject(objects[i], types, result);
        }

        return result;
    };

    graph.attachAssetsToObject = function(objects, types, ok) {
        if (typeof types === "function") {
            ok = types;
            types = null;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        types = types || ["geometry", "material", "transform", "morph"];

        var assetsLoading = 0;

        function done() {
            if (--assetsLoading === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = objects.length; i < len; i++) {
            var assetIds = graph.gatherAssetIdsFromObject(objects[i], types);
            assetsLoading++;
            graph.attachAssets(assetIds, done);
        }
    };

    /**
    *   This function encapsulates a common loading pattern where
    *   where assets are meant to be loaded in "phases" (e.g.
    *   geometry, transforms, materials first, then morphs later).
    *   By default, the phases will be:
    *   - Phase 1: geometry, materials, transforms
    *   - Phase 2: morphs
    *
    *   It will load subtrees of the argument objects and traverses up
    *   up the scenegraph from those objects to properly load hierarchical
    *   transforms.
    *
    *   Arguments:
    *   [array of objects]  objects     The roots of subtrees to attach assets to.
    *   [array of arrays]   typeSets    Groups of types to load per phase (e.g. [[["geometry", "material", "transform"], ["morph"]])
    *   [function]          ok          Callback function to call after each phase.
    *
    *   Note that the callback function is called after each phase, so
    *   it will be called multiple times. At each phase, the following arguments
    *   are passed to the callback function:
    *   [object]            typesLoaded A map of the asset types that were loaded.
    *   [number]            i           The index of the current phase
    *   [boolean]           done        Is this the last phase?
    */
    graph.attachAssetSetsToSubtree = function(objects, typeSets, ok) {
        if (typeof typeSets === "function") {
            ok = typeSets;
            typeSets = null;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        typeSets = typeSets || [["geometry", "material", "transform"], ["morph"]];

        var assetObjects = {};
        var orderedAssetObjects = [];
        var leafObjects = {};
        var objectId, object;

        function registerLeaf(leaf) {
            leafObjects[leaf.objectId] = leaf;
        }

        function registerObjectId(object) {
            if(!assetObjects[object.objectId]) {
                orderedAssetObjects.push(object);
                assetObjects[object.objectId] = true;
            }
        }

        for (var i = 0; i < objects.length; i++) {
            objects[i].getLeafObjects(registerLeaf);
        }

        for (objectId in leafObjects) {
            if (leafObjects.hasOwnProperty(objectId)) {
                object = leafObjects[objectId];

                if (object) {
                    // Traverse up for transforms
                    object.traverseUp(registerObjectId);
                }
            }
        }

        attachTypeSets(orderedAssetObjects, typeSets, 0, ok);
    };

    function attachTypeSets(assetObjects, typeSets, phase, ok) {
        var typeSet = typeSets.shift();

        attachTypeSet(assetObjects, typeSet, function () {
            if(ok) {
                var typesLoaded = {};
                for (var i = 0, len = typeSet.length; i < len; i++) {
                    typesLoaded[typeSet[i]] = true;
                }
                ok(typesLoaded, phase, !typeSets.length);
            }

            if(typeSets.length) {
                attachTypeSets(assetObjects, typeSets, phase + 1, ok);
            }
        });
    }

    function attachTypeSet(assetObjects, typeSet, ok) {
        var numObjects = assetObjects.length;
        var object;

        if (numObjects === 0) {
            if (ok) {
                Human.utils.async(ok);
            }
            return;
        }

        function done() {
            if (--numObjects === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = numObjects; i < len; i++) {
            object = assetObjects[i];

            graph.attachAssetsToObject(object, typeSet, done);
        }
    }

    /** This function Loads the asset from Object Server.
    *   Then applies the asset to the Scene Graph
    */
    graph.attachAssets = function(assetIds, ok) {
        var assetsLoading = 0;

        function done() {
            if (--assetsLoading === 0 && ok) {
                ok();
            }
        }

        var keys = Object.keys(assetIds);

        if (keys.length === 0) {
            if (ok) {
                Human.utils.async(ok);
            }
            return;
        }

        for (var i = 0, len = keys.length; i < len; i++) {
            var type = keys[i];
            var typeAssets = assetIds[type];

            if (!typeAssets) {
                continue;
            }

            for (var assetId in typeAssets) {
                if (typeAssets.hasOwnProperty(assetId)) {
                    var targetObjects = typeAssets[assetId];

                    assetsLoading++;
                    getAsset(assetId, type, targetObjects, done);
                }
            }
        }
    };

    /**
     * Removes assets from target objects.
     * @param objectIds
     */
    graph.destroySubtree = function(objects) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var i;
        var len;
        var object;

        for (i = 0, len = objects.length; i < len; i++) {
            object = objects[i];

            Human.scene.destroyObject(object.objectId);
        }
    };

    /**
     * Removes assets  of type specified in assetTypes from tree. Does not modify the tree itself.
     * @param objectIds
     */
    graph.unloadSubtree = function(objects, assetTypes, ok) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var i;
        var len;
        var object;

        // Configure types to detach
        typesToDetach = {};
        if (assetTypes.indexOf("geometries")>=0){
            typesToDetach.geometryId = true;
        }
        if (assetTypes.indexOf("transforms")>=0){
            typesToDetach.transformId = true;
        }
        if (assetTypes.indexOf("morphs")>=0){
            typesToDetach.morphId = true;
        }
        if (assetTypes.indexOf("materials")>=0){
            typesToDetach.materialId = true;
        }

        if (assetTypes.indexOf("morph")>=0) {
          typesToDetach.morphId = true;
        }

        for (i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            object.getLeafObjects(destroyAssets);
        }
        if (ok){
            ok();
        }
    };

    function destroyAssets(object) {
        // HACK Configured by scoped variable "typesToDetach"
        if (typesToDetach.geometryId) {
            object.detachAsset("geometry");
        }

        if (typesToDetach.materialId) {
            object.detachAsset("material");
        }

        if (typesToDetach.transformId) {
            object.detachAsset("transform");
        }

        if (typesToDetach.morphId) {
            object.detachAsset("morph");
        }
    }

    function gatherAssetIdsFromObject(object, types, assetIds) {
        for (var i = 0, len = types.length; i < len; i++) {
            var type = types[i];
            var assetList;

            if (type === "transform") {
                var transformId = object.transformId;
                if (transformId && !object.transformInitialized) {
                    assetIds.transform = assetIds.transform || {};

                    assetList = assetIds.transform[transformId] = assetIds.transform[transformId] || [];
                    assetList.push(object);
                }
            } else if (object.renderables) {
                for (var j = 0, lenJ = object.renderables.length; j < lenJ; ++j) {
                    var renderable = object.renderables[j];
                    var assetId = renderable[type + "Id"];
                    var attached = renderable[type + "Attached"];

                    if(assetId && !attached) {
                        assetIds[type] = assetIds[type] || {};

                        assetList = assetIds[type][assetId] = assetIds[type][assetId] || [];
                        assetList.push(renderable);
                    }
                }
            }
        }

        return assetIds;
    }

    function assetAttachStart() {
        Human.events.fire("graph.assetAttach.start");
    }

    function assetAttachProgress(assetId, type, targetObjects, nullAsset) {
        numAttachedAssets++;

        Human.events.fire("graph.assetAttach.progress", {
            assetId: assetId,
            targetObjects: targetObjects,
            assetType: type,
            nullAsset: nullAsset
        });

        if(!attachedAssets[type]) {
            attachedAssets[type] = [];
        }

        if(!nullAsset) {
            attachedAssets[type].push(assetId);
        }

        if(numRequestedAssets === numAttachedAssets) {
            assetAttachFinish();
        }
    }

    function assetAttachFinish() {
        Human.events.fire("graph.assetAttach.finish", attachedAssets);

        attachedAssets = {};
        numRequestedAssets = 0;
        numAttachedAssets = 0;
    }

    function getAsset(assetId, type, targetObjects, ok) {
        if(numRequestedAssets === 0) {
            assetAttachStart();
        }

        numRequestedAssets++;

        Human.assets.getAsset(assetId, type, function(asset) {

            if (asset) {
                for (var i = 0, len = targetObjects.length; i < len; i++) {
                    if (type === "transform") {
                        var object = targetObjects[i];

                        // Was object destroyed in the meantime?
                        if(Human.scene.objects[object.objectId]) {
                            object.setTransform(asset);
                        }
                    } else {
                        var renderable = targetObjects[i];
                        renderable.attachAsset(type, asset);
                    }
                    
                }
            }

            assetAttachProgress(assetId, type, targetObjects, !asset);

            ok(asset);
        });
    }

    function inherit(prop, object, parent) {
        if (parent) {
            if (object[prop] !== undefined && object[prop] !== null) {
                return object[prop];
            }
            return parent[prop];

        }
        return object[prop];
    }

    // NOTE(Tarek): Some nastiness to deal with the old anonymous
    // object ID that got into bookmarks.
    function collapseAnonymousObjects(object) {
        if (!object.objects) {
            return;
        }

        if (!object.objectId) {
            return;
        }

        var renderables;
        
        for (var i = 0, len = object.objects.length; i < len; ++i) {
            if (!object.objects[i].objectId) {
                renderables = [];
                break;
            }
        }

        if (renderables && canCollapse(object)) {
            object.anonymousIdToRenderableIndex = {};
            gatherAnonymousRenderables(object, renderables, object);
            object.renderables = renderables;
            object.objects.length = 0;
        }
    }

    // Can't collapse if descendents have objectIds or transformIds
    function canCollapse(object) {
        if (!object.objects) {
            return true;
        }

        for (var i = 0, len = object.objects.length; i < len; ++i) {
            var child = object.objects[i];
            if (child.transformId || child.objectId || child.pivot || child.translate || 
                child.scale || child.rotate || !canCollapse(child)) {
                return false;
            }
        }

        return true;
    }

    function gatherAnonymousRenderables(object, renderables, root) {
        if (!object.objects) {
            return;
        }
        for (var i = 0, len = object.objects.length; i < len; ++i) {
            var child = object.objects[i];
            if (child.layer === undefined) {
                child.layer = object.layer;
            }
            if (child.geometryId) {
                root.anonymousIdToRenderableIndex[root.objectId + anonymousRenderableCount++] = renderables.length;
                renderables.push({
                    geometryId: child.geometryId,
                    materialId: child.materialId,
                    morphId: child.morphId,
                    layer: child.layer
                });
            } else {
                anonymousRenderableCount++;
                gatherAnonymousRenderables(child, renderables, root, root.objectId);
            }
        }
    }

})();
;/*
Track markers in the 3D scene.
Markers can be on tracking objects or floating in space.

NOTE:
1 - only leaf nodes are locatable
2 - expensive occlusion tests are done once every TICKS_PER_UPDATE ticks.
*/
(function(){
    "use strict";
    var Markers = Human.scene.markers = {};

    var markerCount = 0;
    var markerIdPrefix = "marker_";
    var TICKS_PER_UPDATE = 2;
    var tickCount = 0;

    Markers.markers = {}; // key: markerId, value: Marker

    // Responsive Creation
    var waitingForRenderable = {}; // key:objectId, value: Marker
    var waiting = false;
    var defaultBarycentric = vec3.fromValues(0.33, 0.33, 0.33);

    // miscellaneous gl-matrix objects
    var t1vec3 = vec3.create();
    var t2vec3 = vec3.create();
    var t1mat4 = mat4.create();
    var eyePosVec = vec3.create();

    // create a unique id for the marker locator
    function createMarkerId(){
        var id = markerIdPrefix + markerCount;
        markerCount++;
        return id;
    }

    // add Marker object to waitingForRenderable map
    function _addToWaiting(objectId, marker){
        if (waitingForRenderable[objectId]) {
            waitingForRenderable[objectId].push(marker);
        } else {
            waitingForRenderable[objectId] = [marker];
        }
        waiting = true;
    }

    // build any markers whose object's are now ready
    function _buildReady(){
        var objectId, obj, i, mrkrlist;
        var count = 0;
        for (objectId in waitingForRenderable){
            ++count;
            mrkrlist = waitingForRenderable[objectId];
            obj = Human.scene.objects[objectId];
            if (obj && obj.isVisible()) {
                for (i=0; i < mrkrlist.length; i++){
                    mrkrlist[i].build();
                }
                delete waitingForRenderable[objectId];
                --count;
            }
        }
        waiting = count > 0;
    }

    /** Marker Object
     *
     * Marker that tracks an object
     * (id):string
     * objectId: string
     * (primitiveIndex): integer
     * (barycentric): [integer, integer, integer]
     * (pos): [float, float, float]
     * (dir): [float, float, float]
     *
     * Marker that floats in space
     * (id):string
     * pos: [float, float, float]
     * (dir): [float, float, float]
     */
    var Marker = function(cfg){
        var self = this;
        self.id = cfg.id || createMarkerId();
        self.pos = vec3.create(); // world position of marker
        this.viewPos = vec3.create();
        self.dir = vec3.create();

        if (cfg.pos) {
            // initial position in world space
            self.pos[0] = cfg.pos[0];
            self.pos[1] = cfg.pos[1];
            self.pos[2] = cfg.pos[2];
        }
        if (cfg.dir){
            self.dir[0] = cfg.dir[0];
            self.dir[1] = cfg.dir[1];
            self.dir[2] = cfg.dir[2];
            vec3.normalize(self.dir, self.dir);
        }

        self.viewAngle = 0;
        self.canvasPos = vec2.fromValues(0, 0);
        self.built = false;
        self.occluded = false;
        self.objectCentered = false;
        self.renderableIndex = -1;
        self.primitiveIndex = -1;
        self.barycentric = null;

        if (cfg.objectId && Human.scene.objects[cfg.objectId]){
            // Shape Based Marker: Build now or defer until object assets load
            self.object = Human.scene.objects[cfg.objectId];
            self.modelPos = vec3.create();
            if (cfg.primitiveIndex !== undefined){
                self.renderableIndex = cfg.renderableIndex !== undefined ? cfg.renderableIndex : 0;
                self.primitiveIndex = cfg.primitiveIndex;
                var b = cfg.barycentric || defaultBarycentric;
                self.barycentric = vec3.fromValues(b[0], b[1], b[2]);
            } else if (!cfg.pos) {
                self.objectCentered = true;
            }


            if (self.object.isRenderable()){
                self.build();
            } else {
                _addToWaiting(cfg.objectId, self);
            }
        } else if (cfg.pos){
            // World Based Marker: Build now
            self.build();
        } else {
            Human.log.error("Human.scene.marker","marker configuration requires 'objectId' or 'pos' parameter.");
            return;
        }
    };

    // build marker now that its dependencies are loaded
    Marker.prototype.build = function(){
        var self = this;
        if (self.built){
            return;
        }
        // set the marker position
        if (self.primitiveIndex !== -1){
            self.object.barycentricToModelSpace(self.renderableIndex, self.primitiveIndex, self.barycentric, self.modelPos);
            vec3.transformMat4(self.pos, self.modelPos, self.object.getWorldMatrix());
        } else if (self.object && !self.objectCentered) {
            // world-space definition => to model space
            mat4.invert(t1mat4, self.object.getWorldMatrix());
            vec3.transformMat4(self.modelPos, self.pos, t1mat4);
        } else if (self.objectCentered){
            // use object center
            var center = self.object.getCenter();
            self.pos[0] = center[0];
            self.pos[1] = center[1];
            self.pos[2] = center[2];
            mat4.invert(t1mat4, self.object.getWorldMatrix());
            vec3.transformMat4(self.modelPos, self.pos, t1mat4);
        }

        // view angle depends on marker position
        self.updatePosition();
        self.updateViewAngle();
        self.updateOcclusion();
        self.built = true;
    };

    // marker position tracks object deformation and position
    Marker.prototype.updatePosition = function(){
        var self = this;

        // morph animation update
        if (self.primitiveIndex !== -1){
            self.object.barycentricToModelSpace(self.renderableIndex, self.primitiveIndex, self.barycentric, self.modelPos);
        }

        // transform animation update
        if (self.modelPos){
            vec3.transformMat4(self.pos, self.modelPos, self.object.getWorldMatrix());
        }

        vec3.transformMat4(self.viewPos, self.pos, Human.renderer.getViewMat());
        // position in screen space
        Human.renderer.worldPositionToCanvas(self.pos, self.canvasPos);
    };

    // marker view angle changes with camera change
    Marker.prototype.updateViewAngle = function(){
        if (this.objectCentered) {
            this.viewAngle = 0;
            return;
        }

        // update the direction the marker points to the camera
        var eyePos = Human.renderer.camera.eye;
        eyePosVec.set([eyePos.x, eyePos.y, eyePos.z]);
        vec3.subtract(t1vec3, eyePosVec, this.pos);
        vec3.normalize(t1vec3, t1vec3);
        var dot = Math.min(vec3.dot(t1vec3, this.dir), 1);
        this.viewAngle = Math.acos(dot) * 57.2957795;
    };

    // marker occlusion is true if marker is blocked by a human object in the scene or outside of screen space
    Marker.prototype.updateOcclusion = function(){
        this.occluded = this.isOccludedByObject() || this.isOffScreen();
    };

    Marker.prototype.isOccludedByObject = function(){
        if (this.objectCentered) {
            return false;
        }

        var eye, dist, eps, rec, hit;

        // ray origin: t1vec3
        eye = Human.renderer.camera.eye;
        t1vec3[0] = eye.x;
        t1vec3[1] = eye.y;
        t1vec3[2] = eye.z;

        // ray direction: t2vec3
        vec3.sub(t2vec3, this.pos, t1vec3);
        dist = vec3.length(t2vec3);
        eps = Math.min(dist * 0.1, 0.5);
        rec = 1 / dist;
        t2vec3[0] *= rec;
        t2vec3[1] *= rec;
        t2vec3[2] *= rec;

        // intersection test: from ray origin in ray direction
        hit = Human.math.intersections.rayScene(t1vec3, t2vec3, function(object) {
            return object.shown && !object.culled;
        }, function(renderable) {
            return !renderable.isTransparent();
        });

        // compare hit distance to marker distance
        return !!(hit && hit.length && hit[0].t + eps < dist);
    };

    Marker.prototype.isOffScreen = function(){
        var cp = this.canvasPos;
        var w = Human.renderer.canvas.width;
        var h = Human.renderer.canvas.height;
        return cp[0] < 0 || cp[0] > w || cp[1] < 0 || cp[1] > h;
    };

    // create and register this marker
    Markers.create = function(markerConfig){
        var m = new Marker(markerConfig);
        Markers.markers[m.id] = m;
        Human.events.fire("scene.markers.added", {id: m.id});
        if (m.built){
            Human.events.fire("scene.markers.built",{id: [m.id]});
        }
        return m;
    };

    // remove and de-register this marker
    Markers.delete = function(markerId){
        delete Markers.markers[markerId];
        Human.events.fire("scene.markers.deleted", {id: markerId});
    };

    // finish creating the data for each Marker that is dependent on a Human Object
    Markers.buildByObjectId = function(objectId){
        var builtIds = [];
        if (waitingForRenderable[objectId]){
            var i,m;
            for (i=0; i<waitingForRenderable[objectId].length; i++){
                m = waitingForRenderable[objectId][i];
                m.build();
                builtIds.push(m.id);
            }
            delete waitingForRenderable[objectId];
        }
        Human.events.fire("scene.markers.built",{id: builtIds});
    };

    // update markers
    Markers.onFrame = function(){
        tickCount = (tickCount + 1) % TICKS_PER_UPDATE;

        // build
        if (waiting){
            _buildReady();
        }

        // do update
        var m;
        var updatedCount = 0;
        for (var markerId in Markers.markers){
            m = Markers.markers[markerId];
            if (m && m.built){
                m.updatePosition();
                m.updateViewAngle();
                if (tickCount === 0){
                    m.updateOcclusion();
                }
                ++updatedCount;
            }
        }
        // notify
        if (updatedCount > 0) {
            Human.events.fire("scene.markers.updated");
        }
    };

})();
;/* Color Modification Recipes.

Color/Opacity modfications are defined per-object to support fine-grained resolution of control.

Recipes are grouped modifications that can be applied to any collection of leaf nodes.
*/

(function(){
    'use strict';
    var HumanRecipes = Human.scene.colorRecipes = {};
    var ColorFresnel = window.ColorFresnel; // added to global namespace
    var ScalarFresnel = window.ScalarFresnel;

    // Recipe Configuration Data (for lighter encoding of recipe modifcations)
    // MOD_CHANNEL_ORDER = ['tintColor', 'saturation', 'contrast', 'brightness', 'opacity'];
    var TINT = 1 << 4;
    var SATURATION = 1 << 3;
    var CONTRAST = 1 << 2;
    var BRIGHTNESS = 1 << 1;
    var OPACITY = 1 << 0;

    var colorRecipeMods = {};

    // create mod array from recipe config
    function createModsFromConfig(recipeConfig) {

        var channelInt = recipeConfig.channels;
        var rvalues = recipeConfig.mods;

        var fresnelChannelInt = recipeConfig.fresnelChannels;
        var rFresnelValues = recipeConfig.fresnelMods;

        // get color modifcations
        var colorMods = [];
        var opacityMods = [];
        var idx=0;

        if (channelInt !== undefined && channelInt !== null) {
            if (channelInt & TINT) {
                colorMods.push({
                    applyTo: 'tintColor',
                    value: rvalues.slice(idx, idx += 3)
                });
            }
            if (channelInt & SATURATION) {
                colorMods.push({
                    applyTo: 'saturation',
                    value: rvalues.slice(idx, idx += 1)[0]
                });
            }
            if (channelInt & CONTRAST) {
                colorMods.push({
                    applyTo: 'contrast',
                    value: rvalues.slice(idx, idx += 1)[0]
                });
            }
            if (channelInt & BRIGHTNESS) {
                colorMods.push({
                    applyTo: 'brightness',
                    value: rvalues.slice(idx, idx += 1)[0]
                });
            }

            // get opacity modifications (NOTE: applyTo is implictly assumed but written here for convenience and consistency)
            if (channelInt & OPACITY) {
                opacityMods.push({
                    applyTo: 'opacity',
                    value: rvalues.slice(idx, idx += 1)[0]
                });
            }
        }

        idx=0; // reset index for fresnel color mods
        if (fresnelChannelInt !== undefined && fresnelChannelInt !== null) {
            if (fresnelChannelInt & TINT) {
                var colorFresnel = rFresnelValues.slice(idx, idx += 9);
                colorMods.push({
                    applyTo: 'tintColor',
                    value: new ColorFresnel(
                        [colorFresnel[0], colorFresnel[1], colorFresnel[2]], // center
                        [colorFresnel[3], colorFresnel[4], colorFresnel[5]], // edge
                        colorFresnel[6], // centerBias
                        colorFresnel[7], // edgeBias
                        colorFresnel[8]  // power
                    )
                });
            }
            if (fresnelChannelInt & SATURATION) {
                var saturationFresnel = rFresnelValues.slice(idx, idx += 5);
                colorMods.push({
                    applyTo: 'saturation',
                    value: new ScalarFresnel(
                        saturationFresnel[0], // center
                        saturationFresnel[1], // edge
                        saturationFresnel[2], // centerBias
                        saturationFresnel[3], // edgeBias
                        saturationFresnel[4]) // power
                });
            }
            if (fresnelChannelInt & CONTRAST) {
                var contrastFresnel = rFresnelValues.slice(idx, idx += 5);
                colorMods.push({
                    applyTo: 'contrast',
                    value: new ScalarFresnel(
                        contrastFresnel[0],
                        contrastFresnel[1],
                        contrastFresnel[2],
                        contrastFresnel[3],
                        contrastFresnel[4])
                });
            }
            if (fresnelChannelInt & BRIGHTNESS) {
                var brightnessFresnel = rFresnelValues.slice(idx, idx += 5);
                colorMods.push({
                    applyTo: 'brightness',
                    value: new ScalarFresnel(
                        brightnessFresnel[0],
                        brightnessFresnel[1],
                        brightnessFresnel[2],
                        brightnessFresnel[3],
                        brightnessFresnel[4])
                });
            }

            // get opacity modifications (NOTE: applyTo is implictly assumed but written here for convenience and consistency)
            if (fresnelChannelInt & OPACITY) {
                var opacityFresnel = rFresnelValues.slice(idx, idx += 5);
                opacityMods.push({
                    applyTo: 'opacity',
                    value: new ScalarFresnel(
                        opacityFresnel[0],
                        opacityFresnel[1],
                        opacityFresnel[2],
                        opacityFresnel[3],
                        opacityFresnel[4])
                });
            }
        }
        return {
            colorMods: colorMods,
            opacityMods: opacityMods
        };
    }

    // create recipe config from mods array
    function createConfigFromMods(recipeMods) {
        var channelInt = 0;
        var channelValues = [];
        recipeMods.colorMods.forEach(function(modConfig) {
            if (modConfig.applyTo === 'tintColor') {
                channelInt += TINT;
                // add all three values
                modConfig.value.forEach(function(v){
                    channelValues.push(v);
                });
            } else if (modConfig.applyTo === 'saturation') {
                channelInt += SATURATION;
                channelValues.push(modConfig.value[0]);
            } else if (modConfig.applyTo === 'contrast') {
                channelInt += CONTRAST;
                channelValues.push(modConfig.value[0]);
            } else if (modConfig.applyTo === 'brightness') {
                channelInt += BRIGHTNESS;
                channelValues.push(modConfig.value[0]);
            }
        });

        recipeMods.opacityMods.forEach(function(modConfig) {
            if (modConfig.applyTo === 'opacity') {
                channelInt += OPACITY;
                channelValues.push(modConfig.value[0]);
            }
        });

        return {
            channels: channelInt,
            mods: channelValues
        };
    }

    // name color modifier by recipe-channel combo
    function nameRecipeMod(recipeName, channel) {
        return recipeName + '_' + channel;
    }

    // Build a config from modifier set
    HumanRecipes.createConfigFromMods = function(recipeMods) {
        return createConfigFromMods(recipeMods);
    };

    // return names of all registered recipes
    HumanRecipes.getRecipes = function() {
        return Object.keys(colorRecipeMods);
    };

    // return recipe modifications
    HumanRecipes.getRecipeMods = function(recipeName) {
        if (colorRecipeMods.hasOwnProperty(recipeName)) {
            return Human.utils.shallowClone(colorRecipeMods[recipeName]);
        } else {
            Human.log.error("Human.scene.color-recipes", "No such color recipe : " + recipeName);
            return;
        }
    };

    // add named recipe configuration and build mods. Replace if exists and issue warning
    HumanRecipes.registerRecipe = function(recipeName, recipeConfig) {
        if (colorRecipeMods.hasOwnProperty(recipeName)) {
            Human.log.error("Human.scene.color-recipes", "Color mod recipe already exists : " + recipeName);
            return;
        }

        // build recipe modifications
        colorRecipeMods[recipeName] = createModsFromConfig(recipeConfig);
    };

    // clear of any stored recipes
    HumanRecipes.clearRecipes = function() {
        colorRecipeMods = {};
    };

    // remove a specific recipe (this does not un-apply recipes to any objects)
    HumanRecipes.removeRecipe = function(recipeName) {
        delete colorRecipeMods[recipeName];
    };

    // add/remove recipe to object
    HumanRecipes.setObjectRecipe = function(objectId, recipeName, set) {
        // get object
        var obj = Human.scene.objects[objectId];
        var mods = colorRecipeMods[recipeName];
        var modIdx, modConfig, modName;

        if (!obj || !mods){
            return;
        }

        // add/remove color modifications
        for (modIdx = 0; modIdx < mods.colorMods.length; modIdx++) {
            modConfig = mods.colorMods[modIdx];
            modName = nameRecipeMod(recipeName, modConfig.applyTo);
            obj.setColorModifier(modName, set? modConfig : null);
        }

        // set opacity modifications
        for (modIdx = 0; modIdx < mods.opacityMods.length; modIdx++) {
            modConfig = mods.opacityMods[modIdx];
            modName = nameRecipeMod(recipeName, modConfig.applyTo);
            if (set) {
                // add
                obj.setOpacityModifier(modName, modConfig);
            } else if (!set && obj.opacityModifiers[modName]) {
                // remove
                obj.setOpacityModifier(modName, null);
            }
        }
    };

    // return true if object is modified by given recipe
    HumanRecipes.hasTarget = function(recipeName, objectId) {
        var obj = Human.scene.objects[objectId];
        var mods = colorRecipeMods[recipeName];

        if (!obj || !mods) {
            return;
        }

        // first check color modifiers
        var hasRecipe = Object.keys(obj.colorModifiers).reduce(function(_hasRecipe, modifier){
            return _hasRecipe || modifier.startsWith(recipeName);
        }, false);

        // ... then combine with check for opacity modifiers
        return Object.keys(obj.opacityModifiers).reduce(function(_hasRecipe, modifier){
            return _hasRecipe || modifier.startsWith(recipeName);
        }, hasRecipe);
    };

    // serialize recipe mods into recipe config
    HumanRecipes.serializeRecipe = function(recipeName) {
        var recipeMods = HumanRecipes.getRecipeMods(recipeName);
        return createConfigFromMods(recipeMods);
    };

})();
;/**
* @namespace Control of the master root timeline
* This namespace interfaces with the root timeline object.
*
* Responsibilities:
*     - Play chapters on tick events
*     - Issue and store play commands by specifying start and end conditions.
*             -- next chapter, previous chapter
*             -- start conditions: start time, start chapter id, start chpater index
*             -- end conditions: end time, end chapter id, end chapter index, number of chapters.
*
*     - Play state
*             -- playing, not playing (paused, stopped)
*     - Scrubbing
*             -- scrub to specific time in global timeline
*
* NOTE: Looping
* Any play block (set of time defined by time1 and time2) can be instructed to loop. The
* intention to loop is set via the HumanTimeline.play() command arguments. However, for backwards
* compatibility with some existing apps/widgets/content, single chapters can declare themselves to loop
* from the chapter definition directly. In this very specific edge case, we will use that loop property.
*
*
*
*
* TODO: Eventually animations should be loaded DIRECTLY into the leaf timelines. Now they are added to animations, then from animations
* into the leaf timeline. This is just easier for the time being.
*/

(function () {
    "use strict";

    //local namespace
    var HumanTimeline = Human.timeline = {
        objectVisibilityUpdates: {}
    };

    // Timelines Library
    HumanTimeline.animations = {};    // original animation assets
    HumanTimeline.leafTimelines = {};
    HumanTimeline.branchTimelines = {};
    HumanTimeline.rootTimelines = {};
    HumanTimeline.activeRoot = null;

    // Play Configuration
    HumanTimeline.FRAME_LENGTH = 0.033;
    HumanTimeline.TIME_CONSTANT = 1 / 1000;
    HumanTimeline.borderConditions = {
        start: {which: "second", direction: HumanTimeline.direction},
        middle: {which: "both", direction: HumanTimeline.direction},
        end: {which: "first", direction: HumanTimeline.direction}
    };


    // Play State Controls
    HumanTimeline.playing = false;          // true if use wants to play a block of root timeline.
    HumanTimeline.playfree = true;          // true if user wishes to play free animations
    HumanTimeline._lastWorldTime = 0.0;
    HumanTimeline._time1 = 0.0;             // time at start of play block
    HumanTimeline._time2 = 0.0;             // time at end of play block
    HumanTimeline._freeTime = 0.0;          // free time
    HumanTimeline.time = 0.0;               // current time; t1 <= t <= t2
    HumanTimeline.playQueue = [];           // Array of play instructions to be played in order.
    HumanTimeline.loop = false;             // Loops over entire t1-t2 play-block if true
    HumanTimeline.scale = 1.0;              // factor by which to advance time with tick (positive or negative).
    HumanTimeline.direction = "forwards";   // forwards if scale > 0 and "backwards" if scale < 0

    // Bookmark parameters
    HumanTimeline._playParams = null;
    HumanTimeline._scrubParams = null;


    // Backwards Comaptibitlity.
    HumanTimeline.chapters = {};      // Generated by root on timeline.updated event

    // TICK variables
    var root, timeNow, diff, dilation, bc;

    // ------------------------  LOADING AND REGISTERING ASSETS ---------------------------------------------------

    /** Registers an animation on the timeline
    * @memberof Human.timeline
    * @private
    */
    HumanTimeline.addAnimation = function (animationId, animation) {
        if (!animation.update) {
            Human.log.error("Human.timeline.addAnimation", "Param expected: update");
            return;
        }
        if (HumanTimeline.animations[animationId]) {
            HumanTimeline.removeAnimation(animationId);
        }
        HumanTimeline.animations[animationId] = animation;
        Human.events.fire("Timeline.Loaded");
    };

    /** Destroy animation(s) - either a specific animation, all animations associated with a given object,
    * or all animations indiscriminately
    * @memberof Human.timeline
    * @private
    */
    HumanTimeline.removeAnimation = function (animationId) {
        var animation = HumanTimeline.animations[animationId];
        if (!animation) {
            Human.log.warn("Human.timeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }
        delete HumanTimeline.animations[animationId];
        if (animation.destroy) {
            animation.destroy(); // Destroy animation
        }

        if (Human.utils.isEmpty(HumanTimeline.animations)){
            Human.events.fire("Timeline.Empty");
        }

    };

    //  ----------------------- CLOCK TICK HANDLING ---------------------------------------------------------------
    // Return True if time is at the end of a play-block, False otherwise
    // Returns global time at which playblock ends.
    var getEndTime = function(){
        return (HumanTimeline.direction === "forwards")? HumanTimeline._time2 : HumanTimeline._time1;
    };

    // Returns global time at which playblock starts.
    var getStartTime = function(){
        return (HumanTimeline.direction === "forwards")? HumanTimeline._time1 : HumanTimeline._time2;
    };

    var playEnded = function(){
        var ref = getEndTime();
        if (HumanTimeline.time === ref){
            return true;
        } else{
            return false;
        }
    };

    // Return True if time is at the start of a play-block, False otherwise
    var playStarted = function(){
        var ref = getStartTime();
        if (HumanTimeline.time === ref){
            return true;
        } else{
            return false;
        }
    };

    /** Rules for root update on border times.
    * This only needs to be changed when the driection is set.
    *
    * "first/second" refers to the left/right branch at a border relative to root timeline.
    * "start/end" refers to time relative to the viewer.
    * "forwards/backwards" refers to left-to-right (and vice versa) relative to the root timeline.
    *
    * Example: first branch from the forwards direction is the same as the
    * second branch from the backwards direction, and vice versa.
    */
    var setBorderConditions = function(direction){
        var result = {};
        var coef = (direction === "backwards")? -1.0: 1.0;
        var validDirections = ["forwards", "backwards"];

        // validation
        if (validDirections.indexOf(direction) < 0){
            Human.log.warn("timeline.setBorderConditions", "invalid direction :" + direction);
            return null;
        }

        result.start = {which:"second", direction: direction};
        result.middle = {which: "both", direction: direction};
        result.end = {which: "first", direction: direction};

        HumanTimeline.direction = direction;
        HumanTimeline.borderConditions = result;
        HumanTimeline.scale = coef * Math.abs(HumanTimeline.scale);
    };


    HumanTimeline.initTransparencies = function(){
        Human.log.error("timeline.initTransparencies() is deprecated and no longer required for loading");
    };

    HumanTimeline.onFrame = function () {
        // Manage global time --------------------------------------
        root = HumanTimeline.activeRoot;
        if (root === null || root === undefined){
            return;
        }
        timeNow = (new Date()).getTime();
        diff = (timeNow - HumanTimeline._lastWorldTime) * HumanTimeline.TIME_CONSTANT;
        dilation = diff / HumanTimeline.FRAME_LENGTH;
        HumanTimeline._lastWorldTime = timeNow;
        if (HumanTimeline.time > HumanTimeline._time2) {
            HumanTimeline.time = HumanTimeline._time2;
        }
        else if (HumanTimeline.time < HumanTimeline._time1) {
            HumanTimeline.time = HumanTimeline._time1;
        }

        // Free Animations ------------------------------------------
        if (HumanTimeline.playfree){
            root.updateFreeAnimations(HumanTimeline._freeTime);
            HumanTimeline._freeTime += HumanTimeline.scale * dilation * HumanTimeline.FRAME_LENGTH;
        }


        // Branch Timelines ----------------------------------------------
        /**
        * Boundary conditions: Often a play block is the duration of a chapter.
        * At boundaries, the global time points to end/start times on two consecutive
        * branch timelines. Rules specified in the bounary condition dictate
        * whether both are played or just one and which one.
        *
        */
        if (HumanTimeline.playing){

            // Boundary conditions and play permissions
            bc = HumanTimeline.borderConditions.middle; //default
            var toPlay = true;
            if (playEnded()){
                if (HumanTimeline.loop === true){
                    // loop
                    bc = HumanTimeline.borderConditions.start;
                    HumanTimeline.time = getStartTime();
                } else {
                    // stop playing
                    bc = HumanTimeline.borderConditions.end;
                    toPlay = false;
                }
            } else if (playStarted()){
                bc = HumanTimeline.borderConditions.start;
            }

            // Play and adjust Play State based on time.
            root.update(HumanTimeline.time, bc);
            if (toPlay){
                HumanTimeline.playing = true;
                Human.events.fire("timeline.playing", {
                    time: HumanTimeline.time
                });
                HumanTimeline.time += HumanTimeline.scale * dilation * HumanTimeline.FRAME_LENGTH;
            } else {
                Human.events.fire("timeline.completed");
                HumanTimeline.playing = false;
                Human.events.fire("timeline.stopped", {
                    time: HumanTimeline.time
                });
            }
        } // end handling of branch update

        Human.renderer.camera.fly.onFrame();

        if (!Human.utils.isEmpty(HumanTimeline.objectVisibilityUpdates)) {
            Human.events.fire("TweenVisibilityUpdate", HumanTimeline.objectVisibilityUpdates);
            HumanTimeline.objectVisibilityUpdates = {};
        }

    };

    // Manage play queue:
    Human.events.on("timeline.stopped",function(){
        HumanTimeline.playQueue.shift();
        if (HumanTimeline.playQueue.length>0){
            var nextPlay = HumanTimeline.playQueue[0];
            HumanTimeline._play(nextPlay);
        } else {
            Human.events.fire("timeline.paused",{time:Human.timeline.time});
        }
    });

    // ------------------------- PLAY COMMANDS ----------------------------------------------------------------------
    HumanTimeline.parsePlayInstruction = function(params){
        params = params || {};
        var root = params.root || HumanTimeline.activeRoot;
        var direction = "forwards";              // play direction (relative to root);
        root.getTimeFrame();
        var _startCondition;
        var _endCondition;
        var _firstBranch;           // first branch to be played
        var _firstTime;             // time1 (branch local time)
        var _lastBranch;            // last branch to be played
        var _lastTime;              // time2 (branch local time)
        var _t1 = null;                    // first time of time window
        var _t2 = null;                    // last time of time windo
        var _t = null;                     // first time to play
        var align = (params.hasOwnProperty("align"))? params.align : true;
        var startPriorityQueue = ["nextChapter" ,"prevChapter","startChapterId","startTime"];
        var endPriorityQueue = ["nextChapter","prevChapter", "finishChapterId","finishTime", "numChapters"];
        var temp = null;
        var loop = false;
        HumanTimeline._playParams = params;

        _startCondition = filterPriority(startPriorityQueue, params)[0] || "default";
        _endCondition = filterPriority(endPriorityQueue, params)[0] || "default";

        // Get branch, time for start and end conditions
        switch(_startCondition){
            case "nextChapter":
            // Play next chapter from start to finish in forwards order
            _firstTime = 0.0;
            _firstBranch = root.getNeighborChapter(root._nowBranch, "next");
            break;
            case "prevChapter":
            // Play the previous chapter from start to finish in forwards order
            _firstTime = 0.0;
            _firstBranch = root.getNeighborChapter(root._nowBranch, "previous");
            break;
            case "startChapterId":
            // play chapter by id and catch invalid ids
            _firstTime = 0.0;
            _firstBranch = root.getBranch({id: params.startChapterId});
            if (Human.utils.isEmpty(_firstBranch)){
                Human.log.warn("timeline.play", "Invalid chapter id: "+ params.startChapterId);
                return;
            }
            break;
            case "startTime":
            // start at specified time (default to 0)
            temp = root.mapGlobalTime(params.startTime, {tie: "later"});
            _firstBranch = temp.branch;
            _firstTime = temp.time;
            break;
            case "default":
            _firstBranch = root._chapters[0];
            _firstTime = 0.0;
        }

        switch(_endCondition){
            case "nextChapter":
            // play to the end of the target branch
            _lastBranch = _firstBranch;
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "prevChapter":
            // play to the end of the target branch
            _lastBranch = _firstBranch;
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "finishChapterId":
            // play chapter by id and catch invalid ids
            _lastBranch = root.getBranch({id: params.finishChapterId});
            if (Human.utils.isEmpty(_lastBranch)){
                Human.log.warn("timeline.play", "Invalid chapter id: "+ params.finishChapterId);
                return;
            }
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "finishTime":
            // start at specified time (default to end). Edge case if finish time is 0.
            if (params.finishTime === 0){
                _lastBranch = root._chapters[0];
                _lastTime = 0.0;
            } else{
                var which = {tie: "earlier"};
                temp = root.mapGlobalTime(params.finishTime, which);
                _lastBranch = temp.branch;
                _lastTime = temp.time;
            }
            break;
            case "numChapters":
            // play up to numChapters or last chapter
            var startIndex = root.whereIsBranch(_firstBranch, {chapters:true});
            var numRemaining = root._chapters.length - startIndex;
            var numChapters = params.numChapters || 1;
            numChapters = Math.min(numChapters, numRemaining);
            _lastBranch = root._chapters[startIndex + numChapters - 1];
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "default":
            _lastBranch = root._chapters[root._chapters.length - 1];
            _lastTime = "end";
        }

        // Convert to world time and check for forwards/backwards direction
        _t1 = root.mapBranchTime(_firstBranch, _firstTime);
        _t2 = root.mapBranchTime(_lastBranch, _lastTime);
        if (_t1 <= _t2){
            // play t1 -> t2 in forwards direction
            direction = "forwards";
            _t = _t1;
        }
        else {
            // play new t2 -> t1 in backwards direction
            temp = _t1;
            _t1 = _t2;
            _t2 = temp;
            _t = _t2;
            direction = "backwards";
        }

        // Account for alignment to start/end of chapter
        if (align) {
            if (direction === "forwards") {
                _t1 = root.mapBranchTime(_firstBranch, 0);
                _t2 = root.mapBranchTime(_lastBranch, "end");
            } else if (direction === "backwards") {
                _t1 = root.mapBranchTime(_lastBranch, 0);
                _t2 = root.mapBranchTime(_firstBranch, "end");
            }
        }

        /** Looping property
        * Priority goes to params.loop.
        * If not set in params, and only a single whole chapter is meant to be played
        * we will use the chapter's loop property.
        */
        if (params.hasOwnProperty('loop')){
            loop = params.loop;
        }
        else {
            var singleStarts = ["startChapterId","nextChapter","prevChapter"];
            var singleEnds = ["numChapters", "nextChapter", "finishChapterId"];
            if (singleStarts.indexOf(_startCondition) >= 0){
                if (singleEnds.indexOf(_endCondition) >= 0){
                    if (_firstBranch.id === _lastBranch.id){
                        loop = _firstBranch.animation.loop;
                    }
                }
            }
        }

        return {
            "t": _t,
            "t1":_t1,
            "t2":_t2,
            "loop": loop,
            "direction": direction
        };
    };

    /** PLAY QUEUE
    @param {{}} params Play parameters
    @param {Number} [params.prevChapter] True play previous chapter
    @param {Number} [params.nextChapter] True play next chapter
    @param {Number} [params.startTime] Time in seconds to start playing at
    @param {Number} [params.finishTime] Time in seconds to stop playing at
    @param {String} [params.startChapterId] ID of chapter to start playing at
    @param {String} [params.finishChapterId] ID of chapter to stop playing at
    @param {String} [params.numChapters] Number of chapters to play before stopping
    */
    HumanTimeline.play = function(params){
        params = params || {};

        if (params.queue && HumanTimeline.playing) {
            // Flagged to enqueue, currently playing
            HumanTimeline.playQueue.push(params);
        } else {
            // Kill queue, play immediately
            HumanTimeline.playQueue = [params];
            HumanTimeline._play(params);
        }
    };

    // Sets up play block via play state controls
    /**
    * Parameters:
    * @param {Number}  [params.prevChapter] True play previous chapter
    * @param {Number}  [params.nextChapter] True play next chapter
    * @param {boolean} [params.align] True (default) _time1,_time2 align with border times. Otherwise, use passed times.
    * @param {string}  [params.startChapterId]
    * @param {string}  [params.finishChapterId]
    * @param {Number}  [params.startTime]
    * @param {Number}  [params.finishTime]
    * @param {integer} [params.numChapters] number of chapters in forwards direction.
    * @param {boolean} [params.loop]
    *
    * TODO: Consider having both align left and align right.
    *
    * NOTE: This will support playing time backwards, but will not support playing chapters forwrds in
    * reverse order. One should issue use existing play parameters and the playQueue to do that.
    *
    * Backwards Conditions (playing time backwards) when ...
    *   startTime > finishTime (global)
    *   startChapter.idx > finishChapter.idx (root queue order)
    *   startTime > finishChpater.starttime (global)
    *   finishTime < startChapter.startTime (global)
    */
    HumanTimeline._play = function(params){
        var playparams = HumanTimeline.parsePlayInstruction(params || {});

        // Update Timeline Play State and Parameters
        HumanTimeline._time1 = playparams.t1;
        HumanTimeline._time2 = playparams.t2;
        HumanTimeline.time = playparams.t;
        HumanTimeline.loop = playparams.loop;
        setBorderConditions(playparams.direction);

        // Prepare for tick event
        HumanTimeline.playing = true;
        HumanTimeline._lastWorldTime = (new Date()).getTime();
        Human.events.fire("timeline.played", {
            time: HumanTimeline.time
        });

    };

    // Filter parameters for start and end conditions
    var filterPriority = function(priorityQue, optionsMap){
        var okeys = Object.keys(optionsMap);
        var filterfunc = function(pqItem){
            return okeys.indexOf(pqItem)>=0;
        };
        return priorityQue.filter(filterfunc);
    };

    /** Stop the timeline.
    */
    HumanTimeline.stop = function(){

        // play state variables
        HumanTimeline.playing = false;
        HumanTimeline.playQueue = [];

        // Human events
        Human.events.fire("timeline.stopped",{
            time: HumanTimeline.time
        });
    };

    /** Scrub to specific time on global timeline
    * @param.time            : global time to scrub to
    * @param.borderCondition : instructions for handling playing a border.
    * @param.chapterId       : move to the start of the specified chapterId
    * TODO:@params.playAudio     : False (default) to suppress audio publishing while scrubbing
    *
    * This function will also update play block to encompass desired time for
    * proper "unpausing" or resume play. Resets out-of-bounds scrub to play current
    * chapter.
    */
    HumanTimeline.scrub = function(params){
        var root = HumanTimeline.activeRoot;
        var time = 0;
        var bc = {which: "first", direction:"forwards"};
        var target;

        HumanTimeline.playQueue = [];
        HumanTimeline._scrubParams = params; // copy for bookmarks

        // Infer the desired global time based on parameters
        if (params.hasOwnProperty("time")){
            time = params.time;
        } else if (params.hasOwnProperty("chapterId")) {
            var branch = root.getBranch({id:params.chapterId});
            if (!!branch){
                time = root.mapBranchTime(branch, 0);
                bc = {which:"second", direction:"forwards"};
            } else {
                // in case of failure
                time = HumanTimeline.time;
            }

        }
        else {
            time = HumanTimeline.time;
        }
        if (params.hasOwnProperty("borderCondition")){
            var _bc = params.borderCondition;
            var _which = ["first","both","second"];
            var _direction = ["forwards","backwards"];
            if (_which.indexOf(_bc.which) >= 0){
                bc.which = _bc.which;
            }
            if (_direction.indexOf(_bc.direction) >= 0){
                bc.direction = _bc.direction;
            }
        }

        if (time === 0.0){
            bc = {which: "second", direction: "forwards"};
        } else if (time === root.getTimeFrame.lastTime){
            bc = {which: "first", direction:"forwards"};
        }

        // Update play block if scrub time is out of bounds
        if (time < HumanTimeline._time1 || time > HumanTimeline._time2) {
            target = root.mapGlobalTime(time, bc);
            HumanTimeline._time1 = root.mapBranchTime(target.branch, 0.0);
            HumanTimeline._time2 = root.mapBranchTime(target.branch, "end");
        }

        // Manage Play State
        HumanTimeline.playing = false;

        // Determine Boundary Condition
        HumanTimeline.time = time;
        root.update(time, bc);
        Human.events.fire("timeline.scrubbed", {
            time: HumanTimeline.time
        });
    };

    /** Go to next chronological chapter, respecting properties.prevNextMode
    *
    * prevNextMode is set per chapter.
    * two modes are currently supported:
    * play :
    *     -- play current chapter forwards and step into next chapter if next chapter not looping
    *     -- play next chapter and loop, if next chapter is looping
    * scrub :
    *     -- scrub directly to start of next
    *
    * TODO: Override currently looping chapter so that it finishes.
    * TODO: Properly handle border-condition instead of stepping 0.001 seconds into chapter.
    *
    * HACK: The behavior of 'prevNextMode' is not uniquely determined, depends on the property
    * of the next chapter. This is bad, but is needed for backwards compatibility.
    */
    HumanTimeline.next = function(){
        var root = HumanTimeline.activeRoot;
        var prevNextMode = Human.properties.properties["timeline.prevNextMode"];
        var nowBranch = root._nowBranch;
        var nextBranch = root.getNeighborChapter(nowBranch,"next");

        // Cancel if on last chapter.
        if (root.isLast(nowBranch)){
            Human.log.warn("timeline.next", "can't proceed beyond last chapter");
            return;
        }

        //TODO: Use boundary condition here
        var finishTime = root.mapBranchTime(nowBranch,"end") + 0.001;

        if (prevNextMode === "play"){
            var playParams;
            if (nextBranch.animation.loop){
                playParams = {
                    startTime: root.mapBranchTime(nextBranch,0),
                    align: true,
                    finishTime: root.mapBranchTime(nextBranch, "end"),
                    loop: nextBranch.animation.loop,
                    queue: false
                };
            } else {
                // Play rest of this chapter forwards and just enter into next chapter
                playParams = {
                    startTime : HumanTimeline.time,
                    align: false,
                    finishTime : finishTime,
                    loop: false,
                    queue: false
                };
            }

            HumanTimeline.play(playParams);
        } else {
            // Default is to scrub
            HumanTimeline.scrub({
                time: finishTime
            });
        }

    };

    /** Go to previous chronological chapter, respecting properties.prevNextMode
    *
    * prevNextMode is set per chapter.
    * two modes are currently supported:
    * play :
    *     -- play previous chapter backwards
    * scrub :
    *     -- scrub directly to start of previous chapter
    */
    HumanTimeline.prev = function(){
        var root = HumanTimeline.activeRoot;
        var prevNextMode = Human.properties.properties["timeline.prevNextMode"];
        var nowBranch = root._nowBranch;

        // Cancel if on first chapter.
        if (root.isFirst(nowBranch)){
            Human.log.warn("timeline.next", "can't go to chapter before first chapter");
            return;
        }

        var prevChapter = root.getNeighborChapter(nowBranch, "previous");
        // TODO: Use boundary condition here
        var finishTime = root.mapBranchTime(prevChapter, "start") + 0.001;
        var playParams;
        if (prevNextMode === "play") {
            if (nowBranch.animation.loop) {
                // When current chapter is looping, go to start of previous chapter
                playParams = {
                    startTime: root.mapBranchTime(prevChapter,"start"),
                    align: true,
                    finishTime: root.mapBranchTime(prevChapter,"end"),
                    loop: prevChapter.animation.loop,
                    queue: false
                };
            } else {
                // play previous chapter backwards
                playParams = {
                    startTime: root.mapBranchTime(prevChapter, "end"),
                    align: false,
                    finishTime: root.mapBranchTime(prevChapter, "start"),
                    loop: false,
                    queue: false
                };
            }
            HumanTimeline.play(playParams);
        } else {
            // Default is to scrub
            HumanTimeline.scrub({
                time: finishTime
            });
        }
    };

    // ------------------------- BOOKMARKING -------------------------------------------------------------------------

    /**
    * Gets a bookmark of the timeline's current playing state. This does not bookmark the content
    * currently loaded within the timeline, so when restoring the bookmark, ensure that all the currently-loaded
    * animations and chapters are loaded first.
    * @memberof Human.timeline
    * @return The bookmark, which may be given to {@link Human.timeline.setBookmark} to restore it
    * @private
    */
    HumanTimeline.getBookmark = function(){
        var bookmarkParams = {};

        // bookmark root timeline if it exists:
        if (!!Human.timeline.activeRoot){
            bookmarkParams.rootName = Human.timeline.activeRoot.id;
        }

        // bookmark play parameters
        if (HumanTimeline.playing){
            bookmarkParams.play = HumanTimeline._playParams;
            if (bookmarkParams.play.root) {
              delete bookmarkParams.play.root;
            }
        } else {
            bookmarkParams.scrub = HumanTimeline._scrubParams;
        }
        return bookmarkParams;
    };

    /**
    * Sets timeline's playing state to given bookmark. Assumes that the animations and chapters
    * that were on the timeline when the bookmark was captured are currently loaded.
    * @memberof Human.timeline
    * @param {*} bookmark The bookmark
    * @private
    */
    HumanTimeline.setBookmark = function(bookmark){
        if (!!bookmark.rootName && HumanTimeline.rootTimelines.hasOwnProperty(bookmark.rootName)){
            HumanTimeline.activeRoot = HumanTimeline.rootTimelines[bookmark.rootName];
        } else if (!!bookmark.modules && !!bookmark.modules.activeModules) {
            // Search for appropriate root timeline form bookmark's active modules.
            var candidateTimelines = bookmark.modules.activeModules;
            candidateTimelines = candidateTimelines.filter(function(item){
                return Human.timeline.rootTimelines.hasOwnProperty(item);
            });
            if (candidateTimelines.length > 1){
                candidateTimelines = candidateTimelines.filter(function(item){
                    return !Human.modules.isBaseModule(item);
                });
            }
            var rootName = candidateTimelines[0];
            Human.timeline.activeRoot = Human.timeline.rootTimelines[rootName];
        } else {
            Human.log.warn("Human.timeline.setBookmark: Unable to set appropriate root timeline");
        }
    };

    // ------------------------- BACKWARDS COMPATIBILITY -------------------------------------------------------------

    /** Backwards Compatiiblity: Pause()
    * Same as stop but with different human event.
    */
    HumanTimeline.pause = function(){
        HumanTimeline.playing = false;

        // Human events
        Human.events.fire("timeline.paused", {
            time: HumanTimeline.time
        });
    };

    /** Backwards Compatibility: Unpause()
    * Play rest of current chapter (and only current chapter).
    */
    HumanTimeline.unpause = function(){
        var playParams = {
            startTime: HumanTimeline.time,
            numChapters : 1,
            loop: HumanTimeline.loop
        };

        HumanTimeline.play(playParams);

        // Human Events
        Human.events.fire("timeline.unpaused", {
            time: HumanTimeline.time
        });
    };

    HumanTimeline.playFreeAnimations = function(){
        HumanTimeline.playfree = true;
    };

    HumanTimeline.pauseFreeAnimations = function(){
        HumanTimeline.playfree = false;
    };

    HumanTimeline.getTimeFrame = function(){
        if (Human.utils.isEmpty(HumanTimeline.activeRoot)){
            return 0.0;
        } else {
            return HumanTimeline.activeRoot.getTimeFrame();
        }
    };

    //Get the current chapter's start camera position
    HumanTimeline.getCurrentChapterCamera = function(){
        return Human.timeline.activeRoot._nowBranch.getCamera(0.0);
    };

    // Preserve play parameter naming conventions from older versions
    HumanTimeline._convertPlayParams = function(params){
        var result = params;
        if (params.hasOwnProperty("endTime")){
            result.finishTime = result.endTime;
        }
        if (params.hasOwnProperty("endChapterId")){
            result.finishChapterId = params.endChapterId;
        }

        return result;

    };

    // Query State of Timeline
    HumanTimeline.query = function () {

        if (!HumanTimeline.activeRoot){
            return {};
        }
        var chapters = HumanTimeline.activeRoot._assembleQueryChapters();
        return {
            chapters: chapters,
            time: HumanTimeline.time,
            timeFrame: HumanTimeline.getTimeFrame(),
            playing: HumanTimeline.playing,
            paused: !HumanTimeline.playing
        };
    };

    /** Destroy Chapter Sets: chapterSetId = moduleId
    * Don't destroy base anatomy chapter sets unless specifically requested.
    */
    HumanTimeline.destroyChapterSet = function(chapterSetId){
        HumanTimeline.stop();
        if (HumanTimeline.rootTimelines.hasOwnProperty(chapterSetId)){
            HumanTimeline.rootTimelines[chapterSetId].destroy();
        } else if (!!chapterSetId){
            // Destroy all root timelines except base anatomy
            // TODO: Scene Reset (default properties)
            for (var rtid in HumanTimeline.rootTimelines){
                if (HumanTimeline.rootTimelines.hasOwnProperty(rtid)){
                    if (!Human.modules.isBaseModule(rtid)){
                        HumanTimeline.rootTimelines[rtid].destroy();
                    }
                }
            }
        } else {
            // invalid chapterset id
            Human.log.warn("timeline.destoryChapterSet","Invalid argument: " + chapterSetId);
        }
    };

    Human.events.on("timeline.chapters.updated", function(chapters){
      var idx = 0;
      var id;
      HumanTimeline.chapters = {};
      if (HumanTimeline.activeRoot === null){
        return;
      }
      for (idx=0; idx<chapters.length; idx++){
        id = HumanTimeline.activeRoot._chapters[idx].id;
        HumanTimeline.chapters[id] = chapters[idx];
      }

    });

})();
;(function () {
    "use strict";

    /**
     * A tween animation on the {@link Human.timeline}.
     *
     * @param cfg {*}
     * @param cfg.tweens {{}}
     */
    Human.timeline.TweenAnimation = function (cfg) {

        this._options = cfg.options || { };

        this._tweens = cfg.tweens;

        this.timeline = cfg.timeline;

        /**
         * First key for this tween animation
         */
        this.firstTime = 1000000;

        /**
         * Last key for this tween animation
         */
        this.lastTime = -1000000;

        // Calculate time frame

        var tween;
        for (var i = 0, len = this._tweens.length; i < len; i++) {

            tween = this._tweens[i];

            if (tween.firstTime < this.firstTime) {
                this.firstTime = tween.firstTime;
            }

            if (tween.lastTime > this.lastTime) {
                this.lastTime = tween.lastTime;
            }
        }
    };

    /**
     * Updates this animation for the given time.
     *
     * @param {{}} ctx The animation context
     * @param {Number} time Current timeline time in seconds
     */
    Human.timeline.TweenAnimation.prototype.update = function (ctx, time) {
        for (var i = 0, len = this._tweens.length; i < len; i++) {
            this._tweens[i].update(ctx, time);
        }
    };

    /**
     * Destroys this animation.
     */
    Human.timeline.TweenAnimation.prototype.destroy = function () {
        var tween;
        for (var i = 0, len = this._tweens.length; i < len; i++) {
            tween = this._tweens[i];
            if (tween.destroy) {
                tween.destroy();
            }
        }
    };

})();
;(function () {
    "use strict";

    /**
     * A Human.timeline.Tween interpolates one or more attributes of some target engine element.
     *
     * A Tween is configured with a "control", which is a strategy object which which feeds the Tween's output
     * into the engine element.
     *
     * We also configure a Tween with "targets", each of which is a set of values to assign to attributes of the
     * engine element, at some instant in time.
     *
     * For each attribute that appears among the targets, the Tween will create within itself a Human.utils.LerpAttr,
     * which will animate that attribute through its target values.
     *
     * Whenever the Tween is updated with the current time, it updates each of its LerpAttr, then feeds the
     * aggregate set of outputs of those LerpAttr into the engine element, via the control strategy.
     *
     * For example:
     *
     * <pre>
     *     var lerp = new Human.timeline.Tween({
     *
     *          // Control the Human.view.Camera
     *
     *          control: new Human.timeline.CameraControl(),
     *
     *          // Sequence of target value sets, in this case each containing values for "eye", "look" and "up"
     *          // attributes to set on the Human.view.Camera. This will create three Human.utils.LerpAttr instances
     *          // within this Human.timeline.Tween, each in charge of interpolating one of these three attributes.
     *
     *          targets: [
     *              {
     *                  eye:  { x: 0, y: 0, z: -100 },
     *                  look: { x: 0, y: 0, z: 0 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              },
     *              {
     *                  eye:  { x: 10, y: 22, z: -10 },
     *                  look: { x: 0, y: 0, z: 20 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              }
     *          ],
     *
     *          // A time for each target
     *
     *          keys: [
     *              0,
     *              15
     *          ]
     *      });
     * </pre>
     *
     *
     *
     * @param cfg
     * @param cfg.keys Time for each target
     * @param cfg.targets Set of attribute values for each target
     * @param cfg.control Strategy to set the animated values on target engine element
     */
    Human.timeline.Tween = function (cfg) {

        // Adapter which controls the thing we're tweening
        // eg. a Human.timeline.CameraControl
        this._control = cfg.control;

        // Array of Human.utils.LerpAttr
        this._tweenList = [];

        var tweenMap = {};
        var target;
        var key;
        var attr;
        var targetAttr;
        var tween;
        var tweenAttr;

        // Create tweens

        for (var i = 0, len = cfg.targets.length; i < len; i++) {

            target = cfg.targets[i];
            key = cfg.keys[i];

            // Nested "attr" issue
            if (Human.utils.isObject(target.attr) && hasNestedObjects(target.attr)) {
                target = target.attr;
            }

            //Create a Tween for each attribute ("translate", "rotate" etc.) in target.
            // Each tween will contain a sub-tween for each of its target's elements ("x", "y" etc.)

            attr = target;

            for (var attrName in attr) {
                if (attr.hasOwnProperty(attrName)) {

                    targetAttr = attr[attrName];
                    tween = tweenMap[attrName];

                    if (!tween) { // Lazy-create

                        tweenAttr = this._control.attr[attrName];
                      //  if (!tweenAttr) {
                      //      Human.log.error("Human.timeline.Tween", "Attribute expected on control strategy: " + attrName);
                      //      continue;
                      //  }
                        tween = new Human.timeline.TweenAttr(tweenAttr, cfg.options);
                        tweenMap[attrName] = tween;
                        this._tweenList.push(tween);
                    }

                    tween.addTarget(key, targetAttr);
                }
            }
        }

        /**
         * First key for this tween
         */
        this.firstTime = cfg.keys[0];

        /**
         * Last key for this tween
         */
        this.lastTime = cfg.keys[cfg.keys.length - 1];
    };

    Human.timeline.Tween.prototype._run = function (ctx, time) {

        var countUpdated = 0;
        var tweenList = this._tweenList;

        // Update each tween
        for (var j = 0, len = tweenList.length; j < len; j++) {
            if (tweenList[j].update(ctx, time)) {
                countUpdated++;
            }
        }

        return countUpdated;
    };

    Human.timeline.Tween.prototype.query = function (ctx, time) {
        this._run(ctx, time);

        return this._control.attr;
    };

    /**
     * Updates this tween for the given time.
     *
     * @param {{}} ctx Animation context
     * @param {Number} time Time in seconds
     */
    Human.timeline.Tween.prototype.update = function (ctx, time) {
        // Update control if any tween was updated
        if (this._run(ctx, time) > 0) {
            this._control.update(ctx);
        }
    };

    function hasNestedObjects(obj) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && !Human.utils.isObject(obj[prop])) {
                return false;
            }
        }

        return true;
    }

})();
;/**
 * Tweens a set of attributes
 *
 * <p>Usage:</p>
 *
 * <pre>
 *     var lerp = new Human.timeline.TweenAttr({ x: 0, y: 0, z: 0 });
 *
 *     lerp.addTarget(1, { x: 0, y: 10, z: 1 });
 *     lerp.addTarget(2, { x: 5, y: 0, z: 0 });
 *     lerp.addTarget(4, { x: 10, y: 0, z: 1 });
 *
 *     var animationContext = {};
 *
 *     lerp.update(animationContext, 3);
 *
 * </pre>
 *
 * @param {{String:Object}} attr The attribute values to interpolate.
 * @param {{String:Object}} options Interpolation options
 * @param {Boolean} [options.loop] Flag indicating whether interpolation loops within the targets
 * @param {Number} [options.timeOffset] Time offset to add to time at each target given to {@link #addTarget}
 */

(function() {
    "use strict";

    Human.timeline.TweenAttr = function (attr, options) {

        /**
         * The attributes that are interpolated. This is the output of this interpolator.
         */
        this.attr = attr;

        this.attrNames = null;

        options = options || {};

        /**
         * A time in seconds for each target.
         */
        this.keys = [];

        /**
         * The targets - a list of target values for each attribute.
         *
         * <p>For example, if the attributes were {x,y,z}, then it would be this sort of thing:</p>
         *
         * <pre>
         * {
         *     "x": [32, 4, -23],
         *     "y": [-2, 40, 133],
         *     "z": [34, 0, 21]
         * }
         * </pre>
         */
        this.attrTargetLists = {};

        this._tweens = [];

        // Caches indexes of the pair of targets that the enclose the last time value given to #update
        this._key1 = 0;
        this._key2 = 1;

        // Caches the time values at the first and last keys, plus the range between them
        this._firstKey = null;
        this._lastKey = null;
        this._keyDiff = null;

        // True when this interpolator loops
        this._loop = !!options.loop;

        // Optional time offset to add to times given to #addTarget
        this._timeOffset = options.timeOffset || 0;

        // True when we need to re-pad the target lists
        this._paddingDirty = true;
    };

    /**
     * Adds a target to this Tween.
     *
     * <p>Example:</p>
     *
     * <pre>
     *     // Add a target at 4 seconds
     *     addTarget(4, { "x": 0, "y": 0, "z": -10 });
     * </pre>
     *
     * @param {Number} time Time in seconds for the target
     * @param {{String: Object}} attr Attribute values for the target
     */
    Human.timeline.TweenAttr.prototype.addTarget = function (time, attr) {

        time += this._timeOffset;

        // Add key time

        this.keys.push(time);

        var i = this.keys.length - 1;

        var targetList;
        var padded;
        var val;
        var j;
        var prev;

        for (var name in attr) {

            if (attr.hasOwnProperty(name)) {

                targetList = this.attrTargetLists[name];

                if (!targetList) {

                    if (this.keys.length > 1) {
                        throw "First target in tween must contain a value for each animated attribute on target";
                    }

                    targetList = this.attrTargetLists[name] = [];
                }

                val = attr[name];

                targetList[i] = val;
                if (typeof val !== "number") {
                    getCurve(val, time, targetList[i - 1], this.keys[i - 1]);
                }

                if (i > 0) {

                    padded = false;
                    j = i - 1;

                    while (!padded && j >= 0) {

                        prev = targetList[j];

                        // ? never hit ?
                        if (prev === undefined && prev === null) {
                            targetList[j] = val;
                            j--;
                        } else {
                            padded = true;
                        }
                    }
                }
            }
        }

        // Find key range

        if (this._firstKey === null || this._firstKey > time) {
            this._firstKey = time;
        }

        if (this._lastKey === null || this._lastKey < time) {
            this._lastKey = time;
        }

        this._keyDiff = this._lastKey - this._firstKey;

        this._paddingDirty = false;
    };


    Human.timeline.TweenAttr.prototype._padTargets = function () {

        var name;
        var attrTargetLists = this.attrTargetLists;
        var targetList;
        var numKeys = this.keys.length;
        var val;

        for (name in attrTargetLists) {

            if (attrTargetLists.hasOwnProperty(name)) {

                targetList = attrTargetLists[name];

                if (targetList.length === numKeys) {
                    continue;
                }

                val = targetList[targetList.length - 1];

                while (targetList.length < numKeys) {
                    targetList.push(val);
                }
            }
        }

        this._paddingDirty = false;
    };


    /**
     * Drives the interpolation factor on this Tween
     *
     * <p>Example:</p>
     *
     * <pre>
     * update(3.2);
     * </pre>
     *
     * @param {*} ctx Animation context
     * @param {Number} time Current timeline time in seconds
     * @return {Boolean} True if any attribute in {@link #attr} was modified
     */
    Human.timeline.TweenAttr.prototype.update = function (ctx, time) {

        if (this._paddingDirty) {
            this._padTargets();
        }

        var keys = this.keys;

        var names = this.attrNames ? this.attrNames : this.attrNames = Object.keys(this.attrTargetLists);

        if (this._loop) {

            time = this._firstKey + (time % this._keyDiff);

        } else {

            if (time <= keys[0]) {
                this._key1 = 0;
                this._key2 = 1;
                this._clampToTarget(names, 0);
                return true;
            }

            if (time > keys[keys.length - 1]) {
                this._key1 = keys.length - 2;
                this._key2 = this._key1 + 1;
                this._clampToTarget(names, this.keys.length - 1);
                return true;
            }
        }

        while (keys[this._key1] > time) {
            this._key1--;
            this._key2--;
        }

        while (keys[this._key2] < time) {
            this._key1++;
            this._key2++;
        }

        var attrTargetLists = this.attrTargetLists;
        var key1 = this._key1;
        var key2 = this._key2;
        var targetList;
        var target1;
        var val;
        var attr = this.attr;
        var updated = false;
        var i, len, name;


        for (i = 0, len = names.length; i < len; i++) {

            name = names[i];
            targetList = attrTargetLists[name];
            target1 = targetList[key1];
            if (typeof target1 !== "number") {
                target1 = target1.value;
            }
            if (typeof targetList[key2] === "number") {
                val = lerp(time, keys[key1], keys[key2], target1, targetList[key2]);
            } else {
                val = bezier(time, targetList[key2]);
            }

            attr[name] = val;
            updated = true;
        }

        return updated;
    };

    /**
     * Sets the output (#attr) to the values of the target at the given index
     */
    Human.timeline.TweenAttr.prototype._clampToTarget = function (names, time) {
        var attr = this.attr;
        var attrTargetLists = this.attrTargetLists;
        var attrVal;
        var i, len, name;

        for (i = 0, len = names.length; i < len; i++) {
            name = names[i];
            attrVal = attrTargetLists[name][time];
            if (typeof attrVal !== "number") {
                attrVal = attrVal.value;
            }
            attr[name] = attrVal;
        }
    };

    function getCurve(target, time, prevTarget, prevTime) {
        if (typeof prevTarget !== "number") {
            prevTarget = prevTarget.value;
        }
        
        // generate bezier class
        var cp = target.controlPoints;
        var steps = Math.floor((time - prevTime) * 50);
        
        // x - t, y - attr value
        target.bezier = new Human.math.bezier(
            prevTime, prevTarget, 
            cp.x[0], cp.y[0], 
            cp.x[1], cp.y[1],
            time, target.value
            );
        target.lookUp = target.bezier.getLUT(steps);
    }

    function lerp(time, key1, key2, target1, target2) {
        var delta = (time - key1) / (key2 - key1);

        var w = target2 - target1;
        var offs = delta * w;

        return target1 + offs;
    }

    // get attr val from bezier curve lookUp
    function bezier(time, target) {
        var lookUp = target.lookUp;
        var low = 0;
        var high = lookUp.length - 1;
        var mid, sample1, sample2;

        if (time <= lookUp[low].x) {
            return lookUp[low].y;
        }

        if (time >= lookUp[high].x) {
            return lookUp[high].y;
        }

        while (low <= high) {
            mid = Math.floor((low + high) / 2);
            sample1 = lookUp[mid];
            sample2 = lookUp[mid + 1];

            if (sample1.x <= time && sample2.x >= time) {
                return lerp(time, sample1.x, sample2.x, sample1.y, sample2.y);
            } else if (sample1.x > time) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
    }

})();
;(function () {
    "use strict";

    var BEFORE = 1;     // Alpha before first key
    var START = 2;      // At first key
    var AFTER = 3;     // Alpha after last key
    var RUNNING = 4;    // Found keys before and after alpha

    /**
     * A Human.timeline.Switch animates one or more attributes of some target engine element along sequences
     * of discrete values.
     *
     * A Switch is configured with a "control", which is a strategy object which which feeds the Switch's output
     * into the engine element.
     *
     * We also configure a Switch with "targets", each of which is a set of values to assign to attributes of the
     * engine element, at some instant in time.
     *
     * Example:
     *
     * <pre>
     *     var tween = new Human.timeline.Switch({
     *
     *          // Control a Human.scene.object
     *
     *          control: new Human.timeline.ObjectControl(),
     *
     *          // Sequence of target value sets, in this case each containing values for "eye", "look" and "up"
     *          // attributes to set on the Human.view.Camera. This will create three Human.utils.LerpAttr instances
     *          // within this Human.timeline.Switch, each in charge of interpolating one of these three attributes.
     *
     *          targets: [
     *              {
     *                  eye:  { x: 0, y: 0, z: -100 },
     *                  look: { x: 0, y: 0, z: 0 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              },
     *              {
     *                  eye:  { x: 10, y: 22, z: -10 },
     *                  look: { x: 0, y: 0, z: 20 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              }
     *          ],
     *
     *          // A time for each target
     *
     *          keys: [
     *              0,
     *              15
     *          ]
     *      });
     * </pre>
     *
     *
     *
     * @param cfg
     * @param cfg.keys Time for each target
     * @param cfg.targets Set of attribute values for each target
     * @param cfg.control Strategy to set the animated values on target engine element
     */
    Human.timeline.Switch = function (cfg) {

        this._keys = cfg.keys;
        this._targets = cfg.targets;
        this._control = cfg.control;
        this._options = cfg.options || {};
        this._key = 0;
        this._lastKey = null;

        /**
         * First key for this tween
         */
        this.firstTime = cfg.keys[0];

        /**
         * Last key for this tween
         */
        this.lastTime = cfg.keys[cfg.keys.length - 1];
    };

    Human.timeline.Switch.prototype.query = function (ctx, time) {
        this._findTarget(time);
        return this._targets[this._key];
    };

    /**
     * Updates this tween for the given time
     *
     * @param {{}} ctx Animation context
     * @param {Number} time Time in seconds
     */
    Human.timeline.Switch.prototype.update = function (ctx, time) {

        var state = this._findTarget(time);

        switch (state) {
            case BEFORE:

                //this._clampToFrame(0);
                return;

            case START:
                break;

            case AFTER:
                break;
        }

        // if (this._lastKey !== this._key) {
        //     this._control.attr = this._targets[this._key];
        //     this._control.update(ctx);
        //     this._lastKey = this._key;
        // }

        // TODO: Check for necessity to change based on attribute comparison NOT on which key fired last
        // last fired key could have been in another chapter, and visibility is reset each chapter. 
        this._control.attr = this._targets[this._key];
        this._control.update(ctx);
        this._lastKey = this._key;
    };

    /**
     * Finds the index of the key/target for the given time value
     * @param time
     * @returns {number}
     * @private
     */
    Human.timeline.Switch.prototype._findTarget = function (time) {

        if (time < this._keys[0]) {
            this._key = 0;
            return BEFORE;
        }

        if (time === this._keys[0]) {
            this._key = 0;
            return START;
        }

        if (time > this._keys[this._keys.length - 1]) {
            this._key = this._keys.length - 1;
            return AFTER;
        }

        while (this._keys[this._key] > time) {
            this._key--;
        }

        while (this._keys[this._key + 1] !== undefined && this._keys[this._key + 1] !== null && this._keys[this._key + 1] < time) {
            this._key++;
        }

        return RUNNING;
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of {@link Human.renderer.camera}.
     */
    Human.timeline.CameraControl = function () {

        /**
         * Camera attribute values.
         * These are set by the tween, which subsequently applies them to the camera with a call to #update()
         */
        this.attr = {
            up: { x: 0, y: 1, z: 0 },
            eye: { x: 0, y: 0, z: 0 },
            look: { x: 0, y: 0, z: 0 }
        };
    };

    /**
     * Sets this control's attribute values on the target camera
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.CameraControl.prototype.update = function (ctx) {

        // Don't update if camera animation is disabled

        if (ctx.cameraEnabled !== false) {
            Human.renderer.camera.setLookAt(this.attr);
            return true;
        }
    };

})();

;(function () {
    "use strict";

    /**
     * Controls the attributes of a material
     */
    Human.timeline.MaterialControl = function (params) {

        this._materialId = params.modelId + "/" + params.materialId;
        this.attr = {};

        // Backwards Compatibility: Nested Attribute
        if (params.attributes.hasOwnProperty("attr")){
            params.attributes = params.attributes.attr;
        }

        var attr;
        /**
         * Material attribute values.
         * These are set by the tween, which subsequently applies them to the material with a call to #update()
         * A Material should be able to have more than one control for different attributes. The desired attribute to control will be registered per instance of the material control.
         *
         * Backwards Compatibility:
         * The engine used to expect all the material properties (color, specular) to be tweened together. It makes more sense to support independent tweening attributes. However, for existing content, we must still support content that includes simultaneous attribute tweens on color and specular.
         */
        var defaultBaseColor = {
             r: 0,
             g: 0,
             b: 0,
             a: 1
         };

        var defaultSpecularColor = {
             r: 1.0,
             g: 1.0,
             b: 1.0
         };

        var defaultEmitColor = {
             r: 0.0,
             g: 0.0,
             b: 0.0
         };

        var defaultAlphaColor = {float:1};


        for (attr in params.attributes){
            if (params.attributes.hasOwnProperty(attr)){
                if (attr === "baseColor"){
                    this.attr.baseColor = defaultBaseColor;
                } else if (attr === "specularColor") {
                    this.attr.specularColor = defaultSpecularColor;
                } else if (attr === "emitColor") {
                    this.attr.emitColor = defaultEmitColor;
                } else if (attr === "alphaColor") {
                    this.attr.alphaColor = defaultAlphaColor;
                }
            }
        }
    };

    /**
     * Sets this control's attribute values on the target material
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.MaterialControl.prototype.update = function () {

        // Lazy-locate the target material
        // This is here so that we're not dependent on the material being loaded in advance

        var material = Human.assets.materials.materials[this._materialId];

        if (!material) {

            // Material not found

            if (!this._targetMissing) {

                // Warn once only

                Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._materialId);
                this._targetMissing = true;
            }

            return;
        }

        if (material.material) {

            var materialNode = material.material;
            var attr = this.attr;

            if (attr.baseColor) {
                materialNode.setBaseColor(attr.baseColor);
            }

            if (attr.specularColor) {
                materialNode.setSpecularColor(attr.specularColor);
            }

            if (attr.emitColor) {
                materialNode.setEmitColor(attr.emitColor);
            }

            if (attr.alphaColor) {
                // not an rgb, but an alpha value
                materialNode.setAlpha(attr.alphaColor.float);
            }

            return true;
        }
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of a scene object
     */
    Human.timeline.ObjectControl = function (params) {

        var objectIds = null;

        if (params.objectId) {
            objectIds = [params.objectId];
        } else {
            objectIds = params.objectIds;
        }

        for (var i = 0, len = objectIds.length; i < len; ++i) {
            var objectId = objectIds[i];
            if (objectId.indexOf(".") < 0 && objectId.indexOf("-") < 0) {

                // Relative ID of object within this model
                objectIds[i] = params.modelId + "-" + objectId;


            } // Otherwise absolute ID of object in another model
        }

        this._objectIds = objectIds;

        this.id = params.id;

        /**
         * Object attribute values.
         * These are set by the tween, which subsequently applies them to the object with a call to #update()
         */
        this.attr = {

            // A "virtual attribute" on the target Object

            attr: {
            },

            tnt: {  // r, g, b, optionally: x, y, z, rmin, rmax
            },

            cst: {  // val, optionally: x, y, z, rmin, rmax
            },

            sat: {  // val, optionally: x, y, z, rmin, rmax
            },

            brt: {  // val, optionally: x, y, z, rmin, rmax
            },

            o: {   // opacity: val, optionally: x, y, z, rmin, rmax
            }
        };
    };

    /**
     * Sets this control's attribute values on the target object
     */
    Human.timeline.ObjectControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        for (var i = 0, len = this._objectIds.length; i < len; ++i) {
            var objectId = this._objectIds[i];
            var object = Human.scene.objects[objectId];

            if (!object) {

                // Object not found
                // Warn once only

                if (!this._targetMissing) {
                    Human.log.warn("Human.timeline.TweenAnimation", "'lerp:objectAttr' tween can't find object: " + objectId);
                    this._targetMissing = true;
                }
                return;
            }

            // Don't update the object if there is a currently-active
            // chapter that makes it invisible
            var oinchapter = Human.timeline.activeRoot._nowBranch.synchronization[objectId];
            if (!oinchapter || oinchapter.shown !== false){
                updateObject(object, this.attr, this.id);
            }
        }        

    };
    
    var tmpColorModifier = {
        applyTo: null,
        value: 0,
        range: null
    };

    var tmpOpacityModifier = {
        value: 0,
        range: null
    };
    /**
     * Recursively sets attributes on objects in the given subtree
     */
    function updateObject(object, updates, tweenId) {
        var attr = updates.attr;
        var tnt = updates.tnt;
        var cst = updates.cst;
        var sat = updates.sat;
        var brt = updates.brt;
        var o = updates.o;

        if (attr) {
            if (attr.pickable !== undefined) {
                object.setPickable(attr.pickable);
            }

            if (attr.opacity !== undefined) {
                object.setOpacity(attr.opacity);
            }

            if (attr.shown !== undefined) {
                Human.timeline.objectVisibilityUpdates[object.objectId] = attr.shown;
            }
        }

        if (o && o.val !== undefined) {
            tmpOpacityModifier.value = o.val;
            if (o.x !== undefined) {
                tmpOpacityModifier.range = {
                    center: [o.x, o.y, o.z],
                    minRadius: o.rmin,
                    maxRadius: o.rmax
                };
            }
            object.setOpacityModifier("__OPACITY_TWEEN_" + tweenId, tmpOpacityModifier);
        }

        if (tnt && tnt.r !== undefined) {
            tmpColorModifier.applyTo = "tintColor";
            tmpColorModifier.value = [tnt.r, tnt.g, tnt.b];
            if (tnt.x !== undefined) {
                tmpColorModifier.range = {
                    center: [tnt.x, tnt.y, tnt.z],
                    minRadius: tnt.rmin,
                    maxRadius: tnt.rmax
                };
            }
            object.setColorModifier("__TINT_COLOR_TWEEN_" + tweenId, tmpColorModifier);
        }

        if (cst && cst.val !== undefined) {
            tmpColorModifier.applyTo = "contrast";
            tmpColorModifier.value = cst.val;
            if (cst.x !== undefined) {
                tmpColorModifier.range = {
                    center: [cst.x, cst.y, cst.z],
                    minRadius: cst.rmin,
                    maxRadius: cst.rmax
                };
            }
            object.setColorModifier("_CONTRAST_TWEEN_" + tweenId, tmpColorModifier);
        }

        if (sat && sat.val !== undefined) {
            tmpColorModifier.applyTo = "saturation";
            tmpColorModifier.value = sat.val;
            if (sat.x !== undefined) {
                tmpColorModifier.range = {
                    center: [sat.x, sat.y, sat.z],
                    minRadius: sat.rmin,
                    maxRadius: sat.rmax
                };
            }
            object.setColorModifier("__SATURATION_TWEEN_" + tweenId, tmpColorModifier);
        }

        if (brt && brt.val !== undefined) {
            tmpColorModifier.applyTo = "brightness";
            tmpColorModifier.value = brt.val;
            if (brt.x !== undefined) {
                tmpColorModifier.range = {
                    center: [brt.x, brt.y, brt.z],
                    minRadius: brt.rmin,
                    maxRadius: brt.rmax
                };
            }
            object.setColorModifier("__BRIGHTNESS_TWEEN_" + tweenId, tmpColorModifier);
        }

        if (object.objects.length > 0) {
            var objects = object.objects;
            for (var i = 0, len = objects.length; i < len; i++) {
                updateObject(objects[i], updates, tweenId);
            }
        }
    }

})();
;(function () {
    "use strict";

    /**
     * Controls a scene object's transform
     */
    Human.timeline.ObjectTransformControl = function (params) {

        var objectId = params.objectId;
        var initial = params.initial;

        if (objectId.indexOf(".") < 0 && objectId.indexOf("-") < 0) {

            // Relative ID of object within this model
            objectId = params.modelId + "-" + params.objectId;

        } // Otherwise absolute ID of object in another model

        this._objectId = objectId;

        /**
         * Object's transform attribute values.
         * These are set by the tween, which subsequently applies them to the object's transform with a call to #update()
         */

        var attr = this.attr = {};

        ["translate", "rotate", "scale", "pivot"].forEach(function(xform) {
            var val = xform === "scale" ? 1 : 0;

            if (initial[xform] !== undefined) {
                attr[xform] = {};

                if (initial[xform].x !== undefined) {
                    attr[xform].x = val;
                }

                if (initial[xform].y !== undefined) {
                    attr[xform].y = val;
                }

                if (initial[xform].z !== undefined) {
                    attr[xform].z = val;
                }
            }
        });
    };

    /**
     * Sets this control's attribute values on the target object's transform
     */
    Human.timeline.ObjectTransformControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var object = Human.scene.objects[this._objectId];

        if (!object) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("Human.timeline.ObjectTransformControl", "Can't find object: " + this._objectId);
                this._targetMissing = true;
            }

            return;
        }

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        //TODO: Do we need to prevent transform update if object is not shown?
        // var shown = Human.timeline.showObjects[this._objectId];
        var shown = true;
        if (shown !== undefined && shown !== null && shown !== true) {
            return;
        }

        object.setTransform(this.attr);
    };

})();
;(function () {
    "use strict";

    /**
     * Manipulates the texture of a material in a Material Module
     */
    Human.timeline.TextureControl = function (params) {

        this._material = params.modelId + "/" + params.materialId;

        if (params.targetLayer === undefined || params.targetLayer === null) {
            Human.log.error("Human.timeline.TweenAnimation", "'texture' tween attribute expected: 'targetLayer'");
            return;
        }

        this._targetLayer = params.targetLayer;

        /**
         * Material texture layer attribute values.
         * These are set by the tween, which subsequently applies them to the texture layer with a call to #update()
         */
        this.attr = {
            rotate: {z: 0},
            translate: {x: 0, y: 0},
            scale: {x: 1, y: 1},
            blend: {factor: 1.0}
        };
    };

    /**
     * Sets this control's attribute values on the target material's texture
     */
    Human.timeline.TextureControl.prototype.update = function () {

        // Lazy-locate the target material
        // This is here so that we're not dependent on the material being loaded in advance

        var material = Human.assets.materials.materials[this._material];

        if (!material) {

            // Material not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._material);
                this._targetMissing = true;
            }

            return;
        }

        // Update the material texture layer

        var textures = material.textures;

        if (this._targetLayer >= 0 && this._targetLayer < textures.length) {

            var texture = textures[this._targetLayer];
            var attr = this.attr;

            if (attr.scale) {
                texture.setScale(attr.scale);
            }

            if (attr.translate) {
                texture.setTranslate(attr.translate);
            }

            if (attr.rotate !== undefined && attr.rotate !== null) {
                texture.setRotate(attr.rotate.z);
            }

            if (attr.blend !== undefined && attr.blend !== null) {
                texture.setBlendFactor(attr.blend.factor);
            }
        }
    };


})();
;(function () {
    "use strict";

    /**
     * Controls the attributes of a material
     */
    Human.timeline.FresnelControl = function (params) {

        this._materialId = params.modelId + "/" + params.materialId;
        this._fresnelType = params.fresnelType;

        // Backwards Compatibility: Convert baseFresnel to colorFresnel
        if (this._fresnelType === "baseFresnel"){
            this._fresnelType = "colorFresnel";
        }

        // Fresnel attribute values.
        // These are set by the tween, which subsequently applies them to the fresnel with a call to #update()
        //
        this.attr = {
            bias: {
                edge: 0.0,
                center: 0.7,
                power: 1.0
            },
            edge: {
                r: 0.8,
                g: 0.7,
                b: 0.7
            },
            center: {
                r: 0.05,
                g: 0.05,
                b: 0.09
            }
        };
    };

    /**
     * Sets this control's attribute values on the target material
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.FresnelControl.prototype.update = function () {

        if (!this._fresnel) {

            // Lazy-locate the target material
            // This is here so that we're not dependent on the material being loaded in advance

            var material = Human.assets.materials.materials[this._materialId];

            if (!material) {

                // Material not found

                if (!this._materialMissing) {

                    // Warn once only

                    Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._materialId);
                    this._materialMissing = true;
                }

                return;
            }


            // Get color channel, eg "emitFresnel" -> "emit"
            var type = this._fresnelType.length <= 7 ? this._fresnelType : this._fresnelType.substring(0, this._fresnelType.length - 7);

            this._fresnel = material.fresnels[type];

            if (!this._fresnel) {

                // Fresnel not found

                if (!this._fresnelMissing) {

                    // Warn once only

                    Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find fresnel type: " + this._fresnelType);
                    this._fresnelMissing = true;
                }

                return;
            }
        }

        // TODO: Avoid needlessly resetting each attribute?

        var bias = this.attr.bias;

        this._fresnel.setEdgeBias(bias.edge);
        this._fresnel.setCenterBias(bias.center);
        this._fresnel.setPower(bias.power);
        this._fresnel.setEdgeColor(this.attr.edge);
        this._fresnel.setCenterColor(this.attr.center);

        return true;
    };

})();
;(function() {
  "use strict";

  /**
   * Use the tweenParticleLookup calculated in the web app to locate
   * the particle system of interest.  See `merge-particle-systems.ts` in human-studio-next for more info.
   */
  Human.timeline.tweenParticleLookup = function(particleSystemId) {
    var activeChapterId = Human.timeline.activeRoot._nowBranch.id;
    var activeModules = Object.keys(Human.modules.moduleData);

    // There's currently behavior where multiple modules can be active at the same time
    // This occurs when saving a module to a bookmark for the first time.
    // assume the last module.
    var activeModuleId = activeModules[activeModules.length - 1];
    var lookup = Human.modules.moduleData[activeModuleId].tweenParticleLookup;

    var id = lookup && lookup[activeChapterId] && lookup[activeChapterId][particleSystemId] ? lookup[activeChapterId][particleSystemId] : particleSystemId;

    // We also need to have a fallback for data using the previous particle Id merging scheme (prepending chapter Ids)
    // Once all the data is properly migrated to using TweenParticleLookups, then this code can be removed.
    var legacyId = Human.timeline.activeRoot._nowBranch.id + "/" + id;
    var ps = Human.particles.systems[id] || Human.particles.systems[legacyId];
    
    return ps;
  };

})();;(function () {
    "use strict";

    /**
     * Controls the state of a scene object
     */
    Human.timeline.ParticleSystemControl = function (params) {

        this.particleSystemId = params.particleSystemId;

        /**
         * Object attribute values.
         * These are set by the tween, which subsequently applies them to the object with a call to #update()
         */
        this.attr = {

            attr: {
            }
            
        };

        this._targetMissing = false;
    };

    /**
     * Sets this control's attribute values on the target object
     */
    Human.timeline.ParticleSystemControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance
        var ps = Human.timeline.tweenParticleLookup(this.particleSystemId);


        if (!ps) {
            // Object not found
            // Warn once only
            if (!this._targetMissing) {
                Human.log.warn("ParticleSystemControl: can't find system: ", this.particleSystemId);
                this._targetMissing = true;
            }
            return;
        }

        var attr = this.attr.attr;

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        if (ps.enabled && attr) {
            if (attr.emissionAverage !== undefined) {
                ps.emissionAverage = attr.emissionAverage;
            }

            if (attr.emissionVariance !== undefined) {
                ps.emissionVariance = attr.emissionVariance;
            } 
        }
    };

})();
;(function () {
    "use strict";

    var tempVec3 = vec3.create();
    var tempVec3b = vec3.create();

    /**
     * Controls the state of a scene object
     */
    Human.timeline.ParticleComponentControl = function (params) {

        this.particleSystemId = params.particleSystemId;
        this.componentId = params.componentId;

        /**
         * Object attribute values.
         * These are set by the tween, which subsequently applies them to the object with a call to #update()
         */
        this.attr = {

            attr: {
            },

            position: {
            },

            translate: {
            },

            scale: {
            },

            rotate: {
            },

            directionAverage: {
            },

            shapeTranslate: {
            },

            shapeScale: {
            },

            shapeRotate: {
            }
        };

        this._targetMissing = false;
    };

    /**
     * Sets this control's attribute values on the target object
     */
    Human.timeline.ParticleComponentControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var ps = Human.timeline.tweenParticleLookup(this.particleSystemId);

        if (!ps) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("ParticleComponentControl: can't find system: ", this.particleSystemId);
                this._targetMissing = true;
            }
            return;
        }

        var component = ps.components[this.componentId];

        if (!component) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("ParticleComponentControl: can't find component: " + this.componentId);
                this._targetMissing = true;
            }
            return;
        }

        var shape = component.shape;

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        if (ps.enabled) {
            var attr = this.attr.attr;
            var position = this.attr.position;
            var translate = this.attr.translate;
            var scale = this.attr.scale;
            var rotate = this.attr.rotate;
            var directionAverage = this.attr.directionAverage;
            var shapeTranslate = this.attr.shapeTranslate;
            var shapeRotate = this.attr.shapeRotate;
            var shapeScale = this.attr.shapeScale;

            if (attr) {

                if (attr.average !== undefined) {
                    component.average = attr.average;
                }

                if (attr.variance !== undefined) {
                    component.variance = attr.variance;
                }

                if (attr.forceAverage !== undefined) {
                    component.forceAverage = attr.forceAverage;
                }

                if (attr.forceVariance !== undefined) {
                    component.forceVariance = attr.forceVariance;
                }

                if (attr.frequency !== undefined) {
                    component.frequency = attr.frequency;
                }

                if (attr.friction !== undefined) {
                    component.friction = 1 - attr.friction;
                }

                if (attr.radius !== undefined) {
                    component.radius = attr.radius;
                }

                if (attr.directionVariance !== undefined) {
                    component.directionVariance = attr.directionVariance;
                }
            }

            if (position && position.x !== undefined) {
                tempVec3[0] = position.x;
                tempVec3[1] = position.y;
                tempVec3[2] = position.z;
                component.position.set(tempVec3);
            }

            if (translate && translate.x !== undefined) {
                tempVec3[0] = translate.x;
                tempVec3[1] = translate.y;
                tempVec3[2] = translate.z;
                component.translate.set(tempVec3);
            }

            if ((scale || rotate) && component.xform) {
                var scaleVec = null;
                var rotateVec = null;

                if (scale && scale.x !== undefined) {
                    scaleVec = tempVec3;
                    scaleVec[0] = scale.x;
                    scaleVec[1] = scale.y;
                    scaleVec[2] = scale.z;
                }

                if (rotate && rotate.x !== undefined) {
                    rotateVec = tempVec3b;
                    rotateVec[0] = rotate.x;
                    rotateVec[1] = rotate.y;
                    rotateVec[2] = rotate.z;
                }

                Human.math.buildRotationScaleMat3(component.xform, rotateVec, scaleVec);
            }

            if (directionAverage && directionAverage.x !== undefined) {
                tempVec3[0] = directionAverage.x;
                tempVec3[1] = directionAverage.y;
                tempVec3[2] = directionAverage.z;
                vec3.normalize(component.directionAverage, tempVec3);
            }

            if (shape) {

                if (shapeTranslate && shapeTranslate.x !== undefined) {
                    tempVec3[0] = shapeTranslate.x;
                    tempVec3[1] = shapeTranslate.y;
                    tempVec3[2] = shapeTranslate.z;
                    shape.translate.set(tempVec3);
                }

                if (shapeRotate && shapeRotate.x !== undefined) {
                    tempVec3[0] = shapeRotate.x;
                    tempVec3[1] = shapeRotate.y;
                    tempVec3[2] = shapeRotate.z;
                    shape.rotate.set(tempVec3);
                }

                if (shapeScale && shapeScale.x !== undefined) {
                    tempVec3[0] = shapeScale.x;
                    tempVec3[1] = shapeScale.y;
                    tempVec3[2] = shapeScale.z;
                    shape.scale.set(tempVec3);
                }

                shape.updateXform();
            }

        }
    };

})();
;/** Leaf timeline
 * Direct controller of animation assets (morphs and tweens)
 * Animations can come from model (state folder) or tween/morph creator functions.
 * Free Animations will be registered here, but played/updated by root.
 * Options to ignore animated camera.
 */
(function(){
    "use strict";

    var Leaf = Human.timeline.LeafTimeline = function (name, params) {
        
        var self = this;
        params = params || {};
        self.level = "leaf";			     // Identifies the kind of timeline
        self.id = name;                // use required 'name' arguemnt
        self.animations = {};          // all animations (free and timeline)
        self.timelineAnimations = {};  // controlled by branch timelines
        self.freeAnimations = {};		   // always update on tick.
        self.cameraTween = null;       // Null or first camera tween in animations.

        //Camera Controls
        self.animationCtx = {
            cameraEnabled: true			//Default is to allow animation camera tweens to play if present
        };

        //Register With Timeline Controller
        Human.timeline.leafTimelines[self.id] = self;
    };

    /**
     * Attaches animation to leaf.
     * Animation object is a collection of tween/morph objects
     */
    Leaf.prototype.addAnimation = function (animationId, animation) {
        var self = this;
        // Validate
        if (!animation) {
            Human.log.error("LeafTimeline.addAnimation", "null or undefined animation object");
            return;
        }

        if (!animation.update) {
            //All animations must come with update() function
            Human.log.error("LeafTimeline.addAnimation", "Param expected: update");
            return;
        }

        // Replace and attach
        if (self.animations[animationId]) {
            self.removeAnimation(animationId);
        }
        self.animations[animationId] = animation;


        // Attach to free or timeline
        if (animation.timeline === false) {
            // Free
            self.freeAnimations[animationId] = animation;

        } else {
            // Controlled
            self.timelineAnimations[animationId] = animation;
        }

        //Look for and register first camera tween object
        if (!self.cameraTween) {

            var found = false;
            var i;
            var len;
            var tweens = animation._tweens || [];
            var tween;
            var CameraControl = Human.timeline.CameraControl;

            for (i = 0, len = tweens.length; i < len && !found; i++) {
                tween = tweens[i];
                if (tween._control) {
                    if (tween._control instanceof CameraControl) {
                        found = true;
                        self.cameraTween = tween;
                    }
                }
            }
        }

        Human.events.fire("Timeline.Loaded");
    };

    /**
     * Destroy animation (all tweens/morphs associated)
     */
    Leaf.prototype.removeAnimation = function (animationId) {
        var self = this;
        var animation = self.animations[animationId];

        // Validate
        if (!animation) {
            Human.log.warn("Human.timeline.LeafTimeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }


        // Remove from free and controlled collections
        if (animationId in self.freeAnimations) {
            delete self.freeAnimations[animationId];
        } else {
            delete self.timelineAnimations[animationId];
        }
        delete self.animations[animationId];

        // Destroy animaton (tween/morph prototype function)
        if (animation.destroy) {
            animation.destroy();
        }
    };

    /**
     * Returns maximum time frame in the collection of animations.
     */
    Leaf.prototype.getTimeFrame = function () {
        var self = this;
        var anyAnimations = false;
        var max = 0;
        var timeFrame;
        var lastTime;
        var timelineAnimations = self.timelineAnimations; // OPTIMIZATION: avoid dereference each iteration

        // Count all controlled Animations
        for (var animationId in  timelineAnimations) {
            if (timelineAnimations.hasOwnProperty(animationId)) {

                anyAnimations = true;
                lastTime = timelineAnimations[animationId].lastTime;
                max = Math.max(max, lastTime);
            }
        }

        // Result
        timeFrame = {
            firstTime: 0.0,
            lastTime: max
        };

        return timeFrame;
    };

    /**
     * Calls the update() function on all constituent timelines for the passed time.
     * @param boolean cameraEnabled  Whether to play camera tween or not
     */
    Leaf.prototype.update = function (cameraEnabled, time, params) {
        var self = this;
        params = params || {};

        // Defaults to play camera tween unless told not to.
        var ctx = {
            cameraEnabled: cameraEnabled === false ? cameraEnabled : self.animationCtx.cameraEnabled
        };

        var timelineAnimations = self.timelineAnimations; // OPTIMIZATION: avoid dereference each iteration
        var animation;

        // Update all timeline Animations to given time
        for (var animationId in timelineAnimations) {
            if (timelineAnimations.hasOwnProperty(animationId)) {

                //TODO: patch to make up for dynamic camera tweens having different update interface
                animation = timelineAnimations[animationId];

                if (animation.type === "lerp:camera") {
                    //tween returned by flyTo() function -- dynamic tween
                    animation.update(time);
                } else {
                    animation.update(ctx, time);
                }
            }
        }
    };

    /** Remove references to Animations
     */
    Leaf.prototype.destroy = function () {
        var self = this;
        self.animations = {};
        self.freeAnimations = {};
        self.timelineAnimations = {};
        self.cameraTween = null;
        delete Human.timeline.leafTimelines[self.id];
    };

    /* Unload Animation type from
     */
    Leaf.prototype.unload = function(assetType) {
        var self = this;
        var targetType = (assetType==="tweens")? Human.timeline.TweenAnimation: Human.assets.morphs.Animation;
        var animationId;
        for (animationId in self.animations){
            if (self.animations.hasOwnProperty(animationId)){
                if (self.animations[animationId] instanceof targetType){
                    delete self.animations[animationId]; // delete here
                    Human.timeline.removeAnimation(animationId); // delete from timeline
                }
            }
        }

    };

    /** Get camera of timeline at specific time
     * Leaf timelines should only have one or zero cameras
     * Returns camera info at time t if camera exists otherwise null.
     */
    Leaf.prototype.getCamera = function (time) {
        var self = this;
        if (self.cameraTween === null || self.cameraTween === undefined) {
            return null;
        }
        return self.cameraTween.query(self.cameraTween._control, time);
    };

})();
;/** Branch timeline
 * Branch timelines control updates to leaf timelines.
 * Can reference as many leaf-timelines as desired.
 * Should not map to two-different times on the same leaf.
 * INITIALIZATION - Special Handling of First Update to ensure all branches are independent.
 *    - Connfigurable initialization with default to clear and start with chapter data.
 *
 * Concerns:
 *    - Camera Animation:
 *      Engine can only handle one camera tween because there is only one Camera
 *      object. Theoretically, however, each branch map can point to one
 *      or more leaftimlines with a camera path. We currently have to stick with
 *      one; arbitrarily chosen to be the first one encountered.
 *      TODO: Tack and Obey "timeline.chapterCameraPath" property.
 *
 * TODO: Make this inherit from "chapter" data object?
*/

// unpack chapter data lights to the map of light-ids to be turned on.
function unpackChapterLights(lightData){
    /*
    This allows us to keep shared lights belonging to a shared library
    separate from the lights defined locally.
    */
    "use strict";
    var lightConfig = {};
    var i=0,j=0;
    var libId, assetLibs = Human.assets.lights.lightIds;
    var defaults = Human.renderer.lights.defaultLightIds;
    // individual lights
    if (lightData.lights.length){
        for (i=0; i<lightData.lights.length; i++) {
            lightConfig[lightData.lights[i]] = true;
        }
    }

    // light libraries unpacked to individual lights
    if (lightData.libraries.length){
        for (i=0; i<lightData.libraries.length; i++){
            libId = lightData.libraries[i];
            if (assetLibs.hasOwnProperty(libId)){
                for (j=0; j<assetLibs[libId].length; j++){
                    lightConfig[assetLibs[libId][j]] = true;
                }
            } else if (libId === "default"){
                for (j=0; j<defaults.length; j++){
                    lightConfig[defaults[j]] = true;
                }
            }
        }
    }
    return lightConfig;
}

(function(){
    "use strict";

    ///// BUG: see https://github.com/biodigital-human/human-studio-next/pull/590
    Human.timeline.forceRefreshLightsForChapter = function(chapterLights) {
        Human.renderer.lights.clearEnabled();
        var unpacked = unpackChapterLights(chapterLights);
        Human.renderer.lights.setEnabled(unpacked);
    };
    /////

    var Branch = Human.timeline.BranchTimeline = function(humanChapter) {
        var self = this;  // self refers to a specific chapter branch timeline object.
        self._onEndOptions = ["loop", "freeze"]; //options for any constituent timelines after it has ended
        self.level = "branch";
        self.timeRange = null;

        self.id = humanChapter.id;
        self.maps = {};                    // Unique map components to map from branch timeline to child timelines - for animations
        humanChapter.timelineMap.forEach(function(map, idx){
          self.makeMapComponent(map, idx);
        });

        self.media = {};
        for (var clipMap in humanChapter.media){
            if (humanChapter.media.hasOwnProperty(clipMap)){
                self.addClip(clipMap, humanChapter.media[clipMap]);
            }
        }

        //TODO[PostRelease] - group info fields into single info object in humanChapter
        self.info = {
            displayName: humanChapter.displayName || "",
            description: humanChapter.description || ""
        };
        self.synchronization = humanChapter.synchronization;
        self.properties = humanChapter.properties || {};
        self.annotations = humanChapter.annotations || [];
        self.hotspots = humanChapter.hotspots || [];

        // NOTE(Tarek): Don't support alphaToCoverage via content yet.
        if (humanChapter.transparencyMode === "alphaToCoverage") {
            humanChapter.transparencyMode = null;
        }

        self.transparencyMode = humanChapter.transparencyMode || "alpha";

        if (self.transparencyMode === "weightedOIT" && !SceneJS.WEBGL_INFO.floatTexturesSupported) {
            self.transparencyMode = humanChapter.fallbackTransparency || "alpha";
        }

        // View Modes: xray, single/multi-pick, dissect, isolate
        self.viewModes = humanChapter.viewModes || {};

        // TODO[PostRelease] - group options into options block in humanChapter
        self.options = humanChapter.options || {};
        if (humanChapter.hasOwnProperty("xray")){
          self.viewModes.xray = humanChapter.xray;
        }

        self.camera = {};
        // TODO[PostRelease] - redefine humanChapter.camera to be action/location/screenPan in the data
        if (humanChapter.camera){
            self.camera = humanChapter.camera;
        }
        else {
            if (humanChapter.jumpTo){
                self.camera.action = "jumpTo";
                self.camera.location = humanChapter.jumpTo;
                if (humanChapter.jumpTo.hasOwnProperty("screenPan")){
                  self.camera.screenPan = humanChapter.jumpTo.screenPan;
                }
                if (humanChapter.jumpTo.hasOwnProperty("rotationCenter")){
                  self.camera.rotationCenter = humanChapter.jumpTo.rotationCenter;
                }
            } else if (humanChapter.flyTo) {
                self.camera.action = "flyTo";
                self.camera.location = humanChapter.flyTo;
                if (humanChapter.flyTo.hasOwnProperty("screenPan")){
                  self.camera.screenPan = humanChapter.flyTo.screenPan;
                }
                if (humanChapter.flyTo.hasOwnProperty("rotationCenter")){
                  self.camera.rotationCenter = humanChapter.flyTo.rotationCenter;
                }
            }
            if (humanChapter.options && humanChapter.options.screenPan){
                self.camera.screenPan = humanChapter.options.screenPan;
            } else if (humanChapter.hasOwnProperty("screenPan")){
                self.camera.screenPan = humanChapter.screenPan;
            }
        }

        //TODO[PostRelease] - group animation options into animation block in humanChapter
        self.animation = {"loop":false};
        if (humanChapter.loop){
            self.animation.loop = true;
        }

        //TODO[PostRelease] - should we copy default background to chapter background if not defined?
        self.background = humanChapter.background || {};

        // Clipping Planes
        self.clippingPlanes = humanChapter.clippingPlanes || {};
        self.effects = humanChapter.effects;

        // Per-Chapter UI configuration
        self.ui = humanChapter.ui || {};

        // Per-Chapter lighting
        self.lights = humanChapter.lights; // data format

        var environment = humanChapter.environment || humanChapter; // TODO: Why some chapters wrap the cubemaps in 'environment' and not others?

        // Per-Chapter reflections
        if (environment.reflectionMap && environment.reflectionMap.length > 0) {
            self.reflection = environment.reflectionMap[0];
        }

        // Per-Chapter light maps
        if (environment.lightMap && environment.lightMap.length > 0) {
            self.lightmap = environment.lightMap[0];
        }

        // Per-Chapter Graph
        self.graph = humanChapter.graph || {};

        // Bookkeeping Variables - track initialization progress
        self.firstUpdate = true;          // on first update we want to force the camera into correct position
        self.initializedCamera = false;
        self.initializedAnnotations = false;
        self.initializedProperties = false;
        self.initializedGraph = false;
        self.initializedHotspots = false;
        self.initializedParticles = false;
        self.initializedClippingPlanes = false;
        self.initializedPostprocess = false;
        self.initializedTransparencyMode = false;

        // Custom Data
        self.customData = humanChapter.customData || {};

        // Particles TODO[EM] Add Particles to spec
        self.particleSystems = self.customData.particleSystems || [];
        self.ssaa = !!self.customData.ssaa;

        self.postprocess = self.customData.postprocess || [];

        if (window.localContentOnly) {
            self.postprocess.push({"effect":"fxaa"});
        }

        // Translations for displayName and description
        self.translations = self.translations || {};

        //Register with Timeline
        Human.timeline.branchTimelines[self.id] = self;
    };

    // Branch Media Clips
    Branch.prototype.addClip = function (clipMap, clip) {
        var self = this;
        if (self.media.hasOwnProperty(clipMap)) {
            delete self.media[clipMap];
        }

        // NOTE[EM] - fullUrl is a require clip property
        // if (!clip.hasOwnProperty("fullUrl")){
        //     clip.fullUrl = Human.media[clip.streamType].clips[clip.clipId].fullUrl;
        // }

        var mclip = {"data": clip, "published": false};

        mclip.publish = function () {
            Human.events.fire(clip.streamType + ".suggestedClipInfo", this.data);
            Human.events.fire(clip.streamType + ".suggestedClips", [this.data.clipId], true);
            this.published = true;
        };

        mclip.update = function (time) {
            if (this.data.time1 <= time && time <= this.data.time2) {
                if (!this.published) {
                    this.publish();
                }
            }
        };

        self.media[clipMap] = mclip;

    };

    // Branch Timeline Maps
    Branch.prototype.makeMapComponent = function (mapData, idx) {
        var self = this;
        var map = {};
        map.mapId = mapData.data.timeline + "_" + idx;
        map.start = mapData.start;
        map.end = mapData.end;
        map.data = mapData.data;

        if (Human.timeline.leafTimelines.hasOwnProperty(mapData.data.timeline)){
          map.data.timeline = Human.timeline.leafTimelines[mapData.data.timeline];
        } else {
          var _leaf = new Human.timeline.LeafTimeline(mapData.data.timeline);
          // map.data.timeline = Human.timeline.leafTimelines.dummy;
          map.data.timeline = _leaf;
        }

        // Create mapping function childTime = f(branchTime) : map.calcChildTime()
        var m;
        var b;
        if (map.data.fit) {
            // y = mx+b;
            var dy = map.data.end - map.data.start;
            var dx = map.end - map.start;
            m = dy / dx;
            b = map.data.start;
            map.calcChildTime = function (branchTime) {
                return m * (branchTime - map.start) + b;
            };
        }
        else {
            //y = mx + b;  x can be offset by where in time the map starts.
            m = 1.0;    //by definition
            b = map.data.start;
            if (map.data.onEnd === "freeze") {
                map.calcChildTime = function (branchTime) {
                    var y = m * (branchTime - map.start) + b;
                    return Math.min(y, map.data.end);
                };
            }
            else if (map.data.onEnd === "loop") {
                map.calcChildTime = function (branchTime) {
                    //SawTooth Function
                    var period = map.data.end - map.data.start;
                    var x = (branchTime - map.start);
                    return x - (period * Math.floor(x / period)) + b;
                };
            }
            else {
                Human.log.warn("WARNING: invalid onEnd property for branch timeline map data.");
            }
        }

        self.maps[map.mapId] = map;

        self.timeRange = self.getTimeFrame(); // update time range in case new map has changed it.
    };

    // Get All Branch Audio Clips
    Branch.prototype._getAudio = function () {
        var self = this;
        var audioClips = [];
        for (var clipId in self.media) {
            if (self.media.hasOwnProperty(clipId)) {
                if (self.media[clipId].data.streamType === "audio") {
                    audioClips.push(self.media[clipId].data);
                }
            }
        }
        return audioClips;
    };

    // Get start and end time of the entire branch
    Branch.prototype.getTimeFrame = function () {
        var self = this;
        var longestTime = 0.0;
        for (var amapId in self.maps) {
            if (self.maps.hasOwnProperty(amapId) && self.maps[amapId].end > longestTime) {
                longestTime = self.maps[amapId].end;
            }
        }
        if (longestTime === 0.0) {
            longestTime = 2.0;//Default time frame.
        }
        var _timeFrame = {
            firstTime: 0.0,
            lastTime: longestTime
        };
        return _timeFrame;
    };

    // Get Camera Eye/Look/Up Location data
    Branch.prototype.getCamera = function (time) {
        var self = this;
        if (time === "end") {
            time = self.getTimeFrame().lastTime;
        } else if (time === "start") {
            time = 0.0;
        }

        // If camera is tweened query the camera tween: Return eye/look/up
        var cameraLocation = self.getAnimatedCamera(time);
        if (cameraLocation) {
            cameraLocation.screenPan = cameraLocation.screenPan || self.options.screenPan;
            return cameraLocation;
        }

        // If chapter has camera property
        if (!Human.utils.isEmpty(self.camera)) {
            cameraLocation = self.camera.location;
            cameraLocation.screenPan = self.options.screenPan;
            return cameraLocation;
        }

        // Otherwise Use Default
        var defaultCamera = Human.renderer.camera._startcamera; //Fallback if no other methods found
        defaultCamera.screenPan = self.options.screenPan;
        return defaultCamera;
    };

    // Get the Eye/Look/Up from Camera tween, Null if DNE
    Branch.prototype.getAnimatedCamera = function (time) {
        var self = this;
        var timeRange = self.getTimeFrame();

        //cast time
        if (time === "start" || time < timeRange.startTime) {
            time = timeRange.startTime;
        } else if (time === "end" || time === "last" || time > timeRange.lastTime) {
            time = timeRange.lastTime;
        }

        var cameraMap = self.whichCameraMap(0);

        if (cameraMap === null || cameraMap === undefined) {
            return null;
        } else if (time >= cameraMap.start && time <= cameraMap.end) {
            var childTimeline = cameraMap.data.timeline;
            var childtime = cameraMap.calcChildTime(time);
            var camera = childTimeline.getCamera(childtime);
            if (camera !== null && camera !== undefined) {
                return camera;
            }
        } else {
            return null;
        }
    };

    Branch.prototype.whichCameraMap = function (time) {
        var self = this;
        var targetMaps = self.whichMaps(time);
        var idx;
        for (idx=0; idx<targetMaps.length; idx++){
            if (!!targetMaps[idx].map.data.timeline.cameraTween){
                return targetMaps[idx].map;
            }
        }
        //return null if current branch does not have an animated camera tween in its data
        return null;
    };

    Branch.prototype.reset = function () {
        var self = this;
        self.firstUpdate = true;
        self.initializedGraph = false;
        self.initializedCamera = false;
        self.initializedHotspots = false;
        self.initializedProperties = false;
        self.initializedAnnotations = false;
        self.initializedParticles = false;
        self.initializedClippingPlanes = false;
        self.initializedPostprocess = false;
        self.initializedTransparencyMode = false;

        // Reset media objects
        var media = self.media;
        var key;
        var mediaObj;

        // VERIFY: I'm assuming that each item in self.media is an object with a 'published' property
        for (key in media) {
            if (media.hasOwnProperty(key)) {
                mediaObj = media[key];
                mediaObj.published = false;
            }
        }
    };

    Branch.prototype.whichMaps = function (time) {
        var self = this;
        var theMapIds = [];
        var result = [];

        if (time === "start") {
            time = 0.0;
        } else if (time === "end") {
            time = self.getTimeFrame().lastTime;
        }


        for (var mapId in self.maps) {
            if (self.maps.hasOwnProperty(mapId)) {
                var map = self.maps[mapId];
                if (time >= map.start && time <= map.end) {
                    theMapIds.push(mapId);
                }
            }
        }

        //Prefer "keepCamera" over "camera"
        // TODO[EM]: Safe to delete?
        // if (theMapIds.indexOf("transitionCamera") >= 0) {
        //     var ci = theMapIds.indexOf("camera");
        //     if (ci !== null && ci !== undefined) {
        //         theMapIds.splice(ci, 1);
        //     }
        // }

        theMapIds.every(function (mapId) {
            var map = self.maps[mapId];
            var o = {map: map};
            if (map.data.timeline.level === "leaf") {
                o.camera = true;
                result.push(o);
            } else {
                o.camera = false;
                result.unshift(o);
            }
            return true;
        });

        return result;

    };

    Branch.prototype.getChildLeafTimelines = function (time) {
        var self = this;
        var maps = self.whichMaps(time);
        var result = {};
        maps.every(function (d) {
            var leaf = d.map.data.timeline.id;
            var leafTime = d.map.calcChildTime(time);
            result[leaf] = leafTime;
            return true;
        });
        return result;
    };

    Branch.prototype.getUniqueLeafTimelines = function () {
        var self= this;
        var result = {};
        for (var mapid in self.maps) {
            if (self.maps.hasOwnProperty(mapid)) {
                var map = self.maps[mapid];
                result[map.data.timeline.id] = map.data.timeline;
            }
        }
        return result;
    };

    Branch.prototype.initCamera = function(time, ok) {
        /**
         * Update camera if (a) no camera tween, and (b) not ignored
         */
        var self = this;
        var cameraMap = self.whichCameraMap(time);
        if (!cameraMap && ! self.camera.ignore) {
            if (self.camera.screenPan) {
                Human.renderer.camera.setScreenPan(self.camera.screenPan);
            }
            if (self.camera.action === "flyTo") {
                Human.renderer.camera.fly.flyTo(self.camera.location, function() {
                    if (self.camera.rotationCenter) {
                        var rc = self.camera.rotationCenter;
                        Human.renderer.camera.setRotationCenter(rc[0], rc[1], rc[2]);
                    }
                    ok();
                });
            }
            else {
                Human.renderer.camera.fly.jumpTo(self.camera.location, function() {
                    if (self.camera.rotationCenter) {
                        var rc = self.camera.rotationCenter;
                        Human.renderer.camera.setRotationCenter(rc[0], rc[1], rc[2]);
                    }
                    ok();
                });
            }

        } else if (!!cameraMap) {
          if (self.camera.action === "flyTo") {
              Human.renderer.camera.fly.flyTo(self.getCamera(time), function() {
                if (self.camera.rotationCenter) {
                    var rc = self.camera.rotationCenter;
                    Human.renderer.camera.setRotationCenter(rc[0], rc[1], rc[2]);
                }
                ok();
              });
          }
          else {
              Human.renderer.camera.fly.jumpTo(self.getCamera(time), function() {
                if (self.camera.rotationCenter) {
                    var rc = self.camera.rotationCenter;
                    Human.renderer.camera.setRotationCenter(rc[0], rc[1], rc[2]);
                }
                ok();
              });
          }
        }
        else if (ok) {
            ok();
        }
    };

    // deprecated
    Branch.prototype.initAnnotations = function(annotations) {
        var self = this;
        if (Human.view) {
            //clear all annotations
            Human.view.annotations.clearAnnotations();

            //add ones defined in chapter
            annotations.forEach(function (annotation, i) {
                var annotationId = "___" + self.id + "." + i;

                if (!annotation.pos && annotation.objectId) {
                    // an attempt to be generous
                    var object = Human.scene.objects[annotation.objectId];
                    if (object){
                        annotation.pos = object.getCenter();
                    }
                }

                annotation.annotationId = annotationId;
                annotation.title = annotation.title || "";
                annotation.description = annotation.description || "";
                annotation.dir = annotation.pinVec || annotation.dir;
                annotation.type = annotation.type || "default";
                annotation.enabled = annotation.type !== "secondary";
                annotation.shown = annotation.type !== "secondary";
                annotation.labelShown = annotation.type !== "secondary";
                annotation.labelOffset = annotation.labelOffset || null;
                annotation.saved = true;

                Human.view.annotations.createAnnotation(annotation);
            });
        }
    };

    Branch.prototype.initGraph = function(synchronization){
        // Single-traversal object property setting procedure
        Human.scene.setObjectProperties(synchronization);
    };

    Branch.prototype.initProperties = function(){
        var self = this;

        // activate lights
        Human.renderer.lights.clearEnabled();
        Human.renderer.lights.setEnabled(unpackChapterLights(self.lights));

        var scene = Human.renderer.getScene();

        // Activate reflections
        scene.deactivateReflection();
        if (self.reflection) {
            scene.activateReflection(self.reflection);
        }

        // Activate lightmaps
        scene.deactivateLightmap();
        if (self.lightmap) {
            scene.activateLightmap(self.lightmap);
        }

        if (Human.view) {
            Human.view.setViewModes(self.viewModes);
        }

        Human.properties.applyDefaults();

        //All other properties
        Human.properties.set(self.properties);
    };

    Branch.prototype.initParticles = function(){
        for (var i = 0, len = this.particleSystems.length; i < len; ++i) {
            Human.particles.enable(this.particleSystems[i]);
        }
    };

    Branch.prototype.initClippingPlanes = function(){
      /* Clipping planes
       *
       * NOTE: Dependency on Boundary ==========================================
       * By default, When setting a clipping plane, the clip manager will set the plane
       * relative to the boundary of the enabled objects. If the objects are not loaded,
       * the boundary will either be wrong (smaller than it should be) or inverted. When
       * inverted, the clipping planes will block any objects from appearing. This feature
       * does not play well with progressive loading.
       *
       * To recreate the intended clipping plane in the absence of complete object
       * loading (i.e. during a progressive load), the boundary can be passed as a config
       * to clip.setClip().
       */

      // alway start fresh
      Human.renderer.clip.reset();


      // only set the planes defined
      var clipKey;
      for (clipKey in this.clippingPlanes.clips) {
        if (this.clippingPlanes.clips.hasOwnProperty(clipKey)) {
          var clip = Human.utils.shallowClone(this.clippingPlanes.clips[clipKey]);
          clip.boundary = this.clippingPlanes.boundary;
          Human.renderer.clip.setClip(clip);
        }
      }
    };

    Branch.prototype.initPostprocess = function(){

        // parse out groundShadow config and apply seperately.
        var postprocess = this.postprocess.filter(function(effect) {
            return effect.effect !== 'groundShadow';
        });

        Human.renderer.postprocess.parse(postprocess);


        // set up the ground shadow if there is one:
        for (var i = 0; i < this.postprocess.length; i++) {
            if (this.postprocess[i].effect === 'groundShadow') {
                var groundShadow = this.postprocess[i];
                Human.renderer.groundShadow.init();
                Human.renderer.groundShadow.update({
                  blurAmount: groundShadow.blur,
                  opacity: groundShadow.opacity,
                  translation: [groundShadow.xPos, groundShadow.yPos, groundShadow.zPos],
                  scale: groundShadow.size,
                });
                return;
            }
        }

        // if there's no ground shadow in this chapter, turn it off:
        Human.renderer.groundShadow.destroy();
    };

    Branch.prototype.initTransparencyMode = function(){
        Human.renderer.setTransparencyMode(this.transparencyMode);
    };


    Branch.prototype.init = function(time, params, ok){
        var self = this;
        // book keeping
        Human.events.fire("timeline.chapters.activate.start", {
            chapterId: self.id,
            params: params
        });
        self.timeRange = self.getTimeFrame();

        // configurable initialization update
        if (params.camera && !self.initializedCamera) {
            self.initializedCamera = true;
            self.initCamera(time, params.cameraCallback || function(){});
        }

        if (params.graph && ! self.initializedGraph) {
            self.initializedGraph = true;
            self.initGraph(self.synchronization);
        }

        if (params.properties && !self.initializedProperties) {
            self.initializedProperties = true;
            self.initProperties();
        }

        if (params.particles && !self.initializedParticles) {
            Human.particles.disableAll();
            Human.particles.resetAll();
            self.initializedParticles = true;
            self.initParticles();
        }

        if (params.clipping && !self.initializedClippingPlanes) {
          self.initializedClippingPlanes = true;
          self.initClippingPlanes();
        }

        if (params.postprocess && !self.initializedPostprocess) {
            self.initializedPostprocess = true;
            self.initPostprocess();
        }

        if (params.transparencyMode && !self.initializedTransparencyMode) {
            self.initializedTransparencyMode = true;
            self.initTransparencyMode();
        }

        if (self.ssaa) {
           if (Human.renderer.getResolutionScalingSupported()) {
               Human.renderer.setResolutionScaling(2);
           }
        } else {
            Human.renderer.setResolutionScaling(1);
        }

        Human.events.fire("timeline.chapters.initializing", {
            chapterId: self.id,
            params: params
        });

        if (ok){
            ok();
        }
        Human.events.fire("timeline.chapters.activate.finish", {chapterId: self.id});
    };

    Branch.prototype.uninit = function(params,ok){
        //TODO[EM]: How to restore properties?
        //TODO[EM]: How to restore camera?
        var self = this;
        Human.events.fire("timeline.chapter.deactivate.start");
        self.initGraph({});

        // #TODO[EM]: chapter handling of annotations is deprecated.
        self.initAnnotations([]);

        //self.initCamera();
        if (ok){
            ok();
        }
        Human.events.fire("timeline.chapter.deactivate.finish");
    };

    Branch.prototype.update = function (time, params, ok) {
        params = params || {};
        var self = this;
        // Handle first update
        if (self.firstUpdate) {
            self.firstUpdate = false;

            if (!params.hasOwnProperty("camera")){
                params.camera = !self.initializedCamera;
            }
            if (!params.hasOwnProperty("annotations")) {
                params.annotations = !self.initializedAnnotations;
            }
            if (!params.hasOwnProperty("properties")){
                params.properties = !self.initializedProperties;
            }
            if (!params.hasOwnProperty("graph")){
                params.graph = !self.initializedGraph;
            }
            if (!params.hasOwnProperty("particles")){
                params.particles = !self.initializedParticles;
            }

            if (!params.hasOwnProperty("clipping")){
                params.clipping = !self.initializedClippingPlanes;
            }

            if (!params.hasOwnProperty("postprocess")){
                params.postprocess = !self.initializedPostprocess;
            }

            if (!params.hasOwnProperty("transparencyMode")){
                params.transparencyMode = !self.initializedTransparencyMode;
            }

            self.init(time, params, function(){});
        }
        self._update2(time);

        if (ok){
            ok();
        }
    };

    Branch.prototype._update2 = function (time) {
        var self = this;
        if (self.timeRange === null || self.timeRange === undefined) {
            self.timeRange = self.getTimeFrame();
        }

        var timeRange = self.timeRange;

        if (time === "start" || time < timeRange.startTime) {
            time = timeRange.startTime;
        } else if (time === "end" || time === "last" || time > timeRange.lastTime) {
            time = timeRange.lastTime;
        }


        //update timeline maps
        var mapsData = self.whichMaps(time);

        mapsData.forEach(function (d) {
            var map = d.map;
            var cam = d.camera;
            var childTimeline = map.data.timeline;
            var childTime = map.calcChildTime(time);
            childTimeline.update(cam, childTime);
            return true;
        });

        //update media clips
        for (var mediaId in self.media) {
            if (self.media.hasOwnProperty(mediaId)) {
                self.media[mediaId].update(time);
            }
        }
    };

    Branch.prototype.destroy = function(){
        var self = this;
        // Destroys leaf timelines
        var uniqueLeaves = self.getUniqueLeafTimelines();
        for (var leafId in uniqueLeaves){
            if (uniqueLeaves.hasOwnProperty(leafId) && leafId !=="dummy" ) {
                uniqueLeaves[leafId].destroy();
            }
        }
        delete Human.timeline.branchTimelines[self.id];
    };
})();
;/** Root timeline
 * Construction modalities:
 *  - Constructed by module, chapters added by module, build when done
 *
 * Responsibilities:
 *     - manage global time and playing of chapters
 *     - building a global timeline from branches
 *             -- build chapters and manage chapter queue
 *     - managing play status at borders between chapters
 *             -- chapter | chapter boundary
 *     - mapping global (root) to local (branch) times and back
 *     - editing queue
 *             -- add chapters
 *             -- delete chapters
 *             -- reorder chapters
 *
 * Concerns:
 *    - Intuitive control of camera.
 *
 */
(function(){
    "use strict";

    var Root = Human.timeline.RootTimeline = function (moduleId, params) {
        params = params || {};
        var self = this;

        // Variables
        self.id = moduleId;
        self.level = 'root';
        self.animationOptions = {}; // loop:true/false
        self._theQueue = [];      //Master Sequence of All Branch Timelines in the scene registered to be played; can NOT contain empty timelines.
        self._chapters = [];      //Only chapter branches in order
        self._times = [];         // the times corresponding to starts of constituent branch timelines.
        self._timeFrame = null;
        self.freeAnimations = {};

        // Variables: For Update
        self._firstUpdate = true;
        self._prevBranch = null;
        self._prevTime = null;
        self._nowBranch = null;
        self._nowTime = null;
    };

    /** Global Animation Options
     * Set and validate animation options from the 'data' object.
     * Replaces existing animation options.
     * Options that are only referenced at the start and end of global timeline.
     * Note, that rebuilding the root will force a start.
     */
    Root.prototype.setAnimationOptions = function (data, params) {
        var self = this;
        params = params || {};

        // Backwards Compatibility: animation property from module
        if (data.animation) {
            self.animationOptions = data.animation;
        }

        // TODO: Unspecified other options
    };

    /** Add Chapter Branch
     * Add a chapter to the chapters array.
     * @branch: a valid branch timeline object
     * @params.position : (integer) position in the queue.
     * @params.rebuild :  (boolean) specifying wheter to rebuild root after adding chapter.
     *
     * Generally, params.rebuild=false while loader is adding chapters to root and only true on the last chapter.
     */
    Root.prototype.addChapter = function (branch, params) {
        var self = this;
        params = params || {};
        var rebuild = (params.hasOwnProperty("rebuild")) ? params.rebuild : true;
        var position = params.position || self._chapters.length;

        if (position < 0 || position > self._chapters.length) {
            Human.log.warn("RootTimeline.addChapter(): Invalid index " + position + "position");
        }

        // Add to array
        self._chapters.splice(position, 0, branch);
        if (rebuild) {
            self.build();
        }
    };

    // Activate the Root and Step
    // TODO[EM]: How should we handle the time config? Don't like that it's part of init()
    Root.prototype.activate = function(time, config, ok){
        var self = this;
        Human.timeline.activeRoot = self;
        var branchInfo = self.mapGlobalTime(time, {which : "second", direction : "forwards"});

        // Fire Event and Inform Listeners
        Human.events.fire("timeline.chapters.updated", self._assembleChaptersUpdated());

        Human.events.fire("timeline.timeFrame.updated", {
            firstTime: self._timeFrame.firstTime,
            lastTime: self._timeFrame.lastTime
        });

        Human.timeline.stop();

        branchInfo.branch.init(branchInfo.time, config, function(){});
        Human.timeline.activeRoot.update(time, {
          which: 'second', direction: 'forwards'
        });

        Human.timeline.time = time;
        Human.timeline._time1 = time;
        Human.timeline._time2 = time;
        Human.timeline._freeTime = time;

        ok();
    };

    // Deactive the Root
    Root.prototype.deactivate = function(config, ok){
        var self = this;
        if (Human.timeline.activeRoot === null) {
          return;
        }
        if (Human.timeline.activeRoot.id === self.id){
            // Fire Event and Inform Listeners
            Human.events.fire("timeline.chapters.updated", []);
            Human.events.fire("timeline.timeFrame.updated", {
                firstTime: 0,
                lastTime: 0
            });
            Human.timeline.activeRoot = null;
            Human.timeline.stop();
            Human.timeline.time = 0;
            Human.timeline._time1 = 0;
            Human.timeline._time2 = 0;
            Human.timeline._freeTime = 0.0;
            self._nowBranch.uninit(config, ok);
        }
    };

    /** --------------------------- HELPER AND QUERY FUNCTIONS ------------------------------
     */

    /** Get unique descendent leaf timeline
     * Return : {leafId: leafTimeline}
     */
    Root.prototype.getDescendentLeaves = function () {
        var self = this;
        var result = {};
        self._chapters.forEach(function (chapter) {
            var leafReferences = chapter.getChildLeafTimelines(0);
            for (var leafid in leafReferences) {
                if (leafReferences.hasOwnProperty(leafid)) {
                    if (!result.hasOwnProperty(leafid)) {
                        result[leafid] = Human.timeline.leafTimelines[leafid];
                    }
                }
            }
        });

        return result;
    };

    /** Get time frame (duration) of the root Timeline
     */
    Root.prototype.getTimeFrame = function (params) {
        var self = this;
        params = params || {};
        var end = 0.0;
        var sequence = self._chapters;

        // Sum up time of all branches in sequence
        sequence.forEach(function (branch) {
            end += branch.getTimeFrame().lastTime;
        });

        return {
            firstTime: 0.0,
            lastTime: end
        };
    };

    /** Get the index of branch.id in the root queue or optionally the chapters list.
     * Return null if not found
     */
    Root.prototype.whereIsBranch = function (branch, params) {
        var self = this;
        params = params || {};

        var idx = 0, found = false;
        var branchIndex = null;
        var sequence = [];
        if (params.chapters === true) {
            sequence = self._chapters;
        } else {
            // search whole timeline by default
            sequence = self._theQueue;
        }
        while (!found && idx < sequence.length) {
            found = (sequence[idx].id === branch.id) ? true : false;
            if (!found) {
                idx++;
            } else {
                branchIndex = idx;
            }
        }
        return branchIndex;
    };

    /** Get Branch from Que based on one property
     * @param.id : default, retrieve branch with specific id
     */
    Root.prototype.getBranch = function (params) {
        var self = this;
        params = params || {};
        var key, value, found = false, i = 0, branch = {};

        if (Human.utils.isEmpty(params)) {
            return null;
        } else if (Object.keys(params).length > 1) {
            Human.log.warn("timeline.RootTimeline.getBranch", "too many parameters, using only the first.");
        }

        // Search information
        key = Object.keys(params)[0];
        value = params[key];

        while (!found && i < (self._theQueue.length)) {
            branch = self._theQueue[i];
            if (self._theQueue[i][key] === value) {
                found = true;
            }
            i++;
        }

        var result;
        if (found) {
            result = branch;
        } else {
            result = null;
        }
        return result;
    };

    /** map global time TO local time on branch.
     * Returns object : {
        branch: branchTimeline,   # reference to corresponding branch timeline
        time: float,              # corresponding local time on branch
        index: integer            # the index of the branch in the reference sequence
     }
     *
     * @params.tie = "earlier"/"later" if take earlier/later branch in a border case
     * @params.which = "first/second"
     * @params.direction = "forwards/backwards"
     *
     * In the event of a tie, this function references either (a) the tie parameter, or
     * (b) the border condition which/direction parameters to pick the right target branch.
     *
     * Border cases include any time that can point to two branches.
     * By convention, the first and last branches border eachother. Therefore,
     * time 0 will point to lastBranch (as the "earlier" branch), and the first
     * branch (as the "later" branch).
     */
    Root.prototype.mapGlobalTime = function (time, params) {
        var self = this;
        params = params || {};

        // parameter checking
        if (time === "end") {
            time = self.getTimeFrame().lastTime;
        } else if (time === "start") {
            time = 0.0;
        }

        // parameter constraining
        if (time < 0) {
            time = 0;
        } else if (time > self.getTimeFrame().lastTime) {
            time = self.getTimeFrame().lastTime;
        }

        // tie handling and border conditions
        var tie = "earlier"; // default
        if (params.tie){
            tie = params.tie;
        } else if (params.which && params.direction){
            if (params.direction === "forwards"){
                if (params.which === "second"){
                    tie = "later";
                } else {
                    tie = "earlier";
                }
            } else if (params.direction === "backwards") {
                if (params.which === "first"){
                    tie = "later";
                } else {
                    tie = "earlier";
                }
            }
        }



        var result = {
            branch: null,
            time: null,
            index: null
        };

        var borderIndex = self._times.indexOf(time);
        if (borderIndex >= 0) {
            // Border Case: Use tie-breaker option
            var branchIndex = (tie !== "later") ? (borderIndex - 1) : borderIndex;
            branchIndex = (branchIndex < 0) ? self._theQueue.length - 1 : branchIndex;      // use last as "before first"
            branchIndex = (branchIndex >= self._times.length - 1) ? 0 : branchIndex;      // use first as "after last"

            result.branch = self._theQueue[branchIndex];
            result.time = (tie !== "later") ? (time - self._times[branchIndex]) : 0.0;
            result.index = branchIndex;
        }
        else {
            var neighbors = Human.utils.binarySearch(self._times, time);
            result.branch = self._theQueue[neighbors.index1]; // branch corresponding to left hand neighbor
            result.time = time - neighbors.value1;
            result.index = neighbors.index1;
        }
        return result;
    };

    /** map branch local time TO global time
     */
    Root.prototype.mapBranchTime = function (branch, branchTime, params) {
        var self = this;
        params = params || {};
        var worldTime = 0.0;
        var branchIndex = self.whereIsBranch(branch);
        if (branchTime === "end") {
            branchTime = branch.getTimeFrame().lastTime;
        }
        else if (branchTime === "start") {
            branchTime = 0.0;
        }

        if (branchIndex === null) {
            worldTime = null;
        } else {
            worldTime = self._times[branchIndex] + branchTime;
        }
        return worldTime;
    };

    /** Get the chapter-branch of the neighboring branch at specified time
     * @which = "next"/"previous" chapter in sequence
     *
     * @param {now} [branch object, or time float]
     * @param {params.tie} Which branch to use as current branch on border case.
     * Return null if no valid chapter exists;
     */
    Root.prototype.getNeighborChapter = function (now, which, params) {
        var self = this;
        params = params || {};

        var currentBranch = null;
        var currentIndex = null;
        which = (which === "previous") ? "previous" : "next";
        if (now instanceof Human.timeline.BranchTimeline) {
            currentBranch = now;
        } else if (typeof(now) === "number") {
            var tie = (params.tie === "later") ? "later" : "earlier";
            currentBranch = self.mapGlobalTime(now, {tie: tie});
        } else {
            Human.log.warn("timeline.root.getNeighborChapter", "invalid 'now' argument :" + JSON.stringify(now));
            return null;
        }

        currentIndex = self.whereIsBranch(currentBranch);


        // Edge Cases
        if (currentIndex === 0 && which === "previous") {
            return null;
        } else if (currentIndex === self._theQueue.length - 1 && which === "next") {
            return null;
        }

        // search up/down (maximum of two branches away in any direction)
        var idx = currentIndex;
        if (which === "next") {
            idx++;
        } else {
            idx--;
        }

        // return chapter branch
        return self._theQueue[idx];
    };

    /** Return True if branch is first chapter
     */
    Root.prototype.isFirst = function (branch) {
        var self = this;
        if (branch.id === self._theQueue[0].id) {
            return true;
        } else {
            return false;
        }
    };

    /** Return True if chapter is last chapter
     */
    Root.prototype.isLast = function (branch) {
        var self = this;
        var idx = self._theQueue.length - 1;
        if (branch.id === self._theQueue[idx].id) {
            return true;
        } else {
            return false;
        }
    };
    //-----------------------------  BUILD FUNCTIONS ----------------------------------------
    /** Add Free Animations to Global Timeline
     * Animations tagged to be not on the timeline will be added to
     * the global timeline and will not respond to play/stop status.
     *
     * This function will add all free animations in any descendent leaf timelines
     */
    Root.prototype.buildFreeAnimations = function (params) {
        var self = this;
        params = params || {};
        var leaves = self.getDescendentLeaves();
        for (var leafId in leaves) {
            if (leaves.hasOwnProperty(leafId)) {
                var _fa = leaves[leafId].freeAnimations;
                for (var _fai in _fa) {
                    if (_fa.hasOwnProperty(_fai) && !self.freeAnimations.hasOwnProperty(_fai)) {
                        self.freeAnimations[_fai] = _fa[_fai];
                    }
                }
            }
        }
    };

    /** Build queue
     * The Queue is the ordered list of all chapters that
     * collectively constitue the global timeline.
     *
     * Also populate time (and border times)
     */
    Root.prototype.buildQueue = function (params) {
        var self = this;
        params = params || {};
        self._theQueue = [];
        var cumTime = 0.0; // keep track of cumulative time
        self._times = [cumTime];

        self._chapters.forEach(function (chapter) {
            cumTime += chapter.getTimeFrame().lastTime;
            self._theQueue.push(chapter);
            self._times.push(cumTime);
        });
    };

    /** Build Root Timeline
     */
    Root.prototype.build = function (params) {
        var self = this;
        params = params || {};
        self._theQueue = [];
        self._times = [];
        self.buildFreeAnimations();
        self.buildQueue();

        // Register with replacement
        if (Human.timeline.rootTimelines[self.id]) {
            delete Human.timeline.rootTimelines[self.id];
        }
        Human.timeline.rootTimelines[self.id] = self;

        self._timeFrame = self.getTimeFrame();


        // (Re Set current now-branch and now-time
        if (self._nowBranch === null) {
            self._nowBranch = self._theQueue[0];
            self._nowTime = 0.0;
            self._prevBranch = self._nowBranch;
            self._prevTime = 0.0;
        } else if (self.whereIsBranch(self._nowBranch) === null) {
            self._nowBranch = self._theQueue[0];
            self._nowTime = 0.0;
            if (self._prevBranch === null) {
                self._prevBranch = self._nowBranch;
                self._prevTime = self._nowTime;
            } else if (self.whereIsBranch(self._prevBranch) === null) {
                self._prevBranch = self._nowBranch;
                self._prevTime = self._nowTime;
            }
        }

        Human.events.fire("timeline.chapters.updated", self._assembleChaptersUpdated());

        Human.events.fire("timeline.timeFrame.updated", {
            firstTime: self._timeFrame.firstTime,
            lastTime: self._timeFrame.lastTime
        });
    };

    /** Destroy
     * Soft Deletions of branch timelines
     */
    Root.prototype.destroy = function () {
        var self = this;
        // Remove branches
        self._theQueue.forEach(function (branch) {
            if (Human.timeline.branchTimelines.hasOwnProperty(branch.id)) {
                branch.destroy();
            }
        });

        // Remove from roots and as active root
        if (Human.timeline.rootTimelines.hasOwnProperty(self.id)) {
            delete Human.timeline.rootTimelines[self.id];
        }
    };

    //------------------------------  ACTION FUNCTIONS -----------------------------------------
    Root.prototype.updateFreeAnimations = function (time) {
        var self = this;
        for (var fid in self.freeAnimations) {
            if (self.freeAnimations.hasOwnProperty(fid)) {
                self.freeAnimations[fid].update({cameraEnabled: false}, time);
            }
        }

        var particleSystems = self._nowBranch.particleSystems;

        for (var i = 0, len = particleSystems.length; i < len; ++i) {
            Human.particles.update(particleSystems[i], time);
        }
    };

    // update the root timeline at the specified global time.
    Root.prototype.update = function (time, params, ok) {
        var self = this;
        params = params || {};
        var borderCondition = {}, toUpdate = [];
        if (typeof(ok) !== "function"){
            ok = function(){};
        }

        // Default parameter handling
        borderCondition = {which: "both", direction: "forwards"};
        if (params.hasOwnProperty("which")) {
            borderCondition.which = params.which;
        }
        if (params.hasOwnProperty("direction")) {
            borderCondition.direction = params.direction;
        }

        // Check for valid time
        if (time < 0) {
            time = 0;
            Human.log.warn("Time violates lower bound. Updating to time = 0.0");
        }
        else if (time > self._timeFrame.lastTime) {
            time = self._timeFrame.lastTime;
            Human.log.warn("Time violates upper bound. Updating to time = " + time);
        }

        // get list of mapped branches and their local times to update.
        toUpdate = self._getBranchesToUpdate(time, borderCondition);

        // Check for first update
        if (self._firstUpdate) {
            self._nowBranch = toUpdate[0].branch;
            self._nowTime = toUpdate[0].time;
            self._firstUpdate = false;
        }

        // udpate mapped branches in order
        var chaptersFirstUpdate = false;
        toUpdate.forEach(function (item) {
            self._prevBranch = self._nowBranch;
            self._prevTime = self._nowTime;
            chaptersFirstUpdate = item.branch.firstUpdate;
            self._nowBranch = item.branch;
            self._nowTime = item.time;
            item.branch.update(item.time, {}, ok); // TODO[EM]: Some optional overrides to first upddate

            /** Notify that new chapter has been entered the first time
             * Ideally, the chapter-branch itself could do the notification,
             * but for backwards compatibility the UI wants to know which chapter
             * in the context of the whole root timeline has fired.
             */
            if (chaptersFirstUpdate) {
              Human.events.fire("timeline.chapters.activated", self._assembleChaptersActivated());
            }

        });

        // reset previous branch if necessary.
        if (self._prevBranch.id !== self._nowBranch.id) {
            self._prevBranch.reset();
        }

    };

    /** Return an array of the local information (branch, timeline) to be updated
     *   based on global time and border Condition.
     */
    Root.prototype._getBranchesToUpdate = function (time, borderCondition) {
        var self = this;
        if (self._times.indexOf(time) >= 0) {
            return self._getBorderBranches(time, borderCondition);
        } else {
            return [self.mapGlobalTime(time, {tie: "earlier"})];
        }
    };

    /** Return one or more of the branches at specified boder time.
     */
    Root.prototype._getBorderBranches = function (time, borderCondition) {
        var self = this;
        var _left = self.mapGlobalTime(time, {tie: "earlier"});
        var _right = self.mapGlobalTime(time, {tie: "later"});
        var order = [_left, _right]; // default is to play in forwards order

        // Modify the "order" based on border Condition
        if (borderCondition.direction === "backwards") {
            order = [_right, _left];
        }
        if (borderCondition.which === "first") {
            order.splice(1, 1);
        } else if (borderCondition.which === "second") {
            order.splice(0, 1);
        }
        return order;
    };

    // ------------------------------ EVENT INFORMATION ----------------------------------------
    /** This function returns the object to be sent with timeline.chapters.updated
     * The result is a list of chapter blocks, each of which contains
     * the chapter's global start time, duration, displayName, description, and index.
     */
    Root.prototype._assembleChaptersUpdated = function () {
        var self = this;
        var result = [];
        var i;
        var len;
        var chapters = self._chapters;
        var branch;
        var block;

        for (i = 0, len = chapters.length; i < len; i++) {
            branch = chapters[i];
            block = {
                chapterId: branch.id,
                time: self.mapBranchTime(branch, 0.0),
                duration: branch.getTimeFrame().lastTime,
                displayName: branch.info.displayName,
                description: branch.info.description,
                loop: branch.animation.loop,
                index: i
            };
            result.push(block);
        }

        return result;
    };

    /** This function returns the object to be sent with timeline.chapters.activated
     * events, which are fired on every update.
     *
     */
    Root.prototype._assembleChaptersActivated = function () {
        var self = this;
        var result = {};
        result.oldChapterIndex = self.whereIsBranch(self._prevBranch, {chapters: true}); // index of old chapter in sequence of chapters
        result.newChapterIndex = self.whereIsBranch(self._nowBranch, {chapters: true}); // index of new chapter in sequence of chapters
        result.time = self.mapBranchTime(self._nowBranch, self._nowTime);
        result.loop = self._nowBranch.animation.loop || false;
        result.branchID = self._nowBranch.id;   // branchID for mobile
        return result;
    };

    /** This function returns per-chapter information for all chapters needed by timeline.query
     */
    Root.prototype._assembleQueryChapters = function () {
        var self = this;
        var result = [];
        var i;
        var len;
        var chapters = self._chapters;
        var branch;

        for (i = 0, len = chapters.length; i < len; i++) { // OPTIMIZATION: Don't use GC-collected callback
            branch = chapters[i];

            result.push({
                chapterId: branch.id,
                time: self.mapBranchTime(branch, 0.0),
                displayName: branch.info.displayName,
                description: branch.info.description,
                type: "branch",
                tags: branch.tags || [],
                annotations: branch.annotations,
                hotspots: null,
                flyTo: branch.camera.location,
                active: (self._nowBranch.id === branch.id), // OPTIMIZATION: Remove redundant conditional
                sounds: branch._getAudio(),
                translations: branch.translations || null
            });
        }

        return result;
    };

})();
;(function() {
    "use strict";

    var idCounter = 0;


    var Particles = Human.particles = {
        creators: {},
        updaters: {},
        constraints: {},
        shapes: {},
        systems: {}
    };

    var boundary = {
        xmin: Number.POSITIVE_INFINITY,
        ymin: Number.POSITIVE_INFINITY,
        zmin: Number.POSITIVE_INFINITY,
        xmax: Number.NEGATIVE_INFINITY,
        ymax: Number.NEGATIVE_INFINITY,
        zmax: Number.NEGATIVE_INFINITY
    };

    Particles.parse = function(json, ok) {
        json = Human.utils.deepClone(json);

        var numSystems = json.length;

        if (numSystems === 0) {
            if (ok) {
                ok();
            }
            return;
        }

        function done() {
            if (--numSystems === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = json.length; i < len; ++i) {
            parseSystem(json[i], done);
        }
    };

    Particles.getBoundary = function() {
        boundary.xmin = Number.POSITIVE_INFINITY;
        boundary.ymin = Number.POSITIVE_INFINITY;
        boundary.zmin = Number.POSITIVE_INFINITY;
        boundary.xmax = Number.NEGATIVE_INFINITY;
        boundary.ymax = Number.NEGATIVE_INFINITY;
        boundary.zmax = Number.NEGATIVE_INFINITY;

        for (var id in Particles.systems) {
            var bb = Particles.systems[id].getBoundary();
            boundary.xmin = Math.min(boundary.xmin, bb.xmin);
            boundary.ymin = Math.min(boundary.ymin, bb.ymin);
            boundary.zmin = Math.min(boundary.zmin, bb.zmin);
            boundary.xmax = Math.max(boundary.xmax, bb.xmax);
            boundary.ymax = Math.max(boundary.ymax, bb.ymax);
            boundary.zmax = Math.max(boundary.zmax, bb.zmax);
        }

        return boundary;
    };

    Particles.update = function(id, time) {
        // Guard against particles being undefined 
        // This happens when saving a bookmark. and particles are destroyed, then re-created.
        if (Particles.systems[id]) {
            Particles.systems[id].update(time);
            Human.renderer.camera.nearFarDirty = true;
        }
    };

    Particles.updateAll = function(time) {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.update(id, time);
            }
        }
    };

    Particles.enable = function(id) {
        Particles.systems[id].enable();
    };

    Particles.enableAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.enable(id);
            }
        }
    };

    Particles.disable = function(id) {
        Particles.systems[id].disable();
    };

    Particles.disableAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.disable(id);
            }
        }
    };

    Particles.reset = function(id) {
        Particles.systems[id].reset();
    };

    Particles.resetAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.reset(id);
            }
        }
    };

    Particles.destroy = function(id) {
        if (Particles.systems[id]) {
            Particles.systems[id].destroy();
            delete Particles.systems[id];
        }
    };

    Particles.destroyAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.destroy(id);
            }
        }
    };

    function parseSystem(json, ok) {
        var id = json.id || ("ps" + idCounter++);
        var numParticles = json.numParticles;
        var options = {
            properties: json.properties,
            material: json.material,
            textures: json.textures,
            spriteRows: json.spriteRows || 0,
            spriteCols: json.spriteCols || 0,
            spriteStartFrame: json.spriteStartFrame || 0,
            spriteEndFrame: json.spriteEndFrame || 0
        };

        if (options.spriteEndFrame === 0 && options.spriteRows > 0 && options.spriteCols > 0) {
            options.spriteEndFrame = options.spriteRows * options.spriteCols - 1;
        }

        var creators = [];
        var updaters = [];
        var constraints = [];
        var components = {};
        var currentId = 0;

        var creatorDefs = json.creators || [];
        var updaterDefs = json.updaters || [];
        var constraintDefs = json.constraints || [];

        var trapIdCounter = 0;
        var shape = null;
        var shapeDirection = null;
        var s, shapeType;

        var i, len, type, componentId;
        var creator, c, u;
        for (i = 0, len = creatorDefs.length; i < len; ++i) {
            c = creatorDefs[i];
            componentId = c.id || ("__CR" + (++currentId));

            if (components[componentId]) {
                Human.log.error("Component " + componentId + " already exists. Skipping.");
                continue;
            }
            
            type = c.type;

            creator = new Particles.creators[type](c, options);
            creators.push(creator);
            components[componentId] = creator;

            if (type === "Lifetime") {
                options.lifetimes = true;
            } else if (type === "SolidColor") {
                options.colors = true;
            } else if (type === "RandomScale" || type === "RandomRotation") {
                options.scaleRotations = true;
            } else if (type === "RandomRotationSpeed") {
                options.scaleRotations = true;
                options.rotationSpeeds = true;
            } else if (type === "SpriteAnimationDuration") {
                options.uvTranslates = true;
                options.spriteFrameDuration = true;
                options.spriteFrameCounter = true;
                options.spriteCurrentTime = true;
            }
        }

        var updater = null;
        var path = null;
        for (i = 0, len = updaterDefs.length; i < len; ++i) {
            u = updaterDefs[i];
            componentId = u.id || ("__UP" + (++currentId));

            if (components[componentId]) {
                Human.log.error("Component " + componentId + " already exists. Skipping.");
                continue;
            }
            
            type = u.type;

            if (u.shape) {
                s = u.shape;
                shapeType = s.type;

                shape = new Particles.shapes[shapeType](s);
                shapeDirection = s.direction || "in";
            }

            updater = new Particles.updaters[type](u, options);

            if (type === "AgeColorBlend") {
                options.colors = true;
                options.lifetimes = true;
            } else if (type === "Path") {
                path = updater;
                var nodes = u.nodes;
                for (var j = 0; j < nodes.length; ++j) {
                    updater.addNode(nodes[j]);
                }
                options.paths = true;
            } else if (type === "SpriteAnimation") {
                options.uvTranslates = true;
            }

            if (shape) {
                updater.shape = shape;
                updater.shapeDirection = shapeDirection;
            }

            updaters.push(updater);
            components[componentId] = updater;
        }

        var constraint = null;
        for (i = 0, len = constraintDefs.length; i < len; ++i) {
            c = constraintDefs[i];
            componentId = c.id || ("__CN" + (++currentId));

            if (components[componentId]) {
                Human.log.error("Component " + componentId + " already exists. Skipping.");
                continue;
            }

            type = c.type;

            var trapId;

            if (c.shape) {
                s = c.shape;
                shapeType = s.type;

                shape = new Particles.shapes[shapeType](s);
                shapeDirection = s.direction || "in";
            }

            if (c.trap) {
                trapId = trapIdCounter++;
                options.traps = true;
            } else {
                trapId = -1;
            }

            switch (type) {
                case "LifetimeKill":
                case "LifetimeStop":
                    constraint = new Particles.constraints[type](options);
                    break;

                case "PathKill":
                case "PathRadius":
                case "PathStop":
                    constraint = new Particles.constraints[type](path, options);
                    break;

                case "ShapeBounce":
                case "ShapeStop":
                case "ShapeKill":
                    constraint = new Particles.constraints[type](shape, shapeDirection, trapId, options);
                    break;

            }

            constraints.push(constraint);
            components[componentId] = constraint;
        }

        var textures = options.textures || [];

        for (i = 0, len = textures.length; i < len; ++i) {
            textures[i].src = window.localBaseDirectory + "content/states/" + textures[i].src.replace(/^\/+/, "");
        }

        Human.assets.textures.load(textures, function() {
            var ps = new Particles.ParticleSystem(numParticles, options);
            ps.creators = creators;
            ps.updaters = updaters;
            ps.constraints = constraints;
            ps.components = components;

            if (json.emissionAverage !== undefined) {
                ps.emissionAverage = json.emissionAverage;
            }

            if (json.emissionVariance !== undefined) {
                ps.emissionVariance = json.emissionVariance;
            }

            if (json.maxSpeed !== undefined) {
                ps.maxSpeed = json.maxSpeed;
            }

            if (json.pointSize !== undefined) {
                ps.pointSize(json.pointSize);
            }

            Particles.systems[id] = ps;

            if (ok) {
                ok();
            }
        });
    }

})();
;(function() {
    "use strict";

    var tempPosition = new Float32Array(3);
    var tempVelocity = new Float32Array(3);
    var tempColor    = new Uint8Array(4);
    var tempScaleRotations = new Float32Array(2);
    var tempRotationSpeeds = new Float32Array(1);
    var tempUVTranslates = new Float32Array(2);

    var boundary = {
        xmin: Number.POSITIVE_INFINITY,
        ymin: Number.POSITIVE_INFINITY,
        zmin: Number.POSITIVE_INFINITY,
        xmax: Number.NEGATIVE_INFINITY,
        ymax: Number.NEGATIVE_INFINITY,
        zmax: Number.NEGATIVE_INFINITY
    };

    var ParticleSystem = Human.particles.ParticleSystem = function ParticleSystem(maxNumParticles, options) {
        options = options || {};
        
        var material = options.material;
        var textures = options.textures;
        var properties = options.properties || {};
        var layer = properties.layer || 0;
        var addBlend = properties.addBlend || false;
        var hasColors = !!options.colors;
        var hasLifetimes = !!options.lifetimes;
        var hasPaths = !!options.paths;
        var hasTraps = !!options.traps;
        var parentNode = Human.renderer.getScene();
        var hasScaleRotations = !!options.scaleRotations;
        var hasRotationSpeeds = !!options.rotationSpeeds;
        var hasUVTranslates = !!options.uvTranslates;
        var hasSpriteFrameDuration = !!options.spriteFrameDuration;
        var hasSpriteFrameCounter = !!options.spriteFrameCounter;
        var hasSpriteCurrentTime = !!options.spriteCurrentTime;

        this.activeParticlesBegin = 0;
        this.numParticles = 0;
        this.maxSpeed = 0;
        this.maxNumParticles = maxNumParticles;
        this.spriteRows = options.spriteRows || 0;
        this.spriteCols = options.spriteCols || 0;
        this.spriteStartFrame = options.spriteStartFrame || 0;
        this.spriteEndFrame = options.spriteEndFrame || 0;
        this.attributes = {
            stopped: new Array(maxNumParticles),
            dead: new Array(maxNumParticles),
            positions: new Float32Array(maxNumParticles * 3),
            velocities: new Float32Array(maxNumParticles * 3),
            colors: hasColors ? new Uint8Array(this.maxNumParticles * 4) : null,
            lifetimes: hasLifetimes ? new Float32Array(this.maxNumParticles) : null,
            ages: hasLifetimes ? new Float32Array(this.maxNumParticles) : null,
            paths: hasPaths ? new Uint8Array(this.maxNumParticles) : null,
            traps: hasTraps ? new Uint32Array(this.maxNumParticles) : null,
            scaleRotations: hasScaleRotations ? new Float32Array(maxNumParticles * 2) : null,
            rotationSpeeds: hasRotationSpeeds ? new Float32Array(maxNumParticles) : null,
            uvTranslates: hasUVTranslates ? new Float32Array(maxNumParticles * 2) : null,
            spriteFrameDuration: hasSpriteFrameDuration ? new Float32Array(maxNumParticles) : null,
            spriteFrameCounter: hasSpriteFrameCounter ? new Uint8Array(maxNumParticles) : null,
            spriteCurrentTime: hasSpriteCurrentTime ? new Float32Array(maxNumParticles) : null,
        };

        this.rootNode = null;
        this.properties = null;
        this.material = null;
        this.geometry = null;

        var node;

        properties.enabled = false;
        properties.picking = false;

        if (properties.depthMask === false) {
            properties.noDepthMask = true;
        }

        this.rootNode = this.properties = node = parentNode.addNode({
            type: "properties",
            properties: properties
        });

        if (material) {
            material.type = "material";
            this.material = node = node.addNode(material);
        }

        if (textures) {
            for (var i = 0, len = textures.length; i < len; ++i) {
                textures[i].type = "texture";
                textures[i].src = window.localBaseDirectory + "content/states/" + textures[i].src;
                node = node.addNode(textures[i]);
            }
        }

        var pointUVScale = null;

        if (this.spriteRows > 0 && this.spriteCols > 0) {
            pointUVScale = new Float32Array([1 / this.spriteCols, 1 / this.spriteRows]);
        }

        this.geometry = node.addNode({
            type: "geometry",
            positions: this.attributes.positions,
            colors: this.attributes.colors,
            pointScaleRotations: this.attributes.scaleRotations,
            pointUVTranslates: this.attributes.uvTranslates,
            pointUVScale: pointUVScale,
            layer: layer,
            addBlend: addBlend,
            primitive: "points"
        });
        

        this.enabled = false;

        this.emissionAverage = 0;
        this.emissionVariance = 0;
        this.creators = [];
        this.updaters = [];
        this.constraints = [];
        this.components = {};
        this.previousTime = null;
    };

    ParticleSystem.prototype.pointSize = function(size) {
        this.geometry.setPointSize(size);
    };

    ParticleSystem.prototype.getBoundary = function() {
        return boundary;
    };

    ParticleSystem.prototype.update = function(time) {
        if (!this.enabled) {
            return;
        }
        
        boundary.xmin = Number.POSITIVE_INFINITY;
        boundary.ymin = Number.POSITIVE_INFINITY;
        boundary.zmin = Number.POSITIVE_INFINITY;
        boundary.xmax = Number.NEGATIVE_INFINITY;
        boundary.ymax = Number.NEGATIVE_INFINITY;
        boundary.zmax = Number.NEGATIVE_INFINITY;

        var max = Math.max;
        var min = Math.min;
        var sqrt = Math.sqrt;
        var floor = Math.floor;
        var rand = Math.random;

        this.previousTime = this.previousTime || time;
        var delta = min(time - this.previousTime, 0.04);
        if (delta < 0) {
            this.previousTime = time;
            delta = 0;
        }

        var attributes = this.attributes;
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var hasAges = !!ages;

        var maxSpeed = this.maxSpeed * delta;
        var maxSpeed2 = maxSpeed * maxSpeed;
        var scaleRotations = attributes.scaleRotations;
        var rotationSpeeds = attributes.rotationSpeeds;

        var i, j, vi, len;
        var xi, yi, zi, si;


        if (this.numParticles < this.maxNumParticles) {
            var emissionAverage = this.emissionAverage * delta;
            var emissionVariance = this.emissionVariance * delta;

            var count = max(emissionAverage + rand() * 2 * emissionVariance - emissionVariance, 0);

            if (count >= 1) {
                count = floor(count);
            } else {
                count = rand() < count ? 1 : 0;
            }

            var endEmit = min(this.numParticles + count, this.maxNumParticles);

            for (i = this.numParticles; i < endEmit; ++i) {
                vi = i * 3;
                si = i * 2;

                positions[vi]     = 0;
                positions[vi + 1] = 0;
                positions[vi + 2] = 0;

                velocities[vi]     = 0;
                velocities[vi + 1] = 0;
                velocities[vi + 2] = 0;


                attributes.dead[i] = false;
                attributes.stopped[i] = false;
                
                if (attributes.paths) {
                    attributes.paths[i] = 0;
                }

                if (attributes.traps) {
                    attributes.traps[i] = 0;
                }

                if (attributes.traps) {
                    attributes.traps[i] = 0;
                }

                if (attributes.scaleRotations) {
                    attributes.scaleRotations[si]     = 1;
                    attributes.scaleRotations[si + 1] = 0;
                }

                if (attributes.rotationSpeeds) {
                    attributes.rotationSpeeds[i] = 0;
                }

                if (attributes.uvTranslates) {
                    attributes.uvTranslates[si] = this.spriteStartFrame % this.spriteCols * 1.0 / this.spriteCols;
                    attributes.uvTranslates[si + 1] = (this.spriteRows - 1.0 - floor(this.spriteStartFrame / this.spriteCols)) * 1.0 / this.spriteRows;
                }

                if (attributes.spriteFrameCounter) {
                    attributes.spriteFrameCounter[i] = 0;
                }

                if (attributes.spriteFrameDuration) {
                    attributes.spriteFrameDuration[i] = 0;
                }

                if (attributes.spriteCurrentTime) {
                    attributes.spriteCurrentTime[i] = 0;
                }
            }

            
            for (j = 0, len = this.creators.length; j < len; ++j) {
                this.creators[j].create(this.numParticles, endEmit, attributes);
            }
            
            this.numParticles = endEmit;
        }

        for (j = 0, len = this.updaters.length; j < len; ++j) {
            this.updaters[j].update(this.activeParticlesBegin, this.numParticles, attributes, delta);
        }

        for (i = this.activeParticlesBegin; i < this.numParticles; ++i) {
            vi = i * 3;
            si = i * 2;

            xi = vi;
            yi = vi + 1;
            zi = vi + 2;

            tempVelocity[0] = velocities[xi] * delta;
            tempVelocity[1] = velocities[yi] * delta;
            tempVelocity[2] = velocities[zi] * delta;

            if (maxSpeed2 > 0) {
                var speed2 = tempVelocity[0] * tempVelocity[0] + tempVelocity[1] * tempVelocity[1] + tempVelocity[2] * tempVelocity[2];

                if (speed2 > maxSpeed2) {
                    var speed = sqrt(speed2);
                    var ratio = maxSpeed / speed;
                    tempVelocity[0] *= ratio;
                    tempVelocity[1] *= ratio;
                    tempVelocity[2] *= ratio;

                    velocities[xi] = tempVelocity[0];
                    velocities[yi] = tempVelocity[1];
                    velocities[zi] = tempVelocity[2];
                }
            }

            

            positions[xi] += tempVelocity[0];
            positions[yi] += tempVelocity[1];
            positions[zi] += tempVelocity[2];

            if(rotationSpeeds) {
                scaleRotations[si + 1] += rotationSpeeds[i] * delta;
            }

            boundary.xmin = min(boundary.xmin, positions[xi]);
            boundary.ymin = min(boundary.ymin, positions[yi]);
            boundary.zmin = min(boundary.zmin, positions[zi]);
            boundary.xmax = max(boundary.xmax, positions[xi]);
            boundary.ymax = max(boundary.ymax, positions[yi]);
            boundary.zmax = max(boundary.zmax, positions[zi]);

            if (hasAges && ages[i] < lifetimes[i]) {
                ages[i] = min(ages[i] + delta, lifetimes[i]);
            }
        }

        // Expand boundary for stopped particles
        for (i = 0; i < this.activeParticlesBegin; ++i) {
            vi = i * 3;
            xi = vi;
            yi = vi + 1;
            zi = vi + 2;

            boundary.xmin = min(boundary.xmin, positions[xi]);
            boundary.ymin = min(boundary.ymin, positions[yi]);
            boundary.zmin = min(boundary.zmin, positions[zi]);
            boundary.xmax = max(boundary.xmax, positions[xi]);
            boundary.ymax = max(boundary.ymax, positions[yi]);
            boundary.zmax = max(boundary.zmax, positions[zi]);
        }

        for (j = 0, len = this.constraints.length; j < len; ++j) {
            this.constraints[j].constrain(this.activeParticlesBegin, this.numParticles, attributes);
        }

        var stopped = attributes.stopped;
        var dead = attributes.dead;
        for (i = this.activeParticlesBegin; i < this.numParticles; ++i) {
            if (dead[i]) {
                this.kill(i);
                --i;
            } else if (stopped[i]) {
                this.stop(i);
            }
        }
            

        this.geometry.setPositions(attributes.positions.subarray(0, this.numParticles * 3));
        if (attributes.colors) {
            this.geometry.setColors(attributes.colors.subarray(0, this.numParticles * 4));
        }

        if (attributes.scaleRotations) {
            this.geometry.setPointScaleRotations(attributes.scaleRotations.subarray(0, this.numParticles * 2));
        }

        if (attributes.uvTranslates) {
            this.geometry.setPointUVTranslates(attributes.uvTranslates.subarray(0, this.numParticles * 2));
        }

        if (this.numParticles > 0) {
            this.properties.setEnabled(true);
        } else {
            this.properties.setEnabled(false);
        }
        
        this.previousTime = time;
    };

    ParticleSystem.prototype.kill = function(i) {
        var attributes = this.attributes;
        var si = i * 2;
        var vi = i * 3;
        var ci = i * 4;
        var li = i;
        var sEnd = (this.numParticles - 1) * 2;
        var vEnd = (this.numParticles - 1) * 3;
        var cEnd = (this.numParticles - 1) * 4;
        var lEnd = this.numParticles - 1;

        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var colors = attributes.colors;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var paths = attributes.paths;
        var dead = attributes.dead;
        var stopped = attributes.stopped;
        var traps = attributes.traps;
        var scaleRotations = attributes.scaleRotations;
        var rotationSpeeds = attributes.rotationSpeeds;
        var uvTranslates = attributes.uvTranslates;

        positions[vi] = positions[vEnd];
        positions[vi + 1] = positions[vEnd + 1];
        positions[vi + 2] = positions[vEnd + 2];

        velocities[vi] = velocities[vEnd];
        velocities[vi + 1] = velocities[vEnd + 1];
        velocities[vi + 2] = velocities[vEnd + 2];

        dead[li] = dead[lEnd];
        stopped[li] = stopped[lEnd];

        if (colors) {
            colors[ci] = colors[cEnd];
            colors[ci + 1] = colors[cEnd + 1];
            colors[ci + 2] = colors[cEnd + 2];
            colors[ci + 3] = colors[cEnd + 3];
        }

        if (scaleRotations) {
            scaleRotations[si] = scaleRotations[sEnd];
            scaleRotations[si + 1] = scaleRotations[sEnd + 1];
        }

        if (rotationSpeeds) {
            rotationSpeeds[li] = rotationSpeeds[lEnd];
        }


        if (uvTranslates) {
            uvTranslates[si] = uvTranslates[sEnd];
            uvTranslates[si + 1] = uvTranslates[sEnd + 1];
        }
        
        if (lifetimes) {
            ages[li] = ages[lEnd];
            lifetimes[li] = lifetimes[lEnd];
        } 

        if (paths) {
            paths[li] = paths[lEnd];
        }

        if (traps) {
            traps[li] = traps[lEnd];
        }  

        this.numParticles--;
    };

    ParticleSystem.prototype.stop = function(i) {
        var attributes = this.attributes;
        var si = i * 2;
        var vi = i * 3;
        var ci = i * 4;
        var li = i;
        var sBegin = this.activeParticlesBegin * 2;
        var vBegin = this.activeParticlesBegin * 3;
        var cBegin = this.activeParticlesBegin * 4;
        var lBegin = this.activeParticlesBegin;

        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var colors = attributes.colors;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var paths = attributes.paths;
        var stopped = attributes.stopped;
        var traps = attributes.traps;
        var scaleRotations = attributes.scaleRotations;
        var rotationSpeeds = attributes.rotationSpeeds;
        var uvTranslates = attributes.uvTranslates;

        tempPosition[0] = positions[vBegin];
        tempPosition[1] = positions[vBegin + 1];
        tempPosition[2] = positions[vBegin + 2];

        positions[vBegin]     = positions[vi]    ;
        positions[vBegin + 1] = positions[vi + 1];
        positions[vBegin + 2] = positions[vi + 2];

        positions[vi]     = tempPosition[0];
        positions[vi + 1] = tempPosition[1];
        positions[vi + 2] = tempPosition[2];

        tempVelocity[0] = velocities[vBegin];
        tempVelocity[1] = velocities[vBegin + 1];
        tempVelocity[2] = velocities[vBegin + 2];

        velocities[vBegin]     = velocities[vi]    ;
        velocities[vBegin + 1] = velocities[vi + 1];
        velocities[vBegin + 2] = velocities[vi + 2];

        velocities[vi]     = tempVelocity[0];
        velocities[vi + 1] = tempVelocity[1];
        velocities[vi + 2] = tempVelocity[2];

        if (colors) {
            tempColor[0] = colors[cBegin];
            tempColor[1] = colors[cBegin + 1];
            tempColor[2] = colors[cBegin + 2];
            tempColor[3] = colors[cBegin + 3];

            colors[cBegin]     = colors[ci];
            colors[cBegin + 1] = colors[ci + 1];
            colors[cBegin + 2] = colors[ci + 2];
            colors[cBegin + 3] = colors[ci + 3];

            colors[ci]     = tempColor[0];
            colors[ci + 1] = tempColor[1];
            colors[ci + 2] = tempColor[2];
            colors[ci + 3] = tempColor[3];
        }

        if (scaleRotations) {
            tempScaleRotations[0] = scaleRotations[sBegin];
            tempScaleRotations[1] = scaleRotations[sBegin + 1];

            scaleRotations[sBegin]     = scaleRotations[si];
            scaleRotations[sBegin + 1] = scaleRotations[si + 1];

            scaleRotations[si]     = tempScaleRotations[0];
            scaleRotations[si + 1] = tempScaleRotations[1];
        }
            
        if (rotationSpeeds) {

            tempRotationSpeeds[0] = rotationSpeeds[lBegin];

            rotationSpeeds[lBegin]     = rotationSpeeds[i];

            rotationSpeeds[i]      = tempRotationSpeeds[0];
        }

        if (uvTranslates) {
            tempUVTranslates[0] = uvTranslates[sBegin];
            tempUVTranslates[1] = uvTranslates[sBegin + 1];

            uvTranslates[sBegin]     = uvTranslates[si];
            uvTranslates[sBegin + 1] = uvTranslates[si + 1];

            uvTranslates[si]     = tempUVTranslates[0];
            uvTranslates[si + 1] = tempUVTranslates[1];
        }
        
        var tmp;
        if (lifetimes) {
            tmp = ages[lBegin];
            ages[lBegin] = ages[li];
            ages[li] = tmp;

            tmp = lifetimes[lBegin];
            lifetimes[lBegin] = lifetimes[li];
            lifetimes[li] = tmp;
        } 

        if (paths) {
            tmp = paths[lBegin];
            paths[lBegin] = paths[li];
            paths[li] = tmp;
        } 

        if (traps) {
            tmp = traps[lBegin];
            traps[lBegin] = traps[li];
            traps[li] = tmp;
        }  

        stopped[li] = false;

        this.activeParticlesBegin++;
    };

    ParticleSystem.prototype.reset = function() {
        this.numParticles = 0;
        this.activeParticlesBegin = 0;
    };

    ParticleSystem.prototype.enable = function() {
        this.properties.setEnabled(true);
        this.enabled = true;
    };

    ParticleSystem.prototype.disable = function() {
        this.properties.setEnabled(false);
        this.enabled = false;
    };

    ParticleSystem.prototype.destroy = function() {
        this.rootNode.destroy();
    };
})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var DirectionalVelocity = Human.particles.creators.DirectionalVelocity = function(options) {
        this.directionAverage = new Float32Array(options.directionAverage);
        this.directionVariance = options.directionVariance || 0;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
    
        vec3.normalize(this.directionAverage, this.directionAverage);
    };

    DirectionalVelocity.prototype.create = function(begin, end, attributes) {
        
        var velocities = attributes.velocities;

        var rand = Math.random;
        var norm = vec3.normalize;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var acceleration = this.forceAverage + rand() * 2 * this.forceVariance - this.forceVariance;

            direction[0] = this.directionAverage[0] + rand() * 2 * this.directionVariance - this.directionVariance;
            direction[1] = this.directionAverage[1] + rand() * 2 * this.directionVariance - this.directionVariance;
            direction[2] = this.directionAverage[2] + rand() * 2 * this.directionVariance - this.directionVariance;

            norm(direction, direction);

            velocities[vi]     = direction[0] * acceleration;
            velocities[vi + 1] = direction[1] * acceleration;
            velocities[vi + 2] = direction[2] * acceleration;
        }
        
    };

})();
;(function() {
    "use strict";

    var Lifetime = Human.particles.creators.Lifetime = function(options) {
        this.average = options.average;
        this.variance = options.variance || 0;
    };

    Lifetime.prototype.create = function(begin, end, attributes) {
        
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;

        var rand = Math.random;

        for (var i = begin; i < end; ++i) {
            ages[i] = 0;
            lifetimes[i] = this.average;
            if (this.variance > 0) {
                lifetimes[i] += rand() * 2 * this.variance - this.variance;
            } 
        }
        
    };

})();
;(function() {
    "use strict";

    var PointPosition = Human.particles.creators.PointPosition = function(options) {
        this.position = new Float32Array(options.position);
    };

    PointPosition.prototype.create = function(begin, end, attributes) {
        
        var positions = attributes.positions;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            positions[vi]     = this.position[0];
            positions[vi + 1] = this.position[1];
            positions[vi + 2] = this.position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var RandomVelocity = Human.particles.creators.RandomVelocity = function(options) {
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
    };

    RandomVelocity.prototype.create = function(begin, end, attributes) {
        
        var velocities = attributes.velocities;

        var rand = Math.random;
        var norm = vec3.normalize;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var acceleration = this.forceAverage;

            if (this.forceVariance > 0) {
                acceleration += rand() * 2 * this.forceVariance - this.forceVariance;
            }

            direction[0] = rand() * 2 - 1;
            direction[1] = rand() * 2 - 1;
            direction[2] = rand() * 2 - 1;

            norm(direction, direction);

            velocities[vi]     = direction[0] * acceleration;
            velocities[vi + 1] = direction[1] * acceleration;
            velocities[vi + 2] = direction[2] * acceleration;
        }
        
    };

})();
;(function() {
    "use strict";

    var position = vec3.create();

    var SpherePosition = Human.particles.creators.SpherePosition = function(options) {
        this.translate = null;
        this.xform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
        }
    };

    SpherePosition.prototype.create = function(begin, end, attributes) {

        var positions = attributes.positions;

        var rand = Math.random;
        var PI = Math.PI;
        var sin = Math.sin;
        var cos = Math.cos;
        
        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var phi = rand() * PI;
            var theta = rand() * PI * 2;

            var r = rand();

            position[0] = r * sin(phi) * sin(theta);
            position[1] = r * cos(phi);
            position[2] = r * sin(phi) * cos(theta);

            if (this.xform) {
                vec3.transformMat3(position, position, this.xform);
            }

            if (this.translate) {
                position[0] += this.translate[0];
                position[1] += this.translate[1];
                position[2] += this.translate[2];
            }

            positions[vi]     = position[0];
            positions[vi + 1] = position[1];
            positions[vi + 2] = position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var position = vec3.create();

    var CubePosition = Human.particles.creators.CubePosition = function(options) {
        this.translate = null;
        this.xform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
        }
    };

    CubePosition.prototype.create = function(begin, end, attributes) {

        var positions = attributes.positions;
        
        var rand = Math.random;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            position[0] = rand() - 0.5;
            position[1] = rand() - 0.5;
            position[2] = rand() - 0.5;

            if (this.xform) {
                vec3.transformMat3(position, position, this.xform);
            }

            if (this.translate) {
                position[0] += this.translate[0];
                position[1] += this.translate[1];
                position[2] += this.translate[2];
            }

            positions[vi]     = position[0];
            positions[vi + 1] = position[1];
            positions[vi + 2] = position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var position = vec3.create();

    var CylinderPosition = Human.particles.creators.CylinderPosition = function(options) {
        this.translate = null;
        this.xform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
        }
    };

    CylinderPosition.prototype.create = function(begin, end, attributes) {

        var positions = attributes.positions;

        var rand = Math.random;
        var PI = Math.PI;
        var sin = Math.sin;
        var cos = Math.cos;
        
        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var theta = rand() * PI * 2;
            var r = rand();
            var y = rand() * 2 - 1;

            position[0] = r * cos(theta);
            position[1] = y;
            position[2] = r * sin(theta);

            if (this.xform) {
                vec3.transformMat3(position, position, this.xform);
            }

            if (this.translate) {
                position[0] += this.translate[0];
                position[1] += this.translate[1];
                position[2] += this.translate[2];
            }

            positions[vi]     = position[0];
            positions[vi + 1] = position[1];
            positions[vi + 2] = position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var RandomScale = Human.particles.creators.RandomScale = function(options) {
        this.average = options.average;
        this.variance = options.variance || 0;
    };

    RandomScale.prototype.create = function(begin, end, attributes) {
        
        var scaleRotations = attributes.scaleRotations;

        var rand = Math.random;

        var sBegin = begin * 2;
        var sEnd = end * 2;
        for (var i = sBegin; i < sEnd; i += 2) {
            var scale = this.average;

            if (this.variance > 0) {
                scale += rand() * 2 * this.variance - this.variance;
            }

            scaleRotations[i] = scale;
        }
        
    };

})();
;(function() {
    "use strict";

    var RandomRotation = Human.particles.creators.RandomRotation = function(options) {
        this.average = options.average * Human.math.TO_RADIANS;
        this.variance = (options.variance || 0) * Human.math.TO_RADIANS;
    };

    RandomRotation.prototype.create = function(begin, end, attributes) {
        
        var scaleRotations = attributes.scaleRotations;

        var rand = Math.random;

        var rBegin = begin * 2 + 1;
        var rEnd = end * 2 + 1;
        for (var i = rBegin; i < rEnd; i += 2) {
            var rotation = this.average;

            if (this.variance > 0) {
                rotation += rand() * 2 * this.variance - this.variance;
            }

            scaleRotations[i] = rotation;
        }
        
    };

})();
;(function() {
    "use strict";

    var RandomRotationSpeed = Human.particles.creators.RandomRotationSpeed = function(options) {
        this.average = options.average * Human.math.TO_RADIANS;
        this.variance = (options.variance || 0) * Human.math.TO_RADIANS;
    };

    RandomRotationSpeed.prototype.create = function(begin, end, attributes) {
        
        var rotationSpeeds = attributes.rotationSpeeds;

        var rand = Math.random;

        for (var i = begin; i < end; i++) {
            var rotationSpeed = this.average;
            
            if (this.variance > 0) {
                rotationSpeed += rand() * 2 * this.variance - this.variance;
            }

            rotationSpeeds[i] = rotationSpeed;
        }
        
    };

})();;(function() {
    "use strict";

    var SpriteAnimationDuration = Human.particles.creators.SpriteAnimationDuration = function(options, systemOptions) {
        this.rows = systemOptions.spriteRows;
        this.cols = systemOptions.spriteCols;
        this.startFrame = systemOptions.spriteStartFrame;
        this.endFrame = systemOptions.spriteEndFrame;
        this.average = options.average;
        this.variance = options.variance;
    };

    SpriteAnimationDuration.prototype.create = function(begin, end, attributes) {
        
        var frameDuration = attributes.spriteFrameDuration;

        var rand = Math.random;
        var max = Math.max;

        for (var i = begin; i < end; i++) {
            var secPerLoop = this.average;

            if (this.variance > 0) {
                secPerLoop += rand() * 2 * this.variance - this.variance;
            }

            frameDuration[i] = max(secPerLoop / (this.endFrame - this.startFrame), 0);
        }
        
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var BrownianMotion = Human.particles.updaters.BrownianMotion = function(options) {
        this.frequency = options.frequency;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    BrownianMotion.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var norm = vec3.normalize;
        var hasShape = !!this.shape;

        var frequency = this.frequency * delta;
        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            if (rand() < frequency) {
                var vi = i * 3;

                var acceleration = forceAverage;

                if (forceVariance > 0) {
                    acceleration += rand() * 2 * forceVariance - forceVariance;
                }

                direction[0] = rand() * 2 - 1;
                direction[1] = rand() * 2 - 1;
                direction[2] = rand() * 2 - 1;

                norm(direction, direction);

                velocities[vi]     += direction[0] * acceleration;
                velocities[vi + 1] += direction[1] * acceleration;
                velocities[vi + 2] += direction[2] * acceleration;
            }
        }
        
    };

})();
;(function() {
    "use strict";

    var Friction = Human.particles.updaters.Friction = function(options) {
        this.friction = 1 - options.friction;
        this.shape = null;
        this.shapeDirection = "in";
    };

    Friction.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var hasShape = !!this.shape;

        var friction = Math.pow(this.friction, delta);

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;

            velocities[vi] *= friction;
            velocities[vi + 1] *= friction;
            velocities[vi + 2] *= friction;
        }
        
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var UniformForce = Human.particles.updaters.UniformForce = function(options) {
        this.directionAverage = new Float32Array(options.directionAverage);
        this.directionVariance = options.directionVariance || 0;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    
        vec3.normalize(this.directionAverage, this.directionAverage);
    };

    UniformForce.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var norm = vec3.normalize;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;

            var acceleration = forceAverage;

            if (forceVariance > 0) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            direction[0] = this.directionAverage[0];
            direction[1] = this.directionAverage[1];
            direction[2] = this.directionAverage[2];

            if (this.directionVariance) {
                direction[0] += rand() * 2 * this.directionVariance - this.directionVariance;
                direction[1] += rand() * 2 * this.directionVariance - this.directionVariance;
                direction[2] += rand() * 2 * this.directionVariance - this.directionVariance;
            
                norm(direction, direction);
            }

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var RadialForce = Human.particles.updaters.RadialForce = function(options) {
        this.position = new Float32Array(options.position);
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    RadialForce.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var norm = vec3.normalize;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;
            var acceleration = forceAverage;

            if (forceVariance) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            direction[0] = positions[vi]     - this.position[0];
            direction[1] = positions[vi + 1] - this.position[1];
            direction[2] = positions[vi + 2] - this.position[2];

            norm(direction, direction);

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var AgeColorBlend = Human.particles.updaters.AgeColorBlend = function(options) {
        this.colors = new Array(options.colors.length);

        for (var i = 0, len = options.colors.length; i < len; ++i) {
            this.colors[i] = new Uint8Array(options.colors[i]);
        }
        
        this.shape = null;
        this.shapeDirection = "in";
    };

    AgeColorBlend.prototype.update = function(begin, end, attributes) {
        
        var positions = attributes.positions;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var colors = attributes.colors;
        var hasShape = !!this.shape;
        var numIntervals = this.colors.length - 1;

        var floor = Math.floor;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var ci = i * 4;
            var index = (ages[i] / lifetimes[i]) * numIntervals;
            var idx1 = floor(index);
            var idx2 = idx1 + 1;

            var color1 = this.colors[idx1];
            var color2 = this.colors[idx2] || this.colors[idx1];

            var factor = index - idx1;
            var oneMinus = 1 - factor;
            colors[ci]     = oneMinus * color1[0] + factor * color2[0];
            colors[ci + 1] = oneMinus * color1[1] + factor * color2[1];
            colors[ci + 2] = oneMinus * color1[2] + factor * color2[2];
            colors[ci + 3] = oneMinus * color1[3] + factor * color2[3];
        }
        
    };

})();
;(function () {
    "use strict";

    var tempPosition = new Float32Array(3);
    var tempVelocity = new Float32Array(3);
    var tempVec3 = new Float32Array(3);


    var Path = Human.particles.updaters.Path = function Path() {
        this.nodes = [];
        this.shape = null;
        this.shapeDirection = "in";
    };

    Path.prototype.addNode = function(node) {
        
        node.first = this.nodes.length === 0;
        node.position = new Float32Array(node.position);
        node.forceVariance = node.forceVariance || 0;
        this.nodes.push(node);

        if (node.first) {
            node.vec = null;
            node.dir = null;
            node.length = null;
        } else {
            var prevNode = this.nodes[this.nodes.length - 2];
            node.vec = vec3.subtract(vec3.create(), node.position, prevNode.position);
            node.dir = vec3.normalize(vec3.create(), node.vec);
            node.length = vec3.length(node.vec);
        }  
    };

    Path.prototype.updateNode = function(i, nodeData) {
        var node = this.nodes[i];

        if (nodeData.position) {
            node.position = nodeData.position;

            if (!node.first) {
                var prevNode = this.nodes[i - 1];
                vec3.subtract(node.vec, node.position, prevNode.position);
                vec3.normalize(node.dir, node.vec);
                node.length = vec3.length(node.vec);
            }  

            if (i < this.nodes.length - 1) {
                var nextNode = this.nodes[i + 1];
                vec3.subtract(nextNode.vec, nextNode.position, node.position);
                vec3.normalize(nextNode.dir, nextNode.vec);
                nextNode.length = vec3.length(nextNode.vec);
            }
        }

        if (nodeData.radius) {
            node.radius = nodeData.radius;
        }

        if (nodeData.forceAverage) {
            node.forceAverage = nodeData.forceAverage;
        }
    };

    Path.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var paths = attributes.paths;
        var hasShape = !!this.shape;

        var rand = Math.random;
        var dist = vec3.distance;
        var norm = vec3.normalize;
        var sub = vec3.subtract;
        var dot = vec3.dot;
        var length = vec3.length;
        var scale = vec3.scale;

        var node;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            node = this.nodes[paths[i]];
            if (!node) {
                continue;
            }

            var vi = i * 3;

            tempPosition[0] = positions[vi];
            tempPosition[1] = positions[vi + 1];
            tempPosition[2] = positions[vi + 2];

            var pathDir;

            if (node.first) {
                if (dist(tempPosition, node.position) < node.radius) {
                    paths[i]++;
                    node = this.nodes[paths[i]];
                    if (!node) {
                        continue;
                    }
                }

                pathDir = sub(tempVec3, node.position, tempPosition);
                norm(pathDir, pathDir);
                
            } else {
                var prevNode = this.nodes[paths[i] - 1];
                var diff = sub(tempVec3, tempPosition, prevNode.position);
                var proj = dot(diff, node.dir);

                if (proj > node.length) {
                    paths[i]++;
                    node = this.nodes[paths[i]];
                    if (!node) {
                        continue;
                    }

                    tempVelocity[0] = velocities[vi];    
                    tempVelocity[1] = velocities[vi + 1];
                    tempVelocity[2] = velocities[vi + 2];

                    var speed = length(tempVelocity);
                    scale(tempVelocity, node.dir, speed);

                    velocities[vi]     = tempVelocity[0];
                    velocities[vi + 1] = tempVelocity[1];
                    velocities[vi + 2] = tempVelocity[2];
                }

                pathDir = node.dir;
            }

            var forceAverage = node.forceAverage * delta;
            var forceVariance = node.forceVariance * delta;

            var acceleration = forceAverage;

            if (forceVariance > 0) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            velocities[vi]     += pathDir[0] * acceleration;
            velocities[vi + 1] += pathDir[1] * acceleration;
            velocities[vi + 2] += pathDir[2] * acceleration;

        }

    };
})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var Gravity = Human.particles.updaters.Gravity = function(options) {
        this.position = new Float32Array(options.position);
        this.radius = options.radius;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    Gravity.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var max = Math.max;
        var length = vec3.length;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;
            var acceleration = forceAverage;

            if (forceVariance) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            direction[0] = this.position[0] - positions[vi];
            direction[1] = this.position[1] - positions[vi + 1];
            direction[2] = this.position[2] - positions[vi + 2];

            var distance = max(length(direction), this.radius);

            direction[0] /= distance;
            direction[1] /= distance;
            direction[2] /= distance;

            acceleration /= distance * distance;

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var SpriteAnimation = Human.particles.updaters.SpriteAnimation = function(options, systemOptions) {
        this.rows = systemOptions.spriteRows;
        this.cols = systemOptions.spriteCols;
        this.startFrame = systemOptions.spriteStartFrame;
        this.endFrame = systemOptions.spriteEndFrame;
    };

    SpriteAnimation.prototype.update = function(begin, end, attributes, delta) {

        var uvTranslates = attributes.uvTranslates;
        var frameCounter = attributes.spriteFrameCounter;
        var frameDuration = attributes.spriteFrameDuration;
        var currentTime = attributes.spriteCurrentTime;
        
        for (var i = begin; i < end; i++) {
            currentTime[i] += delta;
            if(currentTime[i] >= frameDuration[i]) {
                currentTime[i] = 0.0;
                frameCounter[i]++;
                uvTranslates[i * 2] += 1.0 / this.cols;
                if(uvTranslates[i * 2] === 1.0) {
                    uvTranslates[i * 2] = 0.0;
                    uvTranslates[i * 2 + 1] -= 1.0 / this.rows;
                }
                if(uvTranslates[i * 2 + 1] === -1.0 / this.rows) {
                    uvTranslates[i * 2] = this.startFrame % this.cols * 1.0 / this.cols;
                    uvTranslates[i * 2 + 1] = (this.rows - 1.0 - Math.floor(this.startFrame / this.cols)) * 1.0 / this.rows;
                }
                if(frameCounter[i] > this.endFrame) {
                    frameCounter[i] = this.startFrame;
                    uvTranslates[i * 2] = this.startFrame % this.cols * 1.0 / this.cols;
                    uvTranslates[i * 2 + 1] = (this.rows - 1.0 - Math.floor(this.startFrame / this.cols)) * 1.0 / this.rows;
                }
            }
        }
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);
    var position = new Float32Array(3);
    var diff = new Float32Array(3);
    var projection = new Float32Array(3);
    var x = new Float32Array(3);

    var AxisForce = Human.particles.updaters.AxisForce = function(options) {
        this.position = new Float32Array(options.position);//point on line
        vec3.normalize(options.direction, options.direction);
        this.direction = new Float32Array(options.direction);//directon of line
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    AxisForce.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;
            var acceleration = forceAverage;

            if (forceVariance) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            position[0] = positions[vi];
            position[1] = positions[vi + 1];
            position[2] = positions[vi + 2];

            vec3.sub(diff, position, this.position);
            var d = vec3.dot(diff, this.direction);// Scalar projection of diff on line direction.
            vec3.scale(projection, this.direction, d);// Vector projection of diff on line.
            vec3.add(x, projection, this.position);// Perpendicular projection of particle position on line
            vec3.sub(direction, position, x);// Perpendicular vector from line to particle position
            vec3.normalize(direction, direction);// Unit vector of perp direction from line to point

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var LifetimeKill = Human.particles.constraints.LifetimeKill = function() {
    };

    LifetimeKill.prototype.constrain = function(begin, end, attributes) {
        
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var dead = attributes.dead;

        for (var i = begin; i < end; ++i) {
            if (ages[i] >= lifetimes[i]) {
                dead[i] = true;
            }
        }
        
    };

})();;(function() {
    "use strict";

    var LifetimeStop = Human.particles.constraints.LifetimeStop = function() {
    };

    LifetimeStop.prototype.constrain = function(begin, end, attributes) {
        
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var stopped = attributes.stopped;

        for (var i = begin; i < end; ++i) {
            if (ages[i] >= lifetimes[i]) {
                stopped[i] = true;
            }
        }
        
    };

})();
;(function() {
    "use strict";

    var ShapeKill =  Human.particles.constraints.ShapeKill = function ShapeKill(shape, direction, trapId) {
        this.shape = shape;
        this.direction = direction;

        if (trapId >= 0) {
            this.trap = true;
            this.trapMask = 1 << trapId;
        } else {
            this.trap = false;
            this.trapMask = 0;
        }
    };

    ShapeKill.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var dead = attributes.dead;
        var traps = attributes.traps;
        
        var trap = this.trap;
        var mask = this.trapMask;
        
        for (var i = begin; i < end; ++i) {
            if (this.shape[this.direction](positions, i)) {
                if (trap && (traps[i] & mask) === 0) {
                    continue;
                }

                dead[i] = true;
            } else if (trap) {
                traps[i] |= mask;
            }
            
        }
    };

})();
;(function() {
    "use strict";

    var ShapeStop =  Human.particles.constraints.ShapeStop = function ShapeStop(shape, direction, trapId) {
        this.shape = shape;
        this.direction = direction;

        if (trapId >= 0) {
            this.trap = true;
            this.trapMask = 1 << trapId;
        } else {
            this.trap = false;
            this.trapMask = 0;
        }
    };

    ShapeStop.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var stopped = attributes.stopped;
        var traps = attributes.traps;

        var trap = this.trap;
        var mask = this.trapMask;
        
        for (var i = begin; i < end; ++i) {
            if (this.shape[this.direction](positions, i)) {
                if (trap && (traps[i] & mask) === 0) {
                    continue;
                }

                stopped[i] = true;
            } else if (trap) {
                traps[i] |= mask;
            }
            
        }
    };

})();
;(function() {
    "use strict";

    var tempPosition = new Float32Array(3);
    var tempVec3 = new Float32Array(3);
    var tempVec3b = new Float32Array(3);
    var tempVec3c = new Float32Array(3);
    var tempVec3d = new Float32Array(3);

    var PathRadius = Human.particles.constraints.PathRadius = function PathRadius(path) {
        this.nodes = path.nodes;
    };

    PathRadius.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var paths = attributes.paths;

        var norm = vec3.normalize;
        var sub = vec3.subtract;
        var dot = vec3.dot;
        var length = vec3.length;
        var scale = vec3.scale;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            if (paths[i] < 1) {
                continue;
            }

            var node = this.nodes[paths[i]];

            if (!node) {
                continue;
            }

            tempPosition[0] = positions[vi];
            tempPosition[1] = positions[vi + 1];
            tempPosition[2] = positions[vi + 2];

            var prevNode = this.nodes[paths[i] - 1];
            var diff = sub(tempVec3, tempPosition, prevNode.position);
            var proj = dot(diff, node.dir);

            var positionProj = scale(tempVec3b, node.dir, proj);
            var positionPerp = sub(tempVec3c, diff, positionProj);
            var dist = length(positionPerp);

            if (dist > node.radius) {
                norm(positionPerp, positionPerp);
                var correct = scale(tempVec3d, positionPerp, node.radius - dist);
                positions[vi]     += correct[0];
                positions[vi + 1] += correct[1];
                positions[vi + 2] += correct[2];
            }
        }        

    };
})();;(function() {
    "use strict";


    var PathKill = Human.particles.constraints.PathKill = function PathKill(path) {
        this.nodes = path.nodes;
    };

    PathKill.prototype.constrain = function(begin, end, attributes) {

        var numNodes = this.nodes.length;
        var paths = attributes.paths;
        var dead = attributes.dead;

        for (var i = begin; i < end; ++i) {
            if (paths[i] >= numNodes) {
                dead[i] = true;
            }
        }        

    };
})();;(function() {
    "use strict";


    var PathStop = Human.particles.constraints.PathStop = function PathStop(path) {
        this.nodes = path.nodes;
    };

    PathStop.prototype.constrain = function(begin, end, attributes) {

        var numNodes = this.nodes.length;
        var paths = attributes.paths;
        var stopped = attributes.stopped;

        for (var i = begin; i < end; ++i) {
            if (paths[i] >= numNodes) {
                stopped[i] = true;
            }
        }        

    };
})();;(function() {
    "use strict";

    var tempVelocity = new Float32Array(3);
    var tempVec3 = new Float32Array(3);
    var tempVec3b = new Float32Array(3);

    var surfacePosition = new Float32Array(3);
    var surfaceNormal = new Float32Array(3);

    var ShapeBounce =  Human.particles.constraints.ShapeBounce = function ShapeBounce(shape, direction, trapId) {
        this.shape = shape;
        this.direction = direction;

        if (trapId >= 0) {
            this.trap = true;
            this.trapMask = 1 << trapId;
        } else {
            this.trap = false;
            this.trapMask = 0;
        }
    };

    ShapeBounce.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var traps = attributes.traps;

        var trap = this.trap;
        var mask = this.trapMask;

        var sub = vec3.subtract;
        var dot = vec3.dot;
        var length = vec3.length;
        var scale = vec3.scale;
        
        for (var i = begin; i < end; ++i) {
            if (this.shape[this.direction](positions, i)) {
                if (trap && (traps[i] & mask) === 0) {
                    continue;
                }

                var vi = i * 3;

                this.shape.surfaceProjection(positions, i, surfacePosition, surfaceNormal);
                positions.set(surfacePosition, vi);

                tempVelocity[0] = velocities[vi];
                tempVelocity[1] = velocities[vi + 1];
                tempVelocity[2] = velocities[vi + 2];

                var speed = length(tempVelocity);
                
                tempVelocity[0] /= speed;
                tempVelocity[1] /= speed;
                tempVelocity[2] /= speed;

                var dotN = dot(tempVelocity, surfaceNormal);
                var scaledN = scale(tempVec3, surfaceNormal, 2 * dotN);
                var reflect = sub(tempVec3b, tempVelocity, scaledN);
                scale(reflect, reflect, speed);

                velocities[vi]     = reflect[0]; 
                velocities[vi + 1] = reflect[1]; 
                velocities[vi + 2] = reflect[2];
            } else if (trap) {
                traps[i] |= mask;
            }
        }
    };

})();
;(function () {
    "use strict";

    var position = vec3.create();

    var Sphere = Human.particles.shapes.Sphere = function(options) {
        this.translate = null;
        this.rotate = null;
        this.scale = null;
        this.xform = null;
        this.inverseXform = null;
        this.normalXform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();
            this.inverseXform = mat3.create();
            this.normalXform = mat3.create();

            if (options.rotate) {
                this.rotate = new Float32Array(options.rotate);
            }

            if (options.scale) {
                this.scale = new Float32Array(options.scale);
            }

            this.updateXform();
        }
    };

    Sphere.prototype.updateXform = function() {
        if (!this.xform) {
            return;
        }
        
        Human.math.buildRotationScaleMat3(this.xform, this.rotate, this.scale);
        mat3.invert(this.inverseXform, this.xform);
        mat3.transpose(this.normalXform, this.inverseXform);
    };

    Sphere.prototype.in = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + y * y + z * z <= 1;
    };

    Sphere.prototype.out = function(positions, i) {
        var vi = i * 3;
        
        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + y * y + z * z >= 1;
    };

    Sphere.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }


        vec3.normalize(position, position);
        normal.set(position);

        if (this.xform) {
            vec3.transformMat3(position, position, this.xform);
            vec3.transformMat3(normal, normal, this.normalXform);
            vec3.normalize(normal, normal);
        }

        if (this.translate) {
            position[0] += this.translate[0];
            position[1] += this.translate[1];
            position[2] += this.translate[2];
        }
    };



})();
;(function () {
    "use strict";

    var tempPosition = new Float32Array(3);
    var perp = new Float32Array(3);
    var xform = mat3.create();
    var defaultN = new Float32Array([0, 1, 0]);

    var Plane = Human.particles.shapes.Plane = function(options) {
        this.translate = new Float32Array(options.translate || Human.math.VEC3_ZEROS);
        this.rotate = new Float32Array(options.rotate || Human.math.VEC3_ZEROS);

        this.normal = vec3.create();
        this.distance = 0;
    };

    Plane.prototype.updateXform = function() {
        this.normal.set(defaultN);
        Human.math.buildRotationScaleMat3(xform, this.rotate, null);
        vec3.transformMat3(this.normal, this.normal, xform);

        this.distance = vec3.dot(this.translate, this.normal);
    };

    Plane.prototype.in = function(positions, i) {
        var vi = i * 3;

        var x = positions[vi];
        var y = positions[vi + 1];
        var z = positions[vi + 2];

        var nx = this.normal[0];
        var ny = this.normal[1];
        var nz = this.normal[2];

        return x * nx + y * ny + z * nz <= this.distance;
    };

    Plane.prototype.out = function(positions, i) {
        var vi = i * 3;

        var x = positions[vi];
        var y = positions[vi + 1];
        var z = positions[vi + 2];

        var nx = this.normal[0];
        var ny = this.normal[1];
        var nz = this.normal[2];

        return x * nx + y * ny + z * nz >= this.distance;
    };

    Plane.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;

        tempPosition[0] = positions[vi];
        tempPosition[1] = positions[vi + 1];
        tempPosition[2] = positions[vi + 2];

        normal[0] = this.normal[0];
        normal[1] = this.normal[1];
        normal[2] = this.normal[2];

        vec3.scale(perp, normal, this.distance - vec3.dot(tempPosition, normal));
        vec3.add(position, tempPosition, perp);
    };



})();
;(function () {
    "use strict";

    var position = vec3.create();

    var Cube = Human.particles.shapes.Cube = function(options) {
        this.translate = null;
        this.rotate = null;
        this.scale = null;
        this.xform = null;
        this.inverseXform = null;
        this.normalXform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();
            this.inverseXform = mat3.create();
            this.normalXform = mat3.create();

            if (options.rotate) {
                this.rotate = new Float32Array(options.rotate);
            }

            if (options.scale) {
                this.scale = new Float32Array(options.scale);
            }

            this.updateXform();
        }
    };

    Cube.prototype.updateXform = function() {
        if (!this.xform) {
            return;
        }

        Human.math.buildRotationScaleMat3(this.xform, this.rotate, this.scale);
        mat3.invert(this.inverseXform, this.xform);
        mat3.transpose(this.normalXform, this.inverseXform);
    };

    Cube.prototype.in = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x >= -0.5 && x <= 0.5 && 
               y >= -0.5 && y <= 0.5 && 
               z >= -0.5 && z <= 0.5;
    };

    Cube.prototype.out = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x <= -0.5 || x >= 0.5 || 
               y <= -0.5 || y >= 0.5 || 
               z <= -0.5 || z >= 0.5;
    };

    Cube.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;
        var abs = Math.abs;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        var left = abs(x + 0.5);
        var right = abs(x - 0.5);
        var bottom = abs(y + 0.5);
        var top = abs(y - 0.5);
        var back = abs(z + 0.5);
        var front = abs(z - 0.5);

        if (left < right && left < bottom && left < top && left < back && left < front) {
            x = -0.5;

            normal[0] = -1;
            normal[1] = 0;
            normal[2] = 0;
        } else if (right < bottom && right < top && right < back && right < front) {
            x = 0.5;

            normal[0] = 1;
            normal[1] = 0;
            normal[2] = 0;
        } else if (bottom < top && bottom < back && bottom < front) {
            y = -0.5;
            
            normal[0] = 0;
            normal[1] = -1;
            normal[2] = 0;
        } else if (top < back && top < front) {
            y = 0.5;

            normal[0] = 0;
            normal[1] = 1;
            normal[2] = 0;
        } else if (back < front) {
            z = -0.5;
            
            normal[0] = 0;
            normal[1] = 0;
            normal[2] = -1;
        } else {
            z = 0.5;

            normal[0] = 0;
            normal[1] = 0;
            normal[2] = 1;
        }
        
        if (x < -0.5) {
            x = -0.5;
        } else if (x > 0.5) {
            x = 0.5;
        }

        if (y < -0.5) {
            y = -0.5;
        } else if (y > 0.5) {
            y = 0.5;
        }

        if (z < -0.5) {
            z = -0.5;
        } else if (z > 0.5) {
            z = 0.5;
        }

        position[0] = x;
        position[1] = y;
        position[2] = z;

        if (this.xform) {
            vec3.transformMat3(position, position, this.xform);
            vec3.transformMat3(normal, normal, this.normalXform);
            vec3.normalize(normal, normal);
        }

        if (this.translate) {
            position[0] += this.translate[0];
            position[1] += this.translate[1];
            position[2] += this.translate[2];
        }
    };



})();
;(function () {
    "use strict";

    var position = vec3.create();

    var Cylinder = Human.particles.shapes.Cylinder = function(options) {
        this.translate = null;
        this.rotate = null;
        this.scale = null;
        this.xform = null;
        this.inverseXform = null;
        this.normalXform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();
            this.inverseXform = mat3.create();
            this.normalXform = mat3.create();

            if (options.rotate) {
                this.rotate = new Float32Array(options.rotate);
            }

            if (options.scale) {
                this.scale = new Float32Array(options.scale);
            }

            this.updateXform();
        }
    };

    Cylinder.prototype.updateXform = function() {
        if (!this.xform) {
            return;
        }
        
        Human.math.buildRotationScaleMat3(this.xform, this.rotate, this.scale);
        mat3.invert(this.inverseXform, this.xform);
        mat3.transpose(this.normalXform, this.inverseXform);
    };

    Cylinder.prototype.in = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + z * z <= 1 && y >= -1 && y <= 1;
    };

    Cylinder.prototype.out = function(positions, i) {
        var vi = i * 3;
        
        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + z * z >= 1 || y <= -1 || y >= 1;
    };

    Cylinder.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];
        var r, r2;

        if (y < -1) {
            normal[0] = 0;
            normal[1] = -1;
            normal[2] = 0;
        } else if (y > 1) {
            normal[0] = 0;
            normal[1] = 1;
            normal[2] = 0;
        } else {
            r2 = x * x + z * z;
            r = Math.sqrt(r2);
            normal[0] = x / r;
            normal[1] = 0;
            normal[2] = z / r;
            
        }

        if (y < -1) {
            y = -1;
        }

        if (y > 1) {
            y = 1;
        }

        r2 = r2 || (x * x + z * z);
        if (r2 > 1) {
            r = r || Math.sqrt(r);
            x /= r;
            z /= r;
        }

        position[0] = x;
        position[1] = y;
        position[2] = z;

        if (this.xform) {
            vec3.transformMat3(position, position, this.xform);
            vec3.transformMat3(normal, normal, this.normalXform);
            vec3.normalize(normal, normal);
        }

        if (this.translate) {
            position[0] += this.translate[0];
            position[1] += this.translate[1];
            position[2] += this.translate[2];
        }
    };



})();
;/**
 * @namespace Engine media (videos, audio etc).
 */
Human.media = Human.media || {};;/**
 * @namespace Generic container for streaming media clips
 *
 * NOTE: Clips are now registered by the chapter that wants to play clips.
 * Clip data is still stored with the state folder, but the chapter publishes the clip by id
 *
 */
Human.media.Clips = function (streamType) {
    "use strict";

    var self = this;

    this._streamType = streamType;

    /** Clips mapped to IDs
     */
    this.clips = {};

    /** Clips ordered by their timeline times
     *
     * @type {Array}
     */
    this.clipsList = [];

    /** Clips grouped into libraries
     */
    this.libraries = {};

    /**
     * IDs of clips that are currently "suggested", where those clips have time1 and time2 properties
     * that interesect the current timeline scrubber.
     * @type {Array}
     */
    this.suggestedClips = [];

    Human.events.fire(this._streamType + ".clips", self.clipsList, true);

    //get clip by id
    self.getClipById = function(clipid){
      var result = null;
      this.clipsList.forEach(function(clip){
        if (clip.clipId === clipid){
          result = clip;
        }
      });
      return result;
    };

    /**
     * Creates a clips library
     * NOTE: from state folder
     *
     * @param {String} libraryId Unique library ID
     * @param {[{}]} clips Clips within the library
     */
    this.createLibrary = function (libraryId, clips) {

        if (this.libraries[libraryId]) {

            // Tolerate reload of same library
            Human.log.warn("Human.media." + this._streamType + ".createLibrary", "Library already loaded: " + libraryId);
            return;
        }

        var parts = libraryId.split("/");
        var modelId = parts[0];
        var subasset = parts[1];

        var library = this.libraries[libraryId] = {
            libraryId: libraryId,
            clips: {}
        };

        var p;
        var clip;

        // Create clips
        for (var i = 0, len = clips.length; i < len; i++) {
            p = clips[i];

            // Validate each clip
            if (!p.clipId) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: clipId");
                continue;
            }
            // if (!p.displayName) {
            //     Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: displayName");
            //     continue;
            // }
            if (!p.type) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: type");
                continue;
            }
            if (!p.src) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: src");
                continue;
            }
            if (p.time1 === undefined || p.time1 === null) {
                //Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time1 - defaulting to 0 seconds");
                p.time1 = null;
            }
            if (p.time2 === undefined || p.time2 === null) {
                //Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time2 - defaulting to 0 seconds");
                p.time2 = null;
            }
            if (this.clips[p.clipId]) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip 'clipId' clashes with another clip: '" + p.clipId + "' - replacing existing clip");
            }

            var fullURL = [modelId, this._streamType, subasset, p.src].join("/");

            clip = {
                clipId: p.clipId,
                modelId: modelId,
                streamType: this._streamType,
                subasset: subasset,
                displayName: p.displayName,
                description: p.description || "",
                time1: p.time1,
                time2: p.time2,
                type: p.type || "",
                src: p.src,
                fullUrl: fullURL,
                alternatives: p.alternatives || [],
                length: p.length || 0,
                suggested: false,
                status: "closed"
            };

            // Register clip against library
            library.clips[p.clipId] = clip;

            // Add clip to ID map
            this.clips[p.clipId] = clip;
        }

        // Rebuild time-ordered clip list from ID map
        this._rebuildClipList();
    };

    /** Rebuilds time-ordered clip list and exports it via event
     * @private
     */
    this._rebuildClipList = function () {
        this.clipsList = [];
        for (var clipId in this.clips) {
            if (this.clips.hasOwnProperty(clipId)) {
                this._insertClipIntoList(this.clipsList, this.clips[clipId]);
            }
        }
        // Publish new clip list
        Human.events.fire(this._streamType + ".clips", this.clipsList, true);
    };

    /**
     * Inserts a clip into list of clips ordered by time
     * @private
     */
    this._insertClipIntoList = function (list, clip) {
        if (list.length === 0) {
            // First clip in list
            list.push(clip);
        } else {
            // Find place and insert
            var v;
            for (var j = list.length - 1; j >= 0; j--) {
                v = list[j];
                if (v.time1 < clip.time1) {
                    list.splice(j + 1, 0, clip);
                    return;
                }
            }
            // Clip is earliest - insert at front of list
            list.splice(0, 0, clip);
        }
    };

    /**
     * Destroys a clips library
     * @param libraryId
     */
    this.destroyLibrary = function (libraryId) {
        var lib = this.libraries[libraryId];
        if (!lib) {
            // Tolerate missing library
            Human.log.warn("Human.media." + this._streamType + ".destroyLibrary", "Library not found: " + libraryId);
            return;
        }
        for (var clipId in lib.clips) {
            if (lib.clips.hasOwnProperty(clipId)) {
                delete this.clips[clipId];
                Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "destroyed" });
            }
        }
        delete this.libraries[libraryId];

        // Rebuild time-ordered clip list from remaining clips in ID map
        this._rebuildClipList();
    };

    /**
     * Opens a clip
     * @param clipId
     */
    this.open = function (clipId, ok) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "open" }, true);
        ok();
    };

    /**
     * Plays a clip
     * @param clipId
     */
    this.play = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "playing" }, true);
    };

    /**
     * Scrubs a clip to the given time
     * @param clipId
     * @param time
     */
    this.scrub = function (clipId, time) {
        Human.events.fire(this._streamType + ".scrubbed", { clipId: clipId, time: time });
    };

    /**
     * Pauses a clip
     * @param clipId
     */
    this.pause = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "paused" }, true);
    };

    /**
     * Stops a clip
     * @param clipId
     */
    this.stop = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "stopped" }, true);
    };

    /**
     * Closes a clip
     * @param clipId
     */
    this.close = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "closed" }, true);
    };

    /**
     * Destroys all clip libraries
     */
    this.reset = function () {
        for (var libraryId in this.libraries) {
            if (this.libraries.hasOwnProperty(libraryId)) {
                this.destroyLibrary(libraryId);
            }
        }
    };
};
;/**
 * @namespace Audio clips
 */
Human.media.audio= new Human.media.Clips("audio");;/**
 * @namespace Video clips
 */
Human.media.videos = new Human.media.Clips("videos");;/**
 * @namespace Engine asset libraries.
 * @private
 */

(function() {
    "use strict";

    var assets = Human.assets = {
        loadedAssets: {},
        nullAssets: {},
        assetUseCounts: {},
        libUseCounts: {},
        requestedAssets: 0
    };

    // Defaults to adding an "s" to type
    var ASSET_MODULES = {
        geometry: "geometries",
        audio: "audio",
        videos: "video"
    };

    var libModules = {}; // For each library remembers the module that loaded it, so the module can unload again
    var nullLibs = {};

    var assetCallbacks = {};

    var receivedAssets = 0;
    var loadPercent = 0;

    assets.init = function () {
        this.server.init();
        this.geometries.init();
        this.materials.init();
        this.morphs.init();
        this.reflections.init();
    };

    assets.getAsset = function (assetId, type, ok) {
        if (assets.nullAssets[assetId]) {

            if (ok) {
                Human.utils.async(function () {
                    ok(null);
                });
            }

            return;
        }

        if (assets.loadedAssets[assetId] === "LOADING") {

            if (ok) {
                assetCallbacks[assetId].push(ok);
            }

            return;
        }

        // we have already loaded this asset, possibly from packed files
        if (assets.loadedAssets[assetId]) {
            processAsset(assetId, type, assets.loadedAssets[assetId], ok);
            return;
        }

        if (assets.requestedAssets === 0) {
            assets.assetLoadStart();
        }

        assets.requestedAssets++;

        assets.loadedAssets[assetId] = "LOADING";
        assetCallbacks[assetId] = [];

        if (ok) {
            assetCallbacks[assetId].push(ok);
        }

        // [MOBILE] - check if the asset is on the device
        if (window.localContentOnly || Human.mobile.iOS || Human.mobile.android) {
            var isBinary = ((type === "morph") || (type === "geometry"));

            var oid = assetId;

            if (window.localContentOnly) {
                assetId = assetId.replace(/\|/g, '/').replace(/:/g, ';') + '.bda';
            }
            var request = new XMLHttpRequest();
            request.responseType = isBinary ? "arraybuffer" : "text";
            request.open("GET", window.localBaseDirectory + "assets/" + assetId, true);

            request.onerror = function () {
                if (!window.localContentOnly) {
                    assets.server.getAsset(type, oid, function(asset) {
                        gotAsset(type, oid, asset, true);
                    });
                } else {
                    gotAsset(type, oid, null, false);
                }
            };
            request.onload = function() {
                if (request.status === 200 || window.localContentOnly) {
                    var data = request.response;
                    var asset = (isBinary)? data : JSON.parse(data);
                    if ( window.localContentOnly && !isBinary ) {
                        asset = asset.asset;
                    }
                    gotAsset(type, oid, asset, false);
                } else {
                    assets.server.getAsset(type, assetId, function(asset) {
                        gotAsset(type, assetId, asset, true);
                    });
                }
            };   
            request.send(null);
        } else {
            assets.server.getAsset(type, assetId, function(asset) {
                gotAsset(type, assetId, asset, false);
            });
        }
    };

    function processAsset(assetId,type,theAsset, ok) {
        assetAcquired(assetId);
        // process theAsset.asset for transforms unpacked from transforms.json
        if (type === "transform" && Human.unpackAssets.transformJson === true) {
            assetCallbacks[assetId] = [];
            if (ok) {
                assetCallbacks[assetId].push(ok);
            }
            gotAsset(type,assetId,theAsset.asset,false);
        }
        // process theAsset for data 
        else if (type === "geometry" && Human.unpackAssets.geometryJson === true && theAsset instanceof ArrayBuffer) {
            assetCallbacks[assetId] = [];
            if (ok) {
                assetCallbacks[assetId].push(ok);
            }
            gotAsset(type,assetId,theAsset,false);
        }
        else if (ok) {
            Human.utils.async(function () {
                ok(assets.loadedAssets[assetId]);
            });
        }
    }


    assets.getAssetLibrary = function (type, dir, libId, fileName, params, ok) {
        if (nullLibs[libId]) {
            Human.utils.async(ok);
            return;
        }

        if (assets.libUseCounts[libId]) {

            libAcquired(libId);
            Human.utils.async(ok);

            return;
        }

        assets.server.getAssetLibrary(dir, libId, fileName, function(data) {
            var module;

            if (!data) {
                nullLibs[libId] = true;

                if (ok) {
                    ok();
                }

                return;
            }


            if (assets.libUseCounts[libId]) {

                libAcquired(libId);

                if (ok) {
                    ok();
                }
                return;
            }

            if (type === "animation") {
                if (data.format === "binary") {
                    if (ok) {
                        ok();
                    }
                    return;
                }
                module = Human.assets.tweens;
            } else {
                module = Human.assets[getModuleName(type)];
            }


            if (module) {
                // TODO: Do we need a semaphore to prevent concurrent asynch load of same library?

                module.parseLibrary(libId, data, params, function() {

                    libAcquired(libId);

                    libModules[libId] = module;

                    if (ok) {
                        ok();
                    }
                });

            } else {
                Human.log.error("Unknown asset library type: " + type);
                if (ok) {
                    ok();
                }
            }
        });
    };

    /**
     * Release an asset library that was acquired previously by #getAssetLibrary.
     * Deletes the lib when its use count count has then become zero.
     * Assumes that the library has completely loaded; don't call this while library is still loading.
     *
     * @param {String} libId ID of the asset library to releas
        if (--libUseCounts[lLibId] <= 0) {

            // Last reference released, destroy lib and use ce.
     */
    assets.putAssetLibrary = function(libId) {
        if (assets.libUseCounts[libId] === undefined) { // Not currently loaded
            return;
        }

        if (--assets.libUseCounts[libId] <= 0) {

            // Last reference released, destroy lib and use count

            delete assets.libUseCounts[libId];

            // Delegate asset unloading to module

            var module = libModules[libId];

            if (module && module.unloadLibrary) {
                module.unloadLibrary(libId);
            }

            delete libModules[libId];
        }
    };

    /**
     * Release an assets that was acquired previously by #getAsset.
     *
     * Deletes the asset when its use count count has then become zero.
     *
     * @param {String} assetId ID of the asset to release.
     */
    assets.putAsset = function (assetId) {

        if (this.assetUseCounts[assetId] === undefined) {
            return;
        }

        if (--this.assetUseCounts[assetId] <= 0) {

            // Last reference released, destroy asset and use count
            var asset = assets.loadedAssets[assetId];
            var module = Human.assets[getModuleName(asset.type)];
            module.destroyAsset(assetId);

            delete assets.loadedAssets[assetId];
            delete this.assetUseCounts[assetId];
        }
    };

    // Indicates that an asset library has been acquired, incrementing its use count.
    //
    function libAcquired(libId) {
        if (assets.libUseCounts[libId] === undefined) {
            assets.libUseCounts[libId] = 1;
            return;
        }
        assets.libUseCounts[libId]++;
    }

    // Indicates that an asset has been acquired, incrementing its use count.
    //
    function assetAcquired(assetId) {
        if (assets.assetUseCounts[assetId] === undefined) {
            assets.assetUseCounts[assetId] = 1;
            return;
        }
        assets.assetUseCounts[assetId]++;
    }

    function getModuleName(type) {
        return ASSET_MODULES[type] || type + "s";
    }

    function gotAsset(type, assetId, asset, putToServer) {
        assetLoadProgress(assetId, type);
        var callbacks;
        var i, len;

        if (!asset || asset === assets.server.TIMEOUT) {
            if (!asset) {
                assets.nullAssets[assetId] = true;
            }
            assets.loadedAssets[assetId] = null;
            callbacks = assetCallbacks[assetId];
            for (i = 0, len = callbacks.length; i < len; i++) {
                callbacks[i](null);
            }
            delete assetCallbacks[assetId];
            return;
        }

        try {
            if (putToServer) {
                var isBinary = ((type === "morph") || (type === "geometry"));
                var xhr = new XMLHttpRequest();
                xhr.open("PUT", "/assets/" + assetId, true);
                if (isBinary) {
                    xhr.send(asset);
                } else {
                    xhr.send(JSON.stringify(asset));
                }
            }
            if (type === "transform") {
                callbacks = assetCallbacks[assetId];
                for (i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](asset);
                }
                // Don't cache transform assets
                delete assets.loadedAssets[assetId];
                delete assetCallbacks[assetId];
            } else {
                var module = Human.assets[getModuleName(type)];
                module.parseAsset(assetId, asset, function(asset) {
                    assets.loadedAssets[assetId] = asset;
                    callbacks = assetCallbacks[assetId];
                    for (i = 0, len = callbacks.length; i < len; i++) {
                        assetAcquired(assetId);
                        callbacks[i](asset);
                    }
                    delete assetCallbacks[assetId];
                });
            }
            
        } catch (e) {
            Human.log.error("Error parsing asset: " + assetId + " - " + e.message);
            assets.loadedAssets[assetId] = null;
            assets.nullAssets[assetId] = true;
            var callbacks = assetCallbacks[assetId];
            for (var i = 0, len = callbacks.length; i < len; i++) {
                callbacks[i](null);
            }
            delete assetCallbacks[assetId];
        }
    }

    assets.assetLoadStart = function() {
        Human.events.fire("assets.load.start");
        Human.stats.loadSequence.assetsRequested = Human.timer.now();
        Human.stats.loadTimes.preAsset = Human.stats.loadSequence.assetsRequested - Human.stats.loadSequence.startTime;
        loadPercent = 0;
    };

    function assetLoadProgress(assetId, type) {
        receivedAssets++;

        // don't emit more than 100 events
        var progress = Math.floor(100 * (receivedAssets/assets.requestedAssets));
        if (loadPercent !== progress) {
            loadPercent = progress;
            Human.events.fire("assets.load.progress", {
                assetId: assetId,
                assetType: type,
                requestedAssets: assets.requestedAssets,
                receivedAssets: receivedAssets
            });
        }

        if(receivedAssets === assets.requestedAssets) {
            assetLoadFinish();
        }
    }

    function assetLoadFinish() {
        Human.events.fire("assets.load.finish");

        assets.requestedAssets = 0;
        receivedAssets = 0;

        Human.stats.loadSequence.assetsLoaded = Human.timer.now();
        Human.stats.loadTimes.assetDownload = Human.stats.loadSequence.assetsLoaded - Human.stats.loadSequence.assetsRequested;
        Human.renderer.resetFrameThrottling();
    }


})();
;(function() {
    "use strict";

    var assetServer = Human.assets.server = {
        TIMEOUT: 1
    };

    var TIMEOUT = 120000; //ms

    var ENABLE_DRACO = Human.request.getSearchParam("__bdh_engine_draco") === "true";

    // Callbacks to be run when the socket opens.
    var openCallbacks = [];

    // Callbacks to be run when a message is received.
    // Organized by asset ID.
    var messageCallbacks = {};

    var requestQueue = [];

    // Defaults to adding an "s" to type
    var URL_BASE = {
        geometry: "geometry"
    };

    var moduleDefinitions = {};
    var stateIndexes = {};

    var lastNetworkTime;

    var assetDomain;
    var socket;
    var socketURL;

    var assetServerInitialized = false;

    Human.properties.subscribe({
        propId: "assetDomain",
        value: "assets-human.biodigital.com",
        callback: function (value) {
            assetDomain = value;
        }
    });

    assetServer.init = function () {
        // the offline environment file sets assetDomain = '' to prevent the connection
        if (assetServerInitialized || assetDomain === '') {
            return;
        }

        var socketProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";

        // mobile connects locally via http but wants a secure connection to the asset server
        if (Human.mobile.android || Human.mobile.iOS) {
            socketProtocol = "wss:";
        }

        socketURL = socketProtocol + "//" + assetDomain + "/assets/ws" + (ENABLE_DRACO ? 4 : 3);

        socket = createSocket();

        setInterval(function() {

            socketSend();

            var now = Date.now();

            if (now - lastNetworkTime > TIMEOUT) {
                for (var assetId in messageCallbacks) {
                    if (messageCallbacks.hasOwnProperty(assetId)) {
                        Human.log.error("Server timeout on asset: " + assetId);
                        var callbacks = messageCallbacks[assetId];

                        for (var i = 0, len = callbacks.length; i < len; i++) {
                            callbacks[i](assetServer.TIMEOUT);
                        }
                        delete messageCallbacks[assetId];
                    }
                }
            }

        }, 100);

        assetServerInitialized = true;
    };

    assetServer.cacheModuleDefinition = function(moduleId, moduleDefinition) {
        if (moduleDefinitions[moduleId]) {
            return;
        }

        if (moduleDefinition) {
            moduleDefinitions[moduleId] = JSON.stringify(moduleDefinition);
            return;
        }

        assetServer.getModuleDefinition(moduleId);
    };

    assetServer.getModuleDefinition = function (moduleName, ok, error) {
        if (moduleDefinitions[moduleName]) {
            if (ok) {
                ok(JSON.parse(moduleDefinitions[moduleName]));
            }
            return;
        }

        Human.stats.loadSequence.moduleRequest = Human.timer.now();
        Human.stats.loadTimes.preModule = Human.stats.loadSequence.moduleRequest - Human.stats.loadSequence.startTime;

        Human.utils.getText(window.localBaseDirectory + "content/modules/" + moduleName,
            function (moduleDefinition) {
                jsonDownloadSize(moduleName, moduleDefinition);

                moduleDefinitions[moduleName] = moduleDefinition;

                Human.stats.loadSequence.moduleLoaded = Human.timer.now();
                Human.stats.loadTimes.moduleDownload = Human.stats.loadSequence.moduleLoaded - Human.stats.loadSequence.moduleRequest;

                if (ok) {
                    ok(JSON.parse(moduleDefinition));
                }
            },
            function (xhr, textStatus, errorThrown) {
                Human.events.fire("net.error", {
                    id: moduleName,
                    type: "modules",
                    status: xhr.status,
                    statusText: xhr.statusText
                });

                if (error) {
                    error(errorThrown);
                }
            }

        );
    };

    assetServer.cacheStateIndex = function(stateId, index) {
        if (stateIndexes[stateId]) {
            return;
        }

        if (index) {
            stateIndexes[stateId] = JSON.stringify(index);
            return;
        }

        Human.utils.getText(window.localBaseDirectory + "content/states/" + stateId + "/index?v=" + Human.VERSION + "&locale=" + Human.locale,
            function (index) {
                jsonDownloadSize(stateId + "/index", index);
                stateIndexes[stateId] = index;
            }
        );
    };

    assetServer.getStateIndex = function(stateId, ok, error) {
        if (stateIndexes[stateId]) {
            if (ok) {
                ok(JSON.parse(stateIndexes[stateId]));
            }
            return;
        }

        Human.utils.getText(window.localBaseDirectory + "content/states/" + stateId + "/index?v=" + Human.VERSION + "&locale=" + Human.locale,
            function(index) {
                jsonDownloadSize(stateId + "/index", index);
                ok(JSON.parse(index));
            },
            error
        );
    };

    assetServer.getAnimationManifest = function(libId, ok, error) {
        var parts = libId.split("/");

        Human.utils.getText(window.localBaseDirectory + "content/states/" + parts[0] + "/animations/" + parts[1] + "/manifest",
            function(manifest) {
                jsonDownloadSize(libId, manifest);
                ok(JSON.parse(manifest));
            },
            error
        );
    };

    assetServer.getAsset = function(type, id, ok) {
        var parts = id.split("/");
        var stateId = parts[0];
        var assetId = parts[1];
        var key = parts[2];
        var assetURI = stateId + "/" + (URL_BASE[type] || type + "s") + "/" + assetId;
        if (key) {
            assetURI += "/" + key;
        }

        if (messageCallbacks[assetURI]) {
            messageCallbacks[assetURI].push(ok);
            return;
        }

        messageCallbacks[assetURI] = [ok];

        requestQueue.push(assetURI);
    };

    assetServer.getAssetLibrary = function (dir, libId, fileName, ok) {
        var parts = libId.split("/");

        var directory = (typeof(window.localBaseDirectory) !== 'undefined') ? window.localBaseDirectory : '/';
        Human.utils.getJSON(directory + "content/states/" + parts[0] + "/" + dir + "/" + parts[1] + "/" + fileName,
            ok,
            function() {
                Human.log.error("Asset library not found: " + libId);
                ok(null);
            }
        );
    };

    function createSocket() {
        var socket = new WebSocket(socketURL);

        socket.binaryType = "arraybuffer";

        socket.addEventListener("open", function() {
            socket.send(JSON.stringify({ open: "sesame!" }));

            for (var i = 0, len = openCallbacks.length; i < len; i++) {
                openCallbacks[i]();
            }

            openCallbacks.length = 0;
        });

        socket.addEventListener("close", function(event) {
            Human.log.log("Socket closed", event.code, event.reason);
        });

        socket.addEventListener("error", function() {
            Human.log.error("Socket error");
        });

        socket.addEventListener("message", function(response) {

            var data = response.data;
            var asset;
            var assetId;

            lastNetworkTime = Date.now();

            if (typeof data === "string") {

                // Non-data "message received" signal
                if (data === "\uD83C\uDF7A") {
                    return;
                }


                var json = JSON.parse(data);
                assetId = json.id;

                jsonDownloadSize(assetId, data);

                if (json.error) {
                    Human.log.error("Asset not found: " + assetId);
                    asset = null;
                } else if (!json.asset) {
                    Human.log.error("Null asset: " + assetId);
                    asset = null;
                } else {
                    asset = json.asset;
                }


            } else {

                /*
                 Geometry or morph

                 bytes   : info
                 [0.. 3]: uint32; file type identifer (= 0x11)
                 [4.. 7]: uint32; byte-length of padded asset id
                 [8..11]: uint32; byte-length of padded morph keys JSON
                 [12..15]: uint32; byte-length of positions array
                 [16..19]: uint32; byte-length of normals array
                 [20..23]: uint32; byte-length of indices array
                 [24..27]: uint32; byte-length of uv array
                 [28..43]: unit32[4]; unused, reserved for future use
                 [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
                 [  ..  ]: text; morph key JSON (tail-padded with 0x20)
                 [  ..  ]: float32[]; positions array
                 [  ..  ]: float32[]; normals array
                 [  ..  ]: int32[];   indices array
                 [  ..  ]: float32[]; uv array
                 */


                asset = data;

                var index = new DataView(asset);

                var fileType = index.getUint32(0, true);

                var assetIdStart, assetIdSize;

                if (fileType === 0x11) {
                    assetIdSize = new Uint32Array(asset, 0, 2)[1];
                    assetIdStart = 11 * Uint32Array.BYTES_PER_ELEMENT;
                } else {
                    assetIdSize = index.getUint32(4, true);
                    assetIdStart = index.getUint32(12, true);
                }


                assetId = Human.utils.atos(asset, assetIdStart, assetIdSize).trim();

                binaryDownloadSize(assetId, data);
            }

            var callbacks = messageCallbacks[assetId];

            if (callbacks) {
                for (var i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](asset);
                }
                delete messageCallbacks[assetId];
            }
        });

        return socket;
    }

    function socketSend() {

        if (requestQueue.length === 0) {
            return;
        }

        lastNetworkTime = Date.now();

        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                assets: requestQueue
            }));
            requestQueue.length = 0;
            return;
        }

        openCallbacks.push(function() {
            socket.send(JSON.stringify({
                assets: requestQueue
            }));
            requestQueue.length = 0;
        });

        if (socket.readyState === WebSocket.CLOSING || socket.readyState === WebSocket.CLOSED) {
            socket = createSocket();
        }
    }

    function jsonDownloadSize(id, str) {
        if (Human.stats.trackingDownloadSize) {
            var size = Human.utils.textGzipSize(str);
            Human.stats.jsonDownloadSizes[id] = size;
            Human.stats.jsonDownloadTotal += size;
        }
    }

    function binaryDownloadSize(id, data) {
        if (Human.stats.trackingDownloadSize) {
            var size = Human.utils.binaryGzipSize(data);
            Human.stats.geometryDownloadSizes[id] = size;
            Human.stats.geometryDownloadTotal += size;
        }
    }

})();
;(function () {
    "use strict";

    var Textures = Human.assets.textures = {};

    var DXT_SUPPORTED = SceneJS.checkExtension("WEBGL_compressed_texture_s3tc");
    var PVRTC_SUPPORTED = SceneJS.checkExtension("WEBGL_compressed_texture_pvrtc");
    var ETC1_SUPPORTED = SceneJS.checkExtension("WEBGL_compressed_texture_etc1");

    var BLEND_MODE_MAP = {
        add: "over",
        "hack_add": "add"
    };

    Textures.load = function(textures, ok) {
        textures = textures || [];

        var numTextures = textures.length;

        if (numTextures === 0) {
            ok();
            return;
        }

        function done() {
            if (--numTextures === 0) {
                Human.utils.filterInPlace(textures, filterNotFound);
                ok();
            }
        }

        for (var i = 0; i < numTextures; ++i) {
            // Filter out valid parameters.
            var texture = textures[i];
            texture = {
                src: texture.src || texture.uri,
                applyTo: texture.applyTo,
                blendMode: BLEND_MODE_MAP[texture.blendMode] || texture.blendMode,
                blendFactor: texture.blendFactor,
                preloadColor: texture.preloadColor,
                preloadSrc: texture.preloadSrc,
                swizzledNormals: texture.swizzledNormals || false,
            };
            textures[i] = texture;
            compressTextureSrc(texture);
            if (texture.compressedSrc) {
                Human.utils.getBinary(
                    texture.compressedSrc,
                    getCompressedTextureCallback(texture, done),
                    getCompressedTextureErrorCallback(texture, done)
                );
            } else {
                getImageTexture(texture, done);
            }
        }
    };

    function getCompressedTextureCallback(texture, ok) {
        return function(data) {
            if (Human.stats.trackingDownloadSize) {
                var size = Human.utils.binaryGzipSize(data);
                Human.stats.textureDownloadSizes[texture.compressedSrc] = size;
                Human.stats.textureDownloadTotal += size;
            }

            texture.type = "texture";
            texture.compressedImage = data;
            texture.src = null;
            ok();
        };
    }

    function getCompressedTextureErrorCallback(texture, ok) {
        return function() {
            texture.compressedSrc = null;
            texture.swizzledNormals = null;
            getImageTexture(texture, ok);
        };
    }

    function getImageTexture(texture, ok) {
        if (Human.stats.trackingDownloadSize) {
            var src = texture.src;
            Human.utils.getBinary(src, function(data) {
                Human.stats.textureDownloadSizes[src] = data.byteLength;
                Human.stats.textureDownloadTotal += data.byteLength;
            });
        }
        var img = new Image();
        img.onload = getImageCallback(img, texture, ok);
        img.onerror = ok;
        img.src = texture.src;
        texture.src = null;
    }

    function getImageCallback(img, texture, ok) {
        return function() {
            texture.type = "texture";
            texture.image = img;
            ok();
        };
    }

    function compressTextureSrc(texture) {
        var baseSrc = texture.src.replace(/(\.jpg|\.jpeg|\.png)$/, "");

        if (DXT_SUPPORTED) {
            // do we have swizzled normals?
            if (texture.applyTo === "normals" && texture.swizzledNormals === true) {
                texture.compressedSrc = baseSrc + "-sw-dxt5.dds";
                texture.containerFormat = "dds";
            } else {
                texture.compressedSrc = baseSrc + "-dxt1.dds";
                texture.containerFormat = "dds";
            }
            return;
        }

        if (PVRTC_SUPPORTED) {
            texture.compressedSrc = baseSrc + "-pvrtc.pvr";
            texture.containerFormat = "pvr";
            return;
        }

        if (ETC1_SUPPORTED) {
            texture.compressedSrc = baseSrc + "-etc1.pvr";
            texture.containerFormat = "pvr";
            return;
        }
    }

    function filterNotFound(t) {
        return t.image || t.compressedImage;
    }

})();
;/**
 * @namespace Engine unpacked concatenated transform and geometry assets.
 * @private
 */

(function() {
    "use strict";

    var unpackAssets = Human.unpackAssets = {
        blocksWaiting: 0,
        transformJson: false,
        geometryJson: false
    };

    var blocks = {};
    var geomRequests = {};

    Human.events.on("modules.fetch.start", function(modelId) {
        if (window.localBaseDirectory === undefined || window.localBaseDirectory === '/') {
            window.localBaseDirectory = '/';
            window.localContentOnly = false;
        }  else {
            window.localContentOnly = true;
            unpackAssets.transformJson = false;
            unpackAssets.geometryJson = false;
            blocks = {};
            geomRequests = {};
            unpackAssets.blocksWaiting = 0;
            loadGeometry(modelId);
            loadTransforms(modelId);
        }
    });

    function getGeometry(geometryData) {
        var block = blocks[geometryData.block];
        var offlen = geometryData.offlen;
        var destArray = new ArrayBuffer(offlen[1]);
        var asset = new Uint8Array(destArray, 0, offlen[1]);
        var srcU8 = new Uint8Array(block, offlen[0], offlen[1]);
        asset.set(srcU8);
        return destArray;
    }

    function openBlock(moduleId, block) {
        unpackAssets.blocksWaiting++;
        var request = new XMLHttpRequest();
        request.responseType = "arraybuffer";
        var target = window.localBaseDirectory + "blocks/geometry/modules/" + moduleId + "/" + block;
        request.open("GET", target, true);

        request.onerror = function () {
            console.log("error getting " + target);
        };
        request.onload = function() {
            if (request.status === 200 || window.localContentOnly) {
                blocks[block] = request.response;
                unpackAssets.blocksWaiting--;
                geomRequests[block].forEach(function(geometry) {
                    Human.assets.loadedAssets[geometry.assetId] = getGeometry(geometry.geometry);
                    assetRequested();
                });
                // if (unpackAssets.blocksWaiting === 0) {
                //     console.log("GEOM BLOCKS DONE " + Human.timer.now());
                // }
            }
        };
        request.send(null);
    }

    function loadGeometry(moduleId) {
//        console.log(moduleId + " GEOM START " + Human.timer.now());
        var request = new XMLHttpRequest();
        request.responseType = "text";
        var target = window.localBaseDirectory + "blocks/geometry/modules/" + moduleId + "/index.json";
        request.open("GET", target, true);

        request.onerror = function () {
            console.log("error getting " + target);
        };
        request.onload = function() {
            var count = 0;
            unpackAssets.geometryJson = true;
            if (request.status === 200 || window.localContentOnly) {
                var data = request.response;
                var geometries = JSON.parse(data);
                // parse transforms
                Object.keys(geometries).forEach(function(assetId) {
                    var geometry = geometries[assetId];
                    var block = geometry.block;
                    if (blocks[block] === undefined) {
                        blocks[block] = "Loading";
                        openBlock(moduleId, block);
                        geomRequests[block] = [];
                    }
                    count++;
                    geomRequests[block].push({assetId: assetId, geometry:geometry});
                });
 //               console.log("*** loaded " + count + " geometries from " + target);
            }
        };
        request.send(null);
    }

    function loadTransforms(moduleId) {
        var request = new XMLHttpRequest();
        request.responseType = "text";
        var target = window.localBaseDirectory + "transforms/modules/" + moduleId + ".json";
        request.open("GET", target, true);

        request.onerror = function () {
            console.log("error getting " + target);
        };
        request.onload = function() {
            var count = 0;
            unpackAssets.transformJson = true;
            if (request.status === 200 || window.localContentOnly) {
                var data = request.response;
                var transforms = JSON.parse(data);
                // parse transforms
                Object.keys(transforms).forEach(function(assetId) {
                    Human.assets.loadedAssets[assetId] = transforms[assetId];
                    assetRequested();
                    count++;
                });
//                console.log("*** loaded " + count + " transforms from " + target);
            }
        };
        request.send(null);
    }

    function assetRequested() {
        if (Human.assets.requestedAssets === 0) {
            Human.assets.assetLoadStart();
        }
        Human.assets.requestedAssets++;
    }
})();;/**
 * @namespace Geometry libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsGeometries = Human.assets.geometries = {};

    /** All geometries
     */
    HumanAssetsGeometries.geometries = {};

    var INDEX_TYPE_MAP = {
        "1": Uint8Array,
        "2": Uint16Array,
        "4": Uint32Array
    };

    var ENABLE_DRACO = Human.request.getSearchParam("__bdh_engine_draco") === "true";
    var DRACO_WORKER_FILE = 'draco/worker.js';

    // Draco Worker Setup
    var dracoUnpackCallbacks = {};
    var dracoWorkerLimit = 2;
    var dracoWorkers = new Array(dracoWorkerLimit);
    var dracoWorkerIdx = 0;
    function dracoWorkerMessageCallback(event){
        var status = event.data[0];
        var geoId = event.data[1];
        if (status===1){
            // SUCCESS
            var cfg = event.data[2];
            dracoUnpackCallbacks[geoId](HumanAssetsGeometries.createGeometry(geoId, cfg));
        } else {
            // ERROR
            var message = event.data[2];
            Human.log.error("Human.assets.geometries", message + " : " + geoId);
        }
        delete dracoUnpackCallbacks[geoId];
    }

    // Initialization required after application setup, because worker file base directory must be set by application
    function initializeDracoWorkers(){
        for (var i = 0; i < dracoWorkerLimit; i++) {
            var worker = Human.workers.loadWorker(DRACO_WORKER_FILE);
            worker.onmessage = dracoWorkerMessageCallback;
            dracoWorkers[i] = worker;
        }
    }

    // Holds all SceneJS nodes for geometries
    var libRoot;
    HumanAssetsGeometries.init = function () {
        // Init Draco workers if enabled
        if (ENABLE_DRACO) {
            initializeDracoWorkers();
        }
        // Scene graph now available
        libRoot = Human.renderer.getLibraryRoot().addNode({
            type: "library",
            data: "Geometry library"
        });
    };

    HumanAssetsGeometries.parseAsset = function(geometryId, asset, ok) {
        var fileType = new Uint32Array(asset, 0, 1)[0];

        var cfg = {
            geometry: {
                primitive: 'triangles'
            },
            draco: fileType === 0x13,
            compressed: (fileType !== 0x11)
        };

        if (cfg.draco){
            parseCompressedDracoGeometry(asset, cfg, geometryId, ok);
        } else if (cfg.compressed){
            parseCompressedGeometry(asset, cfg, geometryId, ok);
        } else {
            parseRawGeometry(asset, cfg, geometryId, ok);
        }
    };

    /** Creates a geometry within an existing geometries library
    NOTE: Consider whether createGeometry() needs to be exposed to the public API for geometries.
     * @param libraryId ID of library
     * @param geometryId ID for new geometry, globally unique among geometries in all libraries
     * @param params Geometry params - geometry, texture, flags
     */
    HumanAssetsGeometries.createGeometry = function (geometryId, params) {
        if (HumanAssetsGeometries.geometries[geometryId]) {
            Human.log.error("Human.assets.geometries.createGeometry", "Geometry already loaded: " + geometryId);
            return;
        }
        if (!params.geometry) {
            Human.log.error("Human.assets.geometries.createGeometry", "Mandatory attribute 'geometryId' expected on geometry: " + geometryId);
            return;
        }
        params.geometry.type = "geometry";
        var geometry = {
            //   materialId: params.materialId, // HACK while materialId can be on geometries
            geometry: libRoot.addNode(params.geometry),
            type: "geometry",
            compressed: params.compressed
        };

        var boundary = params.boundary;

        if (!boundary) {
            var scale = null;
            var translate = null;
            if (params.geometry.positionDecodeMat) {
                var mat = params.geometry.positionDecodeMat;
                scale = new Float32Array([mat[0], mat[5], mat[10]]);
                translate = new Float32Array([mat[12], mat[13], mat[14]]);
            }

            boundary = getBoundary(params.geometry.positions, scale, translate);
        }

        // Boundary and center
        geometry.boundary = boundary;
        geometry.center = [
            (boundary.xmax + boundary.xmin) * 0.5,
            (boundary.ymax + boundary.ymin) * 0.5,
            (boundary.zmax + boundary.zmin) * 0.5
        ];
        geometry.axisBoundary = new Float32Array([
            boundary.xmin, boundary.ymin, boundary.zmin,
            boundary.xmax, boundary.ymax, boundary.zmax]);

        HumanAssetsGeometries.geometries[geometryId] = geometry;

        return geometry;
    };

    HumanAssetsGeometries.getCompressionStats = function() {
        var stats = {
            compressed: 0,
            uncompressed: 0
        };

        for (var geometryId in HumanAssetsGeometries.geometries) {
            if (HumanAssetsGeometries.geometries.hasOwnProperty(geometryId)) {
                if (HumanAssetsGeometries.geometries[geometryId].compressed) {
                    stats.compressed++;
                } else {
                    stats.uncompressed++;
                }
            }
        }

        return stats;
    };

    /**
     * Destroys a geometries library
     * @param libraryId
     */
    HumanAssetsGeometries.destroyAsset = function (geometryId) {
        if (geometryId) {
            var geometry = HumanAssetsGeometries.geometries[geometryId];
            geometry.geometry.destroy();
            delete HumanAssetsGeometries.geometries[geometryId];
        } else {
            HumanAssetsGeometries.reset();
        }
    };

    /** Destroys all geometry libraries
     */
    HumanAssetsGeometries.reset = function () {
        for (var geometryId in HumanAssetsGeometries.geometries) {
            if (HumanAssetsGeometries.geometries.hasOwnProperty(geometryId)) {
                HumanAssetsGeometries.destroyAsset(geometryId);
            }
        }
    };

    // comprssed asset variables
    var positionScaleMat = mat4.create();
    var positionTranslateMat = mat4.create();
    var uvScaleMat = mat3.create();
    var uvTranslateMat = mat3.create();

    // create decode matrix for quantized geometry given the decode data
    function createPositionDecodeMatrix(cfg, elements){
        var positionTranslate = elements.subarray(0,3);
        var positionScale = elements.subarray(3,6);
        var positionDecodeMatrix = mat4.create();

        mat4.fromScaling(positionScaleMat, positionScale);
        mat4.fromTranslation(positionTranslateMat, positionTranslate);
        mat4.multiply(positionDecodeMatrix, positionTranslateMat, positionScaleMat);

        // assign to config
        cfg.positionTranslate = positionTranslate;
        cfg.positionScale = positionScale;
        cfg.geometry.positionDecodeMat = positionDecodeMatrix;
        return cfg;
    }

    // create decode uv matrix for quantized geometry given the decode data
    function createUvDecodeMatrix(cfg, elements, uvCount){
        cfg.geometry.uvDecodeMats = new Array(uvCount);
        cfg.uvTranslates = new Array(uvCount);
        cfg.uvScales = new Array(uvCount);

        for (var i = 0; i < uvCount; i++) {
            var _start = i * 4;
            var uvTranslate = cfg.uvTranslates[i] = elements.subarray(_start, _start + 2); //new Float32Array(asset, bytePos, 2);
            var uvScale = cfg.uvScales[i] = elements.subarray(_start + 2, _start + 4);   //new Float32Array(asset, bytePos + 8, 2);

            mat3.fromScaling(uvScaleMat, uvScale);
            mat3.fromTranslation(uvTranslateMat, uvTranslate);
            cfg.geometry.uvDecodeMats[i] = mat3.create();
            mat3.multiply(cfg.geometry.uvDecodeMats[i], uvTranslateMat, uvScaleMat);
        }
        return cfg;
    }

    // parse uncompressed geo asset and create the geometry
    function parseRawGeometry(asset, cfg, geometryId, ok) {
        /*
         Geometry format

         bytes   : info
         [0.. 3]: uint32; file type identifer (= 0x11)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph keys JSON
         [12..15]: uint32; byte-length of positions array
         [16..19]: uint32; byte-length of normals array
         [20..23]: uint32; byte-length of indices array
         [24..27]: uint32; byte-length of uv array
         [28..43]: unit32[4]; unused, reserved for future use
         [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
         [  ..  ]: text; morph key JSON (tail-padded with 0x20)
         [  ..  ]: float32[]; positions array
         [  ..  ]: float32[]; normals array
         [  ..  ]: int32[];   indices array
         [  ..  ]: float32[]; uv array
        */

        var index = new Uint32Array(asset, 0, 11);

        var assetIdSize = index[1];
        var keysSize = index[2];
        var positionsSize = index[3];
        var normalsSize = index[4];
        var indicesSize = index[5];
        var uvsSize = index[6];
        // var unused = index[7 ... 10];

        var assetIdStart = 11  * Uint32Array.BYTES_PER_ELEMENT;
        var keysStart = assetIdStart + assetIdSize;
        var positionsStart = keysStart + keysSize;
        var normalsStart = positionsStart + positionsSize;
        var indicesStart = normalsStart + normalsSize;
        var uvsStart = indicesStart + indicesSize;

        var numVertices = 0;

        if (positionsSize > 0) {
           cfg.geometry.positions = new Float32Array(asset, positionsStart, positionsSize / Float32Array.BYTES_PER_ELEMENT);
           cfg.boundary = getBoundary(cfg.geometry.positions);
           numVertices = cfg.geometry.positions.length / 3;
        }

        if (normalsSize > 0) {
           cfg.geometry.normals = new Float32Array(asset, normalsStart, normalsSize / Float32Array.BYTES_PER_ELEMENT);
        }

        if (uvsSize > 0) {
           cfg.geometry.uv = new Float32Array(asset, uvsStart, uvsSize / Float32Array.BYTES_PER_ELEMENT);
        }

        if (indicesSize > 0) {
           cfg.geometry.indices = new Uint32Array(asset, indicesStart, indicesSize / Uint32Array.BYTES_PER_ELEMENT);
           if (numVertices <= 256) {
               cfg.geometry.indices = new Uint8Array(cfg.geometry.indices);
           } else if (numVertices <= 65536) {
               cfg.geometry.indices = new Uint16Array(cfg.geometry.indices);
           }
        }

        ok(HumanAssetsGeometries.createGeometry(geometryId, cfg));
    }

    // parse compressed geo asset and create the geometry
    function parseCompressedGeometry(asset, cfg, geometryId, ok) {
        /*
        # HEADER
         [0.. 3]: uint32; file type identifier (= 0x12)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph JSON
        [12..15]: uint32; data segment offset (e.g. where DATA starts)
        [16..19]: uint32; indices offset
        [20..23]: uint32; byte-length of positions array
        [24..27]: uint32; byte-length of normals array
        [28..31]: uint32; byte-length of indices array
            [32]: uchar; byte-length of positions matrix elements (= 24)
            [33]: uchar; size (bytes) of indices type (e.g. 1, 2, 4)
            [34]: uchar; # of uv sets
            [35]: unused
        (36..39): uint32; byte-length of array for uv set 1
          ... repeat for uvs
        (  ..  ): uint32; byte-length of array for uv set n
            (  ): uchar; byte-length of uv set 1 matrix elements (= 16)
          ... repeat for uvs
            (  ): uchar; byte-length of uv set n matrix elements (= 16)
        (  ..  ): padding to align DATA to uint32; "unused" is obviated by data offset

        # DATA
        [  ..  ]: quad-char[]/text; asset id (tail-padded with empty spaces, e.g. 0x20)
        [  ..  ]: quad-char[]/text; morph JSON (tail-padded; includes extra info)
        [  ..  ]: float32[]; positions matrix elements
        (  ..  ): float32[]; uv set 1 matrix elements
          ... repeat for uvs
        (  ..  ): float32[]; uv set n matrix elements
        [  ..  ]: uint16[]; quantized positions array
        (  ..  ): uint16[]; quantized uv set 1 array
          ... repeat for uvs
        (  ..  ): uint16[]; quantized uv set n array
        (  ..  ): signed char[]; oct-encoded normals array
        (  ..  ): padding to align indices to uint32, which will work for all sizes
        (  ..  ): indices_t[]; indices array
        */

        var index = new DataView(asset);

        var assetIdSize = index.getUint32(4, true);
        var morphDataSize = index.getUint32(8, true);
        var dataOffset = index.getUint32(12, true);
        var indexOffset = index.getUint32(16, true);
        var positionsSize = index.getUint32(20, true);
        var normalsSize = index.getUint32(24, true);
        var indicesSize = index.getUint32(28, true);
        var positionDecodeSize = index.getUint16(32, true);
        var indexType = index.getUint8(34);
        var uvCount = index.getUint8(35);

        var uvIndex = new Array(uvCount);

        var bytePos, i;

        for (i = 0, bytePos = 36; i < uvCount; i++, bytePos += 6) {
            uvIndex[i] = {
                uvSize: index.getUint32(bytePos, true),
                uvDecodeSize: index.getUint16(bytePos + 4, true)
            };
        }

        // Start at position transform data
        bytePos = dataOffset + assetIdSize + morphDataSize;

        if (positionDecodeSize > 0) {
            createPositionDecodeMatrix(cfg, new Float32Array(asset, bytePos, positionDecodeSize / Float32Array.BYTES_PER_ELEMENT));
            bytePos += positionDecodeSize;
        }

        if (uvCount > 0) {
            createUvDecodeMatrix(cfg, new Float32Array(asset, bytePos, uvCount * 4), uvCount);
            bytePos += uvCount * 16;
        }

        if (positionsSize > 0) {
            cfg.geometry.positions = new Uint16Array(asset, bytePos, positionsSize / Uint16Array.BYTES_PER_ELEMENT);
            cfg.boundary = getBoundary(cfg.geometry.positions, cfg.positionScale, cfg.positionTranslate);

            bytePos += positionsSize;
        }

        if (uvCount > 0) {
            cfg.geometry.uvs = new Array(uvCount);

            for (i = 0; i < uvCount; i++) {
                cfg.geometry.uvs[i] = new Uint16Array(asset, bytePos, uvIndex[i].uvSize / Uint16Array.BYTES_PER_ELEMENT);
                bytePos += uvIndex[i].uvSize;
            }
        }

        if (normalsSize > 0) {
            cfg.geometry.normals = new Int8Array(asset, bytePos, normalsSize / Int8Array.BYTES_PER_ELEMENT);
            bytePos += normalsSize;
        }

        if (indicesSize > 0) {
            var IndexType = INDEX_TYPE_MAP[indexType];
            cfg.geometry.indices = new IndexType(asset, indexOffset, indicesSize / IndexType.BYTES_PER_ELEMENT);
        }

        ok(HumanAssetsGeometries.createGeometry(geometryId, cfg));
    }

    // parse draco-compressed geo asset (via worker) and create the geometry (on worker message callback)
    function parseCompressedDracoGeometry(asset, cfg, geometryId, ok) {
        /*
        # HEADER
         [0.. 3]: uint32; file type identifier (if draco, = 0x13)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph JSON
        [12..15]: uint32; data segment offset (e.g. where DATA starts)
        [16..19]: uint32; byte-length of the draco blob
        [20..21]: uint16; byte-length of positions matrix elements (= 24)
            [22]: uchar; # of uv sets
            [23]: uchar; uint32 padding
            (  ): uint16; byte-length of uv set 1 matrix elements (= 16)
          ... repeat for uvs
            (  ): uint16; byte-length of uv set n matrix elements (= 16)
        (  ..  ): padding to align DATA to uint32
        # DATA
        [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
        [  ..  ]: text; morph JSON (tail-padded; includes extra info)
        [  ..  ]: float32[]; positions matrix elements
        (  ..  ): float32[]; uv set 1 matrix elements
          ... repeat for uvs
        (  ..  ): float32[]; uv set n matrix elements
        [  ..  ]: uchar[]; draco blob byte array
        (  ..  ): padding for uint32 alignment
        */
        var index = new DataView(asset);
        var dataByteStart = index.getUint32(12, true); // little-endian
        var _idChunkLength = index.getUint32(4, true);
        var _morphChunkLength = index.getUint32(8, true);
        var _positionsDecodeLength = 24; // constant 24; 6 elements
        var _numUVs = index.getUint8(22, true);
        var _uvDecodeLength = 16 * _numUVs; // constant 16 for each uv-set: 4 elements

        // data starting byte index values;
        var idByteStart = dataByteStart;
        var morphByteStart = idByteStart + _idChunkLength;
        var positionsByteStart = morphByteStart + _morphChunkLength;
        var uvByteStart = positionsByteStart + _positionsDecodeLength;
        var dracoByteStart = uvByteStart + _numUVs * _uvDecodeLength;

        var dracoByteLength = index.getUint32(16, true);
        var dracoBuffer = new Int8Array(asset, dracoByteStart, dracoByteLength/Int8Array.BYTES_PER_ELEMENT);

        // Quantization Decode
        createPositionDecodeMatrix(cfg, new Float32Array(asset, positionsByteStart, _positionsDecodeLength / Float32Array.BYTES_PER_ELEMENT));
        if (_numUVs > 0 ){
            createUvDecodeMatrix(cfg, new Float32Array(asset, uvByteStart, _uvDecodeLength/Float32Array.BYTES_PER_ELEMENT), _numUVs);
        }
        dracoUnpackCallbacks[geometryId] = ok; // callback when worker is done.
        var currentidx = dracoWorkerIdx % dracoWorkerLimit;
        dracoWorkers[currentidx].postMessage([dracoBuffer, geometryId, cfg], [dracoBuffer.buffer]); // use transferable interface
        dracoWorkerIdx++;
    }

    // boundary variables
    var defaultTranslate = vec3.fromValues(0, 0, 0);
    var defaultScale = vec3.fromValues(1, 1, 1);
    // Get minimal boundary enclosing the given array
    function getBoundary(positions, scale, translate) {
        scale = scale || defaultScale;
        translate = translate || defaultTranslate;
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i] * scale[0] + translate[0];
            y = positions[i + 1] * scale[1] + translate[1];
            z = positions[i + 2] * scale[2] + translate[2];

            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    }

})();
;
/**
 * @namespace Material libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMaterials = Human.assets.materials = {};

    /** All materials
     */
    HumanAssetsMaterials.materials = {};

    // Holds all SceneJS nodes for materials
    var libRoot;

    var EMBEDDED = false;

    HumanAssetsMaterials.init = function () {
        // Scene graph now available
        libRoot = Human.renderer.getLibraryRoot().addNode({
            type:"library",
            data: "Materials library"
        });
    };

    HumanAssetsMaterials.parseAsset = function(materialId, asset, ok) {
        var parts = materialId.split("/");
        var libId = parts[1].split(".")[0];
        var directory = (typeof(window.localBaseDirectory) !== 'undefined') ? window.localBaseDirectory : '/';
        var imagePath = directory + "content/states/" + parts[0] + "/materials/" + libId + "/";
        HumanAssetsMaterials.createMaterial(materialId, parseManifest(asset, imagePath), ok);
    };

    /** Given a state ID and a relative material ID, attempts to find the material within the libraries
     * @param materialId Relative material ID, ie. not prefixed by libraryId
     */
    HumanAssetsMaterials.findMaterial = function (materialId) {
        var material = HumanAssetsMaterials.materials[materialId];

        if (material) {
            return material;
        } else {
            return null;
        }
    };

    /** Creates a material within an existing materials library
     * @param libraryId ID of library
     * @param materialId ID for new material, globally unique among materials in all libraries
     * @param params Material params - material, texture, flags
     */
    HumanAssetsMaterials.createMaterial = function (materialId, params, ok) {
        if (HumanAssetsMaterials.materials[materialId]) {
            Human.log.warn("Human.assets.materials.createMaterial", "Material already loaded: " + materialId);
            return;
        }

        var material = {
            type: "material",
            textureCompressionStats: {
                compressed: 0,
                uncompressed: 0
            },
            hasAlphaTexture: false,
            hasAlphaFresnel: false,
            partiallyOpaque: false
        };

        if (params.material) {
            material.material = libRoot.addNode({
                type: "material",
                workflow: params.material.workflow,
                baseColor: params.material.baseColor,
                specularColor: params.material.specularColor,
                emitColor: params.material.emitColor,
                shine: params.material.shine,
                alpha: params.material.alpha,
                emit: params.material.emit,
                metallic: params.material.metallic,
                roughness: params.material.roughness,
                specularf0: params.material.specularf0
            });

            material.glassFactor = params.material.glassFactor !== undefined && params.material.glassFactor !== null ? params.material.glassFactor : 1.0;
            material.murkiness = params.material.murkiness !== undefined && params.material.murkiness !== null ? params.material.murkiness : 1.0;

            // Fresnels

            var fresnel;
            var edge;
            var center;

            // Base color Fresnel

            if (params.material.baseFresnel) {

                fresnel = params.material.baseFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : {r: 1, g: 1, b: 1};
                center = fresnel.center !== undefined ? fresnel.center : {r: 0, g: 0, b: 0};

                material.fresnels.color = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "color",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center,
                    blendMode: fresnel.blendMode || "multiply"
                });
            }

            // Alpha Fresnel

            if (params.material.alphaFresnel) {

                fresnel = params.material.alphaFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : 0;
                center = fresnel.center !== undefined ? fresnel.center  : 1;

                material.fresnels.alpha = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "alpha",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    },
                    blendMode: fresnel.blendMode || "multiply"
                });

                material.hasAlphaFresnel = true;
            }

            if (params.material.transparencyFresnel){
                fresnel = params.material.transparencyFresnel;
                material.fresnels = material.fresnels || {};
                edge = fresnel.edge !== undefined ? fresnel.edge : 0;
                center = fresnel.center !== undefined ? fresnel.center  : 1;

                material.fresnels.transparency = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "transparency",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    },
                    blendMode: fresnel.blendMode || "multiply"
                });
                
                material.hasAlphaFresnel = true;
            }

            // Reflection Fresnel

            if (params.material.reflectionFresnel) {

                fresnel = params.material.reflectionFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : 1;
                center = fresnel.center !== undefined ? fresnel.center  : 0;

                material.fresnels.reflect = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "reflect",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    },
                    blendMode: fresnel.blendMode || "multiply"
                });
            }

            // Specular Fresnel

            if (params.material.specularFresnel) {

                fresnel = params.material.specularFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.specular = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "specular",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center,
                    blendMode: fresnel.blendMode || "multiply"
                });
            }

            // Emit Fresnel

            if (params.material.emitFresnel) {

                fresnel = params.material.emitFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.emit = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "emit",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center,
                    blendMode: fresnel.blendMode || "multiply"
                });
            }

        } else {
            material.glassFactor = 1.0;
            material.murkiness = 1.0;
        }

        if (params.reflection) { // Reflection asset
            material.reflection = libRoot.addNode({
                type: "cubemap",
                applyTo: "reflect",
                coreId: params.reflection.getCoreId() // Share core with reflection scene node
            });
        }

        if (params.lightmap) {
            material.lightmap = libRoot.addNode({
                type: "cubemap",
                applyTo: "light",
                coreId: params.lightmap.getCoreId()
            });
        }

        var depthMask;
        var layer;
        if (params.flags && params.flags.flags.skybox) {
            depthMask = false;
            layer = Number.MIN_SAFE_INTEGER;
        }

        if (params.flags) {
            material.flags = {
                // Object flags
                skybox: params.flags.flags.skybox,
                billboard: params.flags.flags.billboard,
                frontface: params.flags.flags.frontface,

                // Renderable flags
                backfaces: params.flags.flags.backfaces,
                addBlend: params.flags.flags.addBlend
            };

            material.partiallyOpaque = !!material.flags.partiallyOpaque;
        }

        var textures = params.texture ? params.texture.layers : [];

        Human.assets.textures.load(textures, function() {
            material.textures = new Array(textures.length);

            for (var i = 0, len = textures.length; i < len; ++i) {
                if (textures[i].compressedSrc) {
                    material.textureCompressionStats.compressed++;
                } else {
                    material.textureCompressionStats.uncompressed++;
                }

                if (textures[i].applyTo === "alpha" || textures[i].applyTo === "transparency") {
                    material.hasAlphaTexture = true;
                }

                material.textures[i] = libRoot.addNode(textures[i]);
            }

            HumanAssetsMaterials.materials[materialId] = material;

            ok(material);
        });
    };

    HumanAssetsMaterials.getTextureCompressionStats = function () {
        var stats = {
            compressed: 0,
            uncompressed: 0
        };

        for (var materialId in HumanAssetsMaterials.materials) {
            if (HumanAssetsMaterials.materials.hasOwnProperty(materialId)) {
                stats.compressed += HumanAssetsMaterials.materials[materialId].textureCompressionStats.compressed;
                stats.uncompressed += HumanAssetsMaterials.materials[materialId].textureCompressionStats.uncompressed;
            }
        }

        return stats;
    };

    /**
     * Destroys a materials library
     * @param libraryId
     */
    HumanAssetsMaterials.destroyAsset = function (materialId) {
        // Also check for "" libraries, otherwise will run into circular dependency with reset
        if (materialId) {
            var material = HumanAssetsMaterials.materials[materialId];

            for (var type in material) {
                if (material.hasOwnProperty(type) && typeof material[type].destroy === "function") {
                    material[type].destroy();
                }
            }

            delete HumanAssetsMaterials.materials[materialId];
        } else {
            HumanAssetsMaterials.reset();
        }
    };

    /** Destroys all material libraries
     */
    HumanAssetsMaterials.reset = function () {
        for (var materialId in HumanAssetsMaterials.materials) {
            if (HumanAssetsMaterials.materials.hasOwnProperty(materialId)) {
                HumanAssetsMaterials.destroyAsset(materialId);
            }
        }
    };

    function parseManifest(node, path, material) {
        material = material || {};
        var i, len;

        if (node.id) {
            node.id = null; // Don't let SceneJS create a node with this ID - would cause ID clash
        }
        switch (node.type) {
            case  "texture":
                var layer;
                for (i = 0, len = node.layers.length; i < len; i++) {
                    layer = node.layers[i];
                    layer.src = layer.uri || layer.src;
                    if (!EMBEDDED) {
                        layer.src = path + layer.src;
                    }

                    layer.preloadURI = layer.preloadURI || layer.preloadSrc;
                    if (layer.preloadURI) {
                        if (EMBEDDED) {
                            // (bas) these were changed to absolute uris
                            layer.preloadURI += "?v=" + Human.VERSION;
                        } else {
                            layer.preloadURI = path + layer.preloadURI + "?v=" + Human.VERSION;
                        }
                    }

                    // In SceneJS V3.0, texture blendMode has changed from "add" to "multiply".
                    // Some of our materials for texture have black base color, which worked fine with "add",
                    // but not with "multiply", so we'll default to "add" here.
                    layer.blendMode = layer.blendMode || "over";

                    if (layer.blendMode === "add") {
                        layer.blendMode = "over";
                    } else if (layer.blendMode === "forceAdd") {
                        layer.blendMode = "add";
                    }
                }
                if (material) {
                    material.texture = node;
                }
                break;

            case "material":
                if (material) {
                    material.material = node;
                    var reflectionId, lightmapId, reflections, assetId, reflection;
                    if (node.reflectionId) {
                        reflectionId = node.reflectionId;
                        reflections = Human.assets.reflections;
                        assetId = reflections.exportedReflectionIds[reflectionId];
                        // [GH] - look for a merged reflection ID (stateID + reflectionID)
                        if (!assetId) {
                            var bits = path.split("/");
                            if (bits.length > 3) {  
                                var state = bits[3];
                                reflectionId = state + "/" + reflectionId;
                                assetId = reflections.exportedReflectionIds[reflectionId];
                                if (!assetId) { 
                                    Human.log.error("Human.assets.materials.parseManifest", "Reflection not found: " + reflectionId);
                                }
                            }

                        }
                        if (assetId) {
                            reflection = Human.assets.reflections.reflections[assetId];
                            if (reflection) {
                                material.reflection = reflection.node;
                            } else {
                                Human.log.error("Human.assets.materials.parseManifest", "Reflection not found: " + reflectionId);
                            }
                        }
                    }
                    if (node.lightmapId) {
                        lightmapId = node.lightmapId;
                        reflections = Human.assets.reflections; // Lightmaps are also kept in Human.assets.reflections
                        assetId = reflections.exportedReflectionIds[lightmapId];
                        if (!assetId) {
                            Human.log.error("Human.assets.materials.parseManifest", "Lightmap not found: " + reflectionId);
                        } else {
                            reflection = Human.assets.reflections.reflections[assetId];
                            if (reflection) {
                                material.lightmap = reflection.node;
                            } else {
                                Human.log.error("Human.assets.materials.parseManifest", "Lightmap not found: " + reflectionId);
                            }
                        }
                    }
                }
                break;

            case "flags":
                if (material) {
                    material.flags = node;
                }
                break;
        }
        if (node.nodes) {
            for (i = 0, len = node.nodes.length; i < len; i++) {
                parseManifest(node.nodes[i], path, material);
            }
            node.nodes = null;
        }
        return material;
    }
})();
;/**
 * @namespace Morph libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMorphs = Human.assets.morphs = {};

    /** All morphs
     */
    HumanAssetsMorphs.morphs = {};


    // Holds all SceneJS nodes for morphs
    var libRoot;

    HumanAssetsMorphs.init = function () {
        // Scene graph now available
        libRoot = Human.renderer.getLibraryRoot().addNode({
            type: "library",
            data: "Morphs library"
        });
        
    };

    HumanAssetsMorphs.parseAsset = function(morphId, asset, ok) {

        var morph;

        var fileType = new Uint32Array(asset, 0, 1)[0];

        if (fileType === 0x11) {
            morph = parseRawMorph(asset);
        } else {
            morph = parseCompressedMorph(asset);
        }


        ok(
            Human.assets.morphs.createMorph(morphId, morph)
        );
    };

    /** Given a relative morph ID, attempts to find the morph within the libraries
     * @param morphId Relative morph ID, ie. not prefixed by libraryId
     */
    HumanAssetsMorphs.findMorph = function (morphId) {
        var morph = HumanAssetsMorphs.morphs[morphId];

        if (morph) {
            return morph;
        } else {
            return null;
        }
    };

    /** Creates a material within an existing morphs library
     * @param libraryId ID of library
     * @param morphId ID for new material, globally unique among morphs in all libraries
     * @param params Material params - material, texture, flags

     */

    HumanAssetsMorphs.createMorph = function (morphId, params) {

        var morph = HumanAssetsMorphs.morphs[morphId];

        if (morph) {
            Human.log.warn("Human.assets.morphs.createMorph", "Morph already loaded: " + morphId);
            return morph;
        }

        params.morphGeometry.type = "morphGeometry";
        var morphGeometry = libRoot.addNode(params.morphGeometry);
        var targets = morphGeometry.getTargets();
        var boundary = {
            xmin: Number.POSITIVE_INFINITY,
            ymin: Number.POSITIVE_INFINITY,
            zmin: Number.POSITIVE_INFINITY,
            xmax: Number.NEGATIVE_INFINITY,
            ymax: Number.NEGATIVE_INFINITY,
            zmax: Number.NEGATIVE_INFINITY
        };

        var position = vec3.create();
        var decompressPosition = Human.math.decompressPosition;

        for (var i = 0, len = targets.length; i < len; ++i) {
            var target = targets[i];
            var positions = target.positions;
            var decompress = target.positionDecodeMat;

            for (var j = 0, lenJ = positions.length; j < lenJ; j += 3) {
                position[0] = positions[j];
                position[1] = positions[j + 1];
                position[2] = positions[j + 2];

                if (decompress) {
                    decompressPosition(position, position, decompress);
                }

                if (position[0] < boundary.xmin) {
                    boundary.xmin = position[0];
                }

                if (position[0] > boundary.xmax) {
                    boundary.xmax = position[0];
                }

                if (position[1] < boundary.ymin) {
                    boundary.ymin = position[1];
                }

                if (position[1] > boundary.ymax) {
                    boundary.ymax = position[1];
                }

                if (position[2] < boundary.zmin) {
                    boundary.zmin = position[2];
                }

                if (position[2] > boundary.zmax) {
                    boundary.zmax = position[2];
                }
            }
        }

        morph = {
            type: "morph",
            morphGeometry: morphGeometry,
            boundary: boundary,
            center: [
                (boundary.xmax + boundary.xmin) * 0.5,
                (boundary.ymax + boundary.ymin) * 0.5,
                (boundary.zmax + boundary.zmin) * 0.5
            ],
            positionTranslates: params.positionTranslates,
            positionScales: params.positionScales
        };

        var animation = new Human.assets.morphs.Animation();
        var keys = params.morphGeometry.keys;

        animation.addMorph(keys[0], keys[keys.length - 1],
            function (factor) {
                morph.morphGeometry.setFactor(factor);
            });

        animation.calculateTimeFrame();

        Human.timeline.addAnimation(morphId, animation);

        var stateId = morphId.split("/")[0];
        var leaf = Human.timeline.leafTimelines[stateId] || new Human.timeline.LeafTimeline(stateId);

        leaf.addAnimation(morphId, animation); // add to leaf

        HumanAssetsMorphs.morphs[morphId] = morph;
        return morph;
    };

    /**
     * Destroys a morph library
     * @param libraryId
     */
    HumanAssetsMorphs.destroyAsset = function (morphId) {
        if (morphId) {
            var morph = HumanAssetsMorphs.morphs[morphId];
            if (!morph) {
                Human.log.warn("Human.assets.morphs.destroyMorph", "Morph not found: " + morphId);
                return;
            }
            morph.morphGeometry.destroy(); // Blow away scene subgraph

            delete HumanAssetsMorphs.morphs[morphId];
        } else {
            HumanAssetsMorphs.reset();
        }
    };

    /** Destroys all morph libraries
     */
    HumanAssetsMorphs.reset = function () {
        for (var morphId in HumanAssetsMorphs.morphs) {
            if (HumanAssetsMorphs.morphs.hasOwnProperty(morphId)) {
                HumanAssetsMorphs.destroyAsset(morphId);
            }
        }
    };

    function parseRawMorph(asset) {
        /*

         Morph format

         bytes   : info
         [0.. 3]: uint32; file type identifer (= 0x11)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph keys JSON
         [12..15]: uint32; byte-length of positions array
         [16..19]: uint32; byte-length of normals array
         [20..23]: uint32; byte-length of indices array
         [24..27]: uint32; byte-length of uv array
         [28..43]: unit32[4]; unused, reserved for future use
         [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
         [  ..  ]: text; morph key JSON (tail-padded with 0x20)
         [  ..  ]: float32[]; positions array
         [  ..  ]: float32[]; normals array
         [  ..  ]: int32[];   indices array
         [  ..  ]: float32[]; uv array
         */

        var morph = {
            morphGeometry: {}
        };

        var index = new Uint32Array(asset, 0, 11);

        // var unusedFileType = index[0];
        var assetIdSize = index[1];
        var keysSize = index[2];
        var positionsSize = index[3];
        var normalsSize = index[4];
        var indicesSize = index[5];
        var uvsSize = index[6];
        // var unused = index[7 ... 10];

        var assetIdStart = 11  * Uint32Array.BYTES_PER_ELEMENT;
        var keysStart = assetIdStart + assetIdSize;
        var positionsStart = keysStart + keysSize;
        var normalsStart = positionsStart + positionsSize;
        var indicesStart = normalsStart + normalsSize;
        var uvsStart = indicesStart + indicesSize;

        var keys = morph.morphGeometry.keys = Human.utils.atoj(asset, keysStart, keysSize);

        var numKeys = keys.length;

        var target;
        var targets = morph.morphGeometry.targets = [];

        var targetPositionsSize = positionsSize / numKeys;
        var targetPositionsLength = targetPositionsSize / Float32Array.BYTES_PER_ELEMENT;

        var targetNormalSize = normalsSize / numKeys;
        var targetNormalLength = targetNormalSize / Float32Array.BYTES_PER_ELEMENT;

        var targetUVsSize = uvsSize / numKeys;
        var targetUVsLength = uvsSize / Float32Array.BYTES_PER_ELEMENT;

        for (var i = 0; i < numKeys; i++) {

            target = {};

            if (positionsSize > 0) {
                target.positions = new Float32Array(asset, positionsStart + (i * targetPositionsSize), targetPositionsLength);
            }

            if (normalsSize > 0) {
                target.normals = new Float32Array(asset, normalsStart + (i * targetNormalSize), targetNormalLength);
            }

            if (uvsSize > 0) {
                target.uvs = new Float32Array(asset, uvsStart + (i * targetUVsSize), targetUVsLength);
            }

            targets.push(target);
        }

        return morph;
    }

    var positionScaleMat = mat4.create();
    var positionTranslateMat = mat4.create();

    function parseCompressedMorph(asset) {
        /*
        # HEADER
         [0.. 3]: uint32; file type identifier (= 0x12)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph JSON
        [12..15]: uint32; data segment offset (e.g. where DATA starts)
        [16..19]: uint32; indices offset
        [20..23]: uint32; byte-length of positions array
        [24..27]: uint32; byte-length of normals array
        [28..31]: uint32; byte-length of indices array
            [32]: uchar; byte-length of positions matrix elements (= 24)
            [33]: uchar; size (bytes) of indices type (e.g. 1, 2, 4)
            [34]: uchar; # of uv sets
            [35]: unused
        (36..39): uint32; byte-length of array for uv set 1
          ... repeat for uvs
        (  ..  ): uint32; byte-length of array for uv set n
            (  ): uchar; byte-length of uv set 1 matrix elements (= 16)
          ... repeat for uvs
            (  ): uchar; byte-length of uv set n matrix elements (= 16)
        (  ..  ): padding to align DATA to uint32; "unused" is obviated by data offset

        # DATA
        [  ..  ]: quad-char[]/text; asset id (tail-padded with empty spaces, e.g. 0x20)
        [  ..  ]: quad-char[]/text; morph JSON (tail-padded; includes extra info)
        [  ..  ]: float32[]; positions matrix elements
        (  ..  ): float32[]; uv set 1 matrix elements
          ... repeat for uvs
        (  ..  ): float32[]; uv set n matrix elements
        [  ..  ]: uint16[]; quantized positions array
        (  ..  ): uint16[]; quantized uv set 1 array
          ... repeat for uvs
        (  ..  ): uint16[]; quantized uv set n array
        (  ..  ): signed char[]; oct-encoded normals array
        (  ..  ): padding to align indices to uint32, which will work for all sizes
        (  ..  ): indices_t[]; indices array
        */

        var morph = {};

        var index = new DataView(asset);

        var assetIdSize = index.getUint32(4, true);
        var morphDataSize = index.getUint32(8, true);
        var dataOffset = index.getUint32(12, true);
        var positionsSize = index.getUint32(20, true);
        var normalsSize = index.getUint32(24, true);
        var positionDecodeSize = index.getUint16(32, true);
        var uvCount = index.getUint8(34);

        var uvIndex = new Array(uvCount);

        var bytePos, i;

        for (i = 0, bytePos = 36; i < uvCount; i++, bytePos += 5) {
            uvIndex[i] = {
                uvSize: index.getUint32(bytePos, true),
                uvDecodeSize: index.getUint8(bytePos + 4)
            };
        }

        // Start at position transform data
        bytePos = dataOffset + assetIdSize;

        morph.morphGeometry = Human.utils.atoj(asset, bytePos, morphDataSize);

        var keys = morph.morphGeometry.keys;
        var numKeys = keys.length;

        var targets = morph.morphGeometry.targets = new Array(numKeys);
        var target;

        for (i = 0; i < numKeys; i++) {
            targets[i] = {};
        }

        morph.positionTranslates = new Array(numKeys);
        morph.positionScales = new Array(numKeys);

        var targetPositionDecodeSize = positionDecodeSize / numKeys;

        var targetPositionsSize = positionsSize / numKeys;
        var targetPositionsLength = targetPositionsSize / Uint16Array.BYTES_PER_ELEMENT;

        var targetNormalSize = normalsSize / numKeys;
        var targetNormalLength = targetNormalSize / Int8Array.BYTES_PER_ELEMENT;

        bytePos += morphDataSize;

        if (positionDecodeSize > 0) {

            for (i = 0; i < numKeys; i++) {
                target = targets[i];

                var positionTranslate = morph.positionTranslates[i] = new Float32Array(asset, bytePos, 3);
                var positionScale = morph.positionScales[i] = new Float32Array(asset, bytePos + 12, 3);

                mat4.fromScaling(positionScaleMat, positionScale);
                mat4.fromTranslation(positionTranslateMat, positionTranslate);
                target.positionDecodeMat = mat4.create();

                mat4.multiply(target.positionDecodeMat, positionTranslateMat, positionScaleMat);

                bytePos += targetPositionDecodeSize;
            }
        }

        if (positionsSize > 0) {
            for (i = 0; i < numKeys; i++) {
                targets[i].positions = new Uint16Array(asset, bytePos + (i * targetPositionsSize), targetPositionsLength);
            }

            bytePos += positionsSize;
        }

        if (normalsSize > 0) {
            for (i = 0; i < numKeys; i++) {
                targets[i].normals = new Int8Array(asset, bytePos + (i * targetNormalSize), targetNormalLength);
            }
        }

        return morph;
    }

})();
;(function() {
    "use strict";

    /**
     * An animation comprised of a set of morphs, which may be installed into the {@link Human.timeline}.
     * Like all such animations, it has an {@link #update} method through which the timeline updates the
     * progress of the morphs. The morphs each contain a {@link SceneJS.MorphGeometry} and possibly
     * a {@link SceneJS.Geometry}, which are kept externally in a {@link Human.assets.morphs}.
     *
     * @class
     * @constructor
     * @private
     */
    Human.assets.morphs.Animation = function (cfg) {
        cfg = cfg || {};

        this.type = "morph-animation";
        this._loop = (cfg.loop !== false);
        this._morphList = [];
        this.timeline = cfg.timeline;
        this.firstTime = null;
        this.lastTime = null;
    };

    /**
     * Adds a morph to this animation
     * @param firstTime First time key
     * @param lastTime Last time key
     * @param update Callback to update the morph progress
     */
    Human.assets.morphs.Animation.prototype.addMorph = function (firstTime, lastTime, update) {
        this._morphList.push({ firstTime:firstTime, lastTime:lastTime, update:update  });
    };

    /**
     * Calculates time frame enclosing keys of all contained morphs
     * @return {*}
     */
    Human.assets.morphs.Animation.prototype.calculateTimeFrame = function () {
        var min = 1000000;
        var max = -1000000;
        var morph;
        var morphList = this._morphList;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = morphList[i];
            if (morph.firstTime < min) {
                min = morph.firstTime;
            }
            if (morph.lastTime > max) {
                max = morph.lastTime;
            }
        }

        this.firstTime = min;
        this.lastTime = max;
    };

    /**
     * Updates progress of morphs
     * @param ctx
     * @param time
     */
    Human.assets.morphs.Animation.prototype.update = function (ctx, time) {
        var morph;
        var time2;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = this._morphList[i];
            if (this._loop) {
                // Dont wrap when time is right on the last key
                time2 = (time === morph.lastTime) ? time : (morph.firstTime + time % (morph.lastTime - morph.firstTime));
            } else {
                if (time2 < morph.firstTime) {
                    time2 = morph.firstTime;
                }
                if (time2 > morph.lastTime) {
                    time2 = morph.lastTime;
                }
            }
            morph.update(time2);
        }
    };

    /**
     * Destroys this module
     */
    Human.assets.morphs.Animation.prototype.destroy = function () {
        this.destroyed = true;
    };
})();
;(function () {
    "use strict";

    /**
     * @namespace Loads and unloads lights to and from {@link Human.renderer.lights}.
     *
     * Loads lights in batches for models (states). When loading a batch, will immediately enable those lights, then
     * push a record of those lights onto a stack.
     *
     * After unloading a batch of lights for a model, will remove that batch from the stack, then
     * enable the batch (if any) that remains on the top of the stack.
     *
     * @private
     */
    var lightAssets = Human.assets.lights = {
        lightIds: {}
    };

    /**
     * Loads a library of light sources
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    lightAssets.parseLibrary = function (libId, manifest, params, ok) {

        var lightIds = lightAssets.lightIds[libId];

        if (lightIds) {
            // Should have hit cache at higher level
            Human.log.warn("Human.assets.lights.parseLibrary", "library already loaded");
            ok();
            return;
        }

        var lights = manifest.lights;

        if (!lights) {
            Human.log.error("Human.assets.lights.parseLibrary", "'lights' section expected in lights library");
            ok();
            return;
        }

        lightIds = lightAssets.lightIds[libId] = [];

        // Disable any lights already enabled
        Human.renderer.lights.clearEnabled(); 

        var light;
        var lightId;

        for (var i = 0, len = lights.length; i < len; i++) {

            light = lights[i];

            if (!light.lightId) {

                // Skip invalid light
                Human.log.error("Human.assets.lights.load", "'lightId' missing on light");
                ok();
                continue;
            }

            lightId = libId + "." + light.lightId;

            light.lightId = lightId;
            light.enabled = true;

            Human.renderer.lights.addLight(light);

            lightIds.push(lightId);
        }

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a lights library.
     *
     * @param libId ID of lights library to unload.
     */
    lightAssets.unloadLibrary = function (libId) {

        var lightIds = lightAssets.lightIds[libId];

        if (!lightIds) {
            Human.log.warn("Human.assets.lights.unloadLibrary", "library not loaded");
            return;
        }

        var i;
        var len;
        var lights = Human.renderer.lights;

        for (i = 0, len = lightIds.length; i < len; i++) {
            lights.removeLight(lightIds[i]);
        }

        delete lightAssets.lightIds[libId];
    };
})();
;(function() {
    "use strict";

    var tweenAssets = Human.assets.tweens = {};

    /**
     * Loads a tweens library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    tweenAssets.parseLibrary = function (libId, manifest, params, ok) {
        var tweenDefs = manifest.tweens || {};
        var tweenDef;
        var type;
        var tweenType;
        var controlType;
        var tokens;
        var control;
        var tween;
        var tweens = [];

        var modelId = libId.split("/")[0];
        var leaf;

        if (!Human.timeline.leafTimelines.hasOwnProperty(modelId)){
            leaf = new Human.timeline.LeafTimeline(modelId);
        }

        for (var tweenName in tweenDefs) {
            if (tweenDefs.hasOwnProperty(tweenName)) {

                tweenDef = tweenDefs[tweenName];

                // Validate tween data

                if (!tweenDef.keys) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'keys'");
                    continue;
                }

                if (!tweenDef.targets) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'targets'");
                    continue;
                }

                if (tweenDef.keys.length < 2 || tweenDef.targets.length < 2) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has insufficient keys or targets - minimum of two required");
                    continue;
                }

                if (tweenDef.keys.length !== tweenDef.targets.length) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has mismatching numbers of keys and targets");
                    continue;
                }

                tweenDef.options = Human.utils.applyIf(this.options, tweenDef.options || {});

                type = tweenDef.type;

                if (!type) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'type'");
                    continue;
                }

                tokens = type.split(":");

                tweenType = tokens[0];
                controlType = tokens[1];

                if (tweenType === "lerp") {
                    tweenType = "tween";
                }

                if (!tweenType || !controlType) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute invalid: 'type'");
                    continue;
                }

                // Create control strategy

                switch (controlType) {

                    // Tween attributes of a scene object

                    case "objectAttr":
                        control = new Human.timeline.ObjectControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId),
                            objectIds: tweenDef.objectIds,
                            id: tweenName
                        });
                        break;

                    // Tween attributes of a transform via a scene object

                    case "objectXForm":
                        control = new Human.timeline.ObjectTransformControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId),
                            initial: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a material

                    case "material":
                        control = new Human.timeline.MaterialControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId),
                            attributes: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a material's texture

                    case "texture":
                        control = new Human.timeline.TextureControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId),
                            targetLayer: tweenDef.targetLayer
                        });
                        break;

                    // Tween a frenel on a material

                    case "fresnel":
                        control = new Human.timeline.FresnelControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId),
                            fresnelType: tweenDef.fresnelType
                        });
                        break;

                    case "particleSystem":
                        control = new Human.timeline.ParticleSystemControl({
                            particleSystemId: tweenDef.particleSystemId
                        });
                        break;

                    case "particleComponent":
                        control = new Human.timeline.ParticleComponentControl({
                            particleSystemId: tweenDef.particleSystemId,
                            componentId: tweenDef.componentId
                        });
                        break;

                    // Tween camera

                    case "camera":
                        control = new Human.timeline.CameraControl();
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                // Create tween

                switch (tweenType) {

                    case "tween":
                        tween = new Human.timeline.Tween({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    case "switch":
                        tween = new Human.timeline.Switch({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                tweens.push(tween);
            }
        }

        if (tweens.length > 0) {

            // Create tween animation
            // Only if we have valid tweens

            var animation = new Human.timeline.TweenAnimation({
                tweens: tweens
            });

            // Add to timeline

            Human.timeline.addAnimation(libId, animation);
        }

        leaf = Human.timeline.leafTimelines[modelId];
        leaf.addAnimation(libId, Human.timeline.animations[libId]); // add to leaf

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a tweens library.
     *
     * @param libId ID of library to unload.
     */
    tweenAssets.unloadLibrary = function(libId) {
        var modelId = libId.split("/")[0];

        // Delete Tweens From Leaf Timelines
        Human.timeline.leafTimelines[modelId].unload("tweens");
    };

    /**
     * Converts an ID to an absolute ID if necessary.
     *
     * If the element ID has no "." then it is the relative ID of an element
     * within the given model. Otherwise, it will be the absolute ID of element
     * in another model.
     */
    function getAbsoluteID(modelId, elementId) {
        if (modelId && elementId) {
            return (elementId.indexOf(".") < 0) ? modelId + "-" + elementId : elementId;
        } else {
            return null;
        }
        
    }

})();
;/**
 * @namespace Reflection libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsReflections = Human.assets.reflections = {};

    // Array of reflection IDs for each library, used for unloading
    var libReflectionIds = {};

    /**
     * All reflections
     */
    HumanAssetsReflections.reflections = {};

    /**
     * Reflection IDs exported by #exportReflectionIds; a map of exported IDs to real asset IDs
     *
     * @type {{String:String}}
     * @deprecated
     */
    HumanAssetsReflections.exportedReflectionIds = {};

    // Holds all SceneJS nodes for reflections
    var libRoot;

    HumanAssetsReflections.init = function () {
        // Scene graph now available
        libRoot = Human.renderer.getLibraryRoot().addNode({
            type: "library",
            data: "Reflections library" // For debugging
        });
    };

    /**
     * Loads a reflections library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    HumanAssetsReflections.parseLibrary = function (libId, manifest, params, ok) {

        var reflectionIds = libReflectionIds[libId];

        if (reflectionIds) {

            // Should have hit cache at higher level
            Human.log.warn("Human.assets.reflections.parseLibrary", "library already loaded");

            ok();
            return;
        }

        reflectionIds = [];
        libReflectionIds[libId] = reflectionIds;

        var parts = libId.split("/");
        var imagePath = window.localBaseDirectory + "content/states/" + parts[0] + "/reflections/" + parts[1] + "/";
        var reflectionParams;
        var srcList;
        var reflectionId;
        var reflection;

        var graph = Human.renderer.graph;

        for (var key in manifest) {
            if (manifest.hasOwnProperty(key)) {

                reflectionParams = manifest[key];

                reflectionParams.type = "reflect";
                reflectionParams.blendMode = reflectionParams.blendMode || "add";

                srcList = reflectionParams.src;

                if (!srcList) {
                    Human.log.error("Human.assets.reflections.loader", "Reflection property missing: src");
                    continue;
                }

                if (!Human.utils.isArray(srcList)) {
                    Human.log.error("Human.assets.reflections.loader", "Reflection property should be array: src");
                    continue;
                }

                for (var i = 0, len = srcList.length; i < len; i++) {
                    srcList[i] = imagePath + srcList[i] + "?v=" + Human.VERSION;
                }

                reflectionId = libId + "." + key;

                reflection = {
                    applyTo: reflectionParams.applyTo || "reflect",
                    node: graph.insertNode(Human.renderer.getLibraryRoot(), reflectionParams) // For non-PBR, deprecated
                };

                HumanAssetsReflections.reflections[reflectionId] = reflection;

                if (reflection.applyTo === "reflect") {
                    Human.renderer.getScene().createReflection(reflectionId, { // For PBR, in future also for non-PBR
                        src: reflectionParams.src,
                        intensity: reflectionParams.intensity,
                        space: reflectionParams.space || "world"
                    });
                } else {
                    Human.renderer.getScene().createLightmap(reflectionId, { // For PBR, in future also for non-PBR
                        src: reflectionParams.src,
                        intensity: reflectionParams.intensity,
                        space: reflectionParams.space || "world"
                    });
                }

                reflectionIds.push(reflectionId);
            }
        }

        // Subsequently-loaded materials will need our reflections to exist, so render a frame
        // to force the creation of the reflections' nodes in the scene graph
        Human.renderer.compile();

        if (ok) {
            ok();
        }
    };

    /** Only once reflections are activated and mapped to names can they be used
     * <p>Enable materials to use a particular reflection when they have a "reflectionId" set to "myReflection":</p>
     * <pre>
     *     #exportReflections({
     *          "myReflection" : "someState.someReflectionLib.someReflectionId"
     *          });
     * </pre>
     *
     * @param mapping
     */
    HumanAssetsReflections.exportReflections = function (mapping) {
        mapping = mapping || {};

        for (var key in mapping) {
            if (mapping.hasOwnProperty(key)) {
                var value = mapping[key];
                if (value.indexOf("/") === -1) {
                    mapping[key] = value.replace(/^([^\.]+)\./, "$1/");
                }
            }
        }

        HumanAssetsReflections.exportedReflectionIds = mapping || {};
    };

    /**
     * Unloads a reflections library.
     *
     * @param libId ID of reflections library to unload.
     */
    HumanAssetsReflections.unloadLibrary = function (libId) {

        var reflectionIds = libReflectionIds[libId];

        if (!reflectionIds) {
            Human.log.warn("Human.assets.reflections.unloadLibrary", "library not loaded");
            return;
        }

        var i;
        var len;
        var reflectionId;
        var reflection;

        for (i = 0, len = reflectionIds.length; i < len; i++) {
            reflectionId = reflectionIds[i];
            reflection = HumanAssetsReflections.reflections[reflectionId];
            reflection.node.destroy();

            if (reflection.applyTo === "reflect") {
                Human.renderer.getScene().destroyReflection(reflectionId);
            } else {
                Human.renderer.getScene().destroyLightmap(reflectionId);
            }
        }

        HumanAssetsReflections.exportedReflectionIds = {};
        delete libReflectionIds[libId];
    };
})();
;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads audio to and from {@link Human.media.audio}.
     *
     * @private
     */
    var audioAssets = Human.assets.audio = {};

    /**
     * Loads an audio clips library
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    audioAssets.parseLibrary = function (libId, manifest, params, ok) {
        Human.media.audio.createLibrary(libId, manifest);
        if (ok) {
            ok();
        }
    };

    /**
     * Unloads an audio clips library
     * @param libId Library ID
     */
    audioAssets.unloadLibrary = function (libId) {
        Human.media.audio.destroyLibrary(libId);
    };

})();
;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads video to and from {@link Human.media.video}.
     *
     * @private
     */
    var videoAssets = Human.assets.video = {};

    /**
     * Loads a video clips library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    videoAssets.parseLibrary = function (libId, manifest, params, ok) {
        Human.media.videos.createLibrary(libId, manifest);
        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a video clips library
     * @param libId Library ID
     */
    videoAssets.unloadLibrary = function (libId) {
        Human.media.videos.destroyLibrary(libId);
    };

})();
;/**
 @namespace Captures and restores engine state to and from JSON bookmark objects.

 */
(function () {
    "use strict";

    var HumanBookmarks = Human.bookmarks = {};
    var _HACK_TITLE, _HACK_DESCRIPTION; // Helpful for temporarily inserting bookmark data into chapters.

    /**
     * Captures the current engine state to a JSON bookmark object
     * <h4>Examples</h4>
     * <p>Capture everything:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture();
     * </pre>
     * <p>Capture just camera and view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         camera: true,
     *         view: true
     *     });
     * </pre>
     * <p>Capture everything but view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         view: false
     *     });
     * </pre>
     * @memberof Human.bookmarks
     * @param {{String: Boolean}} mask Mask which specifies what to capture in the bookmark
     * @param {Boolean} mask.modules Capture what modules are loaded?
     * @param {Boolean} mask.camera Capture camera state?
     * @param {Boolean} mask.modes Capture view modes?
     * @param {Boolean} mask.objects Capture scene object states?
     * @param {Boolean} mask.annotations Capture annotations?
     * @returns {{}} The JSON bookmark object
     */
    HumanBookmarks.capture = function (mask) {
        var bm = {
            engineVersion: Human.VERSION
        };
        if (masked(mask, "modules")) {
            bm.modules = {
                moduleLibs: captureModuleLibs(),
                activeModules: captureActiveModules()
            };
        }
        if (masked(mask, "camera")) {
            bm.camera = captureCamera();
        }
        if (masked(mask, "clips")) {
            bm.clips = captureCrossSections();
        }
        if (masked(mask, "objects")) {
            bm.objects = captureObjectStates();
        }

        if (masked(mask, "timeline")) {
            bm.timeline = Human.timeline.getBookmark();
        }

        if (masked(mask, "background")) {
            bm.background = {
                colors: Human.renderer.bg.getBGColor()
            };
        }

        // Plugins are free to read and write state anywhere in a bookmark, but we'll
        // define a convenient namespace as a convention that they may opt to stay within.
        bm.plugins = {};

        var plugins = Human.plugins;
        var plugin;
        for (var id in plugins) {
            if (plugins.hasOwnProperty(id)) {
                plugin = plugins[id];
                if (plugin.writeBookmark) {
                    plugin.writeBookmark(bm);
                }
            }
        }

        Human.events.fire("bookmarks.capture", {
          bookmark: bm
        });

        return bm;
    };

    function masked(mask, key) {
        if (!mask) {
            return true;
        }
        if (mask[key] === true) {
            return true;
        }
        if (mask[key] === false) {
            return false;
        }
        return false;
    }

    /**
     * Bookmarks which module libraries are currently loaded
     */
    function captureModuleLibs() {
        var obj = Human.modules.moduleLibs;
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    }

    /**
     * Bookmarks which modules are currently active
     */
    function captureActiveModules() {
        var modules = [];
        if (Human.modules.numActiveModules > 0) {
            var activeModules = Human.modules.activeModules;
            for (var moduleId in activeModules) {
                if (activeModules.hasOwnProperty(moduleId)) {
                    modules.push(moduleId);
                }
            }
        }
        return modules;
    }

    /**
     * Bookmarks current state of the camera
     * @return {Object}
     */
    function captureCamera() {
        return Human.renderer.camera.getLookAt();
    }

    /**
     * Bookmarks current state of cross-section planes
     * @return {Object} Map containing state of each clip plane, mapped to the plane IDs
     */
    function captureCrossSections() {
        return Human.renderer.clip.serialize();
    }

    /**
     * Bookmarks current visibility, selection and transparency states of scene objects
     * @return {Object} Map containing set of flags for each object
     */
    function captureObjectStates() {
        var map = {};
        var anatomy = Human.scene;
        var objects = anatomy.objects;
        var object, transform;
        var enabledObjects = anatomy.enabledObjects;
        
        var mapData;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                mapData = null;

                // Only capture enabled leaf objects
                if (object.objects.length === 0 && enabledObjects[objectId]) {
                    mapData = mapData || {};

                    mapData.enabled = true;

                    transform = captureTransformData(object);
                    if (transform) {
                        mapData.transform = transform;
                    }
                    mapData.opacity = object.opacity;
                }
                if (mapData) {
                    map[objectId] = mapData;
                }
            }
        }

        for (var idx = 0; idx < Human.scene.rootObjects.length; idx++) {
          object = Human.scene.rootObjects[idx];
          objectId = object.objectId;
          if (!object.shown){
            // make sure these never get turned on, during restore
            map[objectId] = {
              enabled: object.shown,
              opacity: object.opacity
            };
          }

        }

        Human.events.fire("bookmarks.captureObjectStates", {
          data: map
        });

        return map;
    }

    function captureTransformData(object) {
        if (object.pivot === null) {
            // Object transform not initialized
            return null;
        }

        var mapTransform = {};

        if (object.pivot.x !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.x = object.pivot.x;
        }
        if (object.pivot.y !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.y = object.pivot.y;
        }
        if (object.pivot.z !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.z = object.pivot.z;
        }

        if (object.translate.x !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.x = object.translate.x;
        }
        if (object.translate.y !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.y = object.translate.y;
        }
        if (object.translate.z !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.z = object.translate.z;
        }

        if (object.scale.x !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.x = object.scale.x;
        }
        if (object.scale.y !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.y = object.scale.y;
        }
        if (object.scale.z !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.z = object.scale.z;
        }

        if (object.rotate.x !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.x = object.rotate.x;
        }
        if (object.rotate.y !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.y = object.rotate.y;
        }
        if (object.rotate.z !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.z = object.rotate.z;
        }

        if (Object.keys(mapTransform).length > 0) {
            return mapTransform;
        } else {
            return null;
        }
    }

    /* Returns the objects from a module to restore during bookmark activation
    * object id must be shown or enabled in bookmark
    * normalized objectId must exist in Human.scene.objects
    */
    function _buildAssetObjects(bookmark){
      var loadObjects = [];
      var seen = {};
      var sync = bookmark.objects;
      var objId;

      for (objId in sync) {
        if (!sync[objId].shown && !sync[objId].enabled) {
          continue;
        }
        var objectId = Human.modules.convertBaseAnatomyObjectId(objId);
        if (seen[objectId]) {
            continue;
        }
        seen[objectId] = true;
        var object = Human.scene.objects[objectId];

        if (!object) {
            objectId = Human.modules.convertBaseAnatomyObjectId(normalizeAnonymousObject(objId));
            if (seen[objectId]) {
                continue;
            }
            seen[objectId] = true;
            object = Human.scene.objects[objectId];
        }
        
        if (object && object.isLeaf()) {
            loadObjects.push(object);
        }
      }

      return loadObjects;
    }

    function trimUntargetedChapters(moduleId, bookmark){
      var time = 0;
      var root = Human.timeline.rootTimelines[moduleId];
      if (bookmark.timeline) {
        if (bookmark.timeline.hasOwnProperty("scrub")) {
          try {
            time = bookmark.timeline.scrub.time;
          } catch(err) {
            time = 0;
          }

        } else if (bookmark.timeline.hasOwnProperty("play")) {
          var pi = bookmark.timeline.play;
          // pi.root = root;
          try {
            time = Human.timeline.parsePlayInstruction(pi).t;
          } catch(err){
            time = 0;
          }

        }
      }

      var chapterIndex = root.mapGlobalTime(time).index;

      //root._chapters = [Human.modules.modules[moduleId].chapters[chapterIndex]];
      root._chapters = [root._chapters[chapterIndex]];
      root.build();
    }

    function _bookmarkModuleActivationCallback(bookmark, moduleId, ok) {
      // now show the results of the changes

      //overwrite graph
      restoreGraph(bookmark.objects);

      // set modes
      restoreModes(bookmark.modes);


      // overwrite camera
      restoreCamera(bookmark.camera, function() {});

      Human.renderer.resumeCompilation();
      Human.renderer.popPause();

      if (!moduleId || moduleId === undefined) {
          if (ok) {
              ok();
          }
          return;
      }

      var loadObjects = _buildAssetObjects(bookmark);
      var assetTypes = ["tweens", "reflections", "audio", "videos", "lights", "skyBoxes", "geometry", "material", "transform", "morph"];
      Human.modules.load(moduleId, loadObjects, assetTypes, function(){
          //overwrite transforms
          restoreObjectTransforms(bookmark.objects);

          // set clipping planes
          restoreCrossSections(bookmark.clips);

          playTimeline(bookmark);
          Human.events.fire("bookmarks.restored", bookmark);
          if(ok) {
              ok();
          }
      });

    }

    function swapInfoInTarget(bookmark, moduleId) {
        // assumes module with moduleId has been turned into root timeline.
        var root = Human.timeline.rootTimelines[moduleId];
        root._chapters[0].info.displayName = bookmark.title;
        root._chapters[0].info.description = bookmark.description;
        var oldTitle = Human.modules.modules[moduleId].displayName;
        var oldDescription = Human.modules.modules[moduleId].description;
        var oldAnnotations = Human.utils.shallowClone(root._chapters[0].annotations);
        root._chapters[0].annotations = bookmark.annotations;
        Human.modules.modules[moduleId].displayName = bookmark.title; // HACK: for the ui panel viewer
        Human.modules.modules[moduleId].description = bookmark.description; // HACK: for the ui panel viewer
        Human.modules.modules[moduleId].chapters[0].displayName = bookmark.title;
        Human.modules.modules[moduleId].chapters[0].description = bookmark.description;

        return {title: oldTitle, description: oldDescription, annotations: oldAnnotations};
    }

    HumanBookmarks.restore = function(bookmark, ok) {
        Human.events.fire("bookmarks.restoring");

        // We have an oldie
        if(!Human.utils.isObject(bookmark.modules)) {
            normalizeLegacy(bookmark);
        }

        // HACK: Client Side data migration of bookmarks.
        // Old bookmarks referencing states (maleAdult) that newer engines don't understand.
        var activeModules = bookmark.modules.activeModules;
        var multipleModules = activeModules.length > 1;
        var activeModulesClone = [];

        for (var i = 0, len = activeModules.length; i < len; i++) {
          activeModulesClone[i] = Human.modules.convertBaseAnatomyModuleId(activeModules[i]);
        }

        Human.utils.filterInPlace(activeModulesClone, function(moduleId) {
            if (Human.modules.activeModules[moduleId]) {
                return false;
            }

            if (multipleModules && Human.modules.isBaseModule(moduleId)) {
                return false;
            }

            return true;
        });

        // Custom Loading Options
        var moduleId = activeModulesClone[0];
        var modConfig = {
            camera: true,
            graph: true,
            annotations: true,
            properties: true,
            time: true,
            hotspots: true
        };

        bookmark.theModuleId = moduleId;

        // Load Module Life Cycle
        Human.renderer.pushPause();
        Human.renderer.pauseCompilation();

        if (!moduleId){ // Scene Restore

          _bookmarkModuleActivationCallback(bookmark, moduleId, ok);

        } else if (Human.modules.modules.hasOwnProperty(moduleId)){
          var moduleData = Human.modules.moduleData[moduleId];
          Human.modules.create(moduleId, moduleData, function(){
            trimUntargetedChapters(moduleId, bookmark);
            //HACK: TEMPORARILY REPLACE MODULE AND ROOT DATA: HACK FOR INFO PANEL IN FLAGSHIP APP
            var oldInfo = swapInfoInTarget(bookmark, moduleId);
            _HACK_TITLE = oldInfo.title;
            _HACK_DESCRIPTION = oldInfo.description;
            Human.modules.activate(moduleId, 0, modConfig, function(){
                _bookmarkModuleActivationCallback(bookmark, moduleId, ok);
            });
          });
        } else {
          Human.modules.fetch(moduleId, function() {
              var moduleData = Human.modules.moduleData[moduleId];
              Human.modules.create(moduleId, moduleData, function() {
                  trimUntargetedChapters(moduleId, bookmark);
                  //HACK: TEMPORARILY REPLACE MODULE AND ROOT DATA: HACK FOR INFO PANEL IN FLAGSHIP APP
                  var oldInfo = swapInfoInTarget(bookmark, moduleId);
                  _HACK_TITLE = oldInfo.title;
                  _HACK_DESCRIPTION = oldInfo.description;
                  Human.modules.activate(moduleId, 0, modConfig, function() {
                    _bookmarkModuleActivationCallback(bookmark, moduleId, ok);
                });
              });
          });
        }
    };


    //////////////////////////////////////////////////////
    // HANDLE LEGACY BOOKMARKS
    //////////////////////////////////////////////////////

    function normalizeAnonymousObject(objectId){
        // anonymous objects inherit their first named ancestor's ID with padded integers e.g. Group_ID01
        return objectId.replace(/_ID[0-9]+$/,"_ID");
    }

    // Some Normalization of the synchronization data
    function normalizeSynchronization(bookmarkObjects){
        var objectId, normalizedObjectId;
        var synchronization = {};
        var bookmarkDef, anonymousLeaves, i;

        // start with assuming all are false
        for (objectId in Human.scene.objects) {
          if (Human.scene.objects[objectId] && !Human.scene.objects[objectId].anonymous) {
            synchronization[objectId] = {shown:false};
          }
        }

        for (objectId in bookmarkObjects){
            if (bookmarkObjects.hasOwnProperty(objectId)){
                bookmarkDef = bookmarkObjects[objectId];
                normalizedObjectId = Human.modules.convertBaseAnatomyObjectId(objectId);
                normalizedObjectId = normalizeAnonymousObject(normalizedObjectId);
                var object = Human.scene.objects[normalizedObjectId];

                if (object) {
                    if (bookmarkDef.hasOwnProperty("enabled")){
                        bookmarkDef.shown = bookmarkDef.enabled;
                        delete bookmarkDef.enabled;
                    }

                    if (!bookmarkDef.hasOwnProperty("pickable")) {
                        bookmarkDef.pickable = object.pickable;
                    }

                    if (!bookmarkDef.hasOwnProperty("backfaces")) {
                        bookmarkDef.backfaces = object.backfaces;
                    }

                    if (!bookmarkDef.hasOwnProperty("opacity")) {
                        bookmarkDef.opacity = object.opacity;
                    }

                    bookmarkDef.glassFactor = object.glassFactor;
                    bookmarkDef.murkiness = object.murkiness;

                    synchronization[normalizedObjectId] = bookmarkDef;
                }

                // anonymous objects need to be forcibly added.
                if (objectId.match("_ID[0-9]+$")){
                    anonymousLeaves = Human.scene.getLeaves(normalizedObjectId);
                    for (i = 0; i < anonymousLeaves.length; i++){
                        if (Human.scene.objects[anonymousLeaves[i]].anonymous) {
                            if (!bookmarkObjects[anonymousLeaves[i]]) {
                              bookmarkObjects[anonymousLeaves[i]] = { shown : bookmarkDef.shown };
                            } else {
                              bookmarkObjects[anonymousLeaves[i]].shown = bookmarkDef.shown;
                            }
                        }
                    }
                }
            }
        }

        return synchronization;
    }

    function normalizeLegacy(bookmark) {
        bookmark.modules = {};
        bookmark.modules.activeModules = [];
        bookmark.modules.moduleLibs = [];

        if(!Human.utils.isObject(bookmark.objects)) {
            bookmark.objects = {};
        }

        var genderModuleId = getGenderModule(bookmark.objects);

        if(genderModuleId) {
            bookmark.modules.activeModules.unshift(genderModuleId);
        }
    }

    function getGenderModule(objects) {
        var genderModuleId = null;
        var match;

        for (var id in objects) {
            if(objects.hasOwnProperty(id)) {
                match = id.match(/^(fe)?maleAdult/);
                if(match) {
                    genderModuleId = ['production', match[0], match[0] + '.json']
                    .join('/');

                    break;
                }
            }
        }

        return genderModuleId;
    }

    // ================== RESTORE FUNCTIONS =====================================
    function playTimeline(bookmark) {
        if (!bookmark.timeline) {
            Human.timeline.scrub({time:0.0});
            return;
        }
        if (bookmark.timeline.scrub) {
            Human.timeline.scrub(bookmark.timeline.scrub);
        } else if (bookmark.timeline.play) {
            Human.timeline.play(bookmark.timeline.play);
        }
    }

    /**
     * Loads camera position as given in bookmark
     * @param camera
     */
    function restoreCamera(camera, ok) {
        Human.renderer.camera.fly.flyTo(camera, function(){
            if (ok){
                ok();
            }
        });
    }

    /**
     * Loads viewing modes as given in bookmark
     * @param modes Flag for each view mode, indicating enable or disable
     */
    function restoreModes(modes) {
        if (!modes) {
          return;
        }

        if (modes.highlight !== undefined && modes.highlight !== null) {
            Human.rpc.call(null, "highlight.setEnabled", { enable: modes.highlight });
        }
        // Only enable isolate if objects are selected
        if (Human.scene.anySelected() && modes.isolate) {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: modes.isolate  });
            }
        } else {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: false  });
            }
        }
        if (modes.labels !== undefined && modes.labels !== null) {
            Human.rpc.call(null, "labels.setEnabled", { enable: modes.labels });
        }
        if (modes.singlePick !== undefined && modes.singlePick !== null) {
            Human.rpc.call(null, "pick.single.setEnabled", { enable: modes.singlePick });
        }
        if (modes.multiPick !== undefined && modes.multiPick !== null) {
            Human.rpc.call(null, "pick.multi.setEnabled", { enable: modes.multiPick });
        }

        if (modes.xray !== undefined && modes.xray !== null) {
            Human.rpc.call(null, "xray.setEnabled", { enable: modes.xray });
        }
    }

    /**
     * Restore the state of the current scene graph against the passed synchronization object.
     * @param synchronization Object of objectIds and their non-default states
     */
    function restoreGraph(synchronization){
        //Human.scene.setEnabledObjects({ objectIds: {}, replace: true });
        synchronization = normalizeSynchronization(synchronization);
        Human.scene.setObjectProperties(synchronization);

    }

    /**
     * Loads cross-section clip plane states as given in bookmark
     * @param clips Clip plane states, mapped to IDs of the planes
     */
    function restoreCrossSections(clips) {
        Human.renderer.clip.reset();
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                var clip = clips[clipId];

                // Normalize from older format
                if (clip.state !== undefined) {
                    if (clip.state === "clipping" || clip.state === 3 || clip.state === "visible" || clip.state === 4) {
                        clip.enabled = true;
                    }

                    if (typeof clip.clipId === "number") {
                        clip.clipId--;
                    }

                }

                Human.renderer.clip.setClip(clips[clipId]);
            }
        }
    }

    /** Overwrites the transform position of objects in scene.
     *
     */
    function restoreObjectTransforms(objectData) {
        objectData = objectData || {};
        var object, objectId, transform;

        for (objectId in objectData) {
            if (objectData.hasOwnProperty(objectId)) {
                object = Human.scene.objects[objectId];
                transform = objectData[objectId].transform;
                if (object && transform) {
                    object.setTransform(restoreTransform(object, transform));
                }
            }
        }
    }

    function restoreTransform(object, transform) {
        var objectPivot = object.pivot || { x: 0, y: 0, z: 0 };
        var objectTranslate = object.translate || { x: 0, y: 0, z: 0 };
        var objectScale = object.scale || { x: 1, y: 1, z: 1 };
        var objectRotate = object.rotate || { x: 0, y: 0, z: 0 };

        transform.pivot = transform.pivot || {};
        transform.translate = transform.translate || {};
        transform.scale = transform.scale || {};
        transform.rotate = transform.rotate || {};

        transform.pivot.x = transform.pivot.x === undefined ? objectPivot.x : transform.pivot.x;
        transform.pivot.y = transform.pivot.y === undefined ? objectPivot.y : transform.pivot.y;
        transform.pivot.z = transform.pivot.z === undefined ? objectPivot.z : transform.pivot.z;

        transform.translate.x = transform.translate.x === undefined ? objectTranslate.x : transform.translate.x;
        transform.translate.y = transform.translate.y === undefined ? objectTranslate.y : transform.translate.y;
        transform.translate.z = transform.translate.z === undefined ? objectTranslate.z : transform.translate.z;

        transform.scale.x = transform.scale.x === undefined ? objectScale.x : transform.scale.x;
        transform.scale.y = transform.scale.y === undefined ? objectScale.y : transform.scale.y;
        transform.scale.z = transform.scale.z === undefined ? objectScale.z : transform.scale.z;

        transform.rotate.x = transform.rotate.x === undefined ? objectRotate.x : transform.rotate.x;
        transform.rotate.y = transform.rotate.y === undefined ? objectRotate.y : transform.rotate.y;
        transform.rotate.z = transform.rotate.z === undefined ? objectRotate.z : transform.rotate.z;

        return transform;
    }


})();
;/**
 @namespace Handles module creation, activation, deactivation, destruction and query.

 <p>Modules are the engine's abstract unit of content. These are extensible and can be all sorts things, such as anatomies,
 disease conditions, guided tours, bookmarks, medline conditions etc.</p>
 */
(function () {
    "use strict";

    var MAX_HISTORY = 5;

    var HumanModules = Human.modules = {};

    // =========== MODULE MANAGEMENT =========================================

    // Module IDs are internally generated from this pool
    var idPool = new Human.utils.IDPool();

    // Existing and Active modules
    HumanModules.modules = {};
    HumanModules.moduleData = {}; // stores module definitions
    HumanModules.moduleLibs = {};
    HumanModules.activeModules = {};
    HumanModules.numActiveModules = 0;
    HumanModules.history = [];

    // ========= MODULE LIFE CYCLE MANAGEMENT  ================================

    /* Get Module Data from the asset server
     * "ok" and "error" are callbacks
     */
    HumanModules.fetch = function(moduleId, ok, error){
        Human.events.fire("modules.fetch.start", {moduleId: moduleId});
        Human.assets.server.getModuleDefinition(moduleId, function (moduleData) {
                // Attach id to module data
                moduleData.moduleId = moduleId;
                HumanModules.moduleData[moduleId] = moduleData; // you can count on this being pure
                Human.events.fire("modules.fetch.finish", {moduleId: moduleId, moduleData:moduleData});
                if (ok){
                    ok();
                }
            }, function(e){
                Human.log.info("Human.modules.activateModules", "Failed to activate module: '" + moduleId + "' - " + e);
                if (error) {
                    error(e);
                }
        });
    };


    /* Create the Module Object from the module data
     * "ok" is a callback function that accepts two parameters:
     *      1) moduleId
     *      2) Human Module (Human Object)
     */
    HumanModules.create = function(moduleId, moduleData, ok){
        moduleData = Human.utils.deepClone(moduleData);
        Human.events.fire("modules.create.start", {moduleId:moduleId, moduleData:moduleData});

        if (HumanModules.modules[moduleId]){
            delete HumanModules.modules[moduleId];
        }
        // Create the Human Module Object
        var module = new HumanModules.Module(moduleData);
        var _ok = function() {
            HumanModules.modules[moduleId] = module;
            Human.events.fire("modules.created", moduleData);
            Human.events.fire("modules.create.finish", {moduleId:moduleId, module:HumanModules.modules[moduleId]});
            if (ok){
                ok();
            }
        };

        module.create(_ok);

        HumanModules.history.unshift(moduleId);
        if (HumanModules.history.length > MAX_HISTORY) {
            HumanModules.history.pop();
        }
    };

    /* Activates the module according to configuration provided.
     *
     * Module activation simply sets up the scenegraph, the rootTimeline and steps into the rootTimeline
     *
     */
    HumanModules.activate = function(moduleId, time, config, ok){
        Human.events.fire("modules.activate.start", {moduleId:moduleId, config:config});
        Human.events.fire("modules.activating",{moduleId:moduleId});
        var _ok = function(){
            HumanModules.activeModules[moduleId] = HumanModules.modules[moduleId];
            HumanModules.numActiveModules++;
            Human.events.fire("modules.activated", {moduleId:moduleId}); // backwards compatibility.
            Human.events.fire("modules.activate.finish", {moduleId:moduleId});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].activate(time, config, _ok);
    };

    /* Loads requisite assets and asset libraries from CDB via graph traversal and module library requests
     *
     * Unlike other life cycle steps, this function operates on the scene graph
     */
    HumanModules.load = function(moduleId, graphNodes, assetTypes, ok){
        Human.events.fire("modules.load.start", {moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
        // wrap passed callback into new callback
        var _ok = function(){
            Human.renderer.prepareFrame(); // Calculate xforms, boundaries, etc.
            Human.events.fire("modules.load.finish", {moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
            if (ok){
                ok();
            }
        };
        if (assetTypes.includes('geometry')) {
            blockLoad(moduleId, graphNodes, assetTypes, _ok); 
        } else {
            HumanModules.modules[moduleId].load(graphNodes, assetTypes, _ok);
        }
    };

    function blockLoad(moduleId, graphNodes, assetTypes, ok) {
        if (Human.unpackAssets.blocksWaiting > 0) {
            // try again on the next loop
            setTimeout(function() { 
                blockLoad(moduleId, graphNodes, assetTypes, ok);
            }, 2);
        } else {
            HumanModules.modules[moduleId].load(graphNodes, assetTypes, ok);
        }
    }

    /* Unload assets from moduleId that are unique that module.
     */
    HumanModules.unload = function(moduleId, graphNodes, assetTypes, ok){
        Human.events.fire("modules.unload.start",{moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
        var _ok = function(){
            Human.events.fire("modules.unload.finish",{moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].unload(graphNodes, assetTypes, _ok);
    };

    // Detaches module root from the active root
    HumanModules.deactivate = function(moduleId, config, ok){
        Human.events.fire("modules.deactivate.start", {moduleId:moduleId, config: config});
        var _ok = function(){
            delete HumanModules.activeModules[moduleId];
            HumanModules.numActiveModules--;
            Human.events.fire("modules.deactivated", {moduleId:moduleId});
            Human.events.fire("modules.deactivate.finish", {moduleId:moduleId});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].deactivate(config, _ok);
    };

    // Removes the module from memory, and calls module destroy which destroys root and branch timelines
    HumanModules.destroy = function(moduleId, ok){
        Human.events.fire("modules.destory.start", {moduleId:moduleId});
        if (!HumanModules.modules[moduleId]){
            Human.log.warn("Human.modules.destroyModule", "Module does not exist, cannot be destoryed: + " + moduleId);
        }
        else {
            var _ok = function(){
                delete HumanModules.moduleData[moduleId];
                delete HumanModules.modules[moduleId];
                idPool.putId(moduleId);
                Human.events.fire("modules.destroy.finish",{moduleId:moduleId});
                if (ok){
                    ok();
                }
            };
            HumanModules.modules[moduleId].destroy(_ok);
        }

    };

    // NOTE[EM] - This is bad to bake in knowledge of our content management.
    /* BASE ANATOMY UTILITY METHODS */
    HumanModules.isBase = function (input) {
       var match = input.match(/^(femaleAdult|maleAdult|female_complete_anatomy_[0-9]+\.json|male_complete_anatomy_[0-9]+\.json)/);
       return match && match[0];
    };

    HumanModules.isBaseModule = function (input) {
       var parts = input.split('/');
       return HumanModules.isBase(parts[parts.length - 1]) ? input : false;
    };

   HumanModules.requiresBase = function (objectIds) {
       var baseFound = false;

       for (var i = 0; i < objectIds.length; i++) {
           baseFound = HumanModules.isBase(objectIds[i]);

           if(baseFound) {
               break;
           }
       }

       return baseFound;
   };


   /* STATE CONVERSION METHODS */
   var MALE_STATE_ID = HumanModules.MALE_STATE_ID = 'maleAdult_standard';
   var FEMALE_STATE_ID = HumanModules.FEMALE_STATE_ID = 'femaleAdult_standard';
   var MODULE_ID_CONVERSIONS = {
       "production/maleAdult/maleAdult.json": "production/maleAdult/maleAdult_standard.json",
       "production/femaleAdult/femaleAdult.json": "production/femaleAdult/femaleAdult_standard.json"
   };

   HumanModules.convertBaseAnatomyModuleId = function (moduleId) {
       return MODULE_ID_CONVERSIONS[moduleId] || moduleId;
   };

   HumanModules.convertBaseAnatomyStateId = function (stateId) {
       return stateId.replace(/^femaleAdult$/, FEMALE_STATE_ID)
           .replace(/^maleAdult$/, MALE_STATE_ID);
   };

   HumanModules.convertBaseAnatomyObjectId = function (objectId) {
       if(HumanModules.isBase(objectId)) {
           var parts = objectId.split('-');
           var stateId = HumanModules.convertBaseAnatomyStateId(parts[0]);

           objectId = [stateId, parts[1]].join('-');

           if(!/_ID$/.test(objectId)) {
               objectId += "_ID";
           }
       }

       return objectId;
   };

})();
;(function () {
    "use strict";

    // MODULE CREATION constructor
    var Module = Human.modules.Module = function (cfg) {
        // Metadata
        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.translations = cfg.translations || {};
        this.tags = cfg.tags || [];
        this.ui = cfg.ui || {};
        this.active = false;
        this.timeActivated = -1;

        // List of objectIds of objects created by this module
        this.rootObjects = [];

        // Specific to this module type
        this.animation = cfg.animation || {};
        this.camera = cfg.camera;
        this.jumpTo = cfg.jumpTo;
        this.flyTo = cfg.flyTo;
        var p = cfg.modelIds || cfg.stateId;
        this.modelIds = p ? (Human.utils.isArray(p) ? p : [p]) : [];
        this.showObjects = cfg.showObjects;
        this.selectObjects = cfg.selectObjects;
        this.pickThroughObjects = cfg.pickThroughObjects;
        this.opacityObjects = cfg.opacityObjects;
        this.xray = cfg.xray;
        this.properties = cfg.properties;
        this.swapped = false;
        this.swappedObjectId = null;
        this.background = cfg.background || null;
        this.customData = cfg.customData || {};
        this.cache = false;

        this.chapters = cfg.chapters || null;
        this.sceneGraph = cfg.sceneGraph;

        if (cfg.customData && cfg.customData.particleSystems) {
            this.particleSystems = cfg.customData.particleSystems;
        } else {
            this.particleSystems = [];
        }

        this.assetLibraries = cfg.assetLibraries;

        // Help track whether lights are defined and loaded
        this.hasAssetLights = this.assetLibraries.hasOwnProperty('lights') && this.assetLibraries.lights.length > 0;
        this.lights = cfg.lights; // lights defined on the module
        this.hasLights = this.hasAssetLights || !!this.lights;

        // Maps reflection-id shorthand to true reflection asset. NOTE[EM] - parsing could be cleaned up in data
        this.reflections = cfg.reflections || {};
        for (var refid in this.reflections){
          if (this.reflections.hasOwnProperty(refid)){
            var ref = this.reflections[refid];
            var refparts = ref.split(".");
            ref = refparts[0] + "/" + refparts.slice(1).join(".");
            Human.assets.reflections.exportedReflectionIds[refid] = ref;
          }
        }

        this.layers = cfg.layers || {};         // layer slider data structures

        this.objectState = cfg.objects || {}; // hook when module created from bookmark
        this.clips = cfg.clips || {};         // hook when module created from bookmark
        this.modes = cfg.modes || {};         // hook when module created from bookmark

        this.colorRecipes = cfg.colorRecipes || {}; //module-specific color recipes
        this.loadedLibs = {};
    };


    // TODO[EM]: Find a better location for this
    function createSynchronization(chapter, defaultState){
        var objectId, prop;
        defaultState = defaultState || {
            "showObjects": {},
            "selectObjects": {},
            "pickThroughObjects": {},
            "colorRecipeObjects": {}
        };
        var showObjects = chapter.showObjects || defaultState.showObjects || {};
        var selectObjects = chapter.selectObjects || defaultState.selectObjects || {};
        var pickThroughObjects = chapter.pickThroughObjects || defaultState.pickThroughObjects || {};
        var opacityObjects = chapter.opacityObjects || defaultState.opacityObjects || {};
        var colorRecipeObjects = chapter.colorRecipeObjects || defaultState.colorRecipeObjects || {};

        var synchronization = chapter.synchronization || {}; // merge legacy object-property-maps into synchronization

        // Collect Shown Objects
        prop = "shown";
        for (objectId in showObjects){
            if (showObjects.hasOwnProperty(objectId)){
                if (!synchronization.hasOwnProperty(objectId)){
                    synchronization[objectId] = {};
                }
                synchronization[objectId][prop] = showObjects[objectId];
            }
        }

        // Collect Selected Objects
        prop = "selected";
        for (objectId in selectObjects){
            if (selectObjects.hasOwnProperty(objectId)){
                if (!synchronization.hasOwnProperty(objectId)){
                    synchronization[objectId] = {};
                }
                synchronization[objectId][prop] = selectObjects[objectId];
            }
        }

        // Collect UnPickable Objects
        prop = "pickable";
        for (objectId in pickThroughObjects){
            if (pickThroughObjects.hasOwnProperty(objectId)){
                if (!synchronization.hasOwnProperty(objectId)){
                    synchronization[objectId] = {};
                }
                synchronization[objectId][prop] = !pickThroughObjects[objectId];
            }
        }

        prop = "opacity";
        for (objectId in opacityObjects){
            if (!synchronization[objectId]){
                synchronization[objectId] = {};
            }
            synchronization[objectId][prop] = opacityObjects[objectId];
        }

        // per-chapter colorRecipes (for all named color recipes)
        for (var recipeName in colorRecipeObjects) {
            for (objectId in colorRecipeObjects[recipeName]) {
                if (!synchronization[objectId]) {
                    synchronization[objectId] = {};
                }
                synchronization[objectId][recipeName] = colorRecipeObjects[recipeName][objectId];
            }
        }

        return synchronization;

    }

    Module.prototype.create = function(ok){
        var self = this;
        var i, branch, root;

        // Construct the Scene graph for each root
        Human.scene.graph.buildGraph(self.sceneGraph, null, {});
        for (i=0; i< self.sceneGraph.length; i++){
            self.rootObjects.push( Human.scene.objects[self.sceneGraph[i].objectId]);
        }

        // Add Module Lights, if available
        if (this.lights) {
            // lights are globally scoped, and not scoped to module or chapter.
            Human.renderer.lights.addLights(this.lights);
        }

        // lights patch - Update Chapter data structure to include requisite lights
        // NOTE[EM]:BACKWARDS This is for backwards compatibility for chapters that DO NOT define their lights
        var chapter;
        for (i = 0; i < self.chapters.length; i++){
            chapter = self.chapters[i]; // modify the chapter data in place
            if (chapter.lights){
                // Ensure light libraries exist
                // Note(Tarek): This means we're getting bad data!
                if (this.hasAssetLights) {
                    var lightLibs = chapter.lights.libraries;
                    Human.utils.filterInPlace(lightLibs, lightFilterFunction(this.assetLibraries.lights));

                    if (lightLibs.length === 0) {
                        lightLibs.push("default");
                    }
                } else {
                    chapter.lights.libraries = ["default"];
                }
            } else {
                chapter.lights = { libraries:[], lights:[] }; // data spec for per-chapter lighting
                //if module has a light asset-library, use that; otherwise use default
                if (self.hasAssetLights){
                    chapter.lights.libraries = Human.utils.deepClone(self.assetLibraries.lights);
                } else {
                    chapter.lights.libraries = ["default"];
                }
            }

        }

        // Construct Root Timeline
        root = new Human.timeline.RootTimeline(self.moduleId);

        var modStateInstructions = {
          "showObjects": self.showObjects,
          "pickThroughObjects": self.pickThroughObjects,
          "selectObjects": self.selectObjects,
          "opacityObjects": self.opacityObjects
        };

        // Construct Branch Timelines
        // TODO[EM]: consider prepending module name to branch-ids to ensure uniqueness
        for (i=0 ; i < self.chapters.length; i++){
            self.chapters[i].synchronization = createSynchronization(self.chapters[i], modStateInstructions);
            if (!self.chapters[i].hasOwnProperty("id")){
                self.chapters[i].id = self.moduleId + "_" + i;
            }
            branch = new Human.timeline.BranchTimeline(self.chapters[i]);
            root.addChapter(branch, { rebuild: false });
        }
        root.build();
        self.rootTimeline = root;

        // Flush existing particles
        // Bookmark saving does not flush active modules. Bug!
        Human.particles.destroyAll();
        Human.particles.parse(self.particleSystems, ok);
    };

    // TODO[EM]: Consult on time requirement
    Module.prototype.activate = function(time, config, ok){
        var self = this;
        self.timeActivated = Date.now();
        self.active = true;

        // Set Module-Level Properties
        if (self.properties){
          Human.properties.set(self.properties);
        }

        // Create color recipes
        if (self.colorRecipes){
            Human.scene.colorRecipes.clearRecipes();
            for (var recipeName in self.colorRecipes) {
                Human.scene.colorRecipes.registerRecipe(recipeName, self.colorRecipes[recipeName]);
            }
        }

        // Activate Timeline
        if (time !== false){
            self.rootTimeline.activate(time, config, ok);
        }

    };

    // [GH] only load libraries once per module, not for every call to load, as it may happen more than once
    function loadAssetLibrary(libs, type, dir, libId, fileName, params, ok) {
        if (!libs[libId]) {
            libs[libId] = true;
            Human.assets.getAssetLibrary(type, dir, libId, fileName, params, ok);
        }
    }

    function unloadAssetLibrary(libs, libId) {
        if (libs[libId]) {
            delete libs[libId];
            Human.assets.putAssetLibrary(libId);
        }
    }

    function countRequests(assetLibs, types, loaded) {
        var libType, lib, counter = 0;
        // count the number of asset libraries to expect
        for (libType in assetLibs){
            if (assetLibs.hasOwnProperty(libType) && types.indexOf(libType) >= 0) {
                var libsList = assetLibs[libType]; 
                for (var i = 0; i < libsList.length; i++) {
                    lib = libsList[i];
                    if (!loaded[lib]) {       
                        counter += 1;
                    }
                }
            }
        }
        return counter;
    }

    /* Load all assets; whole asset libraries, and assets attached to scene graphs.
     *
     * This function will first load all asset libraries.
     * Once all asset libraries are downloaded, then the assets will be attached to the scene graph.
     *
     * NOTE: this "ok" callback will only be called when ALL assets are loaded
     *
     * NOTE[EM]: Lights are to be enabled on load - they are not otherwise 'activated' by module or chapters
     */
    Module.prototype.load = function(graphNodes, assetTypes, ok){
        var self = this, i = 0;

        if (this.customData.tweens) {
            Human.assets.tweens.parseLibrary(this.customData.tweenId, this.customData.tweens);
        }

        var numRequestedLibs = countRequests(self.assetLibraries, assetTypes, self.loadedLibs);
        if (numRequestedLibs > 0) {
            // tracks the number of unloaded libraries, until all libraries are loaded before kicking off scene graph asset loading
            var countAssetLibs = function() {
                numRequestedLibs--;
                if (numRequestedLibs === 0) {
                    Human.scene.graph.attachAssetSetsToSubtree(graphNodes, [assetTypes], ok);
                }
            };

            // kick off library requests
            if (self.assetLibraries.tweens && assetTypes.indexOf("tweens")>=0){
                for (i=0; i<self.assetLibraries.tweens.length; i++){
                    loadAssetLibrary(self.loadedLibs, "animation", "animations", self.assetLibraries.tweens[i], "manifest", {}, countAssetLibs);
                }
            }
            if (self.assetLibraries.reflections && assetTypes.indexOf("reflections")>=0){
                for (i=0; i<self.assetLibraries.reflections.length; i++){
                    loadAssetLibrary(self.loadedLibs, "reflection", "reflections", self.assetLibraries.reflections[i], "outline", {}, countAssetLibs);
                }
            }
            if (self.assetLibraries.lights && self.assetLibraries.lights.length > 0 && assetTypes.indexOf("lights") >= 0){
                for (i = 0; i < self.assetLibraries.lights.length; i++){
                    loadAssetLibrary(self.loadedLibs, "light", "lights", self.assetLibraries.lights[i], "outline", {}, countAssetLibs);
                }
            }
        } else {
            Human.scene.graph.attachAssetSetsToSubtree(graphNodes, [assetTypes], ok);
        }
    };

    /* Unload all assets; whole asset libraries, and assets attached to scene graphs.
     *
     * This function first unload all asset libraries.
     * Once all asset libarries are deleted, the assets attached to the scene graph will be removed.
     *
     * NOTE: this "ok" callback will only be called when ALL assets are removed.
     *
     * NOTE: assets on the graph are only fully deleted from memory when their reference count hits 0.
     */
    Module.prototype.unload = function(graphNodes, assetTypes, ok){
        var self = this;
        var i = 0;

        // Unloading is not asynchronous, so we don't need to track progress of unloading
        if (self.assetLibraries.tweens && assetTypes.indexOf("tweens")>=0){
            for (i=0; i<self.assetLibraries.tweens.length; i++){
                unloadAssetLibrary(self.loadedLibs, self.assetLibraries.tweens[i]);
            }
        }
        if (self.assetLibraries.reflections && assetTypes.indexOf("reflections")>=0){
            for (i=0; i<self.assetLibraries.reflections.length; i++){
                unloadAssetLibrary(self.loadedLibs, self.assetLibraries.reflections[i]);
            }   
        }
        if (self.assetLibraries.lights && assetTypes.indexOf("lights")>=0){
            for (i=0; i<self.assetLibraries.lights.length; i++){
                unloadAssetLibrary(self.loadedLibs, self.assetLibraries.lights[i]);
            }
        }
        
        Human.scene.graph.unloadSubtree(graphNodes, assetTypes, ok);
    };

    Module.prototype.deactivate = function (config, ok) {
        var self= this;
        self.timeActivated = -1;
        self.active = false;
        self.rootTimeline.deactivate(config, ok);
    };

    // Destroy the root timeline
    Module.prototype.destroy = function(ok){
        var self = this;
        Human.particles.destroyAll();
        self.rootTimeline.destroy();
        Human.scene.graph.destroySubtree(self.rootObjects);
        self = null;
        if (ok){
            ok();
        }
    };

    function lightFilterFunction(lightAssets) {
        return function(lightId) {
            return lightAssets.indexOf(lightId) > -1;
        };
    }

})();
;(function() {
    "use strict";

    Human.mobile = {
        android: window.HumanKitAndroid !== undefined,
        iOS: window.webkit !== undefined,
        bundleid : window.mobilebundleid !== undefined ? window.mobilebundleid : null
    };
})();
;(function () {
    "use strict";

    var HumanWorkers = Human.workers = {};

    var basePath = '';
    /*
    Web worker scripts are loaded relative to the executing page. Since that location varies
    depending on the application, it is a requirement that the app registers the location of
    engine worker scripts.
    */
    HumanWorkers.setPath = function(path){
        basePath = path;
    };

    /*
    Once base path is established, the engine can load its workers through loadWorker,
    specifying only the path of the worker relative to the src/workers/ engine directory.

    E.g. Human.worker.loadWorker('draco/worker.js');
    */
    HumanWorkers.loadWorker = function(workerFileName){
        var uri  = basePath + '/' + workerFileName;
        return new Worker(uri);
    };

})();
;/**
 @namespace Plugin registry.
 */
(function () {

    "use strict";

    Human.plugins = {};

    Human.addPlugin = function (id, plugin) {
        Human.plugins[id] = plugin;
    };
})();;(function(global) {
  'use strict';

  //
  // Utilities
  //

  /**
   * @param {number} a The number to test.
   * @param {number} min The minimum value in the range, inclusive.
   * @param {number} max The maximum value in the range, inclusive.
   * @return {boolean} True if a >= min and a <= max.
   */
  function inRange(a, min, max) {
    return min <= a && a <= max;
  }

  /**
   * @param {number} n The numerator.
   * @param {number} d The denominator.
   * @return {number} The result of the integer division of n by d.
   */
  function div(n, d) {
    return Math.floor(n / d);
  }


  //
  // Implementation of Encoding specification
  // http://dvcs.w3.org/hg/encoding/raw-file/tip/Overview.html
  //

  //
  // 3. Terminology
  //

  //
  // 4. Encodings
  //

  /** @const */ var EOF_byte = -1;
  /** @const */ var EOF_code_point = -1;

  /**
   * @constructor
   * @param {Uint8Array} bytes Array of bytes that provide the stream.
   */
  function ByteInputStream(bytes) {
    /** @type {number} */
    var pos = 0;

    /** @return {number} Get the next byte from the stream. */
    this.get = function() {
        return (pos >= bytes.length) ? EOF_byte : Number(bytes[pos]);
    };

    /** @param {number} n Number (positive or negative) by which to
     *      offset the byte pointer. */
    this.offset = function(n) {
      pos += n;
      if (pos < 0) {
        throw new Error('Seeking past start of the buffer');
      }
      if (pos > bytes.length) {
        throw new Error('Seeking past EOF');
      }
    };

    /**
     * @param {Array.<number>} test Array of bytes to compare against.
     * @return {boolean} True if the start of the stream matches the test
     *     bytes.
     */
    this.match = function(test) {
      if (test.length > pos + bytes.length) {
        return false;
      }
      var i;
      for (i = 0; i < test.length; i += 1) {
        if (Number(bytes[pos + i]) !== test[i]) {
          return false;
        }
      }
      return true;
    };
  }

  /**
   * @constructor
   * @param {Array.<number>} bytes The array to write bytes into.
   */
  function ByteOutputStream(bytes) {
    /** @type {number} */
    var pos = 0;

    /**
     * @param {...number} var_args The byte or bytes to emit into the stream.
     * @return {number} The last byte emitted.
     */
    this.emit = function(var_args) {
      /** @type {number} */
      var last = EOF_byte;
      var i;
      for (i = 0; i < arguments.length; ++i) {
        last = Number(arguments[i]);
        bytes[pos++] = last;
      }
      return last;
    };
  }

  /**
   * @constructor
   * @param {string} string The source of code units for the stream.
   */
  function CodePointInputStream(string) {
    /** @type {number} */
    var pos = 0;
    /** @type {Array.<number>} */
    var cps = (/** @return {Array.<number>} Code points. */function() {
      /** @type {Array.<number>} */
      var cps = [];
      // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
      var i = 0, n = string.length;
      while (i < string.length) {
        var c = string.charCodeAt(i);
        if (!inRange(c, 0xD800, 0xDFFF)) {
          cps.push(c);
        } else if (inRange(c, 0xDC00, 0xDFFF)) {
          cps.push(0xFFFD);
        } else { // (inRange(cu, 0xD800, 0xDBFF))
          if (i === n - 1) {
            cps.push(0xFFFD);
          } else {
            var d = string.charCodeAt(i + 1);
            if (inRange(d, 0xDC00, 0xDFFF)) {
              var a = c & 0x3FF;
              var b = d & 0x3FF;
              i += 1;
              cps.push(0x10000 + (a << 10) + b);
            } else {
              cps.push(0xFFFD);
            }
          }
        }
        i += 1;
      }
      return cps;
    }());

    /** @param {number} n The number of bytes (positive or negative)
     *      to advance the code point pointer by.*/
    this.offset = function(n) {
      pos += n;
      if (pos < 0) {
        throw new Error('Seeking past start of the buffer');
      }
      if (pos > cps.length) {
        throw new Error('Seeking past EOF');
      }
    };


    /** @return {number} Get the next code point from the stream. */
    this.get = function() {
      if (pos >= cps.length) {
        return EOF_code_point;
      }
      return cps[pos];
    };
  }

  /**
   * @constructor
   */
  function CodePointOutputStream() {
    /** @type {string} */
    var string = '';

    /** @return {string} The accumulated string. */
    this.string = function() {
      return string;
    };

    /** @param {number} c The code point to encode into the stream. */
    this.emit = function(c) {
      if (c <= 0xFFFF) {
        string += String.fromCharCode(c);
      } else {
        c -= 0x10000;
        string += String.fromCharCode(0xD800 + ((c >> 10) & 0x3ff));
        string += String.fromCharCode(0xDC00 + (c & 0x3ff));
      }
    };
  }

  /**
   * @param {boolean} fatal If true, decoding errors raise an exception.
   * @param {number=} opt_code_point Override the standard fallback code point.
   * @return {number} The code point to insert on a decoding error.
   */
  function decoderError(fatal, opt_code_point) {
    if (fatal) {
      throw new Error('EncodingError');
    }
    return opt_code_point || 0xFFFD;
  }

  /**
   * @param {number} code_point The code point that could not be encoded.
   */
  function encoderError(code_point) {
    throw new Error('EncodingError');
  }

  /**
   * @param {string} label The encoding label.
   */
  function getEncoding(label) {
    label = String(label).trim().toLowerCase();
    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {
      return label_to_encoding[label];
    }
    throw new Error('EncodingError: Unknown encoding: ' + label);
  }

  /** @type {Array.<{encodings: Array.<{name:string,labels:Array.<string>}>,
   *      heading: string}>} */
  var encodings = [
    {
      "encodings": [
        {
          "labels": [
            "unicode-1-1-utf-8",
            "utf-8",
            "utf8"
          ],
          "name": "utf-8"
        }
      ],
      "heading": "The Encoding"
    },
    {
      "encodings": [
        {
          "labels": [
            "cp864",
            "ibm864"
          ],
          "name": "ibm864"
        },
        {
          "labels": [
            "cp866",
            "ibm866"
          ],
          "name": "ibm866"
        },
        {
          "labels": [
            "csisolatin2",
            "iso-8859-2",
            "iso-ir-101",
            "iso8859-2",
            "iso_8859-2",
            "l2",
            "latin2"
          ],
          "name": "iso-8859-2"
        },
        {
          "labels": [
            "csisolatin3",
            "iso-8859-3",
            "iso_8859-3",
            "iso-ir-109",
            "l3",
            "latin3"
          ],
          "name": "iso-8859-3"
        },
        {
          "labels": [
            "csisolatin4",
            "iso-8859-4",
            "iso_8859-4",
            "iso-ir-110",
            "l4",
            "latin4"
          ],
          "name": "iso-8859-4"
        },
        {
          "labels": [
            "csisolatincyrillic",
            "cyrillic",
            "iso-8859-5",
            "iso_8859-5",
            "iso-ir-144"
          ],
          "name": "iso-8859-5"
        },
        {
          "labels": [
            "arabic",
            "csisolatinarabic",
            "ecma-114",
            "iso-8859-6",
            "iso_8859-6",
            "iso-ir-127"
          ],
          "name": "iso-8859-6"
        },
        {
          "labels": [
            "csisolatingreek",
            "ecma-118",
            "elot_928",
            "greek",
            "greek8",
            "iso-8859-7",
            "iso_8859-7",
            "iso-ir-126"
          ],
          "name": "iso-8859-7"
        },
        {
          "labels": [
            "csisolatinhebrew",
            "hebrew",
            "iso-8859-8",
            "iso-8859-8-i",
            "iso-ir-138",
            "iso_8859-8",
            "visual"
          ],
          "name": "iso-8859-8"
        },
        {
          "labels": [
            "csisolatin6",
            "iso-8859-10",
            "iso-ir-157",
            "iso8859-10",
            "l6",
            "latin6"
          ],
          "name": "iso-8859-10"
        },
        {
          "labels": [
            "iso-8859-13"
          ],
          "name": "iso-8859-13"
        },
        {
          "labels": [
            "iso-8859-14",
            "iso8859-14"
          ],
          "name": "iso-8859-14"
        },
        {
          "labels": [
            "iso-8859-15",
            "iso_8859-15"
          ],
          "name": "iso-8859-15"
        },
        {
          "labels": [
            "iso-8859-16"
          ],
          "name": "iso-8859-16"
        },
        {
          "labels": [
            "koi8-r",
            "koi8_r"
          ],
          "name": "koi8-r"
        },
        {
          "labels": [
            "koi8-u"
          ],
          "name": "koi8-u"
        },
        {
          "labels": [
            "csmacintosh",
            "mac",
            "macintosh",
            "x-mac-roman"
          ],
          "name": "macintosh"
        },
        {
          "labels": [
            "iso-8859-11",
            "tis-620",
            "windows-874"
          ],
          "name": "windows-874"
        },
        {
          "labels": [
            "windows-1250",
            "x-cp1250"
          ],
          "name": "windows-1250"
        },
        {
          "labels": [
            "windows-1251",
            "x-cp1251"
          ],
          "name": "windows-1251"
        },
        {
          "labels": [
            "ascii",
            "ansi_x3.4-1968",
            "csisolatin1",
            "iso-8859-1",
            "iso8859-1",
            "iso_8859-1",
            "l1",
            "latin1",
            "us-ascii",
            "windows-1252"
          ],
          "name": "windows-1252"
        },
        {
          "labels": [
            "cp1253",
            "windows-1253"
          ],
          "name": "windows-1253"
        },
        {
          "labels": [
            "csisolatin5",
            "iso-8859-9",
            "iso-ir-148",
            "l5",
            "latin5",
            "windows-1254"
          ],
          "name": "windows-1254"
        },
        {
          "labels": [
            "cp1255",
            "windows-1255"
          ],
          "name": "windows-1255"
        },
        {
          "labels": [
            "cp1256",
            "windows-1256"
          ],
          "name": "windows-1256"
        },
        {
          "labels": [
            "windows-1257"
          ],
          "name": "windows-1257"
        },
        {
          "labels": [
            "cp1258",
            "windows-1258"
          ],
          "name": "windows-1258"
        },
        {
          "labels": [
            "x-mac-cyrillic",
            "x-mac-ukrainian"
          ],
          "name": "x-mac-cyrillic"
        }
      ],
      "heading": "Legacy single-byte encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "chinese",
            "csgb2312",
            "csiso58gb231280",
            "gb2312",
            "gbk",
            "gb_2312",
            "gb_2312-80",
            "iso-ir-58",
            "x-gbk"
          ],
          "name": "gbk"
        },
        {
          "labels": [
            "gb18030"
          ],
          "name": "gb18030"
        },
        {
          "labels": [
            "hz-gb-2312"
          ],
          "name": "hz-gb-2312"
        }
      ],
      "heading": "Legacy multi-byte Chinese (simplified) encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "big5",
            "big5-hkscs",
            "cn-big5",
            "csbig5",
            "x-x-big5"
          ],
          "name": "big5"
        }
      ],
      "heading": "Legacy multi-byte Chinese (traditional) encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "cseucpkdfmtjapanese",
            "euc-jp",
            "x-euc-jp"
          ],
          "name": "euc-jp"
        },
        {
          "labels": [
            "csiso2022jp",
            "iso-2022-jp"
          ],
          "name": "iso-2022-jp"
        },
        {
          "labels": [
            "csshiftjis",
            "ms_kanji",
            "shift-jis",
            "shift_jis",
            "sjis",
            "windows-31j",
            "x-sjis"
          ],
          "name": "shift_jis"
        }
      ],
      "heading": "Legacy multi-byte Japanese encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "cseuckr",
            "csksc56011987",
            "euc-kr",
            "iso-ir-149",
            "korean",
            "ks_c_5601-1987",
            "ks_c_5601-1989",
            "ksc5601",
            "ksc_5601",
            "windows-949"
          ],
          "name": "euc-kr"
        },
        {
          "labels": [
            "csiso2022kr",
            "iso-2022-kr"
          ],
          "name": "iso-2022-kr"
        }
      ],
      "heading": "Legacy multi-byte Korean encodings"
    },
    {
      "encodings": [
        {
          "labels": [
            "utf-16",
            "utf-16le"
          ],
          "name": "utf-16"
        },
        {
          "labels": [
            "utf-16be"
          ],
          "name": "utf-16be"
        }
      ],
      "heading": "Legacy utf-16 encodings"
    }
  ];

  var name_to_encoding = {};
  var label_to_encoding = {};
  encodings.forEach(
    /** @param {{encodings: Array.<{name:string,labels:Array.<string>}>,
     *      heading:string}} category */
    function(category) {
      category.encodings.forEach(
        /** @param {{name:string,labels:Array.<string>}} encoding */
        function(encoding) {
          name_to_encoding[encoding.name] = encoding;
          encoding.labels.forEach(
            /** @param {string} label */
            function(label) {
              label_to_encoding[label] = encoding;
            });
        });
    });

  //
  // 5. Indexes
  //

  /**
   * @param {number} pointer The |pointer| to search for.
   * @param {Array.<?number>} index The |index| to search within.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in |index|.
   */
  function indexCodePointFor(pointer, index) {
    return (index || [])[pointer] || null;
  }

  /**
   * @param {number} code_point The |code point| to search for.
   * @param {Array.<?number>} index The |index| to search within.
   * @return {?number} The first pointer corresponding to |code point| in
   *     |index|, or null if |code point| is not in |index|.
   */
  function indexPointerFor(code_point, index) {
    var pointer = index.indexOf(code_point);
    return pointer === -1 ? null : pointer;
  }

  /** @type {Object.<string, (Array.<number>|Array.<Array.<number>>)>} */
  var indexes = global['encoding-indexes'] || {};

  /**
   * @param {number} pointer The |pointer| to search for in the gb18030 index.
   * @return {?number} The code point corresponding to |pointer| in |index|,
   *     or null if |code point| is not in the gb18030 index.
   */
  function indexGB18030CodePointFor(pointer) {
    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575)) {
      return null;
    }
    var /** @type {number} */ offset = 0,
        /** @type {number} */ code_point_offset = 0,
        /** @type {Array.<Array.<number>>} */ index = indexes['gb18030'];
    var i;
    for (i = 0; i < index.length; ++i) {
      var entry = index[i];
      if (entry[0] <= pointer) {
        offset = entry[0];
        code_point_offset = entry[1];
      } else {
        break;
      }
    }
    return code_point_offset + pointer - offset;
  }

  /**
   * @param {number} code_point The |code point| to locate in the gb18030 index.
   * @return {number} The first pointer corresponding to |code point| in the
   *     gb18030 index.
   */
  function indexGB18030PointerFor(code_point) {
    var /** @type {number} */ offset = 0,
        /** @type {number} */ pointer_offset = 0,
        /** @type {Array.<Array.<number>>} */ index = indexes['gb18030'];
    var i;
    for (i = 0; i < index.length; ++i) {
      var entry = index[i];
      if (entry[1] <= code_point) {
        offset = entry[1];
        pointer_offset = entry[0];
      } else {
        break;
      }
    }
    return pointer_offset + code_point - offset;
  }

  //
  // 7. The encoding
  //

  // 7.1 utf-8

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function UTF8Decoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ utf8_code_point = 0,
        /** @type {number} */ utf8_bytes_needed = 0,
        /** @type {number} */ utf8_bytes_seen = 0,
        /** @type {number} */ utf8_lower_boundary = 0;

    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte) {
        if (utf8_bytes_needed !== 0) {
          return decoderError(fatal);
        }
        return EOF_code_point;
      }
      byte_pointer.offset(1);

      if (utf8_bytes_needed === 0) {
        if (inRange(bite, 0x00, 0x7F)) {
          return bite;
        }
        if (inRange(bite, 0xC2, 0xDF)) {
          utf8_bytes_needed = 1;
          utf8_lower_boundary = 0x80;
          utf8_code_point = bite - 0xC0;
        } else if (inRange(bite, 0xE0, 0xEF)) {
          utf8_bytes_needed = 2;
          utf8_lower_boundary = 0x800;
          utf8_code_point = bite - 0xE0;
        } else if (inRange(bite, 0xF0, 0xF4)) {
          utf8_bytes_needed = 3;
          utf8_lower_boundary = 0x10000;
          utf8_code_point = bite - 0xF0;
        } else {
          return decoderError(fatal);
        }
        utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
        return null;
      }
      if (!inRange(bite, 0x80, 0xBF)) {
        utf8_code_point = 0;
        utf8_bytes_needed = 0;
        utf8_bytes_seen = 0;
        utf8_lower_boundary = 0;
        byte_pointer.offset(-1);
        return decoderError(fatal);
      }
      utf8_bytes_seen += 1;
      utf8_code_point = utf8_code_point + (bite - 0x80) *
        Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
      if (utf8_bytes_seen !== utf8_bytes_needed) {
        return null;
      }
      var code_point = utf8_code_point;
      var lower_boundary = utf8_lower_boundary;
      utf8_code_point = 0;
      utf8_bytes_needed = 0;
      utf8_bytes_seen = 0;
      utf8_lower_boundary = 0;
      if (inRange(code_point, lower_boundary, 0x10FFFF) &&
          !inRange(code_point, 0xD800, 0xDFFF)) {
        return code_point;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function UTF8Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0xD800, 0xDFFF)) {
        return encoderError(code_point);
      }
      if (inRange(code_point, 0x0000, 0x007f)) {
        return output_byte_stream.emit(code_point);
      }
      var count, offset;
      if (inRange(code_point, 0x0080, 0x07FF)) {
          count = 1;
        offset = 0xC0;
      } else if (inRange(code_point, 0x0800, 0xFFFF)) {
        count = 2;
        offset = 0xE0;
      } else if (inRange(code_point, 0x10000, 0x10FFFF)) {
        count = 3;
        offset = 0xF0;
      }
      var result = output_byte_stream.emit(
        div(code_point, Math.pow(64, count)) + offset);
      while (count > 0) {
        var temp = div(code_point, Math.pow(64, count - 1));
        result = output_byte_stream.emit(0x80 + (temp % 64));
        count -= 1;
      }
      return result;
    };
  }

  name_to_encoding['utf-8'].getEncoder = function(options) {
    return new UTF8Encoder(options);
  };
  name_to_encoding['utf-8'].getDecoder = function(options) {
    return new UTF8Decoder(options);
  };

  //
  // 8. Legacy single-byte encodings
  //

  /**
   * @constructor
   * @param {Array.<number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteDecoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte) {
        return EOF_code_point;
      }
      byte_pointer.offset(1);
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      var code_point = index[bite - 0x80];
      if (code_point === null) {
        return decoderError(fatal);
      }
      return code_point;
    };
  }

  /**
   * @constructor
   * @param {Array.<?number>} index The encoding index.
   * @param {{fatal: boolean}} options
   */
  function SingleByteEncoder(index, options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      var pointer = indexPointerFor(code_point, index);
      if (pointer === null) {
        encoderError(code_point);
      }
      return output_byte_stream.emit(pointer + 0x80);
    };
  }

  (function() {
    ['ibm864', 'ibm866', 'iso-8859-2', 'iso-8859-3', 'iso-8859-4',
     'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8', 'iso-8859-10',
     'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'iso-8859-16', 'koi8-r',
     'koi8-u', 'macintosh', 'windows-874', 'windows-1250', 'windows-1251',
     'windows-1252', 'windows-1253', 'windows-1254', 'windows-1255',
     'windows-1256', 'windows-1257', 'windows-1258', 'x-mac-cyrillic'
    ].forEach(
      function(name) {
        var encoding = name_to_encoding[name];
        var index = indexes[name];
        encoding.getDecoder = function(options) {
          return new SingleByteDecoder(index, options);
        };
        encoding.getEncoder = function(options) {
          return new SingleByteEncoder(index, options);
        };
      }
    );
  }());

  //
  // 9. Legacy multi-byte Chinese (simplified) encodings
  //

  // 9.1 gbk

  /**
   * @constructor
   * @param {boolean} gb18030 True if decoding gb18030, false otherwise.
   * @param {{fatal: boolean}} options
   */
  function GBKDecoder(gb18030, options) {
    var fatal = options.fatal;
    var /** @type {number} */ gbk_first = 0x00,
        /** @type {number} */ gbk_second = 0x00,
        /** @type {number} */ gbk_third = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte && gbk_first === 0x00 &&
          gbk_second === 0x00 && gbk_third === 0x00) {
        return EOF_code_point;
      }
      if (bite === EOF_byte &&
          (gbk_first !== 0x00 || gbk_second !== 0x00 || gbk_third !== 0x00)) {
        gbk_first = 0x00;
        gbk_second = 0x00;
        gbk_third = 0x00;
        decoderError(fatal);
      }
      byte_pointer.offset(1);
      var code_point;
      if (gbk_third !== 0x00) {
        code_point = null;
        if (inRange(bite, 0x30, 0x39)) {
          code_point = indexGB18030CodePointFor(
            (((gbk_first - 0x81) * 10 + (gbk_second - 0x30)) * 126 +
             (gbk_third - 0x81)) * 10 + bite - 0x30);
        }
        gbk_first = 0x00;
        gbk_second = 0x00;
        gbk_third = 0x00;
        if (code_point === null) {
          byte_pointer.offset(-3);
          return decoderError(fatal);
        }
        return code_point;
      }
      if (gbk_second !== 0x00) {
        if (inRange(bite, 0x81, 0xFE)) {
          gbk_third = bite;
          return null;
        }
        byte_pointer.offset(-2);
        gbk_first = 0x00;
        gbk_second = 0x00;
        return decoderError(fatal);
      }
      if (gbk_first !== 0x00) {
        if (inRange(bite, 0x30, 0x39) && gb18030) {
          gbk_second = bite;
          return null;
        }
        var lead = gbk_first;
        var pointer = null;
        gbk_first = 0x00;
        var offset = bite < 0x7F ? 0x40 : 0x41;
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) {
          pointer = (lead - 0x81) * 190 + (bite - offset);
        }
        code_point = pointer === null ? null :
          indexCodePointFor(pointer, indexes['gbk']);
        if (pointer === null) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      if (bite === 0x80) {
        return 0x20AC;
      }
      if (inRange(bite, 0x81, 0xFE)) {
        gbk_first = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {boolean} gb18030 True if decoding gb18030, false otherwise.
   * @param {{fatal: boolean}} options
   */
  function GBKEncoder(gb18030, options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      var pointer = indexPointerFor(code_point, indexes['gbk']);
      if (pointer !== null) {
        var lead = div(pointer, 190) + 0x81;
        var trail = pointer % 190;
        var offset = trail < 0x3F ? 0x40 : 0x41;
        return output_byte_stream.emit(lead, trail + offset);
      }
      if (pointer === null && !gb18030) {
        return encoderError(code_point);
      }
      pointer = indexGB18030PointerFor(code_point);
      var byte1 = div(div(div(pointer, 10), 126), 10);
      pointer = pointer - byte1 * 10 * 126 * 10;
      var byte2 = div(div(pointer, 10), 126);
      pointer = pointer - byte2 * 10 * 126;
      var byte3 = div(pointer, 10);
      var byte4 = pointer - byte3 * 10;
      return output_byte_stream.emit(byte1 + 0x81,
                                     byte2 + 0x30,
                                     byte3 + 0x81,
                                     byte4 + 0x30);
    };
  }

  name_to_encoding['gbk'].getEncoder = function(options) {
    return new GBKEncoder(false, options);
  };
  name_to_encoding['gbk'].getDecoder = function(options) {
    return new GBKDecoder(false, options);
  };

  // 9.2 gb18030
  name_to_encoding['gb18030'].getEncoder = function(options) {
    return new GBKEncoder(true, options);
  };
  name_to_encoding['gb18030'].getDecoder = function(options) {
    return new GBKDecoder(true, options);
  };

  // 9.3 hz-gb-2312

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function HZGB2312Decoder(options) {
    var fatal = options.fatal;
    var /** @type {boolean} */ hzgb2312 = false,
        /** @type {number} */ hzgb2312_lead = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte && hzgb2312_lead === 0x00) {
        return EOF_code_point;
      }
      if (bite === EOF_byte && hzgb2312_lead !== 0x00) {
        hzgb2312_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (hzgb2312_lead === 0x7E) {
        hzgb2312_lead = 0x00;
        if (bite === 0x7B) {
          hzgb2312 = true;
          return null;
        }
        if (bite === 0x7D) {
          hzgb2312 = false;
          return null;
        }
        if (bite === 0x7E) {
          return 0x007E;
        }
        if (bite === 0x0A) {
          return null;
        }
        byte_pointer.offset(-1);
        return decoderError(fatal);
      }
      if (hzgb2312_lead !== 0x00) {
        var lead = hzgb2312_lead;
        hzgb2312_lead = 0x00;
        var code_point = null;
        if (inRange(bite, 0x21, 0x7E)) {
          code_point = indexCodePointFor((lead - 1) * 190 +
                                         (bite + 0x3F), indexes['gbk']);
        }
        if (bite === 0x0A) {
          hzgb2312 = false;
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (bite === 0x7E) {
        hzgb2312_lead = 0x7E;
        return null;
      }
      if (hzgb2312) {
        if (inRange(bite, 0x20, 0x7F)) {
          hzgb2312_lead = bite;
          return null;
        }
        if (bite === 0x0A) {
          hzgb2312 = false;
        }
        return decoderError(fatal);
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function HZGB2312Encoder(options) {
    var fatal = options.fatal;
    var hzgb2312 = false;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F) && hzgb2312) {
        code_point_pointer.offset(-1);
        hzgb2312 = false;
        return output_byte_stream.emit(0x7E, 0x7D);
      }
      if (code_point === 0x007E) {
        return output_byte_stream.emit(0x7E, 0x7E);
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      if (!hzgb2312) {
        code_point_pointer.offset(-1);
        hzgb2312 = true;
        return output_byte_stream.emit(0x7E, 0x7B);
      }
      var pointer = indexPointerFor(code_point, indexes['gbk']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead = div(pointer, 190) + 1;
      var trail = pointer % 190 - 0x3F;
      if (!inRange(lead, 0x21, 0x7E) || !inRange(trail, 0x21, 0x7E)) {
        return encoderError(code_point);
      }
      return output_byte_stream.emit(lead, trail);
    };
  }

  name_to_encoding['hz-gb-2312'].getEncoder = function(options) {
    return new HZGB2312Encoder(options);
  };
  name_to_encoding['hz-gb-2312'].getDecoder = function(options) {
    return new HZGB2312Decoder(options);
  };

  //
  // 10. Legacy multi-byte Chinese (traditional) encodings
  //

  // 10.1 big5

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function Big5Decoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ big5_lead = 0x00,
        /** @type {?number} */ big5_pending = null;

    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      // NOTE: Hack to support emitting two code points
      if (big5_pending !== null) {
        var pending = big5_pending;
        big5_pending = null;
        return pending;
      }
      var bite = byte_pointer.get();
      if (bite === EOF_byte && big5_lead === 0x00) {
        return EOF_code_point;
      }
      if (bite === EOF_byte && big5_lead !== 0x00) {
        big5_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (big5_lead !== 0x00) {
        var lead = big5_lead;
        var pointer = null;
        big5_lead = 0x00;
        var offset = bite < 0x7F ? 0x40 : 0x62;
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) {
          pointer = (lead - 0x81) * 157 + (bite - offset);
        }
        if (pointer === 1133) {
          big5_pending = 0x0304;
          return 0x00CA;
        }
        if (pointer === 1135) {
          big5_pending = 0x030C;
          return 0x00CA;
        }
        if (pointer === 1164) {
          big5_pending = 0x0304;
          return 0x00EA;
        }
        if (pointer === 1166) {
          big5_pending = 0x030C;
          return 0x00EA;
        }
        var code_point = (pointer === null) ? null :
              indexCodePointFor(pointer, indexes['big5']);
        if (pointer === null) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      if (inRange(bite, 0x81, 0xFE)) {
        big5_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function Big5Encoder(options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      var pointer = indexPointerFor(code_point, indexes['big5']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead = div(pointer, 157) + 0x81;
      //if (lead < 0xA1) {
      //  return encoderError(code_point);
      //}
      var trail = pointer % 157;
      var offset = trail < 0x3F ? 0x40 : 0x62;
      return output_byte_stream.emit(lead, trail + offset);
    };
  }

  name_to_encoding['big5'].getEncoder = function(options) {
    return new Big5Encoder(options);
  };
  name_to_encoding['big5'].getDecoder = function(options) {
    return new Big5Decoder(options);
  };


  //
  // 11. Legacy multi-byte Japanese encodings
  //

  // 11.1 euc.jp

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function EUCJPDecoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ eucjp_first = 0x00,
        /** @type {number} */ eucjp_second = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte) {
        if (eucjp_first === 0x00 && eucjp_second === 0x00) {
          return EOF_code_point;
        }
        eucjp_first = 0x00;
        eucjp_second = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);

      var lead, code_point;
      if (eucjp_second !== 0x00) {
        lead = eucjp_second;
        eucjp_second = 0x00;
        code_point = null;
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = indexCodePointFor((lead - 0xA1) * 94 + bite - 0xA1,
                                         indexes['jis0212']);
        }
        if (!inRange(bite, 0xA1, 0xFE)) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (eucjp_first === 0x8E && inRange(bite, 0xA1, 0xDF)) {
        eucjp_first = 0x00;
        return 0xFF61 + bite - 0xA1;
      }
      if (eucjp_first === 0x8F && inRange(bite, 0xA1, 0xFE)) {
        eucjp_first = 0x00;
        eucjp_second = bite;
        return null;
      }
      if (eucjp_first !== 0x00) {
        lead = eucjp_first;
        eucjp_first = 0x00;
        code_point = null;
        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {
          code_point = indexCodePointFor((lead - 0xA1) * 94 + bite - 0xA1,
                                         indexes['jis0208']);
        }
        if (!inRange(bite, 0xA1, 0xFE)) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }
      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }
      if (bite === 0x8E || bite === 0x8F || (inRange(bite, 0xA1, 0xFE))) {
        eucjp_first = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function EUCJPEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      if (code_point === 0x00A5) {
        return output_byte_stream.emit(0x5C);
      }
      if (code_point === 0x203E) {
        return output_byte_stream.emit(0x7E);
      }
      if (inRange(code_point, 0xFF61, 0xFF9F)) {
        return output_byte_stream.emit(0x8E, code_point - 0xFF61 + 0xA1);
      }

      var pointer = indexPointerFor(code_point, indexes['jis0208']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead = div(pointer, 94) + 0xA1;
      var trail = pointer % 94 + 0xA1;
      return output_byte_stream.emit(lead, trail);
    };
  }

  name_to_encoding['euc-jp'].getEncoder = function(options) {
    return new EUCJPEncoder(options);
  };
  name_to_encoding['euc-jp'].getDecoder = function(options) {
    return new EUCJPDecoder(options);
  };

  // 11.2 iso-2022-jp

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      escape_start: 1,
      escape_middle: 2,
      escape_final: 3,
      lead: 4,
      trail: 5,
      Katakana: 6
    };
    var /** @type {number} */ iso2022jp_state = state.ASCII,
        /** @type {boolean} */ iso2022jp_jis0212 = false,
        /** @type {number} */ iso2022jp_lead = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite !== EOF_byte) {
        byte_pointer.offset(1);
      }
      switch (iso2022jp_state) {
      default:
      case state.ASCII:
        if (bite === 0x1B) {
          iso2022jp_state = state.escape_start;
          return null;
        }
        if (inRange(bite, 0x00, 0x7F)) {
          return bite;
        }
        if (bite === EOF_byte) {
          return EOF_code_point;
        }
        return decoderError(fatal);

      case state.escape_start:
        if (bite === 0x24 || bite === 0x28) {
          iso2022jp_lead = bite;
          iso2022jp_state = state.escape_middle;
          return null;
        }
        if (bite !== EOF_byte) {
          byte_pointer.offset(-1);
        }
        iso2022jp_state = state.ASCII;
        return decoderError(fatal);

      case state.escape_middle:
        var lead = iso2022jp_lead;
        iso2022jp_lead = 0x00;
        if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) {
          iso2022jp_jis0212 = false;
          iso2022jp_state = state.lead;
          return null;
        }
        if (lead === 0x24 && bite === 0x28) {
          iso2022jp_state = state.escape_final;
          return null;
        }
        if (lead === 0x28 && (bite === 0x42 || bite === 0x4A)) {
          iso2022jp_state = state.ASCII;
          return null;
        }
        if (lead === 0x28 && bite === 0x49) {
          iso2022jp_state = state.Katakana;
          return null;
        }
        if (bite === EOF_byte) {
          byte_pointer.offset(-1);
        } else {
          byte_pointer.offset(-2);
        }
        iso2022jp_state = state.ASCII;
        return decoderError(fatal);

      case state.escape_final:
        if (bite === 0x44) {
          iso2022jp_jis0212 = true;
          iso2022jp_state = state.lead;
          return null;
        }
        if (bite === EOF_byte) {
          byte_pointer.offset(-2);
        } else {
          byte_pointer.offset(-3);
        }
        iso2022jp_state = state.ASCII;
        return decoderError(fatal);

      case state.lead:
        if (bite === 0x0A) {
          iso2022jp_state = state.ASCII;
          return decoderError(fatal, 0x000A);
        }
        if (bite === 0x1B) {
          iso2022jp_state = state.escape_start;
          return null;
        }
        if (bite === EOF_byte) {
          return EOF_code_point;
        }
        iso2022jp_lead = bite;
        iso2022jp_state = state.trail;
        return null;

      case state.trail:
        iso2022jp_state = state.lead;
        if (bite === EOF_byte) {
          return decoderError(fatal);
        }
        var code_point = null;
        var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;
        if (inRange(iso2022jp_lead, 0x21, 0x7E) && inRange(bite, 0x21, 0x7E)) {
          code_point = (iso2022jp_jis0212 === false) ?
            indexCodePointFor(pointer, indexes['jis0208']) :
            indexCodePointFor(pointer, indexes['jis0212']);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;

      case state.Katakana:
        if (bite === 0x1B) {
          iso2022jp_state = state.escape_start;
          return null;
        }
        if (inRange(bite, 0x21, 0x5F)) {
          return 0xFF61 + bite - 0x21;
        }
        if (bite === EOF_byte) {
          return EOF_code_point;
        }
        return decoderError(fatal);
      }
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022JPEncoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      lead: 1,
      Katakana: 2
    };
    var /** @type {number} */ iso2022jp_state = state.ASCII;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if ((inRange(code_point, 0x0000, 0x007F) ||
           code_point === 0x00A5 || code_point === 0x203E) &&
          iso2022jp_state !== state.ASCII) {
        code_point_pointer.offset(-1);
        iso2022jp_state = state.ASCII;
        return output_byte_stream.emit(0x1B, 0x28, 0x42);
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      if (code_point === 0x00A5) {
        return output_byte_stream.emit(0x5C);
      }
      if (code_point === 0x203E) {
        return output_byte_stream.emit(0x7E);
      }
      if (inRange(code_point, 0xFF61, 0xFF9F) &&
          iso2022jp_state !== state.Katakana) {
        code_point_pointer.offset(-1);
        iso2022jp_state = state.Katakana;
        return output_byte_stream.emit(0x1B, 0x28, 0x49);
      }
      if (inRange(code_point, 0xFF61, 0xFF9F)) {
        return output_byte_stream.emit(code_point - 0xFF61 - 0x21);
      }
      if (iso2022jp_state !== state.lead) {
        code_point_pointer.offset(-1);
        iso2022jp_state = state.lead;
        return output_byte_stream.emit(0x1B, 0x24, 0x42);
      }
      var pointer = indexPointerFor(code_point, indexes['jis0208']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead = div(pointer, 94) + 0x21;
      var trail = pointer % 94 + 0x21;
      return output_byte_stream.emit(lead, trail);
    };
  }

  name_to_encoding['iso-2022-jp'].getEncoder = function(options) {
    return new ISO2022JPEncoder(options);
  };
  name_to_encoding['iso-2022-jp'].getDecoder = function(options) {
    return new ISO2022JPDecoder(options);
  };

  // 11.3 shift_jis

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ShiftJISDecoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ shiftjis_lead = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte && shiftjis_lead === 0x00) {
        return EOF_code_point;
      }
      if (bite === EOF_byte && shiftjis_lead !== 0x00) {
        shiftjis_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (shiftjis_lead !== 0x00) {
        var lead = shiftjis_lead;
        shiftjis_lead = 0x00;
        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) {
          var offset = (bite < 0x7F) ? 0x40 : 0x41;
          var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;
          var code_point = indexCodePointFor((lead - lead_offset) * 188 +
                                             bite - offset, indexes['jis0208']);
          if (code_point === null) {
            return decoderError(fatal);
          }
          return code_point;
        }
        byte_pointer.offset(-1);
        return decoderError(fatal);
      }
      if (inRange(bite, 0x00, 0x80)) {
        return bite;
      }
      if (inRange(bite, 0xA1, 0xDF)) {
        return 0xFF61 + bite - 0xA1;
      }
      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {
        shiftjis_lead = bite;
        return null;
      }
      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ShiftJISEncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x0080)) {
        return output_byte_stream.emit(code_point);
      }
      if (code_point === 0x00A5) {
        return output_byte_stream.emit(0x5C);
      }
      if (code_point === 0x203E) {
        return output_byte_stream.emit(0x7E);
      }
      if (inRange(code_point, 0xFF61, 0xFF9F)) {
        return output_byte_stream.emit(code_point - 0xFF61 + 0xA1);
      }
      var pointer = indexPointerFor(code_point, indexes['jis0208']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead = div(pointer, 188);
      var lead_offset = lead < 0x1F ? 0x81 : 0xC1;
      var trail = pointer % 188;
      var offset = trail < 0x3F ? 0x40 : 0x41;
      return output_byte_stream.emit(lead + lead_offset, trail + offset);
    };
  }

  name_to_encoding['shift_jis'].getEncoder = function(options) {
    return new ShiftJISEncoder(options);
  };
  name_to_encoding['shift_jis'].getDecoder = function(options) {
    return new ShiftJISDecoder(options);
  };

  //
  // 12. Legacy multi-byte Korean encodings
  //

  // 12.1 euc-kr

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function EUCKRDecoder(options) {
    var fatal = options.fatal;
    var /** @type {number} */ euckr_lead = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte && euckr_lead === 0) {
        return EOF_code_point;
      }
      if (bite === EOF_byte && euckr_lead !== 0) {
        euckr_lead = 0x00;
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (euckr_lead !== 0x00) {
        var lead = euckr_lead;
        var pointer = null;
        euckr_lead = 0x00;

        if (inRange(lead, 0x81, 0xC6)) {
          var temp = (26 + 26 + 126) * (lead - 0x81);
          if (inRange(bite, 0x41, 0x5A)) {
            pointer = temp + bite - 0x41;
          } else if (inRange(bite, 0x61, 0x7A)) {
            pointer = temp + 26 + bite - 0x61;
          } else if (inRange(bite, 0x81, 0xFE)) {
            pointer = temp + 26 + 26 + bite - 0x81;
          }
        }

        if (inRange(lead, 0xC7, 0xFD) && inRange(bite, 0xA1, 0xFE)) {
          pointer = (26 + 26 + 126) * (0xC7 - 0x81) + (lead - 0xC7) * 94 +
            (bite - 0xA1);
        }

        var code_point = (pointer === null) ? null :
              indexCodePointFor(pointer, indexes['euc-kr']);
        if (pointer === null) {
          byte_pointer.offset(-1);
        }
        if (code_point === null) {
          return decoderError(fatal);
        }
        return code_point;
      }

      if (inRange(bite, 0x00, 0x7F)) {
        return bite;
      }

      if (inRange(bite, 0x81, 0xFD)) {
        euckr_lead = bite;
        return null;
      }

      return decoderError(fatal);
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function EUCKREncoder(options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      var pointer = indexPointerFor(code_point, indexes['euc-kr']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead, trail;
      if (pointer < ((26 + 26 + 126) * (0xC7 - 0x81))) {
        lead = div(pointer, (26 + 26 + 126)) + 0x81;
        trail = pointer % (26 + 26 + 126);
        var offset = trail < 26 ? 0x41 : trail < 26 + 26 ? 0x47 : 0x4D;
        return output_byte_stream.emit(lead, trail + offset);
      }
      pointer = pointer - (26 + 26 + 126) * (0xC7 - 0x81);
      lead = div(pointer, 94) + 0xC7;
      trail = pointer % 94 + 0xA1;
      return output_byte_stream.emit(lead, trail);
    };
  }

  name_to_encoding['euc-kr'].getEncoder = function(options) {
    return new EUCKREncoder(options);
  };
  name_to_encoding['euc-kr'].getDecoder = function(options) {
    return new EUCKRDecoder(options);
  };

  // 12.2 iso-2022-kr

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022KRDecoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      escape_start: 1,
      escape_middle: 2,
      escape_end: 3,
      lead: 4,
      trail: 5
    };
    var /** @type {number} */ iso2022kr_state = state.ASCII,
        /** @type {number} */ iso2022kr_lead = 0x00;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite !== EOF_byte) {
        byte_pointer.offset(1);
      }
      switch (iso2022kr_state) {
      default:
      case state.ASCII:
        if (bite === 0x0E) {
          iso2022kr_state = state.lead;
          return null;
        }
        if (bite === 0x0F) {
          return null;
        }
        if (bite === 0x1B) {
          iso2022kr_state = state.escape_start;
          return null;
        }
        if (inRange(bite, 0x00, 0x7F)) {
          return bite;
        }
        if (bite === EOF_byte) {
          return EOF_code_point;
        }
        return decoderError(fatal);
      case state.escape_start:
        if (bite === 0x24) {
          iso2022kr_state = state.escape_middle;
          return null;
        }
        if (bite !== EOF_byte) {
          byte_pointer.offset(-1);
        }
        iso2022kr_state = state.ASCII;
        return decoderError(fatal);
      case state.escape_middle:
        if (bite === 0x29) {
          iso2022kr_state = state.escape_end;
          return null;
        }
        if (bite === EOF_byte) {
          byte_pointer.offset(-1);
        } else {
          byte_pointer.offset(-2);
        }
        iso2022kr_state = state.ASCII;
        return decoderError(fatal);
      case state.escape_end:
        if (bite === 0x43) {
          iso2022kr_state = state.ASCII;
          return null;
        }
        if (bite === EOF_byte) {
          byte_pointer.offset(-2);
        } else {
          byte_pointer.offset(-3);
        }
        iso2022kr_state = state.ASCII;
        return decoderError(fatal);
      case state.lead:
        if (bite === 0x0A) {
          iso2022kr_state = state.ASCII;
          return decoderError(fatal, 0x000A);
        }
        if (bite === 0x0E) {
          return null;
        }
        if (bite === 0x0F) {
          iso2022kr_state = state.ASCII;
          return null;
        }
        if (bite === EOF_byte) {
          return EOF_code_point;
        }
        iso2022kr_lead = bite;
        iso2022kr_state = state.trail;
        return null;
      case state.trail:
        iso2022kr_state = state.lead;
        if (bite === EOF_byte) {
          return decoderError(fatal);
        }
        var code_point = null;
        if (inRange(iso2022kr_lead, 0x21, 0x46) && inRange(bite, 0x21, 0x7E)) {
          code_point = indexCodePointFor((26 + 26 + 126) *
                                         (iso2022kr_lead - 1) +
                                         26 + 26 + bite - 1,
                                         indexes['euc-kr']);
        } else if (inRange(iso2022kr_lead, 0x47, 0x7E) &&
                   inRange(bite, 0x21, 0x7E)) {
          code_point = indexCodePointFor((26 + 26 + 126) * (0xC7 - 0x81) +
                                         (iso2022kr_lead - 0x47) * 94 +
                                         (bite - 0x21),
                                         indexes['euc-kr']);
        }
        if (code_point !== null) {
          return code_point;
        }
        return decoderError(fatal);
      }
    };
  }

  /**
   * @constructor
   * @param {{fatal: boolean}} options
   */
  function ISO2022KREncoder(options) {
    var fatal = options.fatal;
    /** @enum */
    var state = {
      ASCII: 0,
      lead: 1
    };
    var /** @type {boolean} */ iso2022kr_initialization = false,
        /** @type {number} */ iso2022kr_state = state.ASCII;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      if (!iso2022kr_initialization) {
        iso2022kr_initialization = true;
        output_byte_stream.emit(0x1B, 0x24, 0x29, 0x43);
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0x0000, 0x007F) &&
          iso2022kr_state !== state.ASCII) {
        code_point_pointer.offset(-1);
        iso2022kr_state = state.ASCII;
        return output_byte_stream.emit(0x0F);
      }
      if (inRange(code_point, 0x0000, 0x007F)) {
        return output_byte_stream.emit(code_point);
      }
      if (iso2022kr_state !== state.lead) {
        code_point_pointer.offset(-1);
        iso2022kr_state = state.lead;
        return output_byte_stream.emit(0x0E);
      }
      var pointer = indexPointerFor(code_point, indexes['euc-kr']);
      if (pointer === null) {
        return encoderError(code_point);
      }
      var lead, trail;
      if (pointer < (26 + 26 + 126) * (0xC7 - 0x81)) {
        lead = div(pointer, (26 + 26 + 126)) + 1;
        trail = pointer % (26 + 26 + 126) - 26 - 26 + 1;
        if (!inRange(lead, 0x21, 0x46) || !inRange(trail, 0x21, 0x7E)) {
          return encoderError(code_point);
        }
        return output_byte_stream.emit(lead, trail);
      }
      pointer = pointer - (26 + 26 + 126) * (0xC7 - 0x81);
      lead = div(pointer, 94) + 0x47;
      trail = pointer % 94 + 0x21;
      if (!inRange(lead, 0x47, 0x7E) || !inRange(trail, 0x21, 0x7E)) {
        return encoderError(code_point);
      }
      return output_byte_stream.emit(lead, trail);
    };
  }

  name_to_encoding['iso-2022-kr'].getEncoder = function(options) {
    return new ISO2022KREncoder(options);
  };
  name_to_encoding['iso-2022-kr'].getDecoder = function(options) {
    return new ISO2022KRDecoder(options);
  };


  //
  // 13. Legacy utf-16 encodings
  //

  // 13.1 utf-16

  /**
   * @constructor
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Decoder(utf16_be, options) {
    var fatal = options.fatal;
    var /** @type {?number} */ utf16_lead_byte = null,
        /** @type {?number} */ utf16_lead_surrogate = null;
    /**
     * @param {ByteInputStream} byte_pointer
     * @return {?number} The next code point decoded, or null if not enough
     *     data exists in the input stream to decode a complete code point.
     */
    this.decode = function(byte_pointer) {
      var bite = byte_pointer.get();
      if (bite === EOF_byte && utf16_lead_byte === null &&
          utf16_lead_surrogate === null) {
        return EOF_code_point;
      }
      if (bite === EOF_byte && (utf16_lead_byte !== null ||
                                utf16_lead_surrogate !== null)) {
        return decoderError(fatal);
      }
      byte_pointer.offset(1);
      if (utf16_lead_byte === null) {
        utf16_lead_byte = bite;
        return null;
      }
      var code_point;
      if (utf16_be) {
        code_point = (utf16_lead_byte << 8) + bite;
      } else {
        code_point = (bite << 8) + utf16_lead_byte;
      }
      utf16_lead_byte = null;
      if (utf16_lead_surrogate !== null) {
        var lead_surrogate = utf16_lead_surrogate;
        utf16_lead_surrogate = null;
        if (inRange(code_point, 0xDC00, 0xDFFF)) {
          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +
            (code_point - 0xDC00);
        }
        byte_pointer.offset(-2);
        return decoderError(fatal);
      }
      if (inRange(code_point, 0xD800, 0xDBFF)) {
        utf16_lead_surrogate = code_point;
        return null;
      }
      if (inRange(code_point, 0xDC00, 0xDFFF)) {
        return decoderError(fatal);
      }
      return code_point;
    };
  }

  /**
   * @constructor
   * @param {boolean} utf16_be True if big-endian, false if little-endian.
   * @param {{fatal: boolean}} options
   */
  function UTF16Encoder(utf16_be, options) {
    var fatal = options.fatal;
    /**
     * @param {ByteOutputStream} output_byte_stream Output byte stream.
     * @param {CodePointInputStream} code_point_pointer Input stream.
     * @return {number} The last byte emitted.
     */
    this.encode = function(output_byte_stream, code_point_pointer) {
      function convert_to_bytes(code_unit) {
        var byte1 = code_unit >> 8;
        var byte2 = code_unit & 0x00FF;
        if (utf16_be) {
          return output_byte_stream.emit(byte1, byte2);
        }
        return output_byte_stream.emit(byte2, byte1);
      }
      var code_point = code_point_pointer.get();
      if (code_point === EOF_code_point) {
        return EOF_byte;
      }
      code_point_pointer.offset(1);
      if (inRange(code_point, 0xD800, 0xDFFF)) {
        encoderError(code_point);
      }
      if (code_point <= 0xFFFF) {
        return convert_to_bytes(code_point);
      }
      var lead = div((code_point - 0x10000), 0x400) + 0xD800;
      var trail = ((code_point - 0x10000) % 0x400) + 0xDC00;
      convert_to_bytes(lead);
      return convert_to_bytes(trail);
    };
  }

  name_to_encoding['utf-16'].getEncoder = function(options) {
    return new UTF16Encoder(false, options);
  };
  name_to_encoding['utf-16'].getDecoder = function(options) {
    return new UTF16Decoder(false, options);
  };

  // 13.2 utf-16be
  name_to_encoding['utf-16be'].getEncoder = function(options) {
    return new UTF16Encoder(true, options);
  };
  name_to_encoding['utf-16be'].getDecoder = function(options) {
    return new UTF16Decoder(true, options);
  };


  // NOTE: currently unused
  function detectEncoding(label, input_stream) {
    if (input_stream.match([0xFF, 0xFE])) {
      input_stream.offset(2);
      return 'utf-16';
    }
    if (input_stream.match([0xFE, 0xFF])) {
      input_stream.offset(2);
      return 'utf-16be';
    }
    if (input_stream.match([0xEF, 0xBB, 0xBF])) {
      input_stream.offset(3);
      return 'utf-8';
    }
    return label;
  }

  //
  // Implementation of Text Encoding Web API
  //

  /** @const */ var DEFAULT_ENCODING = 'utf-8';

  /**
   * @constructor
   * @param {string=} opt_encoding The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {{fatal: boolean}=} options
   */
  function TextEncoder(opt_encoding, options) {
    if (!this || this === global) {
      return new TextEncoder(opt_encoding, options);
    }
    opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;
    options = Object(options);
    /** @private */
    this._encoding = getEncoding(opt_encoding); // may throw
    /** @private @type {boolean} */
    this._streaming = false;
    /** @private */
    this._encoder = null;
    /** @private @type {{fatal: boolean}=} */
    this._options = { fatal: Boolean(options.fatal) };

    if (Object.defineProperty) {
      Object.defineProperty(
        this, 'encoding',
        { get: function() { return this._encoding.name; } });
    } else {
      this.encoding = this._encoding.name;
    }

    return this;
  }

  TextEncoder.prototype = {
    /**
     * @param {string=} opt_string The string to encode.
     * @param {{stream: boolean}=} options
     */
    encode: function encode(opt_string, options) {
      opt_string = opt_string ? String(opt_string) : '';
      options = Object(options);
      // TODO: any options?
      if (!this._streaming) {
        this._encoder = this._encoding.getEncoder(this._options);
      }
      this._streaming = Boolean(options.stream);

      var bytes = [];
      var output_stream = new ByteOutputStream(bytes);
      var input_stream = new CodePointInputStream(opt_string);
      while (input_stream.get() !== EOF_code_point) {
        this._encoder.encode(output_stream, input_stream);
      }
      if (!this._streaming) {
        var last_byte;
        do {
          last_byte = this._encoder.encode(output_stream, input_stream);
        } while (last_byte !== EOF_byte);
        this._encoder = null;
      }
      return new Uint8Array(bytes);
    }
  };


  /**
   * @constructor
   * @param {string=} opt_encoding The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {{fatal: boolean}=} options
   */
  function TextDecoder(opt_encoding, options) {
    if (!this || this === global) {
      return new TextDecoder(opt_encoding, options);
    }
    opt_encoding = opt_encoding ? String(opt_encoding) : DEFAULT_ENCODING;
    options = Object(options);
    /** @private */
    this._encoding = getEncoding(opt_encoding); // may throw
    /** @private @type {boolean} */
    this._streaming = false;
    /** @private */
    this._decoder = null;
    /** @private @type {{fatal: boolean}=} */
    this._options = { fatal: Boolean(options.fatal) };

    if (Object.defineProperty) {
      Object.defineProperty(
        this, 'encoding',
        { get: function() { return this._encoding.name; } });
    } else {
      this.encoding = this._encoding.name;
    }

    return this;
  }

  // TODO: Issue if input byte stream is offset by decoder
  // TODO: BOM detection will not work if stream header spans multiple calls
  // (last N bytes of previous stream may need to be retained?)
  TextDecoder.prototype = {
    /**
     * @param {ArrayBufferView=} opt_view The buffer of bytes to decode.
     * @param {{stream: boolean}=} options
     */
    decode: function decode(opt_view, options) {
      if (opt_view && !('buffer' in opt_view && 'byteOffset' in opt_view &&
                        'byteLength' in opt_view)) {
        throw new TypeError('Expected ArrayBufferView');
      } else if (!opt_view) {
        opt_view = new Uint8Array(0);
      }
      options = Object(options);

      if (!this._streaming) {
        this._decoder = this._encoding.getDecoder(this._options);
      }
      this._streaming = Boolean(options.stream);

      // TODO: encoding detection via BOM?

      var bytes = new Uint8Array(opt_view.buffer,
                                 opt_view.byteOffset,
                                 opt_view.byteLength);
      var input_stream = new ByteInputStream(bytes);

      var detected = detectEncoding(this._encoding.name, input_stream);
      if (getEncoding(detected) !== this._encoding) {
        throw new Error('BOM mismatch'); // TODO: what to do here?
      }

      var output_stream = new CodePointOutputStream(), code_point;
      while (input_stream.get() !== EOF_byte) {
        code_point = this._decoder.decode(input_stream);
        if (code_point !== null && code_point !== EOF_code_point) {
          output_stream.emit(code_point);
        }
      }
      if (!this._streaming) {
        do {
          code_point = this._decoder.decode(input_stream);
          if (code_point !== null && code_point !== EOF_code_point) {
            output_stream.emit(code_point);
          }
        } while (code_point !== EOF_code_point);
        this._decoder = null;
      }
      return output_stream.string();
    }
  };

  global['TextEncoder'] = global['TextEncoder'] || TextEncoder;
  global['TextDecoder'] = global['TextDecoder'] || TextDecoder;
}(this));

;/*
 * BioDigital Human RPC Messaging Client
 *
 * V2
 *
 * Built on 2016-08-24
 *
 * Copyright 2016, BioDigital, Inc.
 */

!function(){"use strict";window.HumanAPI=function a(b){var c=this;"string"==typeof b&&(b={iframeId:b}),b.onReady=function(){c._ready=!0;for(var a=0,b=c._readyCallbacks.length;b>a;a++)c._readyCallbacks[a](),c._readyCallbacks.length=0},c._rpc=new a.WindowRPCClient(b),c._ready=!1,c._readyCallbacks=[]},HumanAPI.prototype.send=function(a,b,c){return"function"==typeof b&&(c=b,b={}),"function"==typeof c&&(c=c.bind(this)),this._rpc.call(a,b||{},c),this},HumanAPI.prototype.on=function(a,b){return"function"==typeof b&&(b=b.bind(this)),"human.ready"===a?(this._ready?b():this._readyCallbacks.push(b),this):(this._rpc.call("apiEvents.on",a,b,!1),this)},HumanAPI.prototype.once=function(a,b){return"function"==typeof b&&(b=b.bind(this)),"human.ready"===a?(this._ready?b():this._readyCallbacks.push(b),this):(this._rpc.call("apiEvents.once",a,b,!0),this)}}(),function(){"use strict";HumanAPI.Map=function(a,b){this.items=a||[];var c=b||0,d=c+1;this.addItem=function(){var a;if(2===arguments.length){var b=arguments[0];if(a=arguments[1],this.items[b])throw"ID clash: '"+b+"'";return this.items[b]=a,b}for(;;){a=arguments[0];var c=d++;if(!this.items[c])return this.items[c]=a,c}},this.removeItem=function(a){delete this.items[a]}}}(),function(){"use strict";HumanAPI.WindowRPCClient=function(a){if(!a.iframeId)throw"config expected: iframeId";if(this._iframe=document.getElementById(a.iframeId),!this._iframe)throw"iframe not found: '"+a.iframeId+"'";if(!this._iframe.contentWindow)throw"element is not an iframe: '"+a.iframeId+"'";this.destroyed=!1,this._handleMap=new HumanAPI.Map({},Date.now()),this._subs={},this._ready=!1,this._messageBuffer=[],this._messageBufferConnected=[],this._connect(a.onUnsupported,a.onConnected,a.onReady)},HumanAPI.WindowRPCClient.prototype._connect=function(a,b,c){var d=null,e=this,f=100,g=function(){h(),d=setInterval(function(){return!e.destroyed&&e._iframe&&e._iframe.contentWindow?void e._iframe.contentWindow.postMessage(JSON.stringify({action:"connect"}),"*"):void h()},f)},h=function(){d&&(clearInterval(d),d=null)};window.addEventListener("message",function(d){var f=d.data;switch(f){case"unsupported":"function"==typeof a&&a(d.data);break;default:var g;try{g=JSON.parse(f)}catch(i){return}if(g.message){var j=g.message;switch(j){case"connected":e._connected=!0,e._sendQueuedMessages(!0),"function"==typeof b&&b();break;case"status":switch(g.status){case"ready":e._ready=!0,h(),e._sendQueuedMessages(),"function"==typeof c&&c()}}}if(g.results||g.response){var k,l=g.results||g.response;for(var m in l)l.hasOwnProperty(m)&&(k=l[m],e._subs[m]&&e.set(m,k))}g.error}},!1),e._iframe.addEventListener("load",g),e._iframe.addEventListener("unload",h),g()},HumanAPI.WindowRPCClient.prototype._sendQueuedMessages=function(a){for(var b=a?this._messageBufferConnected:this._messageBuffer;b.length>0;){var c=b.pop();this._send(c,c.ok,c.once)}},HumanAPI.WindowRPCClient.prototype.call=function(a,b,c,d){var e={call:a,params:b,ok:c,once:d},f=b.connected?this._messageBufferConnected:this._messageBuffer;this._ready||this._connected&&b.connected?this._send(e,c,d):f.unshift(e)},HumanAPI.WindowRPCClient.prototype._send=function(a,b,c){if(b){var d=this,e=this._on(function(a){(void 0===c||c===!0)&&d._off(e),b.call(d,a)});a.id=e,this._sendMessage(a)}else this._sendMessage(a)},HumanAPI.WindowRPCClient.prototype._sendMessage=function(a){this._onSend&&this._onSend(a),this.destroyed||this._iframe.contentWindow.postMessage(JSON.stringify(a),"*")},HumanAPI.WindowRPCClient.prototype.set=function(a,b){var c=this._subs[a];c&&c.call(this,b)},HumanAPI.WindowRPCClient.prototype._on=function(a){var b=this._handleMap.addItem();return this._subs[b]=a,b},HumanAPI.WindowRPCClient.prototype._off=function(a){delete this._subs[a],this._handleMap.removeItem(a)},HumanAPI.WindowRPCClient.prototype.destroy=function(){this.destroyed=!0}}();
;!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((n=n||self).immer={})}(this,(function(n){function t(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function r(n){return!!n&&!!n[B]}function e(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);return!t||t===Object.prototype}(n)||Array.isArray(n)||!!n[q]||!!n.constructor[q]||c(n)||v(n))}function i(n,t,r){void 0===r&&(r=!1),0===u(n)?(r?Object.keys:H)(n).forEach((function(r){return t(r,n[r],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function u(n){var t=n[B];return t?t.t>3?t.t-4:t.t:Array.isArray(n)?1:c(n)?2:v(n)?3:0}function o(n,t){return 2===u(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function f(n,t){return 2===u(n)?n.get(t):n[t]}function a(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function c(n){return C&&n instanceof Map}function v(n){return I&&n instanceof Set}function s(n){return n.i||n.u}function p(n,r){if(void 0===r&&(r=!1),Array.isArray(n))return n.slice();var e=Object.create(Object.getPrototypeOf(n));return i(n,(function(i){if(i!==B){var u=Object.getOwnPropertyDescriptor(n,i),o=u.value;u.get&&(r||t(1),o=u.get.call(n)),u.enumerable?e[i]=o:Object.defineProperty(e,i,{value:o,writable:!0,configurable:!0})}})),e}function h(n,t){r(n)||d(n)||!e(n)||(u(n)>1&&(n.set=n.add=n.clear=n.delete=l),Object.freeze(n),t&&i(n,(function(n,t){return h(t,!0)}),!0))}function l(){t(2)}function d(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function _(n){var r=L[n];return r||t(19,n),r}function y(n,t){L[n]=t}function b(){return N}function m(n,t){t&&(_("Patches"),n.o=[],n.v=[],n.s=t)}function j(n){O(n),n.p.forEach(w),n.p=null}function O(n){n===N&&(N=n.h)}function S(n){return N={p:[],h:N,l:n,_:!0,m:0}}function w(n){var t=n[B];0===t.t||1===t.t?t.j():t.O=!0}function P(n,r){r.m=r.p.length;var i=r.p[0],u=void 0!==n&&n!==i;return r.l.S||_("ES5").P(r,n,u),u?(i[B].M&&(j(r),t(4)),e(n)&&(n=M(r,n),r.h||A(r,n)),r.o&&_("Patches").g(i[B],n,r.o,r.v)):n=M(r,i,[]),j(r),r.o&&r.s(r.o,r.v),n!==X?n:void 0}function M(n,t,r){if(d(t))return t;var e=t[B];if(!e)return i(t,(function(i,u){return g(n,e,t,i,u,r)}),!0),t;if(e.A!==n)return t;if(!e.M)return A(n,e.u,!0),e.u;if(!e.R){e.R=!0,e.A.m--;var u=4===e.t||5===e.t?e.i=p(e.k,!0):e.i;i(u,(function(t,i){return g(n,e,u,t,i,r)})),A(n,u,!1),r&&n.o&&_("Patches").F(e,r,n.o,n.v)}return e.i}function g(n,t,i,c,v,s){if(r(v)){var p=M(n,v,s&&t&&3!==t.t&&!o(t.D,c)?s.concat(c):void 0);if(l=c,d=p,2===(_=u(h=i))?h.set(l,d):3===_?(h.delete(l),h.add(d)):h[l]=d,!r(p))return;n._=!1}var h,l,d,_;if((!t||!a(v,f(t.u,c)))&&e(v)){if(!n.l.J&&n.m<1)return;M(n,v),t&&t.A.h||A(n,v)}}function A(n,t,r){void 0===r&&(r=!1),n.l.J&&n._&&h(t,r)}function x(n,t){var r=n[B],e=Reflect.getOwnPropertyDescriptor(r?s(r):n,t);return e&&e.value}function z(n){if(!n.M){if(n.M=!0,0===n.t||1===n.t){var t=n.i=p(n.u);i(n.p,(function(n,r){t[n]=r})),n.p=void 0}n.h&&z(n.h)}}function E(n){n.i||(n.i=p(n.u))}function R(n,t,r){var e=c(t)?_("MapSet").K(t,r):v(t)?_("MapSet").N(t,r):n.S?function(n,t){var r=Array.isArray(n),e={t:r?1:0,A:t?t.A:b(),M:!1,R:!1,D:{},h:t,u:n,k:null,p:{},i:null,j:null,$:!1},i=e,u=Q;r&&(i=[e],u=T);var o=Proxy.revocable(i,u),f=o.revoke,a=o.proxy;return e.k=a,e.j=f,a}(t,r):_("ES5").C(t,r);return(r?r.A:b()).p.push(e),e}function k(n,t){n.S?z(t):_("ES5").I(t)}function F(){function n(n,t){var r=n[B];if(r&&!r.W){r.W=!0;var e=n[t];return r.W=!1,e}return n[t]}function u(n){n.M||(n.M=!0,n.h&&u(n.h))}function f(n){n.i||(n.i=c(n.u))}function c(n){var t=n&&n[B];if(t){t.W=!0;var r=p(t.k,!0);return t.W=!1,r}return p(n)}function v(n){for(var t=n.length-1;t>=0;t--){var r=n[t][B];if(!r.M)switch(r.t){case 5:l(r)&&u(r);break;case 4:h(r)&&u(r)}}}function h(n){for(var t=n.u,r=n.k,e=Object.keys(r),i=e.length-1;i>=0;i--){var u=e[i],f=t[u];if(void 0===f&&!o(t,u))return!0;var c=r[u],v=c&&c[B];if(v?v.u!==f:!a(c,f))return!0}return e.length!==Object.keys(t).length}function l(n){var t=n.k;if(t.length!==n.u.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);return!(!r||r.get)}function d(n){n.O&&t(3,JSON.stringify(s(n)))}var _={};y("ES5",{C:function(t,r){var o=Array.isArray(t),v=c(t);i(v,(function(r){!function(t,r,i){var o=_[r];o?o.enumerable=i:_[r]=o={enumerable:i,get:function(){return function(t,r){d(t);var i=n(s(t),r);return t.W?i:i===n(t.u,r)&&e(i)?(f(t),t.i[r]=R(t.A.l,i,t)):i}(this[B],r)},set:function(t){!function(t,r,e){if(d(t),t.D[r]=!0,!t.M){if(a(e,n(s(t),r)))return;u(t),f(t)}t.i[r]=e}(this[B],r,t)}},Object.defineProperty(t,r,o)}(v,r,o||function(n,t){var r=Object.getOwnPropertyDescriptor(n,t);return!(!r||!r.enumerable)}(t,r))}));var p={t:o?5:4,A:r?r.A:b(),M:!1,W:!1,R:!1,D:{},h:r,u:t,k:v,i:null,O:!1,$:!1};return Object.defineProperty(v,B,{value:p,writable:!0}),v},I:u,P:function(n,t,e){n.p.forEach((function(n){n[B].W=!0})),e?r(t)&&t[B].A===n&&v(n.p):(n.o&&function n(t){if(t&&"object"==typeof t){var r=t[B];if(r){var e=r.u,f=r.k,a=r.D,c=r.t;if(4===c)i(f,(function(t){t!==B&&(void 0!==e[t]||o(e,t)?a[t]||n(f[t]):(a[t]=!0,u(r)))})),i(e,(function(n){void 0!==f[n]||o(f,n)||(a[n]=!1,u(r))}));else if(5===c){if(l(r)&&(u(r),a.length=!0),f.length<e.length)for(var v=f.length;v<e.length;v++)a[v]=!1;else for(var s=e.length;s<f.length;s++)a[s]=!0;for(var p=Math.min(f.length,e.length),h=0;h<p;h++)void 0===a[h]&&n(f[h])}}}}(n.p[0]),v(n.p))}})}function D(){function n(t){if(!t||"object"!=typeof t)return t;if(Array.isArray(t))return t.map(n);if(c(t))return new Map(Array.from(t.entries()).map((function(t){return[t[0],n(t[1])]})));if(v(t))return new Set(Array.from(t).map(n));var r=Object.create(Object.getPrototypeOf(t));for(var e in t)r[e]=n(t[e]);return r}function e(t){return r(t)?n(t):t}var a="add";y("Patches",{X:function(r,e){return e.forEach((function(e){for(var i=e.path,o=e.op,c=r,v=0;v<i.length-1;v++)"object"!=typeof(c=f(c,i[v]))&&t(15,i.join("/"));var s=u(c),p=n(e.value),h=i[i.length-1];switch(o){case"replace":switch(s){case 2:return c.set(h,p);case 3:t(16);default:return c[h]=p}case a:switch(s){case 1:return c.splice(h,0,p);case 2:return c.set(h,p);case 3:return c.add(p);default:return c[h]=p}case"remove":switch(s){case 1:return c.splice(h,1);case 2:return c.delete(h);case 3:return c.delete(e.value);default:return delete c[h]}default:t(17,o)}})),r},F:function(n,t,r,u){switch(n.t){case 0:case 4:case 2:return function(n,t,r,u){var c=n.u,v=n.i;i(n.D,(function(n,i){var s=f(c,n),p=f(v,n),h=i?o(c,n)?"replace":a:"remove";if(s!==p||"replace"!==h){var l=t.concat(n);r.push("remove"===h?{op:h,path:l}:{op:h,path:l,value:p}),u.push(h===a?{op:"remove",path:l}:"remove"===h?{op:a,path:l,value:e(s)}:{op:"replace",path:l,value:e(s)})}}))}(n,t,r,u);case 5:case 1:return function(n,t,r,i){var u=n.u,o=n.D,f=n.i;if(f.length<u.length){var c=[f,u];u=c[0],f=c[1];var v=[i,r];r=v[0],i=v[1]}for(var s=f.length-u.length,p=0;u[p]===f[p]&&p<u.length;)++p;for(var h=u.length;h>p&&u[h-1]===f[h+s-1];)--h;for(var l=p;l<h;++l)if(o[l]&&f[l]!==u[l]){var d=t.concat([l]);r.push({op:"replace",path:d,value:e(f[l])}),i.push({op:"replace",path:d,value:e(u[l])})}for(var _=r.length,y=h+s-1;y>=h;--y){var b=t.concat([y]);r[_+y-h]={op:a,path:b,value:e(f[y])},i.push({op:"remove",path:b})}}(n,t,r,u);case 3:return function(n,t,r,e){var i=n.u,u=n.i,o=0;i.forEach((function(n){if(!u.has(n)){var i=t.concat([o]);r.push({op:"remove",path:i,value:n}),e.unshift({op:a,path:i,value:n})}o++})),o=0,u.forEach((function(n){if(!i.has(n)){var u=t.concat([o]);r.push({op:a,path:u,value:n}),e.unshift({op:"remove",path:u,value:n})}o++}))}(n,t,r,u)}},g:function(n,t,r,e){r.push({op:"replace",path:[],value:t}),e.push({op:"replace",path:[],value:n.u})}})}function J(){function n(n,t){function r(){this.constructor=n}o(n,t),n.prototype=(r.prototype=t.prototype,new r)}function r(n){n.i||(n.D=new Map,n.i=new Map(n.u))}function i(n){n.i||(n.i=new Set,n.u.forEach((function(t){if(e(t)){var r=R(n.A.l,t,n);n.p.set(t,r),n.i.add(r)}else n.i.add(t)})))}function u(n){n.O&&t(3,JSON.stringify(s(n)))}var o=function(n,t){return(o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},f=function(){function t(n,t){return this[B]={t:2,h:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,D:void 0,u:n,k:this,$:!1,O:!1},this}n(t,Map);var i=t.prototype;return Object.defineProperty(i,"size",{get:function(){return s(this[B]).size}}),i.has=function(n){return s(this[B]).has(n)},i.set=function(n,t){var e=this[B];return u(e),s(e).get(n)!==t&&(r(e),k(e.A.l,e),e.D.set(n,!0),e.i.set(n,t),e.D.set(n,!0)),this},i.delete=function(n){if(!this.has(n))return!1;var t=this[B];return u(t),r(t),k(t.A.l,t),t.D.set(n,!1),t.i.delete(n),!0},i.clear=function(){var n=this[B];return u(n),r(n),k(n.A.l,n),n.D=new Map,n.i.clear()},i.forEach=function(n,t){var r=this;s(this[B]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},i.get=function(n){var t=this[B];u(t);var i=s(t).get(n);if(t.R||!e(i))return i;if(i!==t.u.get(n))return i;var o=R(t.A.l,i,t);return r(t),t.i.set(n,o),o},i.keys=function(){return s(this[B]).keys()},i.values=function(){var n,t=this,r=this.keys();return(n={})[G]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},i.entries=function(){var n,t=this,r=this.keys();return(n={})[G]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},i[G]=function(){return this.entries()},t}(),a=function(){function t(n,t){return this[B]={t:3,h:t,A:t?t.A:b(),M:!1,R:!1,i:void 0,u:n,k:this,p:new Map,O:!1,$:!1},this}n(t,Set);var r=t.prototype;return Object.defineProperty(r,"size",{get:function(){return s(this[B]).size}}),r.has=function(n){var t=this[B];return u(t),t.i?!!t.i.has(n)||!(!t.p.has(n)||!t.i.has(t.p.get(n))):t.u.has(n)},r.add=function(n){var t=this[B];return u(t),this.has(n)||(i(t),k(t.A.l,t),t.i.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[B];return u(t),i(t),k(t.A.l,t),t.i.delete(n)||!!t.p.has(n)&&t.i.delete(t.p.get(n))},r.clear=function(){var n=this[B];return u(n),i(n),k(n.A.l,n),n.i.clear()},r.values=function(){var n=this[B];return u(n),i(n),n.i.values()},r.entries=function(){var n=this[B];return u(n),i(n),n.i.entries()},r.keys=function(){return this.values()},r[G]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},t}();y("MapSet",{K:function(n,t){return new f(n,t)},N:function(n,t){return new a(n,t)}})}var K,N,$="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),C="undefined"!=typeof Map,I="undefined"!=typeof Set,W="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,X=$?Symbol("immer-nothing"):((K={})["immer-nothing"]=!0,K),q=$?Symbol("immer-draftable"):"__$immer_draftable",B=$?Symbol("immer-state"):"__$immer_state",G="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",H="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,L={},Q={get:function(n,t){if(t===B)return n;var r=n.p;if(!n.M&&o(r,t))return r[t];var i=s(n)[t];if(n.R||!e(i))return i;if(n.M){if(i!==x(n.u,t))return i;r=n.i}return r[t]=R(n.A.l,i,n)},has:function(n,t){return t in s(n)},ownKeys:function(n){return Reflect.ownKeys(s(n))},set:function(n,t,r){if(!n.M){var e=x(n.u,t);if(r?a(e,r)||r===n.p[t]:a(e,r)&&t in n.u)return!0;E(n),z(n)}return n.D[t]=!0,n.i[t]=r,!0},deleteProperty:function(n,t){return void 0!==x(n.u,t)||t in n.u?(n.D[t]=!1,E(n),z(n)):n.D[t]&&delete n.D[t],n.i&&delete n.i[t],!0},getOwnPropertyDescriptor:function(n,t){var r=s(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e&&(e.writable=!0,e.configurable=1!==n.t||"length"!==t),e},defineProperty:function(){t(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.u)},setPrototypeOf:function(){t(12)}},T={};i(Q,(function(n,t){T[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),T.deleteProperty=function(n,t){return Q.deleteProperty.call(this,n[0],t)},T.set=function(n,t,r){return Q.set.call(this,n[0],t,r,n[0])};var U=function(){function n(n){this.S=W,this.J=!1,"boolean"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),"boolean"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze),this.produce=this.produce.bind(this),this.produceWithPatches=this.produceWithPatches.bind(this)}var i=n.prototype;return i.produce=function(n,r,i){if("function"==typeof n&&"function"!=typeof r){var u=r;r=n;var o=this;return function(n){var t=this;void 0===n&&(n=u);for(var e=arguments.length,i=Array(e>1?e-1:0),f=1;f<e;f++)i[f-1]=arguments[f];return o.produce(n,(function(n){var e;return(e=r).call.apply(e,[t,n].concat(i))}))}}var f;if("function"!=typeof r&&t(6),void 0!==i&&"function"!=typeof i&&t(7),e(n)){var a=S(this),c=R(this,n,void 0),v=!0;try{f=r(c),v=!1}finally{v?j(a):O(a)}return"undefined"!=typeof Promise&&f instanceof Promise?f.then((function(n){return m(a,i),P(n,a)}),(function(n){throw j(a),n})):(m(a,i),P(f,a))}if((f=r(n))!==X)return void 0===f&&(f=n),this.J&&h(f,!0),f},i.produceWithPatches=function(n,t){var r,e,i=this;return"function"==typeof n?function(t){for(var r=arguments.length,e=Array(r>1?r-1:0),u=1;u<r;u++)e[u-1]=arguments[u];return i.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(e))}))}:[this.produce(n,t,(function(n,t){r=n,e=t})),r,e]},i.createDraft=function(n){e(n)||t(8);var r=S(this),i=R(this,n,void 0);return i[B].$=!0,O(r),i},i.finishDraft=function(n,t){var r=(n&&n[B]).A;return m(r,t),P(void 0,r)},i.setAutoFreeze=function(n){this.J=n},i.setUseProxies=function(n){W||t(20),this.S=n},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}var u=_("Patches").X;return r(n)?u(n,t):this.produce(n,(function(n){return u(n,t.slice(e+1))}))},n}(),V=new U,Y=V.produce,Z=V.produceWithPatches.bind(V),nn=V.setAutoFreeze.bind(V),tn=V.setUseProxies.bind(V),rn=V.applyPatches.bind(V),en=V.createDraft.bind(V),un=V.finishDraft.bind(V);n.Immer=U,n.applyPatches=rn,n.castDraft=function(n){return n},n.castImmutable=function(n){return n},n.createDraft=en,n.default=Y,n.enableAllPlugins=function(){F(),J(),D()},n.enableES5=F,n.enableMapSet=J,n.enablePatches=D,n.finishDraft=un,n.immerable=q,n.isDraft=r,n.isDraftable=e,n.nothing=X,n.original=function(n){if(n&&n[B])return n[B].u},n.produce=Y,n.produceWithPatches=Z,n.setAutoFreeze=nn,n.setUseProxies=tn,Object.defineProperty(n,"__esModule",{value:!0})}));
//# sourceMappingURL=immer.umd.production.min.js.map

;
//# sourceMappingURL=scripts.js.map